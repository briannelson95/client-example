import _uniq from "lodash/uniq";
import { renderHook } from '@testing-library/react-hooks';
import * as Rx from 'rxjs';
import { createHookFromObservableFactory } from '../createHookFromObservableFactory';

const tick = () => new Promise(resolve => setTimeout(resolve, 0));

describe('createHookFromObservableFactory', () => {
  it('takes in an observable factory and returns a loading-tuple hook', async () => {
    const observableFactory = value => Rx.concat(Rx.from(tick().then(() => "hello, ".concat(value))), Rx.from(tick().then(() => "hi, ".concat(value))));

    const useHook = createHookFromObservableFactory(observableFactory);
    const {
      result,
      waitForNextUpdate
    } = renderHook(() => useHook('world'));
    await waitForNextUpdate();
    expect(result.all).toEqual([[undefined, true], // note: the loading state staying at false is expected here because the
    // next update came from the observable which doesn't tell us when it has
    // an incoming update from it's source (it just pushes and we consume)
    ['hello, world', false], ['hi, world', false]]);
  });
  it('flips the loading state if the hook argument changes', async () => {
    const observableFactory = jest.fn(value => Rx.from(tick().then(() => ({
      value: "hello, ".concat(value)
    }))));
    const useHook = createHookFromObservableFactory(observableFactory);
    const {
      result,
      rerender,
      waitForNextUpdate
    } = renderHook(useHook, {
      initialProps: 'world'
    });
    await waitForNextUpdate();
    rerender('hooks');
    await waitForNextUpdate(); // using `uniq` because the hooks testing library will
    // log it twice but it is the same instance

    expect(_uniq(result.all)).toEqual([[undefined, true], [{
      value: 'hello, world'
    }, false], [{
      value: 'hello, world'
    }, true], [{
      value: 'hello, hooks'
    }, false]]);
    expect(observableFactory).toHaveBeenCalledTimes(2);
  });
  it('accepts an initial value and will return that immediately', async () => {
    const observableFactory = jest.fn(value => Rx.from(tick().then(() => "hello, ".concat(value))));
    const useHook = createHookFromObservableFactory(observableFactory, {
      initialValue: 'factory initial'
    });
    const {
      result,
      waitForNextUpdate
    } = renderHook(useHook, {
      initialProps: 'world'
    });
    await waitForNextUpdate();
    expect(result.all).toEqual([['factory initial', true], ['hello, world', false]]);
    expect(observableFactory).toHaveBeenCalledTimes(1);
  });
  it('bubbles errors throws in the observable factory', async () => {
    var _result$error;

    // Error is hoisted. To prevent it from being printed as uncaught in terminal,
    // we explicitly catch it and suppress it, recording that it has been called.
    const preventer = jest.fn(evt => evt.preventDefault());

    if (typeof window !== 'undefined') {
      window.addEventListener('error', preventer, false);
    }

    const observableFactory = () => Rx.from(tick().then(() => {
      throw new Error('test error');
    }));

    const useHook = createHookFromObservableFactory(observableFactory, {
      initialValue: 'factory initial'
    });
    const {
      result,
      waitForNextUpdate
    } = renderHook(useHook, {
      initialProps: 'world'
    });
    await waitForNextUpdate();
    expect((_result$error = result.error) === null || _result$error === void 0 ? void 0 : _result$error.message).toBe('test error');

    if (typeof window !== 'undefined') {
      window.removeEventListener('error', preventer, false);
      expect(preventer).toHaveBeenCalled();
    }
  });
});