import _isEqual from "lodash/isEqual";
import _escapeRegExp from "lodash/escapeRegExp";
import { EMPTY, Observable, of } from 'rxjs';
import { distinctUntilChanged, filter, map, mergeScan, shareReplay } from 'rxjs/operators';
import { decodeUrlState, isNonNullable, resolveDefaultState, resolveIntentState } from './helpers';

/**
 * @internal
 */
export function createRouterEventStream(_ref) {
  let {
    unstable_history: history,
    router,
    tools
  } = _ref;

  function maybeHandleIntent(prevEvent, currentEvent) {
    var _currentEvent$state;

    if ((currentEvent === null || currentEvent === void 0 ? void 0 : currentEvent.type) === 'state' && (_currentEvent$state = currentEvent.state) !== null && _currentEvent$state !== void 0 && _currentEvent$state.intent) {
      const redirectState = resolveIntentState(tools, (prevEvent === null || prevEvent === void 0 ? void 0 : prevEvent.type) === 'state' ? prevEvent.state : {}, currentEvent.state);

      if ((redirectState === null || redirectState === void 0 ? void 0 : redirectState.type) === 'state') {
        history.replace(router.encode(redirectState.state)); // This will not push anything downstream and preserve the prevEvent for the next received value
        // Since we are calling history.replace here, a new event will be received immediately

        return EMPTY;
      }
    }

    return of(currentEvent);
  }

  function maybeRedirectDefaultState(event) {
    if (event.type === 'state') {
      const defaultState = resolveDefaultState(tools, event.state);

      if (defaultState && defaultState !== event.state) {
        history.replace(router.encode(defaultState));
        return null;
      }
    }

    return event;
  }

  const routerBasePath = router.getBasePath();
  const state$ = new Observable(observer => {
    const unlisten = history.listen(location => observer.next(location)); // emit on mount

    observer.next(history.location);
    return unlisten;
  }).pipe( // this is necessary to prevent emissions intended for other workspaces.
  //
  // this regex ends with a `(\\/|$)` (forward slash or end) to prevent false
  // matches where the pathname is a false subset of the current pathname.
  filter(_ref2 => {
    let {
      pathname
    } = _ref2;
    return routerBasePath === '/' ? true : new RegExp("^".concat(_escapeRegExp(routerBasePath), "(\\/|$)"), 'i').test(pathname);
  }), map(_ref3 => {
    let {
      pathname
    } = _ref3;
    return decodeUrlState(router, pathname);
  }), mergeScan(maybeHandleIntent, null), filter(isNonNullable), map(maybeRedirectDefaultState), filter(isNonNullable), distinctUntilChanged(_isEqual), shareReplay(1));
  return state$;
}