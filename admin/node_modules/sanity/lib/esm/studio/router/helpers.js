import { isRecord } from '../../util/isRecord';
import { getOrderedTools } from './util/getOrderedTools';

function resolveUrlStateWithDefaultTool(tools, state) {
  const orderedTools = getOrderedTools(tools);
  const defaultTool = orderedTools[0];

  if (!state || state.tool || !defaultTool) {
    return state;
  }

  return Object.assign({}, state, {
    tool: defaultTool.name
  });
}

function makeBackwardsCompatible(tools, state) {
  if (!state) {
    return state;
  }

  if (getOrderedTools(tools).find(tool => tool.name === state.space)) {
    return { ...state,
      tool: state.space,
      space: undefined
    };
  }

  return state;
}

export function resolveDefaultState(tools, state) {
  const urlStateWithDefaultTool = resolveUrlStateWithDefaultTool(tools, makeBackwardsCompatible(tools, state));
  return urlStateWithDefaultTool;
}
export function resolveIntentState(tools, currentState, intentState) {
  const {
    intent,
    params,
    payload
  } = intentState;

  if (typeof intent !== 'string') {
    throw new Error('intent must be a string');
  }

  if (!isRecord(params)) {
    throw new Error('intent params must be a string');
  }

  const orderedTools = getOrderedTools(tools);
  const currentTool = currentState !== null && currentState !== void 0 && currentState.tool ? orderedTools.find(tool => tool.name === currentState.tool) : null; // If current tool can handle intent and if so, give it precedence

  const matchingTool = (currentTool ? [currentTool, ...orderedTools] : orderedTools).find(tool => tool && typeof tool.canHandleIntent === 'function' && tool.canHandleIntent(intent, params, currentState && currentState[tool.name]));

  if (matchingTool !== null && matchingTool !== void 0 && matchingTool.getIntentState) {
    const toolState = matchingTool.getIntentState(intent, params, currentState && currentState[matchingTool.name], payload);
    return {
      type: 'state',
      isNotFound: false,
      state: { ...currentState,
        tool: matchingTool.name,
        [matchingTool.name]: toolState
      }
    };
  }

  return {
    type: 'intent',
    isNotFound: true,
    intent: {
      name: intent,
      params
    }
  };
}
export function decodeUrlState(rootRouter, pathname) {
  return {
    type: 'state',
    state: rootRouter.decode(pathname) || {},
    isNotFound: rootRouter.isNotFound(pathname)
  };
}
export function isNonNullable(value) {
  return value !== null && value !== undefined;
}