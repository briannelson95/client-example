import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { map, filter, scan, catchError } from 'rxjs/operators';
import { combineLatest, of } from 'rxjs';
import { ErrorBoundary } from '@sanity/ui';
import { createHookFromObservableFactory } from '../../util';
import { ConfigResolutionError } from '../../config';
import { RouterProvider } from '../../router';
import { createRouter, createRouterEventStream } from '../router';
import { useActiveWorkspace } from '../activeWorkspaceMatcher';
import { WorkspaceProvider } from '../workspace';
import { SourceProvider } from '../source'; // TODO: work on error handler
// import {flattenErrors} from './flattenErrors'

const isStateEvent = e => e.type === 'state';

const initialState = {
  isNotFound: true,
  state: {}
};
const useRouterState = createHookFromObservableFactory(_ref => {
  let {
    tools,
    unstable_history,
    router
  } = _ref;
  if (!router || !tools) return of(initialState);
  return createRouterEventStream({
    unstable_history,
    router,
    tools
  }).pipe(filter(isStateEvent), scan((prevState, event) => {
    return { ...prevState,
      isNotFound: event.isNotFound,
      state: event.state
    };
  }, initialState));
}, {
  initialValue: initialState
});

function WorkspaceLoader(_ref2) {
  let {
    children,
    LoadingComponent
  } = _ref2;
  const [error, handleError] = useState(null);
  if (error) throw error;
  const {
    activeWorkspace,
    __internal: {
      history
    }
  } = useActiveWorkspace();
  const [workspace, setWorkspace] = useState(null);
  const handleNavigate = useCallback(opts => {
    if (opts.replace) {
      history.replace(opts.path);
    } else {
      history.push(opts.path);
    }
  }, [history]);
  useEffect(() => {
    const subscription = combineLatest(activeWorkspace.__internal.sources.map(_ref3 => {
      let {
        source
      } = _ref3;
      return source.pipe(catchError(err => {
        if (err instanceof ConfigResolutionError) return of(err);
        throw err;
      }));
    })).pipe(map(results => {
      const errors = results.filter(result => result instanceof ConfigResolutionError);

      if (errors.length) {
        throw new ConfigResolutionError({
          name: activeWorkspace.name,
          causes: errors,
          type: 'workspace'
        });
      }

      return results;
    }), map(_ref4 => {
      let [rootSource, ...restOfSources] = _ref4;
      return { ...activeWorkspace,
        ...rootSource,
        unstable_sources: [rootSource, ...restOfSources],
        type: 'workspace'
      };
    })).subscribe({
      next: setWorkspace,
      error: handleError
    });
    return () => subscription.unsubscribe();
  }, [activeWorkspace]);
  const tools = workspace === null || workspace === void 0 ? void 0 : workspace.tools;
  const router = useMemo(() => {
    if (!workspace) return undefined;
    return createRouter(workspace);
  }, [workspace]);
  const [routerState] = useRouterState({
    unstable_history: history,
    router,
    tools
  });
  if (!router || !workspace) return /*#__PURE__*/React.createElement(LoadingComponent, null); // TODO: may need a screen if one of the sources is not logged in. e.g. it
  // is currently possible for the user to be logged into the current workspace
  // but not all of its nested sources.
  // if (!allSourcesLoggedIn) return <NotAllSourcesAuthenticatedComponent />

  return /*#__PURE__*/React.createElement(WorkspaceProvider, {
    workspace: workspace
  }, /*#__PURE__*/React.createElement(SourceProvider // the first source is always the root source and is always present
  , {
    source: workspace.unstable_sources[0]
  }, /*#__PURE__*/React.createElement(RouterProvider, {
    onNavigate: handleNavigate,
    router: router,
    state: routerState.state
  }, children)));
}

function WorkspaceLoaderBoundary(_ref5) {
  let {
    ConfigErrorsComponent,
    ...props
  } = _ref5;
  const [{
    error
  }, setError] = useState({
    error: null
  }); // TODO: implement this
  // const errors = useMemo(() => flattenErrors(error, []), [error])

  if (error instanceof ConfigResolutionError) return /*#__PURE__*/React.createElement(ConfigErrorsComponent, null); // otherwise hand off to other boundaries

  if (error) throw error;
  return /*#__PURE__*/React.createElement(ErrorBoundary, {
    onCatch: setError
  }, /*#__PURE__*/React.createElement(WorkspaceLoader, props));
}

export { WorkspaceLoaderBoundary as WorkspaceLoader };