var _templateObject;

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

import React, { useCallback, useMemo, useState } from 'react';
import { Text, Flex, Autocomplete, Box, PortalProvider } from '@sanity/ui';
import { SearchIcon } from '@sanity/icons';
import styled from 'styled-components';
import { useDocumentSearchResults } from '../../../../search';
import { SearchFullscreenContent } from './SearchFullscreenContent';
import { SearchItem } from './SearchItem';
import { SearchPopoverContent } from './SearchPopoverContent';
const StyledText = styled(Text)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  word-break: break-word;\n"])));

const filterOption = () => true;

export function SearchField(props) {
  const {
    fullScreen,
    onSearchItemClick,
    portalElement,
    relatedElements,
    setSearchInputElement
  } = props;
  const [query, setQuery] = useState(null);
  const results = useDocumentSearchResults({
    includeDrafts: true,
    query: query || ''
  });
  const handleClickItem = useCallback(() => {
    if (fullScreen && onSearchItemClick) {
      onSearchItemClick();
    }
  }, [fullScreen, onSearchItemClick]);
  const renderOption = useCallback(option => {
    const {
      data
    } = option.payload;
    const documentId = data.hit._id;
    const documentType = data.hit._type;
    return /*#__PURE__*/React.createElement(SearchItem, {
      key: documentId,
      onClick: handleClickItem,
      padding: 2,
      documentId: documentId,
      documentType: documentType
    });
  }, [handleClickItem]);
  const renderPopoverFullscreen = useCallback((popoverProps, ref) => {
    if (!popoverProps.hidden && results.error) {
      var _results$error;

      return /*#__PURE__*/React.createElement(SearchFullscreenContent, {
        tone: "critical"
      }, /*#__PURE__*/React.createElement(Flex, {
        align: "center",
        flex: 1,
        height: "fill",
        justify: "center",
        padding: 4,
        sizing: "border"
      }, /*#__PURE__*/React.createElement(StyledText, {
        align: "center",
        muted: true
      }, (results === null || results === void 0 ? void 0 : (_results$error = results.error) === null || _results$error === void 0 ? void 0 : _results$error.message) || 'Something went wrong while searching')));
    }

    if (!popoverProps.hidden && query && !results.loading && results.value.length === 0) {
      return /*#__PURE__*/React.createElement(SearchFullscreenContent, null, /*#__PURE__*/React.createElement(Flex, {
        align: "center",
        flex: 1,
        height: "fill",
        justify: "center",
        padding: 4,
        sizing: "border"
      }, /*#__PURE__*/React.createElement(StyledText, {
        align: "center",
        muted: true
      }, "No results for ", /*#__PURE__*/React.createElement("strong", null, "\u2018", query, "\u2019"))));
    }

    if (!popoverProps.hidden && results.value.length > 0) {
      return /*#__PURE__*/React.createElement(SearchFullscreenContent, {
        hidden: popoverProps.hidden,
        ref: ref
      }, popoverProps.content);
    }

    return undefined;
  }, [query, results]);
  const renderPopover = useCallback((popoverProps, ref) => {
    if (!popoverProps.hidden && results.error) {
      var _results$error2;

      return /*#__PURE__*/React.createElement(SearchPopoverContent, {
        content: /*#__PURE__*/React.createElement(Box, {
          padding: 4
        }, /*#__PURE__*/React.createElement(Flex, {
          align: "center",
          height: "fill",
          justify: "center"
        }, /*#__PURE__*/React.createElement(StyledText, {
          align: "center",
          muted: true
        }, (results === null || results === void 0 ? void 0 : (_results$error2 = results.error) === null || _results$error2 === void 0 ? void 0 : _results$error2.message) || 'Something went wrong while searching'))),
        open: !popoverProps.hidden,
        ref: ref,
        referenceElement: popoverProps.inputElement
      });
    }

    if (!popoverProps.hidden && query && !results.loading && results.value.length === 0) {
      return /*#__PURE__*/React.createElement(SearchPopoverContent, {
        content: /*#__PURE__*/React.createElement(Box, {
          padding: 4
        }, /*#__PURE__*/React.createElement(Flex, {
          align: "center",
          height: "fill",
          justify: "center"
        }, /*#__PURE__*/React.createElement(StyledText, {
          align: "center",
          muted: true
        }, "No results for ", /*#__PURE__*/React.createElement("strong", null, "\u201C", query, "\u201D")))),
        open: !popoverProps.hidden,
        ref: ref,
        referenceElement: popoverProps.inputElement
      });
    }

    if (!popoverProps.hidden && results.value.length > 0) {
      return /*#__PURE__*/React.createElement(SearchPopoverContent, {
        content: popoverProps.content,
        open: !popoverProps.hidden,
        ref: ref,
        referenceElement: popoverProps.inputElement
      });
    }

    return undefined;
  }, [query, results]);
  const autoComplete = useMemo(() => /*#__PURE__*/React.createElement(Autocomplete, {
    filterOption: filterOption,
    icon: SearchIcon,
    id: "studio-search",
    key: "studio-search",
    listBox: {
      padding: fullScreen ? 2 : 1
    },
    loading: results.loading,
    onQueryChange: setQuery,
    options: results.value.map(hit => {
      return {
        value: hit.hit._id,
        payload: {
          data: hit
        }
      };
    }),
    placeholder: "Search",
    radius: 2,
    ref: setSearchInputElement,
    relatedElements: relatedElements,
    renderOption: renderOption,
    renderPopover: fullScreen ? renderPopoverFullscreen : renderPopover
  }), [fullScreen, relatedElements, renderOption, renderPopover, renderPopoverFullscreen, results.loading, results.value, setSearchInputElement]);
  return /*#__PURE__*/React.createElement(PortalProvider, {
    element: fullScreen ? portalElement : null
  }, autoComplete);
}