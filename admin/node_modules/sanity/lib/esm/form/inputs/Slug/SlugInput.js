import React, { useCallback, useMemo } from 'react';
import * as PathUtils from '@sanity/util/paths';
import { TextInput, Button, Flex, Box, Card, Stack } from '@sanity/ui';
import { useId } from '@reach/auto-id';
import { PatchEvent, set, setIfMissing, unset } from '../../patch';
import { useFormBuilder } from '../../useFormBuilder';
import { slugify } from './utils/slugify';
import { useAsync } from './utils/useAsync';

function getNewFromSource(source, valuePath, document) {
  const parentPath = valuePath.slice(0, -1);
  const parent = PathUtils.get(document, parentPath);
  return Promise.resolve(typeof source === 'function' ? source(document, {
    parentPath,
    parent
  }) : PathUtils.get(document, source));
}

export function SlugInput(props) {
  var _schemaType$options;

  const {
    getDocument
  } = useFormBuilder().__internal;

  const {
    focusRef,
    path,
    value,
    schemaType,
    validation,
    onChange,
    onFocus,
    onFocusPath,
    readOnly
  } = props;
  const sourceField = (_schemaType$options = schemaType.options) === null || _schemaType$options === void 0 ? void 0 : _schemaType$options.source;
  const inputId = useId();
  const errors = useMemo(() => validation.filter(item => item.level === 'error'), [validation]);
  const updateSlug = useCallback(nextSlug => {
    if (!nextSlug) {
      onChange(PatchEvent.from(unset([])));
      return;
    }

    onChange(PatchEvent.from([setIfMissing({
      _type: schemaType.name
    }), set(nextSlug, ['current'])]));
  }, [onChange, schemaType.name]);
  const [generateState, handleGenerateSlug] = useAsync(() => {
    if (!sourceField) {
      return Promise.reject(new Error("Source is missing. Check source on type \"".concat(schemaType.name, "\" in schema")));
    }

    return getNewFromSource(sourceField, path, getDocument() || {
      _type: schemaType.name
    }).then(newFromSource => slugify(newFromSource || '', schemaType)).then(newSlug => updateSlug(newSlug));
  }, [path, updateSlug, document, schemaType]);
  const isUpdating = (generateState === null || generateState === void 0 ? void 0 : generateState.status) === 'pending';
  const handleChange = React.useCallback(event => updateSlug(event.currentTarget.value), [updateSlug]);
  const handleFocus = React.useCallback(() => onFocusPath(['current']), [onFocusPath]);
  return /*#__PURE__*/React.createElement(Stack, {
    space: 3
  }, /*#__PURE__*/React.createElement(Flex, null, /*#__PURE__*/React.createElement(Box, {
    flex: 1
  }, /*#__PURE__*/React.createElement(TextInput, {
    id: inputId,
    ref: focusRef,
    customValidity: errors.length > 0 ? errors[0].message : '',
    disabled: isUpdating,
    onChange: handleChange,
    onFocus: onFocus,
    value: (value === null || value === void 0 ? void 0 : value.current) || '',
    readOnly: readOnly
  }), (generateState === null || generateState === void 0 ? void 0 : generateState.status) === 'error' && /*#__PURE__*/React.createElement(Card, {
    padding: 2,
    tone: "critical"
  }, generateState.error.message)), sourceField && /*#__PURE__*/React.createElement(Box, {
    marginLeft: 1
  }, /*#__PURE__*/React.createElement(Button, {
    mode: "ghost",
    type: "button",
    disabled: readOnly || isUpdating,
    onClick: handleGenerateSlug,
    onFocus: handleFocus,
    text: (generateState === null || generateState === void 0 ? void 0 : generateState.status) === 'pending' ? 'Generatingâ€¦' : 'Generate'
  }))));
}