import React from 'react';

/**
 * Takes an async function and returns a [AsyncState<value>, callback] pair.
 * Whenever the callback is invoked, a new AsyncState is returned.
 * If the returned callback is called again before the previous callback has settled, the resolution of the previous one will be ignored, thus preventing race conditions.
 * @param fn an async function that returns a value
 * @param dependencies list of dependencies that will return a new [value, callback] pair
 */
export function useAsync(fn, dependencies) {
  const [state, setState] = React.useState(null);
  const lastId = React.useRef(0);
  const wrappedCallback = React.useCallback(arg => {
    const asyncId = ++lastId.current;
    setState({
      status: 'pending'
    });
    Promise.resolve().then(() => fn(arg)).then(res => {
      if (asyncId === lastId.current) {
        setState({
          status: 'complete',
          result: res
        });
      }
    }, err => {
      if (asyncId === lastId.current) {
        setState({
          status: 'error',
          error: err
        });
      }
    });
  }, [fn, ...dependencies]);
  return [state, wrappedCallback];
}