import _get from "lodash/get";

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import { Card, Stack } from '@sanity/ui';
import { Item, List } from '../common/list';
import { MemberItemError } from '../../../members';
import { getEmptyValue } from './getEmptyValue';
import { nearestIndexOf } from './utils/nearestIndex';
import { PrimitiveMemberItem } from './PrimitiveMemberItem';
import { ItemRow } from './ItemRow';
import { ArrayOfPrimitivesFunctions } from './ArrayOfPrimitivesFunctions';
export class ArrayOfPrimitivesInput extends React.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_element", null);

    _defineProperty(this, "_lastAddedIndex", -1);

    _defineProperty(this, "handleAppend", itemValue => {
      const {
        value = [],
        onFocusIndex,
        onAppendItem
      } = this.props;
      onAppendItem(itemValue);
      onFocusIndex(value.length);
    });

    _defineProperty(this, "handlePrepend", itemValue => {
      const {
        onFocusIndex,
        value = [],
        onPrependItem
      } = this.props;
      onPrependItem(itemValue);
      onFocusIndex(value.length);
    });

    _defineProperty(this, "handleItemEnterKey", index => {
      const {
        schemaType,
        onInsert
      } = this.props;
      const firstType = schemaType === null || schemaType === void 0 ? void 0 : schemaType.of[0];

      if (firstType) {
        onInsert({
          referenceIndex: index,
          position: 'after',
          items: [getEmptyValue(firstType)]
        });
        this._lastAddedIndex = index + 1;
      }
    });

    _defineProperty(this, "handleItemEscapeKey", index => {
      const {
        value,
        onRemoveItem
      } = this.props;

      if (index === this._lastAddedIndex && (value === null || value === void 0 ? void 0 : value[index]) === '') {
        onRemoveItem(index);
      }
    });

    _defineProperty(this, "handleSortEnd", event => {
      const {
        onFocusIndex,
        onMoveItem,
        value
      } = this.props;
      if (value) onMoveItem({
        fromIndex: event.oldIndex,
        toIndex: event.newIndex
      });
      onFocusIndex(event.newIndex);
    });

    _defineProperty(this, "setElement", el => {
      this._element = el;
    });

    _defineProperty(this, "handleFocusRoot", event => {
      const {
        onFocus
      } = this.props; // We want to handle focus when the array input *itself* element receives
      // focus, not when a child element receives focus, but React has decided
      // to let focus bubble, so this workaround is needed
      // Background: https://github.com/facebook/react/issues/6410#issuecomment-671915381

      if (event.currentTarget === event.target && event.currentTarget === this._element) {
        onFocus(event);
      }
    });

    _defineProperty(this, "renderItem", props => {
      const {
        schemaType,
        readOnly
      } = this.props;
      const isSortable = !readOnly && _get(schemaType, 'options.sortable') !== false;
      return /*#__PURE__*/React.createElement(ItemRow, _extends({}, props, {
        isSortable: isSortable,
        insertableTypes: schemaType.of,
        onEnterKey: this.handleItemEnterKey,
        onEscapeKey: this.handleItemEscapeKey
      }));
    });
  }

  focus() {
    if (this._element) {
      this._element.focus();
    }
  }

  getSnapshotBeforeUpdate(prevProps) {
    const {
      focusPath: prevFocusPath = [],
      value: prevValue = []
    } = prevProps;
    const {
      focusPath = [],
      value = []
    } = this.props;

    if (prevFocusPath[0] === focusPath[0] && prevValue.length !== value.length) {
      var _selection$focusNode;

      // the length of the array has changed, but the focus path has not, which may happen if someone inserts or removes a new item above the one currently in focus
      const focusIndex = focusPath[0];
      const selection = window.getSelection();

      if (!((selection === null || selection === void 0 ? void 0 : selection.focusNode) instanceof HTMLElement)) {
        return null;
      }

      const input = (_selection$focusNode = selection.focusNode) === null || _selection$focusNode === void 0 ? void 0 : _selection$focusNode.querySelector('input,textarea');
      return input instanceof HTMLInputElement ? {
        prevFocusedIndex: focusIndex,
        restoreSelection: {
          text: selection.toString(),
          start: input.selectionStart,
          end: input.selectionEnd,
          value: input.value
        }
      } : {};
    }

    return null;
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    const {
      onFocusIndex
    } = this.props;

    if (snapshot !== null && snapshot !== void 0 && snapshot.restoreSelection && prevProps.value) {
      var _this$_element;

      const prevFocusedValue = prevProps.value[snapshot.prevFocusedIndex];
      const nearestIndex = nearestIndexOf(this.props.value || [], snapshot.prevFocusedIndex, prevFocusedValue);

      if (nearestIndex === -1) {
        return;
      }

      const newInput = (_this$_element = this._element) === null || _this$_element === void 0 ? void 0 : _this$_element.querySelector("[data-item-index='".concat(nearestIndex, "'] input,textarea"));

      if (newInput instanceof HTMLInputElement) {
        newInput.focus();

        try {
          newInput.setSelectionRange(snapshot.restoreSelection.start, snapshot.restoreSelection.end);
        } catch (_unused) {// not all inputs supports selection (e.g. <input type="number" />)
        }
      }

      onFocusIndex(nearestIndex);
    }
  }

  render() {
    const {
      schemaType,
      members,
      readOnly,
      value,
      onChange,
      renderInput
    } = this.props;
    const isSortable = !readOnly && _get(schemaType, 'options.sortable') !== false;
    return /*#__PURE__*/React.createElement(Stack, {
      space: 3
    }, /*#__PURE__*/React.createElement(Stack, {
      space: 1
    }, members.length > 0 && /*#__PURE__*/React.createElement(Card, {
      padding: 1,
      border: true
    }, /*#__PURE__*/React.createElement(List, {
      onSortEnd: this.handleSortEnd,
      isSortable: isSortable
    }, members.map((member, index) => {
      if (member.kind === 'item') {
        return /*#__PURE__*/React.createElement(Item, {
          key: member.key,
          index: index,
          "data-item-index": index,
          isSortable: isSortable
        }, /*#__PURE__*/React.createElement(PrimitiveMemberItem, {
          member: member,
          renderInput: renderInput,
          renderItem: this.renderItem
        }));
      }

      if (member.kind === 'error') {
        return /*#__PURE__*/React.createElement(MemberItemError, {
          key: member.key,
          member: member
        });
      } //@ts-expect-error all possible cases should be covered


      return /*#__PURE__*/React.createElement(React.Fragment, null, "Unknown member kind: $", member.kind);
    })))), /*#__PURE__*/React.createElement(ArrayOfPrimitivesFunctions, {
      type: schemaType,
      value: value,
      readOnly: readOnly,
      onAppendItem: this.handleAppend,
      onPrependItem: this.handlePrepend,
      onCreateValue: getEmptyValue,
      onChange: onChange
    }));
  }

}