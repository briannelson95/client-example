import _isPlainObject from "lodash/isPlainObject";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable camelcase */

/* eslint-disable react/default-props-match-prop-types */

/* eslint-disable react/jsx-handler-names */
import { isKeySegment, isObjectSchemaType, isReferenceSchemaType } from '@sanity/types';
import { Box, Button, Card, Dialog, Flex, Spinner, Stack, Text } from '@sanity/ui';
import React from 'react';
import { map } from 'rxjs/operators';
import { randomKey, resolveTypeName } from '@sanity/util/content';
import { getSchemaTypeTitle } from '../../../../schema/helpers';
import { isDev } from '../../../../environment';
import { Alert } from '../../../components/Alert';
import { Details } from '../../../components/Details';
import { Item, List } from '../common/list';
import { applyAll } from '../../../patch/applyPatch';
import { PatchEvent, unset } from '../../../patch';
import { DefaultArrayInputFunctions } from '../common/ArrayFunctions';
import { isObjectItemProps } from '../../../types/asserters';
import { withFocusRing } from '../../../components/withFocusRing';
import { MemberItem, MemberItemError } from '../../../members';
import { uploadTarget } from './uploadTarget/uploadTarget';
import { isEmpty } from './item/helpers';
import { ArrayItem } from './item/ArrayItem';
export function createProtoValue(type) {
  if (!isObjectSchemaType(type)) {
    throw new Error("Invalid item type: \"".concat(type.type, "\". Default array input can only contain objects (for now)"));
  }

  const _key = randomKey(12);

  return type.name === 'object' ? {
    _key
  } : {
    _type: type.name,
    _key
  };
}
/**
 * @internal
 */

const UploadTarget = uploadTarget(withFocusRing(Card));
export class ArrayInput extends React.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_focusArea", null);

    _defineProperty(this, "toast", null);

    _defineProperty(this, "uploadSubscriptions", {});

    _defineProperty(this, "state", {
      isResolvingInitialValue: false
    });

    _defineProperty(this, "insert", (item, position, referenceItem) => {
      const {
        onInsert
      } = this.props;
      onInsert({
        items: [item],
        position,
        referenceItem
      });
    });

    _defineProperty(this, "handlePrepend", value => {
      this.handleInsert({
        item: value,
        position: 'before',
        referenceItem: 0
      });
    });

    _defineProperty(this, "handleAppend", value => {
      this.handleInsert({
        item: value,
        position: 'after',
        referenceItem: -1
      });
    });

    _defineProperty(this, "handleInsert", event => {
      const {
        onFocusPath,
        onOpenItem,
        resolveInitialValue
      } = this.props;
      this.setState({
        isResolvingInitialValue: true
      });
      const memberType = this.getMemberTypeOfItem(event.item);

      if (!memberType) {
        throw new Error("Type \"".concat(event.item._type, "\" not valid for this array"));
      }

      const resolvedInitialValue = isEmpty(event.item) && resolveInitialValue ? resolveInitialValue(memberType, event.item) : Promise.resolve({});
      resolvedInitialValue.then(initial => ({ ...event.item,
        ...initial
      })).then(value => {
        this.insert(value, event.position, event.referenceItem);
      }, error => {
        var _this$toast;

        (_this$toast = this.toast) === null || _this$toast === void 0 ? void 0 : _this$toast.push({
          title: "Could not resolve initial value",
          description: "Unable to resolve initial value for type: ".concat(memberType.name, ": ").concat(error.message, "."),
          status: 'error'
        });
        this.insert(event.item, event.position, event.referenceItem);
      }).finally(() => {
        this.setState({
          isResolvingInitialValue: false
        });

        if (event.edit !== false) {
          onOpenItem(this.props.path.concat([{
            _key: event.item._key
          }]));
        }

        onFocusPath([{
          _key: event.item._key
        }]);
      });
    });

    _defineProperty(this, "handleRemoveItem", item => {
      this.removeItem(item);
    });

    _defineProperty(this, "handleFocus", event => {
      const {
        onFocus
      } = this.props; // We want to handle focus when the array input *itself* element receives
      // focus, not when a child element receives focus, but React has decided
      // to let focus bubble, so this workaround is needed
      // Background: https://github.com/facebook/react/issues/6410#issuecomment-671915381

      if (event.currentTarget === event.target && event.currentTarget === this._focusArea) {
        onFocus(event);
      }
    });

    _defineProperty(this, "handleBlur", event => {
      const {
        onBlur
      } = this.props; // We want to handle blur when the array input *itself* element receives
      // blur, not when a child element receives blur, but React has decided
      // to let focus events bubble, so this workaround is needed
      // Background: https://github.com/facebook/react/issues/6410#issuecomment-671915381

      if (event.currentTarget === event.target && event.currentTarget === this._focusArea) {
        onBlur(event);
      }
    });

    _defineProperty(this, "handleSortEnd", event => {
      const {
        value,
        onMoveItem
      } = this.props;
      const item = value === null || value === void 0 ? void 0 : value[event.oldIndex];
      const refItem = value === null || value === void 0 ? void 0 : value[event.newIndex];

      if (!(item !== null && item !== void 0 && item._key) || !(refItem !== null && refItem !== void 0 && refItem._key)) {
        // eslint-disable-next-line no-console
        console.error('Neither the item you are moving nor the item you are moving to have a key. Cannot continue.');
        return;
      }

      if (event.oldIndex === event.newIndex || item._key === refItem._key) {
        return;
      }

      onMoveItem({
        fromIndex: event.oldIndex,
        toIndex: event.newIndex
      });
    });

    _defineProperty(this, "setFocusArea", el => {
      this._focusArea = el;
    });

    _defineProperty(this, "setToast", toast => {
      this.toast = toast;
    });

    _defineProperty(this, "handleRemoveNonObjectValues", () => {
      const {
        onChange,
        value
      } = this.props;
      const nonObjects = (value || []).reduce((acc, val, i) => _isPlainObject(val) ? acc : acc.concat(i), []).reverse();
      const patches = nonObjects.map(index => unset([index]));
      onChange(patches);
    });

    _defineProperty(this, "handleUpload", _ref => {
      let {
        file,
        type,
        uploader
      } = _ref;
      const {
        onChange,
        client
      } = this.props;
      const item = createProtoValue(type);
      const key = item._key;
      this.insert(item, 'after', -1);
      const events$ = uploader.upload(client, file, type).pipe(map(uploadEvent => PatchEvent.from(uploadEvent.patches || []).prefixAll({
        _key: key
      })));
      this.uploadSubscriptions = { ...this.uploadSubscriptions,
        [key]: events$.subscribe(event => onChange(event.patches))
      };
    });

    _defineProperty(this, "renderItem", itemProps => {
      var _schemaType$options;

      if (!isObjectItemProps(itemProps)) {
        throw new Error('Expected item to be of object type');
      }

      const {
        id,
        renderPreview,
        schemaType
      } = this.props;

      if (isReferenceSchemaType(itemProps.schemaType)) {
        return itemProps.children;
      }

      const typeTitle = getSchemaTypeTitle(itemProps.schemaType);
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ArrayItem, {
        changed: itemProps.changed,
        validation: itemProps.validation,
        readOnly: itemProps.readOnly,
        onInsert: itemProps.onInsert,
        onRemove: itemProps.onRemove,
        onFocus: itemProps.onFocus,
        index: itemProps.index,
        schemaType: itemProps.schemaType,
        layout: (_schemaType$options = schemaType.options) === null || _schemaType$options === void 0 ? void 0 : _schemaType$options.layout,
        insertableTypes: schemaType.of,
        value: itemProps.value,
        focused: itemProps.focused,
        open: itemProps.open,
        path: itemProps.path,
        onClick: itemProps.onOpen,
        presence: itemProps.presence,
        renderPreview: renderPreview
      }, itemProps.open ? /*#__PURE__*/React.createElement(Dialog, {
        width: 1,
        header: "Edit ".concat(typeTitle),
        id: "".concat(id, "-item-").concat(itemProps.key, "-dialog"),
        onClose: itemProps.onClose
      }, /*#__PURE__*/React.createElement(Box, {
        padding: 4
      }, itemProps.children)) : null));
    });
  }

  getMemberTypeOfItem(item) {
    const {
      schemaType
    } = this.props;
    const itemTypeName = resolveTypeName(item);
    return schemaType.of.find(memberType => memberType.name === itemTypeName);
  }

  removeItem(item) {
    const {
      onChange,
      onFocusPath,
      value
    } = this.props; // create a patch for removing the item

    const patch = unset(isKeySegment(item) ? [{
      _key: item._key
    }] : [(value === null || value === void 0 ? void 0 : value.indexOf(item)) || -1]); // apply the patch to the current value

    const result = applyAll(value || [], [patch]); // if the result is an empty array

    if (Array.isArray(result) && !result.length) {
      // then unset the value
      onChange(unset());
    } else {
      // otherwise apply the patch
      onChange(patch);
    }

    if (item._key in this.uploadSubscriptions) {
      this.uploadSubscriptions[item._key].unsubscribe();
    } // move focus to the nearest sibling


    const idx = (value === null || value === void 0 ? void 0 : value.indexOf(item)) || -1;
    const nearestSibling = (value === null || value === void 0 ? void 0 : value[idx + 1]) || (value === null || value === void 0 ? void 0 : value[idx - 1]); // if there's no siblings we want to focus the input itself

    onFocusPath(nearestSibling ? [{
      _key: nearestSibling._key
    }] : []);
  }

  focus() {
    if (this._focusArea) {
      this._focusArea.focus();
    }
  }

  renderMember(member) {
    const {
      renderField,
      renderInput,
      renderPreview
    } = this.props;

    if (member.kind === 'item') {
      return /*#__PURE__*/React.createElement(MemberItem, {
        member: member,
        renderItem: this.renderItem,
        renderField: renderField,
        renderInput: renderInput,
        renderPreview: renderPreview
      });
    }

    if (member.kind === 'error') {
      return /*#__PURE__*/React.createElement(MemberItemError, {
        member: member
      });
    } //@ts-expect-error all possible cases should be covered


    return /*#__PURE__*/React.createElement(React.Fragment, null, "Unknown member kind: $", member.kind);
  }

  render() {
    const {
      schemaType,
      onChange,
      value = [],
      readOnly,
      members,
      resolveUploader
    } = this.props;
    const {
      isResolvingInitialValue
    } = this.state;
    const hasNonObjectValues = (value || []).some(item => !_isPlainObject(item));

    if (hasNonObjectValues) {
      return /*#__PURE__*/React.createElement(Alert, {
        status: "error",
        suffix: /*#__PURE__*/React.createElement(Stack, {
          padding: 2
        }, /*#__PURE__*/React.createElement(Button, {
          onClick: this.handleRemoveNonObjectValues,
          text: "Remove non-object values",
          tone: "critical"
        })),
        title: /*#__PURE__*/React.createElement(React.Fragment, null, "Invalid list values")
      }, /*#__PURE__*/React.createElement(Text, {
        as: "p",
        muted: true,
        size: 1
      }, "Some items in this list are not objects. This must be fixed in order to edit the list."), /*#__PURE__*/React.createElement(Details, {
        marginTop: 4,
        open: isDev,
        title: /*#__PURE__*/React.createElement(React.Fragment, null, "Developer info")
      }, /*#__PURE__*/React.createElement(Stack, {
        space: 3
      }, /*#__PURE__*/React.createElement(Text, {
        as: "p",
        muted: true,
        size: 1
      }, "This usually happens when items are created using an API client, or when a custom input component has added invalid data to the list."))));
    }

    const options = schemaType.options || {};
    const isSortable = options.sortable !== false;
    const isGrid = options.layout === 'grid';
    return /*#__PURE__*/React.createElement(Stack, {
      space: 3
    }, /*#__PURE__*/React.createElement(UploadTarget, {
      types: schemaType.of,
      resolveUploader: resolveUploader,
      onUpload: this.handleUpload,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur,
      ref: this.setFocusArea,
      tabIndex: 0
    }, /*#__PURE__*/React.createElement(Stack, {
      "data-ui": "ArrayInput__content",
      space: 3
    }, (members === null || members === void 0 ? void 0 : members.length) === 0 && /*#__PURE__*/React.createElement(Card, {
      padding: 3,
      border: true,
      style: {
        borderStyle: 'dashed'
      },
      radius: 2
    }, /*#__PURE__*/React.createElement(Text, {
      align: "center",
      muted: true,
      size: 1
    }, schemaType.placeholder || /*#__PURE__*/React.createElement(React.Fragment, null, "No items"))), ((members === null || members === void 0 ? void 0 : members.length) > 0 || isResolvingInitialValue) && /*#__PURE__*/React.createElement(Card, {
      border: true,
      radius: 1,
      paddingY: isGrid ? 2 : 1,
      paddingX: isGrid ? 2 : undefined
    }, /*#__PURE__*/React.createElement(List, {
      onSortEnd: this.handleSortEnd,
      isSortable: isSortable,
      isGrid: isGrid
    }, members.map((member, index) => {
      return /*#__PURE__*/React.createElement(Item, {
        key: member.key,
        isSortable: isSortable,
        isGrid: isGrid,
        index: index
      }, this.renderMember(member));
    }), isResolvingInitialValue && /*#__PURE__*/React.createElement(Item, {
      isGrid: isGrid,
      index: -1
    }, /*#__PURE__*/React.createElement(Card, {
      radius: 1,
      padding: 1
    }, /*#__PURE__*/React.createElement(Flex, {
      align: "center",
      justify: "center",
      padding: 3
    }, /*#__PURE__*/React.createElement(Box, {
      marginX: 3
    }, /*#__PURE__*/React.createElement(Spinner, {
      muted: true
    })), /*#__PURE__*/React.createElement(Text, null, "Resolving initial value\u2026")))))))), /*#__PURE__*/React.createElement(DefaultArrayInputFunctions, {
      type: schemaType,
      value: value,
      readOnly: readOnly,
      onAppendItem: this.handleAppend,
      onPrependItem: this.handlePrepend,
      onCreateValue: createProtoValue,
      onChange: onChange
    }));
  }

}