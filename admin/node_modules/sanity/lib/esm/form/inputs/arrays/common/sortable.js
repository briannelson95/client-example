function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React from 'react';
import { SortableContainer, SortableElement, SortableHandle } from 'react-sortable-hoc';
export const MOVING_ITEM_CLASS_NAME = 'moving';
export const DRAG_HANDLE_ATTRIBUTE = 'data-drag-handle'; // higher order components to make a sortable list/item components

export function sortableHandle(Component) {
  return SortableHandle(Component);
} // Wrapper to avoid accidental leaking of react-sortable-hoc props

export function sortableItem(Component) {
  return SortableElement(Component);
} // Wrapper to avoid accidental leaking of react-sortable-hoc props

function sortableContainer(Component, options) {
  const Container = SortableContainer( /*#__PURE__*/React.forwardRef(function Sortable(props, forwardedRef) {
    return /*#__PURE__*/React.createElement(Component, _extends({}, props, {
      ref: forwardedRef
    }));
  })); // there are some wonky typings from react-sortable-hoc

  return /*#__PURE__*/React.forwardRef(function SortableList(props, ref) {
    return /*#__PURE__*/React.createElement(Container, _extends({}, props, options, {
      ref: ref
    }));
  });
}

const KeyCode = {
  Space: 32,
  Enter: 13,
  Esc: 27,
  Up: 38,
  Left: 37,
  Right: 39,
  Down: 40
};
const KEYCODES = {
  lift: [KeyCode.Space, KeyCode.Enter],
  drop: [KeyCode.Space, KeyCode.Enter],
  cancel: [KeyCode.Esc],
  up: [KeyCode.Left, KeyCode.Up],
  down: [KeyCode.Right, KeyCode.Down]
};
export function sortableGrid(Component) {
  return sortableContainer(Component, {
    helperClass: MOVING_ITEM_CLASS_NAME,
    keyCodes: KEYCODES,
    axis: 'xy',
    lockAxis: 'xy',
    useDragHandle: true,
    shouldCancelStart
  });
}
export function sortableList(Component) {
  return sortableContainer(Component, {
    helperClass: MOVING_ITEM_CLASS_NAME,
    keyCodes: KEYCODES,
    axis: 'y',
    lockAxis: 'y',
    useDragHandle: true,
    shouldCancelStart
  });
} // Cancel sorting if the event target is not drag handle

function shouldCancelStart(event) {
  return !isDragHandle(event.target);
}

function isDragHandle(element) {
  return element.matches("[".concat(DRAG_HANDLE_ATTRIBUTE, "=\"true\"],[").concat(DRAG_HANDLE_ATTRIBUTE, "=\"true\"] *"));
}