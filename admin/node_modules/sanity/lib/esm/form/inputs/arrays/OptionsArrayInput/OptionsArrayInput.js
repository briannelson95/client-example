import _startCase from "lodash/startCase";
import _get from "lodash/get";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import { Box, Checkbox, Flex, Text } from '@sanity/ui';
import { resolveTypeName } from '@sanity/util/content';
import { set, unset } from '../../../patch';
import { ItemWithMissingType } from '../ArrayOfObjectsInput/item/ItemWithMissingType';
import { Item, List } from '../common/list';
import { ChangeIndicator } from '../../../../components/changeIndicators';
import { resolveValueWithLegacyOptionsSupport, isLegacyOptionsItem } from './legacyOptionsSupport';
const changeIndicatorOptions = {
  compareDeep: true
};

function isEqual(item, otherItem) {
  if (isLegacyOptionsItem(item) || isLegacyOptionsItem(otherItem)) {
    return item.value === otherItem.value;
  }

  if (item === otherItem) {
    return true;
  }

  if (typeof item !== typeof otherItem) {
    return false;
  }

  if (typeof item !== 'object' && !Array.isArray(item)) {
    return item === otherItem;
  }

  if (item._key && item._key === otherItem._key) {
    return true;
  }

  if (Array.isArray(item)) {
    if (!item.length !== otherItem.length) {
      return false;
    }

    return item.every((it, i) => isEqual(item[i], otherItem[i]));
  }

  const keys = Object.keys(item);
  const otherKeys = Object.keys(item);

  if (keys.length !== otherKeys.length) {
    return false;
  }

  return keys.every(keyName => isEqual(item[keyName], otherItem[keyName]));
}

function inArray(array, candidate) {
  return array ? array.some(item => isEqual(item, candidate)) : false;
}

export class OptionsArrayInput extends React.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_element", null);

    _defineProperty(this, "handleChange", (isChecked, optionValue) => {
      const {
        schemaType,
        value = []
      } = this.props;

      const list = _get(schemaType.options, 'list');

      if (!isChecked && optionValue._key) {
        // This is an optimization that only works if list items are _keyed
        this.props.onChange(unset([{
          _key: optionValue._key
        }]));
      }

      const nextValue = list.filter(item => isEqual(optionValue, item) ? isChecked : inArray(value, resolveValueWithLegacyOptionsSupport(item))).map(resolveValueWithLegacyOptionsSupport);
      this.props.onChange(nextValue.length > 0 ? set(nextValue) : unset());
    });

    _defineProperty(this, "setElement", el => {
      this._element = el;
    });

    _defineProperty(this, "handleFocus", index => {
      const {
        onFocusIndex
      } = this.props;
      onFocusIndex(index);
    });
  }

  getMemberTypeOfItem(option) {
    const {
      schemaType
    } = this.props;
    return schemaType.of.find(memberType => memberType.name === resolveTypeName(resolveValueWithLegacyOptionsSupport(option)));
  }

  focus() {
    if (this._element) {
      this._element.focus();
    }
  }

  render() {
    var _schemaType$options, _schemaType$options2, _schemaType$options3;

    const {
      changed,
      focused,
      onBlur,
      onFocus,
      path,
      renderPreview,
      schemaType,
      value,
      readOnly
    } = this.props;
    const options = ((_schemaType$options = schemaType.options) === null || _schemaType$options === void 0 ? void 0 : _schemaType$options.list) || []; // note: direction was never documented and makes more sense to use "grid" for it too

    const isGrid = ((_schemaType$options2 = schemaType.options) === null || _schemaType$options2 === void 0 ? void 0 : _schemaType$options2.direction) === 'horizontal' || ((_schemaType$options3 = schemaType.options) === null || _schemaType$options3 === void 0 ? void 0 : _schemaType$options3.layout) === 'grid';
    return /*#__PURE__*/React.createElement(ChangeIndicator, {
      path: path,
      isChanged: changed,
      hasFocus: !!focused
    }, /*#__PURE__*/React.createElement(List, {
      isGrid: isGrid
    }, options.map((option, index) => {
      const optionType = this.getMemberTypeOfItem(option);
      const checked = inArray(value || [], resolveValueWithLegacyOptionsSupport(option));
      const disabled = !optionType;
      const title = (option === null || option === void 0 ? void 0 : option.title) || _startCase(option === null || option === void 0 ? void 0 : option.value) || option;
      return /*#__PURE__*/React.createElement(Item, {
        index: index,
        isGrid: isGrid,
        key: index
      }, /*#__PURE__*/React.createElement(Flex, {
        align: "center",
        as: "label",
        muted: disabled
      }, /*#__PURE__*/React.createElement(WrappedCheckbox, {
        disabled: disabled,
        checked: checked,
        onChange: e => this.handleChange(e.currentTarget.checked, option),
        onFocus: () => this.handleFocus(index),
        onBlur: onBlur,
        readOnly: readOnly
      }), optionType && (title ? /*#__PURE__*/React.createElement(Box, {
        padding: 2
      }, /*#__PURE__*/React.createElement(Text, null, title)) : /*#__PURE__*/React.createElement(Box, {
        marginLeft: 2
      }, renderPreview({
        layout: 'media',
        schemaType: optionType,
        value: resolveValueWithLegacyOptionsSupport(option)
      }))), !optionType && /*#__PURE__*/React.createElement(ItemWithMissingType, {
        value: option,
        onFocus: event => onFocus(event)
      })));
    })));
  }

}

const WrappedCheckbox = props => {
  const {
    disabled,
    checked,
    onChange,
    onFocus,
    readOnly,
    onBlur
  } = props;
  return /*#__PURE__*/React.createElement(Checkbox, {
    disabled: disabled,
    checked: checked,
    readOnly: readOnly,
    onChange: onChange,
    onFocus: onFocus,
    onBlur: onBlur
  });
};