import _sortBy from "lodash/sortBy";

var _templateObject;

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

import { Box, Flex, Text, useToast } from '@sanity/ui';
import React from 'react';
import styled from 'styled-components';
import { fileTarget } from '../../../common/fileTarget';
import { DropMessage } from '../../../files/common/DropMessage';
import { Overlay } from './styles';
const Root = styled.div(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  position: relative;\n"])));

function getUploadCandidates(types, resolveUploader, file) {
  return types.map(memberType => ({
    type: memberType,
    uploader: resolveUploader(memberType, file)
  })).filter(member => member.uploader);
}

export function uploadTarget(Component) {
  const FileTarget = fileTarget(Component);
  return /*#__PURE__*/React.forwardRef(function UploadTarget(props, forwardedRef) {
    const {
      children,
      resolveUploader,
      onUpload,
      types,
      ...rest
    } = props;
    const {
      push: pushToast
    } = useToast();
    const uploadFile = React.useCallback((file, resolvedUploader) => {
      const {
        type,
        uploader
      } = resolvedUploader;
      onUpload === null || onUpload === void 0 ? void 0 : onUpload({
        file,
        type,
        uploader
      });
    }, [onUpload]);
    const handleFiles = React.useCallback(files => {
      if (!resolveUploader) {
        return;
      }

      const tasks = files.map(file => ({
        file,
        uploaderCandidates: getUploadCandidates(types, resolveUploader, file)
      }));
      const ready = tasks.filter(task => task.uploaderCandidates.length > 0);
      const rejected = tasks.filter(task => task.uploaderCandidates.length === 0);

      if (rejected.length > 0) {
        const plural = rejected.length > 1;
        pushToast({
          closable: true,
          status: 'warning',
          title: "The following item".concat(plural ? 's' : '', " can't be uploaded because there's no known conversion from content type").concat(plural ? 's' : '', " to array item:"),
          description: rejected.map((task, i) => /*#__PURE__*/React.createElement(Flex, {
            key: i,
            padding: 2
          }, /*#__PURE__*/React.createElement(Box, {
            marginLeft: 1
          }, /*#__PURE__*/React.createElement(Text, {
            weight: "semibold"
          }, task.file.name)), /*#__PURE__*/React.createElement(Box, {
            paddingLeft: 2
          }, /*#__PURE__*/React.createElement(Text, {
            size: 1
          }, "(", task.file.type, ")"))))
        });
      } // todo: consider if we should to ask the user here
      // the list of candidates is sorted by their priority and the first one is selected
      // const ambiguous = tasks
      //   .filter(task => task.uploaderCandidates.length > 1)


      ready.forEach(task => {
        uploadFile(task.file, // eslint-disable-next-line max-nested-callbacks
        _sortBy(task.uploaderCandidates, candidate => candidate.uploader.priority)[0]);
      });
    }, [pushToast, resolveUploader, types, uploadFile]);
    const [hoveringFiles, setHoveringFiles] = React.useState([]);
    const handleFilesOut = React.useCallback(() => setHoveringFiles([]), []);
    return /*#__PURE__*/React.createElement(Root, null, /*#__PURE__*/React.createElement(FileTarget, _extends({}, rest, {
      ref: forwardedRef,
      onFiles: handleFiles,
      onFilesOver: setHoveringFiles,
      onFilesOut: handleFilesOut
    }), resolveUploader && hoveringFiles.length > 0 && /*#__PURE__*/React.createElement(Overlay, {
      zOffset: 10
    }, /*#__PURE__*/React.createElement(DropMessage, {
      hoveringFiles: hoveringFiles,
      types: types,
      resolveUploader: resolveUploader
    })), children));
  });
}