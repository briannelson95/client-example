import _noop from "lodash/noop";

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { render } from '@testing-library/react';
import React, { forwardRef, useImperativeHandle } from 'react';
import Schema from '@sanity/schema';
import { LayerProvider, studioTheme, ThemeProvider, ToastProvider } from '@sanity/ui';
import { of } from 'rxjs';
import { RouterProvider, route } from '../../../../router';
import { ReferenceInput } from '../ReferenceInput';

const EMPTY_SEARCH = () => of([]);

const AVAILABLE = {
  available: true,
  reason: 'READABLE'
};
const UNAVAILABLE_NOT_FOUND = {
  available: false,
  reason: 'NOT_FOUND'
};
const UNAVAILABLE_PERMISSION_DENIED = {
  available: false,
  reason: 'PERMISSION_DENIED'
};
const infinityNoop = new Proxy(() => infinityNoop, {
  get: () => infinityNoop
}); // eslint-disable-next-line @typescript-eslint/no-explicit-any

const StubComponent = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    documentId,
    documentType
  } = _ref;
  useImperativeHandle(ref, () => infinityNoop, []);
  return null;
});
StubComponent.displayName = 'StubComponent';

function ReferenceInputTester(props) {
  const onFocus = jest.fn();
  const onChange = jest.fn();
  return /*#__PURE__*/React.createElement(RouterProvider, {
    router: route.intents('/intents'),
    state: {},
    onNavigate: _noop
  }, /*#__PURE__*/React.createElement(ThemeProvider, {
    scheme: "light",
    theme: studioTheme
  }, /*#__PURE__*/React.createElement(ToastProvider, null, /*#__PURE__*/React.createElement(LayerProvider, null, /*#__PURE__*/React.createElement(ReferenceInput, _extends({
    onFocus: onFocus,
    onChange: onChange,
    validation: [],
    level: 0,
    liveEdit: false,
    focusPath: [],
    presence: [],
    onSearch: EMPTY_SEARCH,
    createOptions: [],
    editReferenceLinkComponent: StubComponent,
    onEditReference: _noop
  }, props))))));
}

function ReferenceInfoTester(props) {
  const schema = Schema.compile({
    types: [{
      name: 'actor',
      type: 'document',
      fields: [{
        name: 'name',
        type: 'string'
      }]
    }, {
      name: 'actorReference',
      type: 'reference',
      weak: props.typeIsWeakRef,
      to: [{
        type: 'actor'
      }]
    }]
  });
  return /*#__PURE__*/React.createElement(ReferenceInputTester, {
    getReferenceInfo: id => of(props.referenceInfo),
    onSearch: EMPTY_SEARCH,
    focusPath: props.isEditing ? ['_ref'] : [],
    schemaType: schema.get('actorReference'),
    value: props.value
  });
}

const PUBLISHED_PREVIEW = {
  title: 'Actor (published)',
  description: ''
};
const DRAFT_PREVIEW = {
  title: 'Actor (draft)',
  description: ''
};
describe('if schema type is a strong reference', () => {
  test('the UI does *NOT* show a warning if the draft exist and the reference value is weak and has a _strengthenOnPublish flag', () => {
    const {
      getByTestId,
      queryByTestId
    } = render( /*#__PURE__*/React.createElement(ReferenceInfoTester, {
      value: {
        _type: 'reference',
        _ref: 'someActor',
        _weak: true,
        _strengthenOnPublish: {
          type: 'actor'
        }
      },
      referenceInfo: {
        id: 'someActor',
        type: 'actorReference',
        availability: AVAILABLE,
        preview: {
          published: undefined,
          draft: DRAFT_PREVIEW
        }
      }
    }));
    expect(queryByTestId('alert-nonexistent-document')).toBe(null);
  });
  test('the UI shows a warning if the document is published and the value is is weak', () => {
    const {
      getByTestId,
      queryByTestId
    } = render( /*#__PURE__*/React.createElement(ReferenceInfoTester, {
      value: {
        _type: 'reference',
        _weak: true,
        _ref: 'someActor'
      },
      referenceInfo: {
        id: 'someActor',
        type: 'actorReference',
        availability: AVAILABLE,
        preview: {
          published: undefined,
          draft: DRAFT_PREVIEW
        }
      }
    }));
    expect(queryByTestId('alert-reference-strength-mismatch')).toBeInTheDocument();
  });
});
describe('if schema type is a weak reference', () => {
  test('the UI indicates that the referenced document does not exist', () => {
    const {
      getByTestId
    } = render( /*#__PURE__*/React.createElement(ReferenceInfoTester, {
      typeIsWeakRef: true,
      value: {
        _type: 'reference',
        _weak: true,
        _ref: 'someActor'
      },
      referenceInfo: {
        id: 'someActor',
        type: 'actorReference',
        availability: UNAVAILABLE_NOT_FOUND,
        preview: {
          published: PUBLISHED_PREVIEW,
          draft: DRAFT_PREVIEW
        }
      }
    }));
    expect(getByTestId('alert-nonexistent-document')).toBeInTheDocument();
  });
  test('a warning is visible if the reference value is strong while the schema says it should be weak', () => {
    const {
      getByTestId
    } = render( /*#__PURE__*/React.createElement(ReferenceInfoTester, {
      typeIsWeakRef: true,
      value: {
        _type: 'reference',
        _ref: 'someActor'
      },
      referenceInfo: {
        id: 'someActor',
        type: 'actorReference',
        availability: AVAILABLE,
        preview: {
          published: PUBLISHED_PREVIEW,
          draft: DRAFT_PREVIEW
        }
      }
    }));
    expect(getByTestId('alert-reference-strength-mismatch')).toBeInTheDocument();
  });
});