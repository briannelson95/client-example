function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import Debug from 'debug';
const debug = Debug('sanity-imagetool');
const supportsTouch = typeof window !== 'undefined' && 'ontouchstart' in window;
export function makeDragAware(Component) {
  return class DragAware extends React.PureComponent {
    constructor() {
      super(...arguments);

      _defineProperty(this, "domNode", null);

      _defineProperty(this, "currentPos", null);

      _defineProperty(this, "isDragging", false);

      _defineProperty(this, "handleTouchMove", event => {
        // Disables mobile scroll by touch
        if (this.isDragging) {
          event.preventDefault();
        }
      });

      _defineProperty(this, "handleDragStart", event => {
        const {
          onDragStart,
          readOnly
        } = this.props;

        if (readOnly || !this.domNode) {
          return;
        }

        if (this.isDragging) {
          debug('Start cancelled, already a drag in progress');
          return;
        }

        this.isDragging = true;
        const nextPos = getPos(event);
        debug('Drag started %o', nextPos);
        onDragStart(getPositionRelativeToRect(nextPos.x, nextPos.y, this.domNode.getBoundingClientRect()));
        this.currentPos = nextPos;
      });

      _defineProperty(this, "handleDrag", event => {
        if (!this.isDragging || this.props.readOnly || !this.currentPos) {
          return;
        }

        const {
          onDrag
        } = this.props;
        const nextPos = getPos(event);
        const diff = diffPos(nextPos, this.currentPos);
        onDrag(diff);
        debug('moving by %o', diff);
        this.currentPos = nextPos;
      });

      _defineProperty(this, "handleDragEnd", event => {
        const {
          onDragEnd,
          readOnly
        } = this.props;

        if (!this.isDragging || readOnly || !this.domNode) {
          return;
        }

        const nextPos = getPos(event);
        onDragEnd(getPositionRelativeToRect(nextPos.x, nextPos.y, this.domNode.getBoundingClientRect()));
        this.isDragging = false;
        this.currentPos = null;
        debug('Done moving %o', nextPos);
      });

      _defineProperty(this, "handleDragCancel", () => {
        if (!this.isDragging || this.props.readOnly || !this.currentPos || !this.domNode) {
          return;
        }

        const {
          onDragEnd
        } = this.props;
        this.isDragging = false;
        onDragEnd(getPositionRelativeToRect(this.currentPos.x, this.currentPos.y, this.domNode.getBoundingClientRect()));
        this.currentPos = null;
      });

      _defineProperty(this, "setDomNode", node => {
        this.domNode = node;
      });
    }

    componentDidMount() {
      if (supportsTouch) {
        document.body.addEventListener('touchmove', this.handleTouchMove, {
          passive: false
        });
        document.body.addEventListener('touchend', this.handleDragEnd);
        document.body.addEventListener('touchcancel', this.handleDragCancel);
      } else {
        document.body.addEventListener('mousemove', this.handleDrag);
        document.body.addEventListener('mouseup', this.handleDragEnd);
        document.body.addEventListener('mouseleave', this.handleDragCancel);
      }
    }

    componentWillUnmount() {
      if (supportsTouch) {
        document.body.removeEventListener('touchmove', this.handleTouchMove);
        document.body.removeEventListener('touchend', this.handleDragEnd);
        document.body.removeEventListener('touchcancel', this.handleDragCancel);
      } else {
        document.body.removeEventListener('mousemove', this.handleDrag);
        document.body.removeEventListener('mouseup', this.handleDragEnd);
        document.body.removeEventListener('mouseleave', this.handleDragCancel);
      }
    }

    render() {
      const {
        readOnly,
        onDragStart,
        onDragEnd,
        onDrag,
        ...rest
      } = this.props;
      return /*#__PURE__*/React.createElement(Component, _extends({
        ref: this.setDomNode,
        onTouchStart: readOnly ? undefined : this.handleDragStart,
        onMouseDown: readOnly ? undefined : this.handleDragStart,
        onTouchMove: readOnly ? undefined : this.handleDrag
      }, rest));
    }

  };
}

function getPositionRelativeToRect(x, y, rect) {
  return {
    x: x - rect.left,
    y: y - rect.top
  };
}

function getPos(event) {
  if ('touches' in event) {
    return event.touches.length > 0 ? {
      x: event.touches[0].clientX,
      y: event.touches[0].clientY
    } : {
      x: 0,
      y: 0
    };
  }

  return {
    x: event.clientX,
    y: event.clientY
  };
}

function diffPos(pos, otherPos) {
  return {
    x: pos.x - otherPos.x,
    y: pos.y - otherPos.y
  };
}