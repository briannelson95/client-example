import _get from "lodash/get";

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable import/no-unresolved,react/jsx-handler-names */
import { Box, Button, Card, Dialog, Menu, MenuButton, MenuItem, Stack } from '@sanity/ui';
import { ChevronDownIcon, ImageIcon, SearchIcon } from '@sanity/icons';
import React from 'react';
import { setIfMissing, unset } from '../../../patch';
import { PresenceOverlay } from '../../../../presence';
import { ImperativeToast } from '../../../../components/transitional';
import { UploadPlaceholder } from '../common/UploadPlaceholder';
import { WithReferencedAsset } from '../../../utils/WithReferencedAsset';
import { FileTarget } from '../common/styles';
import { UploadProgress } from '../common/UploadProgress';
import { handleSelectAssetFromSource } from '../common/assetSource';
import { ActionsMenu } from '../common/ActionsMenu';
import { UploadWarning } from '../common/UploadWarning';
import { ImageToolInput } from '../ImageToolInput';
import { ChangeIndicator } from '../../../../components/changeIndicators';
import { FormInput } from '../../../FormInput';
import { MemberField, MemberFieldError, MemberFieldSet } from '../../../members';
import { ImageActionsMenu } from './ImageActionsMenu';
import { ImagePreview } from './ImagePreview';
import { isImageSource } from '@sanity/asset-utils';
import { InvalidImageWarning } from './InvalidImageWarning';

const getDevicePixelRatio = () => {
  if (typeof window === 'undefined' || !window.devicePixelRatio) {
    return 1;
  }

  return Math.round(Math.max(1, window.devicePixelRatio));
};

function passThrough(_ref) {
  let {
    children
  } = _ref;
  return children;
}

const ASSET_FIELD_PATH = ['asset'];
const ASSET_IMAGE_MENU_POPOVER = {
  portal: true
};
export class ImageInput extends React.PureComponent {
  constructor(props) {
    var _this;

    super(props);
    _this = this;

    _defineProperty(this, "_assetElementRef", null);

    _defineProperty(this, "_assetPath", void 0);

    _defineProperty(this, "uploadSubscription", null);

    _defineProperty(this, "state", {
      isUploading: false,
      selectedAssetSource: null,
      hoveringFiles: [],
      isStale: false,
      isMenuOpen: false
    });

    _defineProperty(this, "toast", null);

    _defineProperty(this, "setFocusElement", el => {
      this._assetElementRef = el;
    });

    _defineProperty(this, "getUploadOptions", file => {
      const {
        schemaType,
        resolveUploader
      } = this.props;
      const uploader = resolveUploader && resolveUploader(schemaType, file);
      return uploader ? [{
        type: schemaType,
        uploader
      }] : [];
    });

    _defineProperty(this, "uploadWith", function (uploader, file) {
      let assetDocumentProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      const {
        schemaType,
        onChange,
        client
      } = _this.props;
      const {
        label,
        title,
        description,
        creditLine,
        source
      } = assetDocumentProps;
      const options = {
        metadata: _get(schemaType, 'options.metadata'),
        storeOriginalFilename: _get(schemaType, 'options.storeOriginalFilename'),
        label,
        title,
        description,
        creditLine,
        source
      };

      _this.cancelUpload();

      _this.setState({
        isUploading: true
      });

      onChange(setIfMissing({
        _type: schemaType.name
      }));
      _this.uploadSubscription = uploader.upload(client, file, schemaType, options).subscribe({
        next: uploadEvent => {
          if (uploadEvent.patches) {
            onChange(uploadEvent.patches);
          }
        },
        error: err => {
          var _this$toast;

          // eslint-disable-next-line no-console
          console.error(err);
          (_this$toast = _this.toast) === null || _this$toast === void 0 ? void 0 : _this$toast.push({
            status: 'error',
            description: 'The upload could not be completed at this time.',
            title: 'Upload failed'
          });

          _this.clearUploadStatus();
        },
        complete: () => {
          onChange([unset(['hotspot']), unset(['crop'])]);

          _this.setState({
            isUploading: false
          }); // this.toast.push({
          //   status: 'success',
          //   title: 'Upload completed',
          // })

        }
      });
    });

    _defineProperty(this, "handleRemoveButtonClick", () => {
      const {
        value
      } = this.props; // When removing the image, we should also remove any crop and hotspot
      // _type and _key are "meta"-properties and are not significant unless
      // other properties are present. Thus, we want to remove the entire
      // "container" object if these are the only properties present, BUT
      // only if we're not an array element, as removing the array element
      // will close the selection dialog. Instead, when closing the dialog,
      // the array logic will check for an "empty" value and remove it for us

      const allKeys = Object.keys(value || {});
      const remainingKeys = allKeys.filter(key => !['_type', '_key', '_upload', 'asset', 'crop', 'hotspot'].includes(key));
      const isEmpty = remainingKeys.length === 0;
      const removeKeys = ['asset'].concat(allKeys.filter(key => ['crop', 'hotspot', '_upload'].includes(key))).map(key => unset([key]));
      this.props.onChange(isEmpty && !this.valueIsArrayElement() ? unset() : removeKeys);
    });

    _defineProperty(this, "handleFieldChange", event => {
      const {
        onChange,
        schemaType
      } = this.props; // When editing a metadata field for an image (eg `altText`), and no asset
      // is currently selected, we want to unset the entire image field if the
      // field we are currently editing goes blank and gets unset.
      //
      // For instance:
      // An image field with an `altText` and a `title` subfield, where the image
      // `asset` and the `title` field is empty, and we are erasing the `alt` field.
      // We do _not_ however want to clear the field if any content is present in
      // the other fields - but we do not consider `crop` and `hotspot`.
      //
      // Also, we don't want to use this logic for array items, since the parent will
      // take care of it when closing the array dialog

      if (!this.valueIsArrayElement() && this.eventIsUnsettingLastFilledField(event)) {
        onChange(unset());
        return;
      }

      onChange(event.prepend(setIfMissing({
        _type: schemaType.name
      })).patches);
    });

    _defineProperty(this, "eventIsUnsettingLastFilledField", event => {
      const patch = event.patches[0];

      if (event.patches.length !== 1 || patch.type !== 'unset') {
        return false;
      }

      const allKeys = Object.keys(this.props.value || {});
      const remainingKeys = allKeys.filter(key => !['_type', '_key', 'crop', 'hotspot'].includes(key));
      const isEmpty = event.patches[0].path.length === 1 && remainingKeys.length === 1 && remainingKeys[0] === event.patches[0].path[0];
      return isEmpty;
    });

    _defineProperty(this, "valueIsArrayElement", () => {
      const {
        path
      } = this.props;
      const parentPathSegment = path.slice(-1)[0]; // String path segment mean an object path, while a number or a
      // keyed segment means we're a direct child of an array

      return typeof parentPathSegment !== 'string';
    });

    _defineProperty(this, "handleOpenDialog", () => {
      const {
        onOpenField
      } = this.props;
      onOpenField('hotspot');
    });

    _defineProperty(this, "handleCloseDialog", () => {
      const {
        onCloseField
      } = this.props;
      onCloseField('hotspot');
    });

    _defineProperty(this, "handleSelectAssetFromSource", assetFromSource => {
      const {
        onChange,
        schemaType,
        resolveUploader
      } = this.props;
      handleSelectAssetFromSource({
        assetFromSource,
        onChange,
        type: schemaType,
        resolveUploader,
        uploadWith: this.uploadWith,
        isImage: true
      });
      this.setState({
        selectedAssetSource: null
      });
    });

    _defineProperty(this, "handleFilesOver", hoveringFiles => {
      this.setState({
        hoveringFiles
      });
    });

    _defineProperty(this, "handleFilesOut", () => {
      this.setState({
        hoveringFiles: []
      });
    });

    _defineProperty(this, "handleCancelUpload", () => {
      this.cancelUpload();
    });

    _defineProperty(this, "handleClearUploadState", () => {
      this.setState({
        isStale: false
      });
      this.clearUploadStatus();
    });

    _defineProperty(this, "handleStaleUpload", () => {
      this.setState({
        isStale: true
      });
    });

    _defineProperty(this, "handleClearField", () => {
      this.props.onChange([unset(['asset']), unset(['crop']), unset(['hotspot'])]);
    });

    _defineProperty(this, "handleSelectFiles", files => {
      const {
        directUploads,
        readOnly
      } = this.props;
      const {
        hoveringFiles
      } = this.state;

      if (directUploads && !readOnly) {
        this.uploadFirstAccepted(files);
      } else if (hoveringFiles.length > 0) {
        this.handleFilesOut();
      }
    });

    _defineProperty(this, "handleSelectImageFromAssetSource", source => {
      this.setState({
        selectedAssetSource: source
      });
    });

    _defineProperty(this, "handleAssetSourceClosed", () => {
      this.setState({
        selectedAssetSource: null
      });
    });

    _defineProperty(this, "renderHotspotInput", hotspotInputProps => {
      const {
        value,
        changed,
        id,
        imageUrlBuilder
      } = this.props;
      const withImageTool = this.isImageToolEnabled() && value && value.asset;
      return /*#__PURE__*/React.createElement(Dialog, {
        header: "Edit hotspot and crop",
        id: "".concat(id, "_dialog"),
        onClose: this.handleCloseDialog,
        width: 1,
        __unstable_autoFocus: false
      }, /*#__PURE__*/React.createElement(PresenceOverlay, null, /*#__PURE__*/React.createElement(Box, {
        padding: 4
      }, /*#__PURE__*/React.createElement(Stack, {
        space: 5
      }, withImageTool && (value === null || value === void 0 ? void 0 : value.asset) && /*#__PURE__*/React.createElement(ImageToolInput, _extends({}, this.props, {
        imageUrl: imageUrlBuilder.image(value.asset).url(),
        value: value,
        presence: hotspotInputProps.presence,
        changed: changed
      }))))));
    });

    _defineProperty(this, "renderPreview", () => {
      const {
        value,
        schemaType,
        readOnly,
        directUploads,
        imageUrlBuilder,
        resolveUploader
      } = this.props;

      if (!value || !isImageSource(value)) {
        return null;
      }

      const {
        hoveringFiles
      } = this.state;
      const acceptedFiles = hoveringFiles.filter(file => resolveUploader(schemaType, file));
      const rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
      const imageUrl = imageUrlBuilder.width(2000).fit('max').image(value).dpr(getDevicePixelRatio()).auto('format').url();
      return /*#__PURE__*/React.createElement(ImagePreview, {
        drag: !(value !== null && value !== void 0 && value._upload) && hoveringFiles.length > 0,
        isRejected: rejectedFilesCount > 0 || !directUploads,
        readOnly: readOnly,
        src: imageUrl,
        alt: "Preview of uploaded image"
      });
    });

    _defineProperty(this, "setToast", toast => {
      this.toast = toast;
    });

    this._assetPath = props.path.concat(ASSET_FIELD_PATH);
  }

  focus() {
    if (this._assetElementRef) {
      this._assetElementRef.focus();
    }
  }

  isImageToolEnabled() {
    return _get(this.props.schemaType, 'options.hotspot') === true;
  }

  clearUploadStatus() {
    var _this$props$value;

    if ((_this$props$value = this.props.value) !== null && _this$props$value !== void 0 && _this$props$value._upload) {
      this.props.onChange(unset(['_upload']));
    }
  }

  cancelUpload() {
    if (this.uploadSubscription) {
      this.uploadSubscription.unsubscribe();
      this.clearUploadStatus();
    }
  }

  uploadFirstAccepted(files) {
    const {
      schemaType,
      resolveUploader
    } = this.props;
    const match = files.map(file => ({
      file,
      uploader: resolveUploader(schemaType, file)
    })).find(result => result.uploader);

    if (match) {
      this.uploadWith(match.uploader, match.file);
    }

    this.setState({
      isMenuOpen: false
    });
  }

  renderAssetMenu() {
    const {
      value,
      assetSources,
      schemaType,
      readOnly,
      directUploads,
      imageUrlBuilder,
      observeAsset
    } = this.props;
    const {
      isMenuOpen
    } = this.state;
    const asset = value === null || value === void 0 ? void 0 : value.asset;

    if (!asset) {
      return null;
    }

    const accept = _get(schemaType, 'options.accept', 'image/*');

    const showAdvancedEditButton = value && asset && this.isImageToolEnabled();
    let browseMenuItem = assetSources && assetSources.length === 0 ? null : /*#__PURE__*/React.createElement(MenuItem, {
      icon: SearchIcon,
      text: "Select",
      onClick: () => {
        this.setState({
          isMenuOpen: false
        });
        this.handleSelectImageFromAssetSource(assetSources[0]);
      },
      disabled: readOnly,
      "data-testid": "file-input-browse-button"
    });

    if (assetSources && assetSources.length > 1) {
      browseMenuItem = assetSources.map(assetSource => {
        return /*#__PURE__*/React.createElement(MenuItem, {
          key: assetSource.name,
          text: assetSource.title,
          onClick: () => {
            this.setState({
              isMenuOpen: false
            });
            this.handleSelectImageFromAssetSource(assetSource);
          },
          icon: assetSource.icon || ImageIcon,
          "data-testid": "file-input-browse-button-".concat(assetSource.name),
          disabled: readOnly
        });
      });
    }

    return /*#__PURE__*/React.createElement(WithReferencedAsset, {
      observeAsset: observeAsset,
      reference: asset
    }, _ref2 => {
      let {
        _id,
        originalFilename,
        extension
      } = _ref2;
      let copyUrl;
      let downloadUrl;

      if (isImageSource(value)) {
        const filename = originalFilename || "download.".concat(extension);
        downloadUrl = imageUrlBuilder.image(_id).forceDownload(filename).url();
        copyUrl = imageUrlBuilder.image(_id).url();
      }

      return /*#__PURE__*/React.createElement(ImageActionsMenu, {
        isMenuOpen: isMenuOpen,
        onEdit: this.handleOpenDialog,
        showEdit: showAdvancedEditButton,
        onMenuOpen: isOpen => this.setState({
          isMenuOpen: isOpen
        })
      }, /*#__PURE__*/React.createElement(ActionsMenu, {
        onUpload: this.handleSelectFiles,
        browse: browseMenuItem,
        onReset: this.handleRemoveButtonClick,
        downloadUrl: downloadUrl,
        copyUrl: copyUrl,
        readOnly: readOnly,
        directUploads: directUploads,
        accept: accept
      }));
    });
  }

  renderBrowser() {
    const {
      assetSources,
      readOnly,
      directUploads,
      id
    } = this.props;
    if (assetSources && assetSources.length === 0) return null;

    if (assetSources && assetSources.length > 1 && !readOnly && directUploads) {
      return /*#__PURE__*/React.createElement(MenuButton, {
        id: "".concat(id, "_assetImageButton"),
        button: /*#__PURE__*/React.createElement(Button, {
          mode: "ghost",
          text: "Select",
          "data-testid": "file-input-multi-browse-button",
          icon: SearchIcon,
          iconRight: ChevronDownIcon
        }),
        menu: /*#__PURE__*/React.createElement(Menu, null, assetSources.map(assetSource => {
          return /*#__PURE__*/React.createElement(MenuItem, {
            key: assetSource.name,
            text: assetSource.title,
            onClick: () => {
              this.setState({
                isMenuOpen: false
              });
              this.handleSelectImageFromAssetSource(assetSource);
            },
            icon: assetSource.icon || ImageIcon,
            disabled: readOnly,
            "data-testid": "file-input-browse-button-".concat(assetSource.name)
          });
        })),
        popover: ASSET_IMAGE_MENU_POPOVER
      });
    }

    return /*#__PURE__*/React.createElement(Button, {
      fontSize: 2,
      text: "Select",
      icon: SearchIcon,
      mode: "ghost",
      onClick: () => {
        this.setState({
          isMenuOpen: false
        });
        this.handleSelectImageFromAssetSource(assetSources[0]);
      },
      "data-testid": "file-input-browse-button",
      disabled: readOnly
    });
  }

  renderUploadPlaceholder() {
    const {
      schemaType,
      readOnly,
      directUploads,
      resolveUploader
    } = this.props;
    const {
      hoveringFiles
    } = this.state;
    const acceptedFiles = hoveringFiles.filter(file => resolveUploader(schemaType, file));
    const rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;

    const accept = _get(schemaType, 'options.accept', 'image/*');

    return /*#__PURE__*/React.createElement("div", {
      style: {
        padding: 1
      }
    }, /*#__PURE__*/React.createElement(Card, {
      tone: readOnly ? 'transparent' : 'inherit',
      border: true,
      padding: 3,
      style: hoveringFiles.length === 0 ? {
        borderStyle: 'dashed'
      } : {
        borderStyle: 'dashed',
        borderColor: 'transparent'
      }
    }, /*#__PURE__*/React.createElement(UploadPlaceholder, {
      browse: this.renderBrowser(),
      onUpload: this.handleSelectFiles,
      readOnly: readOnly,
      hoveringFiles: hoveringFiles,
      acceptedFiles: acceptedFiles,
      rejectedFilesCount: rejectedFilesCount,
      type: "image",
      accept: accept,
      directUploads: directUploads
    })));
  }

  renderUploadState(uploadState) {
    var _this$_assetElementRe;

    const {
      isUploading
    } = this.state;
    const elementHeight = (_this$_assetElementRe = this._assetElementRef) === null || _this$_assetElementRe === void 0 ? void 0 : _this$_assetElementRe.offsetHeight;
    const height = elementHeight === 0 ? undefined : elementHeight;
    return /*#__PURE__*/React.createElement(UploadProgress, {
      uploadState: uploadState,
      onCancel: isUploading ? this.handleCancelUpload : undefined,
      onStale: this.handleStaleUpload,
      height: height
    });
  }

  renderAssetSource() {
    const {
      selectedAssetSource
    } = this.state;
    const {
      value,
      observeAsset
    } = this.props;

    if (!selectedAssetSource) {
      return null;
    }

    const Component = selectedAssetSource.component;

    if (value && value.asset) {
      return /*#__PURE__*/React.createElement(WithReferencedAsset, {
        observeAsset: observeAsset,
        reference: value.asset
      }, imageAsset => /*#__PURE__*/React.createElement(Component, {
        selectedAssets: [imageAsset],
        assetType: "image",
        selectionType: "single",
        onClose: this.handleAssetSourceClosed,
        onSelect: this.handleSelectAssetFromSource
      }));
    }

    return /*#__PURE__*/React.createElement(Component, {
      selectedAssets: [],
      selectionType: "single",
      assetType: "image",
      onClose: this.handleAssetSourceClosed,
      onSelect: this.handleSelectAssetFromSource
    });
  }

  getFileTone() {
    const {
      schemaType,
      value,
      readOnly,
      directUploads,
      resolveUploader
    } = this.props;
    const {
      hoveringFiles
    } = this.state;
    const acceptedFiles = hoveringFiles.filter(file => resolveUploader(schemaType, file));
    const rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;

    if (hoveringFiles.length > 0) {
      if (rejectedFilesCount > 0 || !directUploads) {
        return 'critical';
      }
    }

    if (!(value !== null && value !== void 0 && value._upload) && !readOnly && hoveringFiles.length > 0) {
      return 'primary';
    }

    if (readOnly) {
      return 'transparent';
    }

    return value !== null && value !== void 0 && value._upload && value !== null && value !== void 0 && value.asset ? 'transparent' : 'default';
  }

  renderAsset() {
    const {
      value,
      readOnly,
      onFocus,
      onBlur
    } = this.props;
    const {
      hoveringFiles,
      isStale
    } = this.state;
    const hasValueOrUpload = Boolean((value === null || value === void 0 ? void 0 : value._upload) || (value === null || value === void 0 ? void 0 : value.asset));

    if (value && typeof value.asset !== 'undefined' && !(value !== null && value !== void 0 && value._upload) && !isImageSource(value)) {
      return () => /*#__PURE__*/React.createElement(InvalidImageWarning, {
        onClearValue: this.handleClearField
      });
    } // todo: convert this to a functional component and use this with useCallback
    //  it currently has to return a new function on every render in order to pick up state from this component


    return inputProps => /*#__PURE__*/React.createElement(React.Fragment, null, isStale && /*#__PURE__*/React.createElement(Box, {
      marginBottom: 2
    }, /*#__PURE__*/React.createElement(UploadWarning, {
      onClearStale: this.handleClearUploadState
    })), /*#__PURE__*/React.createElement(ChangeIndicator, {
      path: inputProps.path.concat(ASSET_FIELD_PATH),
      hasFocus: !!inputProps.focused,
      isChanged: inputProps.changed
    }, !(value !== null && value !== void 0 && value._upload) && /*#__PURE__*/React.createElement(FileTarget, {
      tabIndex: 0,
      disabled: Boolean(readOnly),
      ref: this.setFocusElement,
      onFiles: this.handleSelectFiles,
      onFilesOver: this.handleFilesOver,
      onFilesOut: this.handleFilesOut,
      onFocus: onFocus,
      onBlur: onBlur,
      tone: this.getFileTone(),
      $border: hasValueOrUpload || hoveringFiles.length > 0,
      style: {
        padding: 1
      },
      sizing: "border",
      radius: 2
    }, !(value !== null && value !== void 0 && value.asset) && this.renderUploadPlaceholder(), !(value !== null && value !== void 0 && value._upload) && (value === null || value === void 0 ? void 0 : value.asset) && /*#__PURE__*/React.createElement("div", {
      style: {
        position: 'relative'
      }
    }, this.renderAssetMenu(), this.renderPreview())), (value === null || value === void 0 ? void 0 : value._upload) && this.renderUploadState(value._upload)));
  }

  render() {
    const {
      members,
      renderInput,
      renderField,
      renderItem,
      renderPreview
    } = this.props;
    const {
      selectedAssetSource
    } = this.state; // we use the hotspot field as the "owner" of both hotspot and crop

    const hotspotField = members.find(member => member.kind === 'field' && member.name === 'hotspot');
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ImperativeToast, {
      ref: this.setToast
    }), members.map(member => {
      if (member.kind === 'field' && (member.name === 'crop' || member.name === 'hotspot')) {
        // we're rendering these separately
        return null;
      }

      if (member.kind === 'field') {
        return /*#__PURE__*/React.createElement(MemberField, {
          key: member.key,
          member: member,
          renderInput: member.name === 'asset' ? this.renderAsset() : renderInput,
          renderField: member.name === 'asset' ? passThrough : renderField,
          renderItem: renderItem,
          renderPreview: renderPreview
        });
      }

      if (member.kind === 'fieldSet') {
        return /*#__PURE__*/React.createElement(MemberFieldSet, {
          key: member.key,
          member: member,
          renderInput: renderInput,
          renderField: renderField,
          renderItem: renderItem,
          renderPreview: renderPreview
        });
      }

      if (member.kind === 'error') {
        return /*#__PURE__*/React.createElement(MemberFieldError, {
          member: member
        });
      } //@ts-expect-error all possible cases should be covered


      return /*#__PURE__*/React.createElement(React.Fragment, null, "Unknown member kind: $", member.kind);
    }), (hotspotField === null || hotspotField === void 0 ? void 0 : hotspotField.open) && /*#__PURE__*/React.createElement(FormInput, _extends({}, this.props, {
      absolutePath: hotspotField.field.path,
      renderInput: this.renderHotspotInput
    })), selectedAssetSource && this.renderAssetSource());
  }

}