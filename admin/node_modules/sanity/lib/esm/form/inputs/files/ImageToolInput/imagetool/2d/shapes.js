function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

export class Size {
  constructor(height, width) {
    _defineProperty(this, "height", void 0);

    _defineProperty(this, "width", void 0);

    this.height = height;
    this.width = width;
  }

}
export class Point {
  constructor(x, y) {
    _defineProperty(this, "x", void 0);

    _defineProperty(this, "y", void 0);

    this.x = x;
    this.y = y;
  }

}

class HLine {
  constructor(y, left, right) {
    _defineProperty(this, "y", void 0);

    _defineProperty(this, "_left", void 0);

    _defineProperty(this, "_right", void 0);

    this.y = y;
    this._left = left;
    this._right = right;
  }

  get right() {
    return new Point(this._right, this.y);
  }

  get left() {
    return new Point(this._left, this.y);
  }

  get length() {
    return this._right - this._left;
  }

}

class Corners {
  constructor(rect) {
    _defineProperty(this, "rect", void 0);

    this.rect = rect;
  }

  get top() {
    return new HLine(this.rect.top, this.rect.left, this.rect.right);
  }

  get bottom() {
    return new HLine(this.rect.bottom, this.rect.left, this.rect.right);
  }

}

export class Rect {
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  static fromEdges(_ref) {
    let {
      left,
      right,
      top,
      bottom
    } = _ref;
    return new Rect(left, top, 1 - left - right, 1 - top - bottom);
  }

  constructor() {
    let left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    _defineProperty(this, "left", void 0);

    _defineProperty(this, "top", void 0);

    _defineProperty(this, "width", void 0);

    _defineProperty(this, "height", void 0);

    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
  }

  setTopLeft(left, top) {
    return new Rect(left, top, this.width || 0, this.height || 0);
  }

  setSize(width, height) {
    return new Rect(this.left || 0, this.top || 0, width, height);
  }

  setCenter(x, y) {
    const width = this.width || 0;
    const height = this.height || 0;
    return new Rect(x - width / 2, y - height / 2, width || 0, height || 0);
  }

  get center() {
    return new Point(this.left + this.width / 2, this.top + this.height / 2);
  }

  get corners() {
    return new Corners(this);
  }

  get right() {
    return this.left + this.width;
  }

  get bottom() {
    return this.top + this.height;
  }

  multiply(rect) {
    return new Rect((this.left || 0) + this.width * rect.left, (this.top || 0) + this.height * rect.top, this.width * rect.width, this.height * rect.height);
  }

  grow(delta) {
    return new Rect(this.left - delta, this.top - delta, this.width + delta * 2, this.height + delta * 2);
  }

  shrink(delta) {
    return this.grow(-delta);
  }

  cropRelative(crop) {
    const top = this.top + crop.top * this.height;
    const left = this.left + crop.left * this.width;
    const height = this.height * crop.height;
    const width = this.width * crop.width;
    return new Rect(left, top, width, height);
  }

  clamp(bounds) {
    // always try to fit the whole rect inside given bounds
    // adjust top, left if we can, resize if we must
    let {
      left,
      top,
      width,
      height
    } = this;

    if (bounds.width < width) {
      width = bounds.width;
      left = bounds.left;
    }

    if (bounds.height < height) {
      height = bounds.height;
      top = bounds.top;
    }

    if (left + width > bounds.left + bounds.width) {
      left = bounds.right - width;
    }

    if (top + height > bounds.top + bounds.height) {
      top = bounds.bottom - height;
    }

    return new Rect(Math.max(left, bounds.left), Math.max(top, bounds.top), width, height);
  }

}