import _debounce from "lodash/debounce";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import Debug from 'debug';
import { calculateStyles } from './calculateStyles';
import { DEFAULT_HOTSPOT, DEFAULT_CROP } from './constants';
import { HotspotImageContainer } from './HotspotImage.styles';
const debug = Debug('sanity-imagetool');

function getCropAspect(crop, srcAspect) {
  const origHeight = 1 / srcAspect;
  const origWidth = srcAspect * origHeight;
  const cropWidth = origWidth - (crop.left + crop.right) * origWidth;
  const cropHeight = origHeight - (crop.top + crop.bottom) * origHeight;
  return cropWidth / cropHeight;
}

export class HotspotImage extends React.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      containerAspect: null
    });

    _defineProperty(this, "containerElement", null);

    _defineProperty(this, "imageElement", null);

    _defineProperty(this, "setImageElement", el => {
      this.imageElement = el;
    });

    _defineProperty(this, "handleResize", _debounce(() => this.updateContainerAspect(this.props)));

    _defineProperty(this, "setContainerElement", el => {
      this.containerElement = el;
    });
  }

  componentDidMount() {
    const imageElement = this.imageElement; // Fixes issues that may happen if the component is rendered on server and mounted after the image has finished loading
    // In these situations, neither the onLoad or the onError events will be called.
    // Derived from http://imagesloaded.desandro.com/

    const alreadyLoaded = imageElement && imageElement.src && imageElement.complete && imageElement.naturalWidth !== undefined;

    if (alreadyLoaded) {
      debug("Image '%s' already loaded, refreshing (from cache) to trigger onLoad / onError", this.props.src); // eslint-disable-next-line no-self-assign

      imageElement.src = imageElement.src;
    }

    this.updateContainerAspect(this.props);

    if (typeof window !== 'undefined') {
      window.addEventListener('resize', this.handleResize);
    }
  }

  componentWillUnmount() {
    if (typeof window !== 'undefined') {
      window.removeEventListener('resize', this.handleResize);
    }
  } // eslint-disable-next-line camelcase


  UNSAFE_componentWillReceiveProps(nextProps) {
    if (nextProps.aspectRatio !== this.props.aspectRatio) {
      this.updateContainerAspect(nextProps);
    }
  }

  updateContainerAspect(props) {
    if (!this.containerElement) return;

    if (props.aspectRatio === 'auto') {
      const parentNode = this.containerElement.parentNode;
      this.setState({
        containerAspect: parentNode.offsetWidth / parentNode.offsetHeight
      });
    } else {
      this.setState({
        containerAspect: null
      });
    }
  }

  getTargetAspectValue() {
    const {
      aspectRatio,
      srcAspectRatio,
      crop
    } = this.props;

    if (aspectRatio === 'none') {
      return crop ? getCropAspect(crop, srcAspectRatio) : srcAspectRatio;
    }

    if (aspectRatio === 'auto') {
      return this.state.containerAspect;
    }

    return aspectRatio || null;
  }

  render() {
    const {
      srcAspectRatio,
      crop,
      hotspot,
      src,
      srcSet,
      alignX = 'center',
      alignY = 'center',
      className,
      style,
      alt,
      onError,
      onLoad
    } = this.props;
    const targetAspect = this.getTargetAspectValue();
    const targetStyles = calculateStyles({
      container: {
        aspectRatio: targetAspect || srcAspectRatio
      },
      image: {
        aspectRatio: srcAspectRatio
      },
      hotspot,
      crop,
      align: {
        x: alignX,
        y: alignY
      }
    });
    return /*#__PURE__*/React.createElement(HotspotImageContainer, {
      className: "".concat(className),
      style: style,
      ref: this.setContainerElement
    }, /*#__PURE__*/React.createElement("div", {
      style: targetStyles.container
    }, /*#__PURE__*/React.createElement("div", {
      style: targetStyles.padding
    }), /*#__PURE__*/React.createElement("div", {
      style: targetStyles.crop
    }, /*#__PURE__*/React.createElement("img", {
      ref: this.setImageElement,
      src: src,
      alt: alt,
      srcSet: srcSet,
      onLoad: onLoad,
      onError: onError,
      style: targetStyles.image
    }))));
  }

}

_defineProperty(HotspotImage, "defaultProps", {
  alignX: 'center',
  alignY: 'center',
  className: '',
  crop: DEFAULT_CROP,
  hotspot: DEFAULT_HOTSPOT,
  aspectRatio: 'none'
});