var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6;

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

import { usePortableTextEditor, usePortableTextEditorSelection, // Type,
PortableTextEditor } from '@sanity/portable-text-editor';
import React, { memo, useCallback, useMemo, useState } from 'react';
import { Box, Button, Flex, Hotkeys, Text, Tooltip, useElementRect, useToast } from '@sanity/ui';
import { CollapseIcon, ExpandIcon } from '@sanity/icons';
import styled, { css } from 'styled-components';
import { useRovingFocus } from '../../../../components/rovingFocus';
import { resolveInitialValueForType } from '../../../../templates';
import { ActionMenu } from './ActionMenu';
import { BlockStyleSelect } from './BlockStyleSelect';
import { InsertMenu } from './InsertMenu';
import { getBlockStyles, getInsertMenuItems } from './helpers';
import { useActionGroups, useFeatures } from './hooks';
const RootFlex = styled(Flex)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  width: 100%;\n"])));
const StyleSelectBox = styled(Box)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n  width: 8em;\n"])));
const StyleSelectFlex = styled(Flex)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n  border-right: 1px solid var(--card-border-color);\n"])));
const ActionMenuBox = styled(Box)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n  ", "\n"])), _ref => {
  let {
    $withInsertMenu
  } = _ref;
  return $withInsertMenu && css(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["\n      max-width: max-content;\n      border-right: 1px solid var(--card-border-color);\n    "])));
});
const FullscreenButtonBox = styled(Box)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral(["\n  border-left: 1px solid var(--card-border-color);\n"])));
const SLOW_INITIAL_VALUE_LIMIT = 300;
const IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
const InnerToolbar = /*#__PURE__*/memo(function InnerToolbar(_ref2) {
  let {
    actionGroups,
    blockStyles,
    disabled,
    insertMenuItems,
    isFullscreen,
    onToggleFullscreen
  } = _ref2;
  const actionsLen = actionGroups.reduce((acc, x) => acc + x.actions.length, 0);
  const showActionMenu = actionsLen > 0;
  const showInsertMenu = insertMenuItems.length > 0;
  const [rootElement, setRootElement] = useState(null);
  const rootElementRect = useElementRect(rootElement);
  const collapsed = rootElementRect ? (rootElementRect === null || rootElementRect === void 0 ? void 0 : rootElementRect.width) < 400 : false;
  useRovingFocus({
    rootElement: rootElement
  });
  return /*#__PURE__*/React.createElement(RootFlex, {
    align: "center",
    ref: setRootElement
  }, /*#__PURE__*/React.createElement(StyleSelectFlex, {
    flex: collapsed ? 1 : undefined
  }, /*#__PURE__*/React.createElement(StyleSelectBox, {
    padding: isFullscreen ? 2 : 1
  }, /*#__PURE__*/React.createElement(BlockStyleSelect, {
    disabled: disabled,
    items: blockStyles
  }))), /*#__PURE__*/React.createElement(Flex, {
    flex: 1
  }, showActionMenu && /*#__PURE__*/React.createElement(ActionMenuBox, {
    flex: collapsed ? undefined : 1,
    padding: isFullscreen ? 2 : 1,
    $withInsertMenu: showInsertMenu
  }, /*#__PURE__*/React.createElement(ActionMenu, {
    disabled: disabled,
    collapsed: collapsed,
    groups: actionGroups,
    isFullscreen: isFullscreen
  })), showInsertMenu && /*#__PURE__*/React.createElement(Box, {
    flex: collapsed ? undefined : 1,
    padding: isFullscreen ? 2 : 1
  }, /*#__PURE__*/React.createElement(InsertMenu, {
    disabled: disabled,
    collapsed: collapsed,
    items: insertMenuItems,
    isFullscreen: isFullscreen
  }))), /*#__PURE__*/React.createElement(FullscreenButtonBox, {
    padding: isFullscreen ? 2 : 1
  }, /*#__PURE__*/React.createElement(Tooltip, {
    content: /*#__PURE__*/React.createElement(Flex, {
      align: "center",
      padding: 1
    }, /*#__PURE__*/React.createElement(Box, {
      flex: 1,
      paddingX: 1
    }, /*#__PURE__*/React.createElement(Text, {
      size: 1
    }, "".concat(isFullscreen ? 'Collapse' : 'Expand', " editor"))), /*#__PURE__*/React.createElement(Box, {
      marginLeft: 1
    }, /*#__PURE__*/React.createElement(Hotkeys, {
      keys: ["".concat(IS_MAC ? 'Cmd' : 'Ctrl'), 'Enter']
    }))),
    placement: isFullscreen ? 'bottom' : 'top',
    portal: "default"
  }, /*#__PURE__*/React.createElement(Button, {
    padding: 2,
    icon: isFullscreen ? CollapseIcon : ExpandIcon,
    mode: "bleed",
    onClick: onToggleFullscreen
  }))));
});
export function Toolbar(props) {
  const {
    hotkeys,
    isFullscreen,
    readOnly,
    onExpand,
    onToggleFullscreen
  } = props;
  const features = useFeatures();
  const editor = usePortableTextEditor();
  const selection = usePortableTextEditorSelection();
  const disabled = readOnly || !selection;
  const {
    push
  } = useToast();
  const resolveInitialValue = useCallback(type => {
    let isSlow = false;
    const slowTimer = setTimeout(() => {
      isSlow = true;
      push({
        id: 'resolving-initial-value',
        status: 'info',
        title: 'Resolving initial value…'
      });
    }, SLOW_INITIAL_VALUE_LIMIT);
    return resolveInitialValueForType(type, {}).then(value => {
      if (isSlow) {
        // I found no way to close an existing toast, so this will replace the message in the
        // "Resolving initial value…"-toast and then make sure it gets closed.
        push({
          id: 'resolving-initial-value',
          status: 'info',
          duration: 500,
          title: 'Initial value resolved'
        });
      }

      return value;
    }).catch(error => {
      push({
        title: "Could not resolve initial value",
        id: 'resolving-initial-value',
        description: "Unable to resolve initial value for type: ".concat(type.name, ": ").concat(error.message, "."),
        status: 'error'
      });
      return undefined;
    }).finally(() => clearTimeout(slowTimer));
  }, [push]);
  const handleInsertBlock = useCallback(async type => {
    const initialValue = await resolveInitialValue(type);
    const path = PortableTextEditor.insertBlock(editor, type, initialValue);

    if (path) {
      PortableTextEditor.blur(editor);
      onExpand(path);
    }
  }, [editor, onExpand, resolveInitialValue]);
  const handleInsertInline = useCallback(async type => {
    const initialValue = await resolveInitialValue(type);
    const path = PortableTextEditor.insertChild(editor, type, initialValue);

    if (path) {
      PortableTextEditor.blur(editor);
      onExpand(path);
    }
  }, [editor, onExpand, resolveInitialValue]);
  const actionGroups = useActionGroups({
    hotkeys,
    onExpand,
    resolveInitialValue,
    disabled: true
  });
  const blockStyles = useMemo(() => getBlockStyles(features), [features]);
  const insertMenuItems = useMemo(() => getInsertMenuItems(features, disabled, handleInsertBlock, handleInsertInline), [disabled, features, handleInsertBlock, handleInsertInline]);
  return /*#__PURE__*/React.createElement(InnerToolbar, {
    actionGroups: actionGroups,
    blockStyles: blockStyles,
    disabled: disabled,
    insertMenuItems: insertMenuItems,
    isFullscreen: isFullscreen,
    onToggleFullscreen: onToggleFullscreen
  });
}