import { PortableTextEditable } from '@sanity/portable-text-editor';
import { BoundaryElementProvider, useBoundaryElement, useGlobalKeyDown, useLayer } from '@sanity/ui';
import React, { useCallback, useMemo, useRef } from 'react';
import { Toolbar } from './toolbar';
import { Decorator } from './text';
import { EditableCard, EditableContainer, EditableWrapper, Root, Scroller, ToolbarCard } from './Editor.styles';
import { useSpellcheck } from './hooks/useSpellCheck';
import { useScrollSelectionIntoView } from './hooks/useScrollSelectionIntoView';

const renderDecorator = (mark, mType, attributes, defaultRender) => {
  return /*#__PURE__*/React.createElement(Decorator, {
    mark: mark
  }, defaultRender());
};

export function Editor(props) {
  const {
    hotkeys,
    initialSelection,
    isFullscreen,
    onCopy,
    onOpenItem,
    onPaste,
    onToggleFullscreen,
    path,
    readOnly,
    renderAnnotation,
    renderBlock,
    renderChild,
    scrollElement,
    setPortalElement,
    setScrollElement
  } = props;
  const {
    isTopLayer
  } = useLayer();
  const editableRef = useRef(null);
  const {
    element: boundaryElement
  } = useBoundaryElement(); // Let escape close fullscreen mode

  useGlobalKeyDown(useCallback(event => {
    if (!isTopLayer || !isFullscreen) {
      return;
    }

    if (event.key === 'Escape') {
      onToggleFullscreen();
    }
  }, [onToggleFullscreen, isFullscreen, isTopLayer])); // Keep the editor focused even though we are clicking on the background or the toolbar of the editor.

  const handleMouseDown = useCallback(event => {
    var _editableRef$current;

    if (event.target instanceof Node && !((_editableRef$current = editableRef.current) !== null && _editableRef$current !== void 0 && _editableRef$current.contains(event.target))) {
      event.preventDefault();
      event.stopPropagation();
    }
  }, []);
  const renderPlaceholder = useCallback(() => /*#__PURE__*/React.createElement(React.Fragment, null, "Empty"), []);
  const spellcheck = useSpellcheck();
  const scrollSelectionIntoView = useScrollSelectionIntoView(scrollElement);
  const editable = useMemo(() => /*#__PURE__*/React.createElement(PortableTextEditable, {
    hotkeys: hotkeys,
    onCopy: onCopy,
    onPaste: onPaste,
    ref: editableRef,
    readOnly: readOnly,
    renderAnnotation: renderAnnotation,
    renderBlock: renderBlock,
    renderChild: renderChild,
    renderDecorator: renderDecorator,
    renderPlaceholder: renderPlaceholder,
    scrollSelectionIntoView: scrollSelectionIntoView,
    selection: initialSelection,
    spellCheck: spellcheck
  }), [hotkeys, initialSelection, onCopy, onPaste, readOnly, renderAnnotation, renderBlock, renderChild, renderPlaceholder, scrollSelectionIntoView, spellcheck]);
  const handleToolBarOnExpand = useCallback(relativePath => {
    onOpenItem(path.concat(relativePath));
  }, [onOpenItem, path]);
  return /*#__PURE__*/React.createElement(Root, {
    $fullscreen: isFullscreen,
    "data-testid": "pt-editor",
    onMouseDown: handleMouseDown
  }, !readOnly && /*#__PURE__*/React.createElement(ToolbarCard, {
    "data-testid": "pt-editor__toolbar-card",
    shadow: 1
  }, /*#__PURE__*/React.createElement(Toolbar, {
    isFullscreen: isFullscreen,
    hotkeys: hotkeys,
    onExpand: handleToolBarOnExpand,
    readOnly: readOnly,
    onToggleFullscreen: onToggleFullscreen
  })), /*#__PURE__*/React.createElement(EditableCard, {
    flex: 1
  }, /*#__PURE__*/React.createElement(Scroller, {
    ref: setScrollElement
  }, /*#__PURE__*/React.createElement(EditableContainer, {
    padding: isFullscreen ? 2 : 0,
    sizing: "border",
    width: 1
  }, /*#__PURE__*/React.createElement(EditableWrapper, {
    $isFullscreen: isFullscreen,
    $readOnly: readOnly
  }, /*#__PURE__*/React.createElement(BoundaryElementProvider, {
    element: isFullscreen ? scrollElement : boundaryElement
  }, editable)))), /*#__PURE__*/React.createElement("div", {
    "data-portal": "",
    ref: setPortalElement
  })));
}