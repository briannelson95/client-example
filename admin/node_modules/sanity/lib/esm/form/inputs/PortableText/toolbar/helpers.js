import _get from "lodash/get";
import { BlockElementIcon, BoldIcon, CodeIcon, InlineElementIcon, ItalicIcon, LinkIcon, OlistIcon, StrikethroughIcon, UnderlineIcon, UnknownIcon, UlistIcon } from '@sanity/icons';
import { PortableTextEditor // Type,
} from '@sanity/portable-text-editor';
import React from 'react';
import { CustomIcon } from './CustomIcon';

function getPTEFormatActions(editor, disabled, hotkeyOpts) {
  const features = PortableTextEditor.getPortableTextFeatures(editor);
  return features.decorators.map(decorator => {
    var _decorator$blockEdito;

    const shortCutKey = Object.keys(hotkeyOpts.marks || {}).find(key => {
      var _hotkeyOpts$marks;

      return ((_hotkeyOpts$marks = hotkeyOpts.marks) === null || _hotkeyOpts$marks === void 0 ? void 0 : _hotkeyOpts$marks[key]) === decorator.value;
    });
    let hotkeys = [];

    if (shortCutKey) {
      hotkeys = [shortCutKey];
    }

    return {
      type: 'format',
      disabled: disabled,
      icon: (_decorator$blockEdito = decorator.blockEditor) === null || _decorator$blockEdito === void 0 ? void 0 : _decorator$blockEdito.icon,
      key: decorator.value,
      handle: () => {
        PortableTextEditor.toggleMark(editor, decorator.value);
        PortableTextEditor.focus(editor);
      },
      hotkeys,
      title: decorator.title
    };
  });
}

function getPTEListActions(editor, disabled) {
  const features = PortableTextEditor.getPortableTextFeatures(editor);
  return features.lists.map(listItem => {
    var _listItem$blockEditor;

    return {
      type: 'listStyle',
      key: listItem.value,
      disabled: disabled,
      icon: (_listItem$blockEditor = listItem.blockEditor) === null || _listItem$blockEditor === void 0 ? void 0 : _listItem$blockEditor.icon,
      handle: () => {
        PortableTextEditor.toggleList(editor, listItem.value);
      },
      title: listItem.title
    };
  });
}

function getAnnotationIcon(item) {
  return _get(item, 'icon') || _get(item, 'blockEditor.icon') || _get(item, 'type.icon') || _get(item, 'type.to.icon') || _get(item, 'type.to[0].icon');
}

function getPTEAnnotationActions(editor, disabled, onInsert) {
  const features = PortableTextEditor.getPortableTextFeatures(editor);
  const focusChild = PortableTextEditor.focusChild(editor);
  const hasText = focusChild && focusChild.text;
  return features.annotations.map(item => {
    return {
      type: 'annotation',
      disabled: !hasText || disabled,
      icon: getAnnotationIcon(item),
      key: item.value,
      handle: active => {
        if (active) {
          PortableTextEditor.removeAnnotation(editor, item.type);
          PortableTextEditor.focus(editor);
        } else {
          onInsert(item.type);
        }
      },
      title: item.title
    };
  });
}

export function getPTEToolbarActionGroups(editor, disabled, onInsertAnnotation, hotkeyOpts) {
  return [{
    name: 'format',
    actions: getPTEFormatActions(editor, disabled, hotkeyOpts)
  }, {
    name: 'list',
    actions: getPTEListActions(editor, disabled)
  }, {
    name: 'annotation',
    actions: getPTEAnnotationActions(editor, disabled, onInsertAnnotation)
  }];
}
export function getBlockStyles(features) {
  return features.styles.map(style => {
    return {
      key: "style-".concat(style.value),
      style: style.value,
      styleComponent: style && style.blockEditor && style.blockEditor.render,
      title: style.title
    };
  });
}

function getInsertMenuIcon(type, fallbackIcon) {
  const referenceIcon = _get(type, 'to[0].icon');

  return type.icon || type.type && type.type.icon || referenceIcon || fallbackIcon;
}

export function getInsertMenuItems(features, disabled, onInsertBlock, onInsertInline) {
  const blockItems = features.types.blockObjects.map((type, index) => ({
    handle: () => onInsertBlock(type),
    icon: getInsertMenuIcon(type, BlockElementIcon),
    inline: false,
    key: "block-".concat(index),
    type: type
  }));
  const inlineItems = features.types.inlineObjects.map((type, index) => ({
    handle: () => onInsertInline(type),
    icon: getInsertMenuIcon(type, InlineElementIcon),
    inline: true,
    key: "inline-".concat(index),
    type: type
  })); // Do not include items that are supposed to be hidden

  const filteredBlockItems = blockItems.concat(inlineItems).filter(item => {
    var _item$type;

    return !((_item$type = item.type) !== null && _item$type !== void 0 && _item$type.hidden);
  });
  return filteredBlockItems;
}
const annotationIcons = {
  link: LinkIcon
};
const formatIcons = {
  strong: BoldIcon,
  em: ItalicIcon,
  'strike-through': StrikethroughIcon,
  underline: UnderlineIcon,
  code: CodeIcon
};
const listStyleIcons = {
  number: OlistIcon,
  bullet: UlistIcon
};
export function getActionIcon(action, active) {
  if (action.icon) {
    if (typeof action.icon === 'string') {
      return /*#__PURE__*/React.createElement(CustomIcon, {
        active: active,
        icon: action.icon
      });
    }

    return action.icon;
  }

  if (action.type === 'annotation') {
    return annotationIcons[action.key] || UnknownIcon;
  }

  if (action.type === 'listStyle') {
    return listStyleIcons[action.key] || UnknownIcon;
  }

  return formatIcons[action.key] || UnknownIcon;
}