function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React, { useState, useMemo, useCallback } from 'react';
import { PortableTextEditor, usePortableTextEditor } from '@sanity/portable-text-editor';
import { BoundaryElementProvider, Portal, PortalProvider, Text, useBoundaryElement, usePortal } from '@sanity/ui';
import { ChangeIndicator } from '../../../components/changeIndicators';
import { ActivateOnFocus } from '../../components/ActivateOnFocus/ActivateOnFocus';
import { EMPTY_ARRAY } from '../../utils/empty';
import { FormInput } from '../../FormInput';
import { BlockObject } from './object/BlockObject';
import { InlineObject } from './object/InlineObject';
import { Annotation, TextBlock } from './text';
import { Editor } from './Editor';
import { ExpandedLayer, Root } from './Compositor.styles';
import { useHotkeys } from './hooks/useHotKeys';
import { ObjectEditModal } from './object/renderers/ObjectEditModal';
import { useScrollToOpenedMember } from './hooks/useScrollToOpenedMember';
import { usePortableTextMemberItems } from './hooks/usePortableTextMembers';
import { _isBlockType } from './_helpers';

function isTouchDevice() {
  return typeof window !== 'undefined' && 'ontouchstart' in window || typeof navigator !== 'undefined' && navigator.maxTouchPoints > 0;
}

const activateVerb = isTouchDevice() ? 'Tap' : 'Click';
const ACTIVATE_ON_FOCUS_MESSAGE = /*#__PURE__*/React.createElement(Text, {
  weight: "semibold"
}, activateVerb, " to activate");
export function Compositor(props) {
  const {
    changed,
    focusPath = EMPTY_ARRAY,
    focused,
    hasFocus,
    hotkeys,
    isActive,
    isFullscreen,
    onChange,
    onCopy,
    onActivate,
    onOpenItem,
    onCloseItem,
    onPaste,
    onToggleFullscreen,
    path,
    renderBlockActions,
    renderCustomMarkers,
    value,
    readOnly,
    renderPreview
  } = props;
  const editor = usePortableTextEditor();
  const [wrapperElement, setWrapperElement] = useState(null);
  const [scrollElement, setScrollElement] = useState(null);
  const portableTextMemberItems = usePortableTextMemberItems();
  const {
    element: boundaryElement
  } = useBoundaryElement(); // Scroll to the DOM element of the "opened" portable text member when relevant.

  useScrollToOpenedMember({
    hasFocus,
    editorRootPath: path,
    scrollElement,
    onCloseItem
  });
  const handleToggleFullscreen = useCallback(() => {
    onToggleFullscreen();
  }, [onToggleFullscreen]);
  const hotkeysWithFullscreenToggle = useMemo(() => ({ ...hotkeys,
    custom: {
      'mod+enter': onToggleFullscreen,
      ...((hotkeys === null || hotkeys === void 0 ? void 0 : hotkeys.custom) || {})
    }
  }), [hotkeys, onToggleFullscreen]);
  const editorHotkeys = useHotkeys(hotkeysWithFullscreenToggle);
  const ptFeatures = useMemo(() => PortableTextEditor.getPortableTextFeatures(editor), [editor]);
  const hasContent = !!value;
  const initialSelection = useMemo(() => focusPath.length > 0 ? {
    anchor: {
      path: focusPath,
      offset: 0
    },
    focus: {
      path: focusPath,
      offset: 0
    }
  } : null, // eslint-disable-next-line react-hooks/exhaustive-deps
  [] // Only initial
  );
  const renderBlock = useCallback((block, blockType, attributes, defaultRender) => {
    const isTextBlock = block._type === ptFeatures.types.block.name;

    if (isTextBlock) {
      return /*#__PURE__*/React.createElement(TextBlock, {
        attributes: attributes,
        block: block,
        isFullscreen: isFullscreen,
        onChange: onChange,
        readOnly: readOnly,
        renderBlockActions: hasContent ? renderBlockActions : undefined,
        renderCustomMarkers: hasContent ? renderCustomMarkers : undefined
      }, defaultRender(block));
    }

    return /*#__PURE__*/React.createElement(BlockObject, {
      attributes: attributes,
      block: block,
      isFullscreen: isFullscreen,
      onChange: onChange,
      onOpenItem: onOpenItem,
      readOnly: readOnly,
      renderBlockActions: hasContent ? renderBlockActions : undefined,
      renderCustomMarkers: hasContent ? renderCustomMarkers : undefined,
      renderPreview: renderPreview,
      type: blockType
    });
  }, [hasContent, isFullscreen, onChange, onOpenItem, ptFeatures.types.block.name, readOnly, renderBlockActions, renderCustomMarkers, renderPreview]);
  const renderChild = useCallback((child, childType, attributes, defaultRender) => {
    const isSpan = child._type === ptFeatures.types.span.name;

    if (isSpan) {
      return defaultRender(child);
    }

    return /*#__PURE__*/React.createElement(InlineObject, {
      attributes: attributes,
      onOpenItem: onOpenItem,
      readOnly: readOnly,
      renderCustomMarkers: renderCustomMarkers,
      scrollElement: scrollElement,
      type: childType,
      value: child,
      renderPreview: renderPreview
    });
  }, [onOpenItem, ptFeatures.types.span.name, readOnly, renderCustomMarkers, renderPreview, scrollElement]);
  const renderAnnotation = useCallback((annotation, annotationType, attributes, defaultRender) => {
    return /*#__PURE__*/React.createElement(Annotation, {
      attributes: attributes,
      onOpenItem: onOpenItem,
      readOnly: readOnly,
      renderCustomMarkers: renderCustomMarkers,
      scrollElement: scrollElement,
      value: annotation,
      type: annotationType
    }, defaultRender());
  }, [onOpenItem, readOnly, renderCustomMarkers, scrollElement]);
  const [portalElement, setPortalElement] = useState(null);
  const openMemberItems = useMemo(() => portableTextMemberItems.filter(m => m.member.open && !_isBlockType(m.node.schemaType)), [portableTextMemberItems]);
  const editorNode = useMemo(() => /*#__PURE__*/React.createElement(Editor, {
    hotkeys: editorHotkeys,
    initialSelection: initialSelection,
    isFullscreen: isFullscreen,
    onOpenItem: onOpenItem,
    onCopy: onCopy,
    onPaste: onPaste,
    onToggleFullscreen: handleToggleFullscreen,
    path: path,
    readOnly: readOnly,
    renderAnnotation: renderAnnotation,
    renderBlock: renderBlock,
    renderChild: renderChild,
    setPortalElement: setPortalElement,
    scrollElement: scrollElement,
    setScrollElement: setScrollElement
  }), // Keep only stable ones here!
  [editorHotkeys, handleToggleFullscreen, initialSelection, isFullscreen, onCopy, onOpenItem, onPaste, path, readOnly, renderAnnotation, renderBlock, renderChild, scrollElement]);
  const boundaryElm = isFullscreen ? scrollElement : boundaryElement;
  const children = useMemo(() => boundaryElm && /*#__PURE__*/React.createElement(React.Fragment, null, editorNode, /*#__PURE__*/React.createElement(BoundaryElementProvider, {
    element: boundaryElm
  }, openMemberItems.map(dMemberItem => {
    return /*#__PURE__*/React.createElement(ObjectEditModal, {
      kind: dMemberItem.kind,
      key: dMemberItem.member.key,
      memberItem: dMemberItem,
      onClose: onCloseItem,
      scrollElement: boundaryElm
    }, /*#__PURE__*/React.createElement(FormInput, _extends({
      absolutePath: dMemberItem.node.path
    }, props)));
  }))), [boundaryElm, editorNode, openMemberItems, onCloseItem, props]);
  const portal = usePortal();
  const portalElements = useMemo(() => ({
    collapsed: wrapperElement,
    default: portal.element,
    editor: portalElement,
    expanded: portal.element
  }), [portal.element, portalElement, wrapperElement]);
  const editorLayer = useMemo(() => /*#__PURE__*/React.createElement(Portal, {
    __unstable_name: isFullscreen ? 'expanded' : 'collapsed'
  }, /*#__PURE__*/React.createElement(ExpandedLayer, {
    "data-fullscreen": isFullscreen ? '' : undefined
  }, children)), [children, isFullscreen]);
  return /*#__PURE__*/React.createElement(PortalProvider, {
    __unstable_elements: portalElements
  }, /*#__PURE__*/React.createElement(ActivateOnFocus, {
    message: ACTIVATE_ON_FOCUS_MESSAGE,
    onActivate: onActivate,
    isOverlayActive: !isActive
  }, /*#__PURE__*/React.createElement(ChangeIndicator, {
    disabled: isFullscreen,
    hasFocus: Boolean(focused),
    isChanged: changed,
    path: path
  }, /*#__PURE__*/React.createElement(Root, {
    "data-focused": hasFocus ? '' : undefined,
    "data-read-only": readOnly ? '' : undefined
  }, /*#__PURE__*/React.createElement("div", {
    "data-wrapper": "",
    ref: setWrapperElement
  }, editorLayer), /*#__PURE__*/React.createElement("div", {
    "data-border": ""
  })))));
}