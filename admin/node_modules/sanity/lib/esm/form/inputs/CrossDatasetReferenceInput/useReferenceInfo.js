import { useCallback, useState } from 'react';
import { catchError, map, startWith } from 'rxjs/operators';
import { of } from 'rxjs';
import { useMemoObservable } from 'react-rx';
import { usePrevious } from '../../hooks/usePrevious';

// eslint-disable-next-line @typescript-eslint/no-empty-function
const noop = () => {};

const INITIAL_LOADING_STATE = {
  isLoading: true,
  result: undefined,
  error: undefined,
  retry: noop
};
const EMPTY_STATE = {
  isLoading: false,
  result: undefined,
  error: undefined,
  retry: noop
};
export function useReferenceInfo(doc, getReferenceInfo) {
  const [retryAttempt, setRetryAttempt] = useState(0);
  const retry = useCallback(() => {
    setRetryAttempt(current => current + 1);
  }, []);
  const referenceInfo = useMemoObservable(() => doc._id ? getReferenceInfo(doc).pipe(map(result => ({
    isLoading: false,
    result,
    error: undefined,
    retry
  })), startWith(INITIAL_LOADING_STATE), catchError(err => {
    console.error(err);
    return of({
      isLoading: false,
      result: undefined,
      error: err,
      retry
    });
  })) : of(EMPTY_STATE), [retryAttempt, getReferenceInfo, doc === null || doc === void 0 ? void 0 : doc._id, doc === null || doc === void 0 ? void 0 : doc._type, retry], INITIAL_LOADING_STATE); // workaround for a "bug" with useMemoObservable that doesn't
  // return the initial value upon resubscription

  const previousId = usePrevious(doc._id, doc._id);

  if (previousId !== doc._id) {
    return INITIAL_LOADING_STATE;
  }

  return referenceInfo;
}