import _range from "lodash/range";

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { Box, Button, Flex, Grid, Select, Text, useForwardedRef } from '@sanity/ui';
import { ChevronLeftIcon, ChevronRightIcon } from '@sanity/icons';
import { addDays, addMonths, setDate, setHours, setMinutes, setMonth, setYear } from 'date-fns';
import React, { forwardRef, useCallback, useEffect } from 'react';
import { CalendarMonth } from './CalendarMonth';
import { ARROW_KEYS, HOURS_24, MONTH_NAMES, DEFAULT_TIME_PRESETS } from './constants';
import { features } from './features';
import { formatTime } from './utils';
import { YearInput } from './YearInput';
// This is used to maintain focus on a child element of the calendar-grid between re-renders
// When using arrow keys to move focus from a day in one month to another we are setting focus at the button for the day
// after it has changed but *only* if we *already* had focus inside the calendar grid (e.g not if focus was on the "next
// year" button, or any of the other controls)
// When moving from the last day of a month that displays 6 weeks in the grid to a month that displays 5 weeks, current
// focus gets lost on render, so this provides us with a stable element to help us preserve focus on a child element of
// the calendar grid between re-renders
const PRESERVE_FOCUS_ELEMENT = /*#__PURE__*/React.createElement("span", {
  "data-preserve-focus": true,
  style: {
    overflow: 'hidden',
    position: 'absolute',
    outline: 'none'
  },
  tabIndex: -1
});
export const Calendar = /*#__PURE__*/forwardRef(function Calendar(props, forwardedRef) {
  const {
    selectTime,
    onFocusedDateChange,
    selectedDate = new Date(),
    focusedDate = selectedDate,
    timeStep = 1,
    onSelect,
    ...restProps
  } = props;
  const setFocusedDate = useCallback(date => onFocusedDateChange(date), [onFocusedDateChange]);
  const setFocusedDateMonth = useCallback(month => setFocusedDate(setDate(setMonth(focusedDate, month), 1)), [focusedDate, setFocusedDate]);
  const handleFocusedMonthChange = useCallback(e => setFocusedDateMonth(Number(e.currentTarget.value)), [setFocusedDateMonth]);
  const moveFocusedDate = useCallback(by => setFocusedDate(addMonths(focusedDate, by)), [focusedDate, setFocusedDate]);
  const setFocusedDateYear = useCallback(year => setFocusedDate(setYear(focusedDate, year)), [focusedDate, setFocusedDate]);
  const handleDateChange = useCallback(date => {
    onSelect(setMinutes(setHours(date, selectedDate.getHours()), selectedDate.getMinutes()));
  }, [onSelect, selectedDate]);
  const handleMinutesChange = useCallback(event => {
    const m = Number(event.currentTarget.value);
    onSelect(setMinutes(selectedDate, m));
  }, [onSelect, selectedDate]);
  const handleHoursChange = useCallback(event => {
    const m = Number(event.currentTarget.value);
    onSelect(setHours(selectedDate, m));
  }, [onSelect, selectedDate]);
  const handleTimeChange = useCallback((hours, mins) => {
    onSelect(setHours(setMinutes(selectedDate, mins), hours));
  }, [onSelect, selectedDate]);
  const ref = useForwardedRef(forwardedRef);
  const focusCurrentWeekDay = useCallback(() => {
    var _ref$current, _ref$current$querySel;

    (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : (_ref$current$querySel = _ref$current.querySelector("[data-focused=\"true\"]")) === null || _ref$current$querySel === void 0 ? void 0 : _ref$current$querySel.focus();
  }, [ref]);
  const handleKeyDown = useCallback(event => {
    var _ref$current2, _ref$current2$querySe;

    if (!ARROW_KEYS.includes(event.key)) {
      return;
    }

    event.preventDefault();

    if (event.target.hasAttribute('data-calendar-grid')) {
      focusCurrentWeekDay();
      return;
    }

    if (event.key === 'ArrowUp') {
      onFocusedDateChange(addDays(focusedDate, -7));
    }

    if (event.key === 'ArrowDown') {
      onFocusedDateChange(addDays(focusedDate, 7));
    }

    if (event.key === 'ArrowLeft') {
      onFocusedDateChange(addDays(focusedDate, -1));
    }

    if (event.key === 'ArrowRight') {
      onFocusedDateChange(addDays(focusedDate, 1));
    } // set focus temporarily on this element to make sure focus is still inside the calendar-grid after re-render


    (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : (_ref$current2$querySe = _ref$current2.querySelector('[data-preserve-focus]')) === null || _ref$current2$querySe === void 0 ? void 0 : _ref$current2$querySe.focus();
  }, [ref, focusCurrentWeekDay, onFocusedDateChange, focusedDate]);
  useEffect(() => {
    focusCurrentWeekDay();
  }, [focusCurrentWeekDay]);
  useEffect(() => {
    var _document$activeEleme;

    const currentFocusInCalendarGrid = (_document$activeEleme = document.activeElement) === null || _document$activeEleme === void 0 ? void 0 : _document$activeEleme.matches('[data-calendar-grid], [data-calendar-grid] [data-preserve-focus]');

    if ( // Only move focus if it's currently in the calendar grid
    currentFocusInCalendarGrid) {
      focusCurrentWeekDay();
    }
  }, [ref, focusCurrentWeekDay, focusedDate]);
  const handleYesterdayClick = useCallback(() => handleDateChange(addDays(new Date(), -1)), [handleDateChange]);
  const handleTodayClick = useCallback(() => handleDateChange(new Date()), [handleDateChange]);
  const handleTomorrowClick = useCallback(() => handleDateChange(addDays(new Date(), 1)), [handleDateChange]);
  const handleNowClick = useCallback(() => onSelect(new Date()), [onSelect]);
  return /*#__PURE__*/React.createElement(Box, _extends({
    "data-ui": "Calendar"
  }, restProps, {
    ref: ref
  }), /*#__PURE__*/React.createElement(Box, {
    padding: 2
  }, features.dayPresets && /*#__PURE__*/React.createElement(Grid, {
    columns: 3,
    "data-ui": "CalendaryDayPresets",
    gap: 1
  }, /*#__PURE__*/React.createElement(Button, {
    text: "Yesterday",
    mode: "bleed",
    fontSize: 1,
    onClick: handleYesterdayClick
  }), /*#__PURE__*/React.createElement(Button, {
    text: "Today",
    mode: "bleed",
    fontSize: 1,
    onClick: handleTodayClick
  }), /*#__PURE__*/React.createElement(Button, {
    text: "Tomorrow",
    mode: "bleed",
    fontSize: 1,
    onClick: handleTomorrowClick
  })), /*#__PURE__*/React.createElement(Flex, null, /*#__PURE__*/React.createElement(Box, {
    flex: 1
  }, /*#__PURE__*/React.createElement(CalendarMonthSelect, {
    moveFocusedDate: moveFocusedDate,
    onChange: handleFocusedMonthChange,
    value: focusedDate === null || focusedDate === void 0 ? void 0 : focusedDate.getMonth()
  })), /*#__PURE__*/React.createElement(Box, {
    marginLeft: 2
  }, /*#__PURE__*/React.createElement(CalendarYearSelect, {
    moveFocusedDate: moveFocusedDate,
    onChange: setFocusedDateYear,
    value: focusedDate.getFullYear()
  }))), /*#__PURE__*/React.createElement(Box, {
    "data-calendar-grid": true,
    onKeyDown: handleKeyDown,
    marginTop: 2,
    overflow: "hidden",
    tabIndex: 0
  }, /*#__PURE__*/React.createElement(CalendarMonth, {
    date: focusedDate,
    focused: focusedDate,
    onSelect: handleDateChange,
    selected: selectedDate
  }), PRESERVE_FOCUS_ELEMENT)), selectTime && /*#__PURE__*/React.createElement(Box, {
    padding: 2,
    style: {
      borderTop: '1px solid var(--card-border-color)'
    }
  }, /*#__PURE__*/React.createElement(Flex, {
    align: "center"
  }, /*#__PURE__*/React.createElement(Flex, {
    align: "center",
    flex: 1
  }, /*#__PURE__*/React.createElement(Box, null, /*#__PURE__*/React.createElement(Select, {
    "aria-label": "Select hour",
    value: selectedDate === null || selectedDate === void 0 ? void 0 : selectedDate.getHours(),
    onChange: handleHoursChange
  }, HOURS_24.map(h => /*#__PURE__*/React.createElement("option", {
    key: h,
    value: h
  }, "".concat(h).padStart(2, '0'))))), /*#__PURE__*/React.createElement(Box, {
    paddingX: 1
  }, /*#__PURE__*/React.createElement(Text, null, ":")), /*#__PURE__*/React.createElement(Box, null, /*#__PURE__*/React.createElement(Select, {
    "aria-label": "Select minutes",
    value: selectedDate === null || selectedDate === void 0 ? void 0 : selectedDate.getMinutes(),
    onChange: handleMinutesChange
  }, _range(0, 60, timeStep).map(m => /*#__PURE__*/React.createElement("option", {
    key: m,
    value: m
  }, "".concat(m).padStart(2, '0')))))), /*#__PURE__*/React.createElement(Box, {
    marginLeft: 2
  }, /*#__PURE__*/React.createElement(Button, {
    text: "Set to current time",
    mode: "bleed",
    onClick: handleNowClick
  }))), features.timePresets && /*#__PURE__*/React.createElement(Flex, {
    direction: "row",
    justify: "center",
    align: "center",
    style: {
      marginTop: 5
    }
  }, DEFAULT_TIME_PRESETS.map(_ref => {
    let [hours, minutes] = _ref;
    return /*#__PURE__*/React.createElement(CalendarTimePresetButton, {
      key: "".concat(hours, "-").concat(minutes),
      hours: hours,
      minutes: minutes,
      onTimeChange: handleTimeChange,
      selectedDate: selectedDate
    });
  }))));
});

function CalendarTimePresetButton(props) {
  const {
    hours,
    minutes,
    onTimeChange,
    selectedDate
  } = props;
  const formatted = formatTime(hours, minutes);
  const handleClick = useCallback(() => {
    onTimeChange(hours, minutes);
  }, [hours, minutes, onTimeChange]);
  return /*#__PURE__*/React.createElement(Button, {
    text: formatted,
    "aria-label": "".concat(formatted, " on ").concat(selectedDate.toDateString()),
    mode: "bleed",
    fontSize: 1,
    onClick: handleClick
  });
}

function CalendarMonthSelect(props) {
  const {
    moveFocusedDate,
    onChange,
    value
  } = props;
  const handlePrevMonthClick = useCallback(() => moveFocusedDate(-1), [moveFocusedDate]);
  const handleNextMonthClick = useCallback(() => moveFocusedDate(1), [moveFocusedDate]);
  return /*#__PURE__*/React.createElement(Flex, {
    flex: 1
  }, /*#__PURE__*/React.createElement(Button, {
    "aria-label": "Go to previous month",
    onClick: handlePrevMonthClick,
    mode: "bleed",
    icon: ChevronLeftIcon,
    paddingX: 2,
    radius: 0
  }), /*#__PURE__*/React.createElement(Box, {
    flex: 1
  }, /*#__PURE__*/React.createElement(Select, {
    radius: 0,
    value: value,
    onChange: onChange
  }, MONTH_NAMES.map((m, i) =>
  /*#__PURE__*/
  // eslint-disable-next-line react/no-array-index-key
  React.createElement("option", {
    key: i,
    value: i
  }, m)))), /*#__PURE__*/React.createElement(Button, {
    "aria-label": "Go to next month",
    mode: "bleed",
    icon: ChevronRightIcon,
    onClick: handleNextMonthClick,
    paddingX: 2,
    radius: 0
  }));
}

function CalendarYearSelect(props) {
  const {
    moveFocusedDate,
    onChange,
    value
  } = props;
  const handlePrevYearClick = useCallback(() => moveFocusedDate(-12), [moveFocusedDate]);
  const handleNextYearClick = useCallback(() => moveFocusedDate(12), [moveFocusedDate]);
  return /*#__PURE__*/React.createElement(Flex, null, /*#__PURE__*/React.createElement(Button, {
    "aria-label": "Previous year",
    onClick: handlePrevYearClick,
    mode: "bleed",
    icon: ChevronLeftIcon,
    paddingX: 2,
    radius: 0
  }), /*#__PURE__*/React.createElement(YearInput, {
    value: value,
    onChange: onChange,
    radius: 0,
    style: {
      width: 65
    }
  }), /*#__PURE__*/React.createElement(Button, {
    "aria-label": "Next year",
    onClick: handleNextYearClick,
    mode: "bleed",
    icon: ChevronRightIcon,
    paddingX: 2,
    radius: 0
  }));
}