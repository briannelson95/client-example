import { format, parse } from '@sanity/util/legacyDateFormat';
import { getMinutes, setMinutes, parseISO } from 'date-fns';
import React, { useCallback } from 'react';
import { ChangeIndicator } from '../../../components/changeIndicators';
import { set, unset } from '../../patch';
import { CommonDateTimeInput } from './CommonDateTimeInput';
import { isValidDate } from './utils';
const DEFAULT_DATE_FORMAT = 'YYYY-MM-DD';
const DEFAULT_TIME_FORMAT = 'HH:mm';

function parseOptions() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    dateFormat: options.dateFormat || DEFAULT_DATE_FORMAT,
    timeFormat: options.timeFormat || DEFAULT_TIME_FORMAT,
    timeStep: 'timeStep' in options && Number(options.timeStep) || 1,
    calendarTodayLabel: options.calendarTodayLabel || 'Today'
  };
}

function serialize(date) {
  return date.toISOString();
}

function deserialize(isoString) {
  const deserialized = new Date(isoString);

  if (isValidDate(deserialized)) {
    return {
      isValid: true,
      date: deserialized
    };
  }

  return {
    isValid: false,
    error: "Invalid date value: \"".concat(isoString, "\"")
  };
} // enforceTimeStep takes a dateString and datetime schema options and enforces the time
// to be within the configured timeStep


function enforceTimeStep(dateString, timeStep) {
  if (!timeStep || timeStep === 1) {
    return dateString;
  }

  const date = parseISO(dateString);
  const minutes = getMinutes(date);
  const leftOver = minutes % timeStep;

  if (leftOver !== 0) {
    return serialize(setMinutes(date, minutes - leftOver));
  }

  return serialize(date);
}

export function DateTimeInput(props) {
  const {
    changed,
    focused,
    focusRef,
    id,
    onChange,
    path,
    readOnly,
    schemaType,
    value
  } = props;
  const {
    dateFormat,
    timeFormat,
    timeStep
  } = parseOptions(schemaType.options);
  const handleChange = useCallback(nextDate => {
    let date = nextDate;

    if (date !== null && timeStep > 1) {
      date = enforceTimeStep(date, timeStep);
    }

    onChange(date === null ? unset() : set(date));
  }, [onChange, timeStep]);
  const formatInputValue = React.useCallback(date => format(date, "".concat(dateFormat, " ").concat(timeFormat)), [dateFormat, timeFormat]);
  const parseInputValue = React.useCallback(inputValue => parse(inputValue, "".concat(dateFormat, " ").concat(timeFormat)), [dateFormat, timeFormat]);
  return /*#__PURE__*/React.createElement(ChangeIndicator, {
    path: path,
    isChanged: changed,
    hasFocus: !!focused
  }, /*#__PURE__*/React.createElement(CommonDateTimeInput, {
    deserialize: deserialize,
    formatInputValue: formatInputValue,
    id: id,
    onChange: handleChange,
    parseInputValue: parseInputValue,
    placeholder: schemaType.placeholder,
    readOnly: readOnly,
    ref: focusRef,
    selectTime: true,
    serialize: serialize,
    timeStep: timeStep,
    value: value
  }));
}