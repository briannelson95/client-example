/* eslint-disable react/jsx-handler-names */
import { isBooleanSchemaType } from '@sanity/types';
import React from 'react';
import * as is from '../../utils/is';
import { FormField, FormFieldSet } from '../../components/formField';
import { SanityPreview } from '../../../preview';
import { resolveReferenceInput } from './resolveReferenceInput';
import { resolveArrayInput } from './resolveArrayInput';
import { resolveStringInput } from './resolveStringInput';
import { resolveNumberInput } from './resolveNumberInput';
import { defaultInputs } from './defaultInputs';
import { getArrayFieldLevel, getObjectFieldLevel } from './helpers';
import { isObjectField } from '../../utils/asserters';

function resolveComponentFromTypeVariants(type) {
  if (is.type('array', type)) {
    return resolveArrayInput(type);
  }

  if (is.type('reference', type)) {
    return resolveReferenceInput(type);
  } // String input with a select


  if (is.type('string', type)) {
    return resolveStringInput(type);
  }

  if (is.type('number', type)) {
    return resolveNumberInput(type);
  }

  return undefined;
}

function getTypeChain(type, visited) {
  if (!type) return [];
  if (visited.has(type)) return [];
  visited.add(type);
  const next = type.type ? getTypeChain(type.type, visited) : [];
  return [type, ...next];
}

export function defaultResolveInputComponent(schemaType) {
  var _schemaType$component;

  if ((_schemaType$component = schemaType.components) !== null && _schemaType$component !== void 0 && _schemaType$component.input) return schemaType.components.input;
  const componentFromTypeVariants = resolveComponentFromTypeVariants(schemaType);

  if (componentFromTypeVariants) {
    return componentFromTypeVariants;
  }

  const typeChain = getTypeChain(schemaType, new Set());
  const deduped = typeChain.reduce((acc, type) => {
    acc[type.name] = type;
    return acc;
  }, {}); // using an object + Object.values to de-dupe the type chain by type name

  const subType = Object.values(deduped).find(t => defaultInputs[t.name]);

  if (subType) {
    return defaultInputs[subType.name];
  }

  throw new Error("Could not find input component for schema type `".concat(schemaType.name, "`"));
}

function NoopField(_ref) {
  let {
    children
  } = _ref;
  return /*#__PURE__*/React.createElement(React.Fragment, null, children);
}

function PrimitiveField(field) {
  return /*#__PURE__*/React.createElement(FormField, {
    "data-testid": "field-".concat(field.inputId),
    level: field.level,
    title: field.title,
    description: field.description,
    validation: field.validation,
    __unstable_presence: field.presence
  }, field.children);
}

function ObjectOrArrayField(field) {
  const level = isObjectField(field) ? getObjectFieldLevel(field) : getArrayFieldLevel(field);
  return /*#__PURE__*/React.createElement(FormFieldSet, {
    "data-testid": "field-".concat(field.inputId),
    level: level,
    title: field.title,
    description: field.description,
    collapsed: field.collapsed,
    collapsible: field.collapsible,
    onCollapse: field.onCollapse,
    onExpand: field.onExpand,
    validation: field.validation,
    __unstable_presence: field.presence
  }, field.children);
}

function ImageOrFileField(field) {
  // unless the hotspot tool dialog is open we want to show whoever is in there as the field presence
  const hotspotField = field.inputProps.members.find(member => member.kind === 'field' && member.name === 'hotspot');
  const presence = hotspotField !== null && hotspotField !== void 0 && hotspotField.open ? field.presence : field.presence.concat((hotspotField === null || hotspotField === void 0 ? void 0 : hotspotField.field.presence) || []);
  const level = getObjectFieldLevel(field);
  return /*#__PURE__*/React.createElement(FormFieldSet, {
    level: level,
    title: field.title,
    description: field.description,
    collapsed: field.collapsed,
    collapsible: field.collapsible,
    onCollapse: field.onCollapse,
    onExpand: field.onExpand,
    validation: field.validation,
    __unstable_presence: presence
  }, field.children);
}

export function defaultResolveFieldComponent(schemaType) {
  var _schemaType$component2;

  if ((_schemaType$component2 = schemaType.components) !== null && _schemaType$component2 !== void 0 && _schemaType$component2.field) return schemaType.components.field;

  if (isBooleanSchemaType(schemaType)) {
    return NoopField;
  }

  if (getTypeChain(schemaType, new Set()).some(t => t.name === 'image' || t.name === 'file')) {
    return ImageOrFileField;
  }

  if (schemaType.jsonType !== 'object' && schemaType.jsonType !== 'array') {
    return PrimitiveField;
  }

  return ObjectOrArrayField;
}
export function defaultResolveItemComponent(schemaType) {
  var _schemaType$component3;

  if ((_schemaType$component3 = schemaType.components) !== null && _schemaType$component3 !== void 0 && _schemaType$component3.item) return schemaType.components.item;
  return NoopField;
} // TODO: add PreviewProps interface

export function defaultResolvePreviewComponent(schemaType) {
  var _schemaType$component4;

  if ((_schemaType$component4 = schemaType.components) !== null && _schemaType$component4 !== void 0 && _schemaType$component4.preview) return schemaType.components.preview;
  return SanityPreview; // TODO
}