function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React, { useCallback, useMemo } from 'react';
import { FileInput } from '../../inputs/files/FileInput';
import { resolveUploader as defaultResolveUploader } from '../uploads/resolveUploader';
import { useFormBuilder } from '../../useFormBuilder';
import { useDocumentPreviewStore } from '../../../datastores';
import { useClient } from '../../../hooks';
import { observeFileAsset } from './client-adapters/assets';
export function StudioFileInput(props) {
  var _props$schemaType$opt;

  const sourcesFromSchema = (_props$schemaType$opt = props.schemaType.options) === null || _props$schemaType$opt === void 0 ? void 0 : _props$schemaType$opt.sources;
  const documentPreviewStore = useDocumentPreviewStore();

  const {
    file: fileConfig
  } = useFormBuilder().__internal;

  const client = useClient();
  const resolveUploader = useCallback((type, file) => {
    if (!fileConfig.directUploads) {
      return null;
    }

    return defaultResolveUploader(type, file);
  }, [fileConfig.directUploads]); // NOTE: type.options.sources may be an empty array and in that case we're
  // disabling selecting images from asset source  (it's a feature, not a bug)

  const assetSources = useMemo(() => sourcesFromSchema || fileConfig.assetSources, [fileConfig, sourcesFromSchema]);
  const observeAsset = useCallback(id => observeFileAsset(documentPreviewStore, id), [documentPreviewStore]);
  return /*#__PURE__*/React.createElement(FileInput, _extends({}, props, {
    client: client,
    assetSources: assetSources,
    directUploads: fileConfig.directUploads,
    observeAsset: observeAsset,
    resolveUploader: resolveUploader
  }));
}