/**
 * Reconciles two versions of a state tree by iterating over the next and deep comparing against the next towards the previous.
 * Wherever identical values are found, the previous value is kept, preserving object identities for arrays and objects where possible
 * @param previous - the previous value
 * @param next - the next/current value
 */
export function immutableReconcile(previous, next) {
  let parents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();
  if (previous === next) return previous; // eslint-disable-next-line no-eq-null

  if (previous == null || next == null) return next;
  const prevType = typeof previous;
  const nextType = typeof next; // Different types

  if (prevType !== nextType) return next;

  if (Array.isArray(next)) {
    parents.add(next);
    assertType(previous);
    assertType(next);
    let allEqual = previous.length === next.length;
    const result = [];

    for (let index = 0; index < next.length; index++) {
      if (parents.has(next[index])) {
        return next;
      }

      const nextItem = immutableReconcile(previous[index], next[index], parents);

      if (nextItem !== previous[index]) {
        allEqual = false;
      }

      result[index] = nextItem;
    }

    return allEqual ? previous : result;
  }

  if (nextType === 'object') {
    parents.add(next);
    assertType(previous);
    assertType(next);
    let allEqual = true;
    const result = {};

    for (const key of Object.keys(next)) {
      if (parents.has(next[key])) {
        return next;
      }

      const nextValue = immutableReconcile(previous[key], next[key], parents);

      if (nextValue !== previous[key]) {
        allEqual = false;
      }

      result[key] = nextValue;
    }

    return allEqual ? previous : result;
  }

  return next;
} // just some typescript trickery get type assertion
// eslint-disable-next-line @typescript-eslint/no-empty-function

function assertType(value) {}