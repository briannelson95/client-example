import _union from "lodash/union";
import _sortBy from "lodash/sortBy";
import _flow from "lodash/flow";
import _uniq from "lodash/uniq";
import _flatten from "lodash/flatten";
import _toLower from "lodash/toLower";
import _compact from "lodash/compact";
import { map, tap } from 'rxjs/operators';
import { joinPath } from '../../util/searchUtils';
import { tokenize } from '../common/tokenize';
import { removeDupes } from '../../util/draftUtils';
import { applyWeights } from './applyWeights';

const combinePaths = _flow([_flatten, _union, _compact]);

const toGroqParams = terms => {
  const params = {};
  return terms.reduce((acc, term, i) => {
    acc["t".concat(i)] = "".concat(term, "*"); // "t" is short for term

    return acc;
  }, params);
};

const pathWithMapper = _ref => {
  let {
    mapWith,
    path
  } = _ref;
  return mapWith ? "".concat(mapWith, "(").concat(path, ")") : path;
};

export function createWeightedSearch( // eslint-disable-next-line camelcase
types, client) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!types) {
    throw new Error('missing types');
  }

  const {
    filter,
    params,
    tag
  } = options;
  const searchSpec = types.map(type => {
    var _type$__experimental_;

    return {
      typeName: type.name,
      paths: (_type$__experimental_ = type.__experimental_search) === null || _type$__experimental_ === void 0 ? void 0 : _type$__experimental_.map(config => ({
        weight: config.weight,
        path: joinPath(config.path),
        mapWith: config.mapWith
      }))
    };
  });
  const combinedSearchPaths = combinePaths(searchSpec.map(configForType => {
    var _configForType$paths;

    return (_configForType$paths = configForType.paths) === null || _configForType$paths === void 0 ? void 0 : _configForType$paths.map(opt => pathWithMapper(opt));
  }));
  const selections = searchSpec.map(spec => {
    var _spec$paths;

    const constraint = "_type == \"".concat(spec.typeName, "\" => ");
    const selection = "{ ".concat((_spec$paths = spec.paths) === null || _spec$paths === void 0 ? void 0 : _spec$paths.map((cfg, i) => "\"w".concat(i, "\": ").concat(pathWithMapper(cfg))), " }");
    return "".concat(constraint).concat(selection);
  }); // this is the actual search function that takes the search string and returns the hits

  return function search(queryString) {
    var _searchOpts$limit;

    let searchOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    const terms = _uniq(_compact(tokenize(_toLower(queryString))));

    const constraints = terms.map((term, i) => combinedSearchPaths.map(joinedPath => "".concat(joinedPath, " match $t").concat(i))).filter(constraint => constraint.length > 0);
    const filters = ['_type in $__types', searchOpts.includeDrafts === false && "!(_id in path('drafts.**'))", ...constraints.map(constraint => "(".concat(constraint.join('||'), ")")), filter ? "(".concat(filter, ")") : ''].filter(Boolean);
    const selection = selections.length > 0 ? "...select(".concat(selections.join(',\n'), ")") : '';
    const query = "*[".concat(filters.join('&&'), "][0...$__limit]{_type, _id, ").concat(selection, "}");
    return client.observable.fetch(query, { ...toGroqParams(terms),
      __types: searchSpec.map(spec => spec.typeName),
      __limit: (_searchOpts$limit = searchOpts.limit) !== null && _searchOpts$limit !== void 0 ? _searchOpts$limit : 1000,
      ...(params || {})
    }, {
      tag
    }).pipe(options.unique ? map(removeDupes) : tap(), map(hits => applyWeights(searchSpec, hits, terms)), map(hits => _sortBy(hits, hit => -hit.score)));
  };
}