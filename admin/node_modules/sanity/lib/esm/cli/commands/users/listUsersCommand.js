import _size from "lodash/size";
import _sortBy from "lodash/sortBy";
const sortFields = ['id', 'name', 'role', 'date'];
const helpText = "\nOptions\n  --no-invitations Don't include pending invitations\n  --no-robots Don't include robots (token users)\n  --sort <field> Sort users by specified column: ".concat(sortFields.join(', '), "\n  --order <asc/desc> Sort output ascending/descending\n\nExamples\n  # List all users of the project\n  sanity users list\n\n  # List all users of the project, but exclude pending invitations and robots\n  sanity users list --no-invitations --no-robots\n\n  # List all users, sorted by role\n  sanity users list --sort role\n");
const listUsersCommand = {
  name: 'list',
  group: 'users',
  signature: '',
  helpText,
  description: 'List all users of the project',
  action: async (args, context) => {
    const {
      apiClient,
      output,
      chalk
    } = context;
    const {
      sort,
      order,
      robots,
      invitations
    } = {
      sort: 'date',
      order: 'asc',
      robots: true,
      invitations: true,
      ...args.extOptions
    };

    if (!sortFields.includes(sort)) {
      throw new Error("Can't sort by field \"".concat(sort, "\". Must be one of ").concat(sortFields.join(', ')));
    }

    if (order !== 'asc' && order !== 'desc') {
      throw new Error("Unknown sort order \"".concat(order, "\", must be either \"asc\" or \"desc\""));
    }

    const client = apiClient();
    const globalClient = client.clone().config({
      useProjectHostname: false
    });
    const {
      projectId
    } = client.config();
    const useGlobalApi = true;
    const [pendingInvitations, project] = await Promise.all([invitations ? globalClient.request({
      uri: "/invitations/project/".concat(projectId),
      useGlobalApi
    }).then(getPendingInvitations) : [], globalClient.request({
      uri: "/projects/".concat(projectId),
      useGlobalApi
    })]);
    const memberIds = project.members.map(member => member.id);
    const users = await globalClient.request({
      uri: "/users/".concat(memberIds.join(',')),
      useGlobalApi
    }).then(user => Array.isArray(user) ? user : [user]);
    const projectMembers = project.members.map(member => ({ ...member,
      ...getUserProps(users.find(candidate => candidate.id === member.id))
    })).filter(member => !member.isRobot || robots);
    const members = [...projectMembers, ...pendingInvitations];

    const ordered = _sortBy(members.map(_ref => {
      let {
        id,
        name,
        role,
        date
      } = _ref;
      return [id, name, role, date];
    }), [sortFields.indexOf(sort)]);

    const rows = order === 'asc' ? ordered : ordered.reverse();
    const maxWidths = rows.reduce((max, row) => row.map((current, index) => Math.max(_size(current), max[index])), sortFields.map(str => _size(str)));

    const printRow = row => {
      const isInvite = row[0] === '<pending>';
      const textRow = row.map((col, i) => "".concat(col).padEnd(maxWidths[i])).join('   ');
      return isInvite ? chalk.dim(textRow) : textRow;
    };

    output.print(chalk.cyan(printRow(sortFields)));
    rows.forEach(row => output.print(printRow(row)));
  }
};

function getUserProps(user) {
  const {
    displayName: name,
    createdAt: date
  } = user || {};
  return {
    name: name || '',
    date: date || ''
  };
}

function getPendingInvitations(invitations) {
  return invitations.filter(invite => !invite.isAccepted && !invite.isRevoked && !invite.acceptedByUserId).map(invite => ({
    id: '<pending>',
    name: invite.email,
    role: invite.role,
    date: invite.createdAt
  }));
}

export default listUsersCommand;