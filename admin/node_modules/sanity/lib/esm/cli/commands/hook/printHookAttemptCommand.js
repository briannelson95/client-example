const printHookAttemptCommand = {
  name: 'attempt',
  group: 'hook',
  signature: 'ATTEMPT_ID',
  helpText: '',
  description: 'Print details of a given webhook delivery attempt',
  action: async (args, context) => {
    const {
      apiClient,
      output
    } = context;
    const [attemptId] = args.argsWithoutOptions;
    const client = apiClient();
    let attempt;

    try {
      attempt = await client.request({
        uri: "/hooks/attempts/".concat(attemptId)
      });
    } catch (err) {
      throw new Error("Hook attempt retrieval failed:\n".concat(err.message));
    }

    const {
      createdAt,
      resultCode,
      resultBody,
      failureReason,
      inProgress
    } = attempt;
    output.print("Date: ".concat(createdAt));
    output.print("Status: ".concat(getStatus(attempt)));
    output.print("Status code: ".concat(resultCode));

    if (attempt.isFailure) {
      output.print("Failure: ".concat(formatFailure(attempt)));
    }

    if (!inProgress && (!failureReason || failureReason === 'http')) {
      const body = resultBody ? "\n---\n".concat(resultBody, "\n---\n") : '<empty>';
      output.print("Response body: ".concat(body));
    }
  }
};
export default printHookAttemptCommand;
export function formatFailure(attempt) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    includeHelp
  } = options;
  const {
    id,
    failureReason,
    resultCode
  } = attempt;
  const help = includeHelp ? "(run `sanity hook attempt ".concat(id, "` for details)") : '';

  switch (failureReason) {
    case 'http':
      return "HTTP ".concat(resultCode, " ").concat(help);

    case 'timeout':
      return 'Request timed out';

    case 'network':
      return 'Network error';

    case 'other':
    default:
  }

  return 'Unknown error';
}
export function getStatus(attempt) {
  if (attempt.isFailure) {
    return 'Failed';
  }

  if (attempt.inProgress) {
    return 'In progress';
  }

  return 'Delivered';
}