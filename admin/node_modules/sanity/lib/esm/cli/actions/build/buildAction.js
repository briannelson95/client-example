import path from 'path';
import { promisify } from 'util'; // eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore This may not yet be built.

import { buildStaticFiles } from '@sanity/server';
import chalk from 'chalk';
import rimrafCallback from 'rimraf';
import { checkStudioDependencyVersions } from '../../util/checkStudioDependencyVersions';
import { checkRequiredDependencies } from '../../util/checkRequiredDependencies';
import { getTimer } from '../../util/timing';
const rimraf = promisify(rimrafCallback);
export default async function buildSanityStudio(args, context, overrides) {
  const timer = getTimer();
  const {
    output,
    prompt,
    workDir,
    cliConfig
  } = context;
  const flags = {
    minify: true,
    stats: false,
    'source-maps': false,
    ...args.extOptions
  };
  const unattendedMode = Boolean(flags.yes || flags.y);
  const defaultOutputDir = path.resolve(path.join(workDir, 'dist'));
  const outputDir = path.resolve(args.argsWithoutOptions[0] || defaultOutputDir);
  await checkStudioDependencyVersions(workDir); // If the check resulted in a dependency install, the CLI command will be re-run,
  // thus we want to exit early

  if ((await checkRequiredDependencies(context)).didInstall) {
    return {
      didCompile: false
    };
  }

  const envVarKeys = getSanityEnvVars();

  if (envVarKeys.length > 0) {
    output.print('\nIncluding the following environment variables as part of the JavaScript bundle:');
    envVarKeys.forEach(key => output.print("- ".concat(key)));
    output.print('');
  }

  let shouldClean = true;

  if (outputDir !== defaultOutputDir && !unattendedMode) {
    shouldClean = await prompt.single({
      type: 'confirm',
      message: "Do you want to delete the existing directory (".concat(outputDir, ") first?"),
      default: true
    });
  }

  let spin;

  if (shouldClean) {
    timer.start('cleanOutputFolder');
    spin = output.spinner('Clean output folder').start();
    await rimraf(outputDir);
    const cleanDuration = timer.end('cleanOutputFolder');
    spin.text = "Clean output folder (".concat(cleanDuration.toFixed(), "ms)");
    spin.succeed();
  }

  spin = output.spinner('Build Sanity Studio').start();

  try {
    var _cliConfig$project;

    timer.start('bundleStudio');
    const bundle = await buildStaticFiles({
      cwd: workDir,
      outputDir,
      basePath: (overrides === null || overrides === void 0 ? void 0 : overrides.basePath) || (cliConfig === null || cliConfig === void 0 ? void 0 : (_cliConfig$project = cliConfig.project) === null || _cliConfig$project === void 0 ? void 0 : _cliConfig$project.basePath) || '/',
      sourceMap: Boolean(flags['source-maps']),
      minify: Boolean(flags.minify),
      vite: cliConfig && 'vite' in cliConfig ? cliConfig.vite : undefined
    });
    const buildDuration = timer.end('bundleStudio');
    spin.text = "Build Sanity Studio (".concat(buildDuration.toFixed(), "ms)");
    spin.succeed();

    if (flags.stats) {
      output.print('\nLargest module files:');
      output.print(formatModuleSizes(sortModulesBySize(bundle.chunks).slice(0, 15)));
    }
  } catch (err) {
    spin.fail();
    throw err;
  }

  return {
    didCompile: true
  };
} // eslint-disable-next-line no-process-env

function getSanityEnvVars() {
  let env = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.env;
  return Object.keys(env).filter(key => key.toUpperCase().startsWith('SANITY_STUDIO_'));
}

function sortModulesBySize(chunks) {
  return chunks.flatMap(chunk => chunk.modules).sort((modA, modB) => modB.renderedLength - modA.renderedLength);
}

function formatModuleSizes(modules) {
  const lines = [];

  for (const mod of modules) {
    lines.push(" - ".concat(formatModuleName(mod.name), " (").concat(formatSize(mod.renderedLength), ")"));
  }

  return lines.join('\n');
}

function formatModuleName(modName) {
  const delimiter = '/node_modules/';
  const nodeIndex = modName.lastIndexOf(delimiter);
  return nodeIndex === -1 ? modName : modName.slice(nodeIndex + delimiter.length);
}

function formatSize(bytes) {
  return chalk.cyan("".concat((bytes / 1024).toFixed(), " kB"));
}