import _upperFirst from "lodash/upperFirst";
import { isDocumentType, isUnion } from '../helpers';
export function generateTypeQueries(types, sortings) {
  const queries = [];
  const documentTypes = types.filter(isDocumentType);
  const documentTypeNames = documentTypes.map(docType => JSON.stringify(docType.originalName || docType.name));
  const documentsFilter = "_type in [".concat(documentTypeNames.join(', '), "]");
  const documentInterface = types.find(type => type.name === 'Document');

  if (!documentInterface || isUnion(documentInterface)) {
    throw new Error('Failed to find document interface');
  }

  const queryable = [...documentTypes, documentInterface];

  const isSortable = type => sortings.some(sorting => sorting.name === "".concat(type.name, "Sorting")); // Single ID-based result lookup queries


  queryable.forEach(type => {
    queries.push({
      fieldName: type.name,
      type: type.name,
      constraints: [{
        field: '_id',
        comparator: 'eq',
        value: {
          kind: 'argumentValue',
          argName: 'id'
        }
      }],
      args: [{
        name: 'id',
        description: "".concat(type.name, " document ID"),
        type: 'ID',
        isNullable: false
      }]
    });
  }); // Fetch all of type

  queryable.forEach(type => {
    const sorting = [];

    if (isSortable(type)) {
      sorting.push({
        name: 'sort',
        type: {
          kind: 'List',
          isNullable: true,
          children: {
            type: "".concat(type.name, "Sorting"),
            isNullable: false
          }
        }
      });
    }

    queries.push({
      fieldName: "all".concat(_upperFirst(type.name)),
      filter: type.name === 'Document' && type.kind === 'Interface' ? documentsFilter : "_type == ".concat(JSON.stringify(type.originalName || type.name)),
      type: {
        kind: 'List',
        isNullable: false,
        children: {
          type: type.name,
          isNullable: false
        }
      },
      args: [{
        name: 'where',
        type: "".concat(type.name, "Filter"),
        isFieldFilter: true
      }, ...sorting, {
        name: 'limit',
        type: 'Int',
        description: 'Max documents to return',
        isFieldFilter: false
      }, {
        name: 'offset',
        type: 'Int',
        description: 'Offset at which to start returning documents from',
        isFieldFilter: false
      }]
    });
  });
  return queries;
}