/**
 * Attempts to read the schema file at the given path, and return a compiled schema
 */
import path from 'path';
import { fork } from 'child_process';
import { createSchema } from '../../../schema';
export async function getSanitySchema(schemaPath) {
  const types = await getSanitySchemaTypes(schemaPath);
  const schema = createSchema({
    name: 'default',
    types
  });
  return schema;
}

function isExpectedResultShape(message) {
  return typeof message === 'object' && message !== null && !Array.isArray(message) && 'type' in message;
}

function isTypesResult(message) {
  return isExpectedResultShape(message) && message.type === 'types';
}

function getSanitySchemaTypes(schemaPath) {
  return new Promise((resolve, reject) => {
    const childPath = path.join(__dirname, 'getSanitySchema.fork.js');
    const childProc = fork(childPath, [schemaPath], {});
    childProc.on('message', message => {
      if (!isExpectedResultShape(message)) {
        reject(new Error('Unexpected result shape from schema fork'));
        return;
      }

      if (isTypesResult(message)) {
        resolve(message.types);
        return;
      }

      const error = new Error(message.error);
      error.type = message.errorType;
      reject(new Error("Failed to read schema at \"".concat(schemaPath, "\": ").concat(message.error)));
    });
    childProc.on('error', err => {
      reject(new Error("Failed to read schema at \"".concat(schemaPath, "\":\n\n").concat(err.stack)));
    });
    childProc.on('exit', code => {
      if (code !== 0) {
        reject(new Error("childProc stopped with exit code ".concat(code)));
      }
    });
  });
}