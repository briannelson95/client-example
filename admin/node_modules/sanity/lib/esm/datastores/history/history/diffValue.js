function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { wrap, diffInput } from '@sanity/diff';
import { isSameAnnotation } from './utils';

class ArrayContentWrapper {
  constructor(content, value, annotation, extractor) {
    _defineProperty(this, "type", 'array');

    _defineProperty(this, "value", void 0);

    _defineProperty(this, "length", void 0);

    _defineProperty(this, "annotation", void 0);

    _defineProperty(this, "extractor", void 0);

    _defineProperty(this, "content", void 0);

    _defineProperty(this, "elements", []);

    this.content = content;
    this.value = value;
    this.annotation = annotation;
    this.extractor = extractor;
    this.length = content.elements.length;
  }

  at(idx) {
    if (idx >= this.length) throw new Error('out of bounds');
    const input = this.elements[idx];

    if (input) {
      return input;
    }

    return this.elements[idx] = wrapValue(this.content.elements[idx], this.value[idx], this.extractor);
  }

  annotationAt(idx) {
    const meta = this.content.metas[idx];
    return this.extractor.fromMeta(meta);
  }

}

class ObjectContentWrapper {
  constructor(content, value, annotation, extractor) {
    _defineProperty(this, "type", 'object');

    _defineProperty(this, "value", void 0);

    _defineProperty(this, "keys", void 0);

    _defineProperty(this, "annotation", void 0);

    _defineProperty(this, "extractor", void 0);

    _defineProperty(this, "content", void 0);

    _defineProperty(this, "fields", {});

    this.content = content;
    this.value = value;
    this.annotation = annotation;
    this.extractor = extractor;
    this.keys = Object.keys(content.fields);
  }

  get(key) {
    const input = this.fields[key];

    if (input) {
      return input;
    }

    const value = this.content.fields[key];
    if (!value) return undefined;
    return this.fields[key] = wrapValue(value, this.value[key], this.extractor);
  }

}

class StringContentWrapper {
  constructor(content, value, annotation, extractor) {
    _defineProperty(this, "type", 'string');

    _defineProperty(this, "value", void 0);

    _defineProperty(this, "annotation", void 0);

    _defineProperty(this, "extractor", void 0);

    _defineProperty(this, "content", void 0);

    this.content = content;
    this.value = value;
    this.annotation = annotation;
    this.extractor = extractor;
  }

  sliceAnnotation(start, end) {
    const result = [];
    let idx = 0;

    function push(text, annotation) {
      if (result.length > 0) {
        const lst = result[result.length - 1];

        if (isSameAnnotation(lst.annotation, annotation)) {
          lst.text += text;
          return;
        }
      }

      result.push({
        text,
        annotation
      });
    }

    for (const part of this.content.parts) {
      const length = part.value.length;
      const subStart = Math.max(0, start - idx);

      if (subStart < length) {
        // The start of the slice is inside this part somewhere.
        // Figure out where the end is:
        const subEnd = Math.min(length, end - idx); // If the end of the slice is before this part, then we're guaranteed
        // that there are no more parts.

        if (subEnd <= 0) break;
        push(part.value.slice(subStart, subEnd), this.extractor.fromValue(part));
      }

      idx += length;
    }

    return result;
  }

}

function wrapValue(value, raw, extractor) {
  const annotation = extractor.fromValue(value);

  if (value.content) {
    switch (value.content.type) {
      case 'array':
        return new ArrayContentWrapper(value.content, raw, annotation, extractor);

      case 'object':
        return new ObjectContentWrapper(value.content, raw, annotation, extractor);

      case 'string':
        return new StringContentWrapper(value.content, raw, annotation, extractor);

      default: // do nothing

    }
  }

  return wrap(raw, annotation);
}

function extractAnnotationForFromInput(timeline, firstChunk, meta) {
  if (meta) {
    // The next transaction is where it disappeared:
    return annotationForTransactionIndex(timeline, meta.transactionIndex + 1, meta.chunk.index);
  } else if (firstChunk) {
    return annotationForTransactionIndex(timeline, firstChunk.start, firstChunk.index);
  }

  return null;
}

function extractAnnotationForToInput(timeline, meta) {
  if (meta) {
    return annotationForTransactionIndex(timeline, meta.transactionIndex, meta.chunk.index);
  }

  return null;
}

function annotationForTransactionIndex(timeline, idx, chunkIdx) {
  const tx = timeline.transactionByIndex(idx);
  if (!tx) return null;
  const chunk = timeline.chunkByTransactionIndex(idx, chunkIdx);
  if (!chunk) return null;
  return {
    chunk,
    timestamp: tx.timestamp,
    author: tx.author
  };
} // eslint-disable-next-line max-params


export function diffValue(timeline, firstChunk, from, fromRaw, to, toRaw) {
  const fromInput = wrapValue(from, fromRaw, {
    fromValue(value) {
      return extractAnnotationForFromInput(timeline, firstChunk, value.endMeta);
    },

    fromMeta(meta) {
      return extractAnnotationForFromInput(timeline, firstChunk, meta);
    }

  });
  const toInput = wrapValue(to, toRaw, {
    fromValue(value) {
      return extractAnnotationForToInput(timeline, value.startMeta);
    },

    fromMeta(meta) {
      return extractAnnotationForToInput(timeline, meta);
    }

  });
  return diffInput(fromInput, toInput);
}