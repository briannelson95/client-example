import { emitOperation } from '../operationEvents';
import { del } from './delete';
import { publish } from './publish';
import { patch } from './patch';
import { commit } from './commit';
import { discardChanges } from './discardChanges';
import { unpublish } from './unpublish';
import { duplicate } from './duplicate';
import { restore } from './restore';
/* Ok, this became a bit messy - sorry
 *  The important thing to consider here is the PublicOperations interface -
 *  as long as this is properly typed, how everything else is implemented doesn't matter
 *  */

function createOperationGuard(opName) {
  return {
    disabled: 'NOT_READY',
    execute: () => {
      throw new Error("Called ".concat(opName, " before it was ready."));
    }
  };
} // This creates a version of the operations api that will throw if called.
// Most operations depend on having the "current document state" available locally and if an action gets called
// before we have the state available, we throw an error to signal "premature" invocation before ready


export const GUARDED = {
  commit: createOperationGuard('commit'),
  delete: createOperationGuard('delete'),
  del: createOperationGuard('del'),
  publish: createOperationGuard('publish'),
  patch: createOperationGuard('patch'),
  discardChanges: createOperationGuard('discardChanges'),
  unpublish: createOperationGuard('unpublish'),
  duplicate: createOperationGuard('duplicate'),
  restore: createOperationGuard('restore')
};

const createEmitter = (operationName, idPair, typeName) => {
  return function () {
    for (var _len = arguments.length, executeArgs = new Array(_len), _key = 0; _key < _len; _key++) {
      executeArgs[_key] = arguments[_key];
    }

    return emitOperation(operationName, idPair, typeName, executeArgs);
  };
};

function wrap(opName, op, operationArgs) {
  const disabled = op.disabled(operationArgs);
  return {
    disabled,
    execute: createEmitter(opName, operationArgs.idPair, operationArgs.typeName)
  };
}

export function createOperationsAPI(args) {
  return {
    commit: wrap('commit', commit, args),
    delete: wrap('delete', del, args),
    del: wrap('delete', del, args),
    publish: wrap('publish', publish, args),
    patch: wrap('patch', patch, args),
    discardChanges: wrap('discardChanges', discardChanges, args),
    unpublish: wrap('unpublish', unpublish, args),
    duplicate: wrap('duplicate', duplicate, args),
    restore: wrap('restore', restore, args)
  };
}