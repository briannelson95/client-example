import { from, of } from 'rxjs';
import { filter, map, mergeMap, toArray } from 'rxjs/operators';
const TOKEN_DOCUMENT_ID_BASE = "secrets.sanity.sharedContent";

function isNonNullable(value) {
  return value !== null;
}

// eslint-disable-next-line camelcase
export function __tmp_wrap_crossProjectToken(_ref) {
  let {
    client: _client
  } = _ref;

  const versionedClient = _client.withConfig({
    apiVersion: '1'
  });

  function fetchTokenDocument(client, id) {
    return client.observable.fetch("*[_id == $id]{_id, _type, _updatedAt, token}[0]", {
      id
    });
  }

  return {
    getTokenDocumentId,
    getProjectIdFromTokenDocumentId,
    fetchCrossProjectToken,
    fetchAllCrossProjectTokens
  }; // export

  function getTokenDocumentId(_ref2) {
    let {
      tokenId,
      projectId
    } = _ref2;
    return [TOKEN_DOCUMENT_ID_BASE, projectId, tokenId].filter(Boolean).join('.');
  } // export


  function getProjectIdFromTokenDocumentId(id) {
    if (!id.startsWith(TOKEN_DOCUMENT_ID_BASE)) {
      return null;
    } //prettier-ignore


    const [
      /*secrets*/

      /*sanity*/

      /*sharedContent*/
    ,,, projectId] = id.split('.');
    return projectId;
  } // export


  function fetchCrossProjectToken(client, _ref3) {
    let {
      projectId,
      tokenId
    } = _ref3;

    if (client.config().projectId === projectId) {
      return of(undefined);
    }

    return fetchTokenDocument(client, getTokenDocumentId({
      projectId,
      tokenId
    })).pipe(map(tokenDoc => tokenDoc.token));
  } // export


  function fetchAllCrossProjectTokens() {
    return versionedClient.observable.fetch("*[_id in path(\"".concat(TOKEN_DOCUMENT_ID_BASE, ".**\")]{_id, _type, _updatedAt, token}")).pipe(mergeMap(tokenDocs => from(tokenDocs)), map(doc => {
      const projectId = getProjectIdFromTokenDocumentId(doc._id);
      return projectId ? {
        projectId,
        token: doc.token
      } : null;
    }), filter(isNonNullable), toArray());
  }
}