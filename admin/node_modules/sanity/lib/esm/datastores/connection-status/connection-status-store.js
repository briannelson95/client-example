import { observableCallback } from 'observable-callback';
import { map, mergeMapTo, startWith, take, takeUntil } from 'rxjs/operators';
import { concat, fromEvent, merge, NEVER, of, throwError, timer } from 'rxjs';
import { catchWithCount } from './utils/catchWithCount';
const onOnline$ = typeof window === 'undefined' ? of({}) : fromEvent(window, 'online');
const onOffline$ = typeof window === 'undefined' ? of({}) : fromEvent(window, 'offline');

const expBackoff = retryCount => Math.pow(2, retryCount) * 100;

export const CONNECTING = {
  type: 'connecting'
};
const [onRetry$, onRetry] = observableCallback();
export { onRetry };

const createErrorStatus = _ref => {
  let {
    error,
    isOffline,
    attemptNo,
    retryAt
  } = _ref;
  return {
    type: 'error',
    error,
    attemptNo,
    isOffline,
    retryAt
  };
};

/**
 * This is the beginning of what should be the data store tracking connection status in the Sanity studio.
 */
export function createConnectionStatusStore(_ref2) {
  let {
    bifur
  } = _ref2;
  const connectionStatus$ = merge(bifur.heartbeats, onOffline$.pipe(mergeMapTo(throwError(new Error('The browser went offline'))))).pipe(map(ts => ({
    type: 'connected',
    lastHeartbeat: ts
  })), catchWithCount((error, successiveErrorsCount, caught) => {
    const timeUntilRetry = Math.min(1000 * 240, expBackoff(successiveErrorsCount));
    const retryAt = new Date(new Date().getTime() + timeUntilRetry);
    const expiry$ = timer(retryAt);
    const isOffline = !navigator.onLine;
    const initialErrorStatus = createErrorStatus({
      error,
      retryAt,
      isOffline,
      attemptNo: successiveErrorsCount
    });
    const triggerRetry$ = NEVER.pipe(takeUntil(isOffline ? onOnline$ : merge(expiry$, onOnline$, onRetry$)));
    return concat(of(initialErrorStatus), triggerRetry$.pipe(take(1)), caught);
  }), startWith(CONNECTING));
  return {
    connectionStatus$
  };
}