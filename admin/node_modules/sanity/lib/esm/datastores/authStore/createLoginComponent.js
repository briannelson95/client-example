import { Button, Flex, Heading, Spinner, Stack, Text } from '@sanity/ui';
import React, { useEffect, useState } from 'react';
import { createHookFromObservableFactory } from '../../util';
import { providerLogos } from './providerLogos';

async function getProviders(_ref) {
  let {
    client,
    mode,
    providers: customProviders = []
  } = _ref;
  const {
    providers,
    thirdPartyLogin,
    sso
  } = await client.request({
    uri: '/auth/providers'
  });
  if (!customProviders.length) return providers;
  const custom = customProviders.map(provider => {
    // taken from here:
    // https://github.com/sanity-io/sanity/blob/795637999b67c23de1657a3701091a337383f632/packages/%40sanity/default-login/src/util/getProviders.js#L19
    // A user may want to remove certain login options (eg GitHub) and thus
    // provide "official" login options through the config. These shouldn't be
    // treated as custom login providers which require the third-party login
    // feature, but as the official provider
    const isOfficial = providers.some(official => official.url === provider.url);
    const isSupported = isOfficial || thirdPartyLogin || sso && Object.values(sso).some(Boolean);
    return { ...provider,
      custom: !isOfficial,
      supported: isSupported
    };
  });
  if (mode === 'replace') return custom; // Append to the list of official providers, but replace any provider that has
  // the same URL with the custom one (allows customizing the title, name)

  return providers.filter(official => custom.some(provider => provider.url !== official.url)).concat(custom);
}

function createHrefForProvider(_ref2) {
  let {
    loginMethod,
    projectId,
    url,
    basePath
  } = _ref2;
  const params = new URLSearchParams();
  params.set('origin', "".concat(window.location.origin).concat(basePath));
  params.set('projectId', projectId);
  params.set('type', loginMethod);
  return "".concat(url, "?").concat(params);
}

export function createLoginComponent(_ref3) {
  let {
    getClient,
    loginMethod,
    redirectOnSingle,
    ...providerOptions
  } = _ref3;
  const useClient = createHookFromObservableFactory(getClient);

  function LoginComponent(_ref4) {
    let {
      projectId,
      basePath
    } = _ref4;
    const [providers, setProviders] = useState(null);
    const [error, setError] = useState(null);
    if (error) throw error;
    const [client] = useClient();
    useEffect(() => {
      if (!client) return;
      getProviders({
        client,
        ...providerOptions
      }).then(setProviders).catch(setError);
    }, [client]); // only create a direct URL if `redirectOnSingle` is true and there is only
    // one provider available

    const redirectUrl = redirectOnSingle && (providers === null || providers === void 0 ? void 0 : providers.length) === 1 && (providers === null || providers === void 0 ? void 0 : providers[0]) && createHrefForProvider({
      loginMethod,
      projectId,
      url: providers[0].url,
      basePath
    });
    const loading = !providers || redirectUrl;
    useEffect(() => {
      if (redirectUrl) {
        window.location.href = redirectUrl;
      }
    }, [redirectUrl]);

    if (loading) {
      return /*#__PURE__*/React.createElement(Flex, {
        align: "center",
        direction: "column",
        gap: 4,
        justify: "center",
        padding: 6,
        sizing: "border"
      }, /*#__PURE__*/React.createElement(Text, {
        muted: true
      }, "Loading\u2026"), /*#__PURE__*/React.createElement(Spinner, {
        muted: true
      }));
    }

    return /*#__PURE__*/React.createElement(Stack, {
      space: 4
    }, /*#__PURE__*/React.createElement(Heading, {
      align: "center",
      size: 1
    }, "Choose login provider"), /*#__PURE__*/React.createElement(Stack, {
      space: 2
    }, providers.map((provider, index) => /*#__PURE__*/React.createElement(Button // eslint-disable-next-line react/no-array-index-key
    , {
      icon: providerLogos[provider.name],
      key: "".concat(provider.url, "_").concat(index),
      as: "a",
      href: createHrefForProvider({
        loginMethod,
        projectId,
        url: provider.url,
        basePath
      }),
      mode: "ghost",
      text: provider.title
    }))));
  }

  return LoginComponent;
}