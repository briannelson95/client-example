import { combineLatest, of } from 'rxjs';
import { map, switchMap } from 'rxjs/operators';
import { getIdPair } from '../util/draftUtils';
import { isRecord } from '../util/isRecord';
import { create_preview_availability } from './availability';
export function create_preview_documentPair(versionedClient, observePaths) {
  const {
    observeDocumentPairAvailability
  } = create_preview_availability(versionedClient, observePaths);
  const ALWAYS_INCLUDED_SNAPSHOT_PATHS = [['_updatedAt'], ['_createdAt'], ['_type']];
  return {
    observePathsDocumentPair
  };

  function observePathsDocumentPair(value, paths) {
    const {
      draftId,
      publishedId
    } = getIdPair('_id' in value ? value._id : value._ref);
    return observeDocumentPairAvailability(value).pipe(switchMap(availability => {
      if (!availability.draft.available && !availability.published.available) {
        // short circuit, neither draft nor published is available so no point in trying to get a snapshot
        return of({
          id: publishedId,
          type: null,
          draft: {
            availability: availability.draft,
            snapshot: undefined
          },
          published: {
            availability: availability.published,
            snapshot: undefined
          }
        });
      }

      const snapshotPaths = [...paths, ...ALWAYS_INCLUDED_SNAPSHOT_PATHS];
      return combineLatest([observePaths({
        _type: 'reference',
        _ref: draftId
      }, snapshotPaths), observePaths({
        _type: 'reference',
        _ref: publishedId
      }, snapshotPaths)]).pipe(map(_ref => {
        let [draftSnapshot, publishedSnapshot] = _ref;
        // note: assume type is always the same
        const type = isRecord(draftSnapshot) && '_type' in draftSnapshot && draftSnapshot._type || isRecord(publishedSnapshot) && '_type' in publishedSnapshot && publishedSnapshot._type || null;
        return {
          id: publishedId,
          type: typeof type === 'string' ? type : null,
          draft: {
            availability: availability.draft,
            snapshot: draftSnapshot
          },
          published: {
            availability: availability.published,
            snapshot: publishedSnapshot
          }
        };
      }));
    }));
  }
}