import { Observable } from 'rxjs';
import { isNonNullable } from '../../util/isNonNullable';
export function debounceCollect(fn, wait) {
  let timer;
  let queue = {};
  let idx = 0;
  return function debounced() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new Observable(obs => {
      clearTimeout(timer);
      timer = setTimeout(flush, wait);
      const queueItem = {
        args: args,
        observer: obs,
        completed: false
      };
      const id = idx++;
      queue[id] = queueItem;
      return () => {
        // console.log('completed', queueItem.args)
        queueItem.completed = true;
      };
    });
  };

  function flush() {
    const currentlyFlushingQueue = queue;
    queue = {};
    const queueItemIds = Object.keys(currentlyFlushingQueue) // Todo: use debug
    // .map(id => {
    //   if (currentlyFlushingQueue[id].completed) {
    //     console.log('Dropped', currentlyFlushingQueue[id].args)
    //   }
    //   return id
    // })
    .filter(id => {
      const queueItem = currentlyFlushingQueue[id];
      return queueItem && !queueItem.completed;
    });

    if (queueItemIds.length === 0) {
      // nothing to do
      return;
    }

    const collectedArgs = queueItemIds.map(id => {
      const queueItem = currentlyFlushingQueue[id];
      return queueItem && queueItem.args;
    }).filter(isNonNullable);
    fn(collectedArgs).subscribe({
      next(results) {
        results.forEach((result, i) => {
          const queueItem = currentlyFlushingQueue[queueItemIds[i]];

          if (queueItem && !queueItem.completed) {
            queueItem.observer.next(results[i]);
          }
        });
      },

      complete() {
        queueItemIds.forEach(id => {
          const entry = currentlyFlushingQueue[id];

          if (entry && !entry.completed) {
            entry.observer.complete();
          }
        });
      },

      error(err) {
        queueItemIds.forEach(id => {
          const entry = currentlyFlushingQueue[id];

          if (entry && !entry.completed) {
            entry.observer.error(err);
          }
        });
      }

    });
  }
}