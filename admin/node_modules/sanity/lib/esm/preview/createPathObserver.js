import _uniq from "lodash/uniq";
import _isString from "lodash/isString";
import { isReference } from '@sanity/types';
import { of as observableOf } from 'rxjs';
import { switchMap } from 'rxjs/operators';
import { isRecord } from '../util';
import { props } from './utils/props';

function createEmpty(fields) {
  return fields.reduce((result, field) => {
    result[field] = undefined;
    return result;
  }, {});
}

function resolveMissingHeads(value, paths) {
  return paths.filter(path => !(path[0] in value));
}

function observePaths(value, paths, observeFields, apiConfig) {
  if (!value || typeof value !== 'object') {
    // Reached a leaf. Return as is
    return observableOf(value); // @todo
  }

  const id = isReference(value) ? value._ref : value._id;
  const currentValue = { ...value,
    _id: id
  };

  if (currentValue._type === 'reference') {
    delete currentValue._type;
    delete currentValue._ref;
    delete currentValue._weak;
    delete currentValue._dataset;
    delete currentValue._projectId;
    delete currentValue._strengthenOnPublish;
  }

  const pathsWithMissingHeads = resolveMissingHeads(currentValue, paths);

  if (id && pathsWithMissingHeads.length > 0) {
    // Reached a node that is either a document (with _id), or a reference (with _ref) that
    // needs to be "materialized"
    const nextHeads = _uniq(pathsWithMissingHeads.map(path => path[0]));

    const dataset = isRecord(value) && _isString(value._dataset) ? value._dataset : undefined;
    const projectId = isRecord(value) && _isString(value._projectId) ? value._projectId : undefined;
    const refApiConfig = // if it's a cross dataset reference we want to use it's `_projectId` + `_dataset`
    // attributes as api config
    dataset && projectId ? {
      projectId: projectId,
      dataset: dataset
    } : apiConfig;
    return observeFields(id, nextHeads, refApiConfig).pipe(switchMap(snapshot => {
      if (snapshot === null) {
        return observableOf(null);
      }

      return observePaths({ ...createEmpty(nextHeads),
        ...(isReference(value) ? { ...value,
          ...refApiConfig
        } : value),
        ...snapshot
      }, paths, observeFields, refApiConfig);
    }));
  } // We have all the fields needed already present on value


  const leads = {};
  paths.forEach(path => {
    const [head, ...tail] = path;

    if (!leads[head]) {
      leads[head] = [];
    }

    leads[head].push(tail);
  });
  const next = Object.keys(leads).reduce((res, head) => {
    const tails = leads[head].filter(tail => tail.length > 0);

    if (tails.length === 0) {
      res[head] = isRecord(value) ? value[head] : undefined;
    } else {
      res[head] = observePaths(value[head], tails, observeFields, apiConfig);
    }

    return res;
  }, currentValue);
  return observableOf(next).pipe(props({
    wait: true
  }));
} // Normalizes path arguments so it supports both dot-paths and array paths, e.g.
// - ['propA.propB', 'propA.propC']
// - [['propA', 'propB'], ['propA', 'propC']]


function normalizePaths(path) {
  return path.map(segment => typeof segment === 'string' ? segment.split('.') : segment);
}

export function createPathObserver(context) {
  const {
    observeFields
  } = context;
  return {
    observePaths(value, paths, apiConfig) {
      return observePaths(value, normalizePaths(paths), observeFields, apiConfig);
    }

  };
}