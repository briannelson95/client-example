import _xor from "lodash/xor";
import _uniq from "lodash/uniq";
import _startCase from "lodash/startCase";
import React, { useCallback, useMemo } from 'react';
import { DiffCard } from '../../../../diff';
import * as TextSymbols from '../symbols';
import { escapeRegExp, getAllMarkDefs, findChildDiff, findAnnotationDiff, findSpanDiffFromChild, getChildSchemaType, getDecorators, getInlineObjects, isDecorator } from '../helpers';
import Block from './Block';
import { Annotation } from './Annotation';
import Decorator from './Decorator';
import { InlineObject } from './InlineObject';
import { Text } from './Text';
const decoratorSymbolsStart = TextSymbols.DECORATOR_SYMBOLS.map(set => set[0]);
const decoratorSymbolsEnd = TextSymbols.DECORATOR_SYMBOLS.map(set => set[1]);
const annotationSymbolsStart = TextSymbols.ANNOTATION_SYMBOLS.map(set => set[0]);
const annotationSymbolsEnd = TextSymbols.ANNOTATION_SYMBOLS.map(set => set[1]);
const allSymbolsStart = decoratorSymbolsStart.concat(annotationSymbolsStart);
const allSymbolsEnd = decoratorSymbolsEnd.concat(annotationSymbolsEnd);
const allDecoratorSymbols = decoratorSymbolsStart.concat(decoratorSymbolsEnd);
const markRegex = new RegExp("".concat(allDecoratorSymbols.concat(allSymbolsEnd).join('|')), 'g');
export default function PortableText(props) {
  const {
    diff,
    schemaType
  } = props;
  const block = diff.origin.toValue || diff.origin.fromValue;
  const inlineObjects = useMemo(() => diff.origin.toValue ? getInlineObjects(diff.origin) : [], [diff.origin]);
  const renderChild = useCallback(ptDiffChild => {
    const spanSchemaType = getChildSchemaType(schemaType.fields, ptDiffChild);
    let decoratorTypes = [];

    if (spanSchemaType) {
      decoratorTypes = getDecorators(spanSchemaType);
      const childrenDiff = diff.fields.children;
      const segments = childrenDiff.items[0].diff && childrenDiff.items[0].diff.type === 'object' && childrenDiff.items[0].diff.fields.text.type === 'string' && childrenDiff.items[0].diff.fields.text.segments || [];
      const returnedChildren = [];
      const annotationSegments = {}; // Special case for new empty PT-block (single span child with empty text)

      if (isEmptyTextChange(block, diff) && (diff.origin.action === 'added' || diff.origin.action === 'removed')) {
        const textDiff = findChildDiff(diff.origin, block.children[0]) || diff.origin;

        if (textDiff && textDiff.action !== 'unchanged') {
          return /*#__PURE__*/React.createElement(DiffCard, {
            annotation: textDiff.annotation,
            as: textDiff.action === 'removed' ? 'del' : 'ins',
            key: "empty-block-".concat(block._key),
            tooltip: {
              description: "".concat(_startCase(textDiff.action), " empty text")
            }
          }, /*#__PURE__*/React.createElement("span", null, TextSymbols.EMPTY_BLOCK_SYMBOL));
        }
      } // Run through all the segments from the PortableTextDiff


      let childToIndex = -1;
      let segIndex = -1;
      const activeAnnotations = [];
      let endedAnnotation;
      const allMarkDefs = getAllMarkDefs(diff.origin);
      segments.forEach(seg => {
        segIndex++;
        const isInline = TextSymbols.INLINE_SYMBOLS.includes(seg.text);
        const isMarkStart = allSymbolsStart.includes(seg.text);
        const isMarkEnd = allSymbolsEnd.includes(seg.text);
        const isChildStart = seg.text === TextSymbols.CHILD_SYMBOL;
        const isRemoved = seg.action === 'removed';

        if (isChildStart) {
          if (!isRemoved) {
            childToIndex++;
          } // No output

        } else if (isMarkStart || isMarkEnd) {
          if (isMarkStart && annotationSymbolsStart.includes(seg.text)) {
            const object = allMarkDefs[annotationSymbolsStart.indexOf(seg.text)];

            if (object) {
              activeAnnotations.push({
                mark: object._key,
                symbols: [seg.text, annotationSymbolsEnd[annotationSymbolsStart.indexOf(seg.text)]],
                object
              });
            }
          }

          if (isMarkEnd && annotationSymbolsEnd.includes(seg.text)) {
            endedAnnotation = activeAnnotations.pop();
          } // No output

        } else if (isInline) {
          var _inlineObjects$indexO;

          // Render inline object
          const indexOfSymbol = TextSymbols.INLINE_SYMBOLS.findIndex(sym => sym === seg.text);
          const key = (_inlineObjects$indexO = inlineObjects[indexOfSymbol]) === null || _inlineObjects$indexO === void 0 ? void 0 : _inlineObjects$indexO._key;
          const originChild = inlineObjects[indexOfSymbol];

          if (key) {
            const objectSchemaType = getChildSchemaType(schemaType.fields, originChild);
            const objectDiff = findChildDiff(diff.origin, originChild);
            returnedChildren.push( /*#__PURE__*/React.createElement(InlineObject, {
              key: "inline-object-".concat(originChild._key),
              object: originChild,
              path: [{
                _key: block._key
              }, 'children', {
                _key: originChild._key
              }],
              diff: objectDiff,
              schemaType: objectSchemaType
            }));
          }
        } else if (seg.text) {
          var _childDiff$fields, _childDiff$fields2;

          // TODO: find a better way of getting a removed child
          const getChildFromFromValue = () => {
            var _diff$origin$fromValu;

            return (_diff$origin$fromValu = diff.origin.fromValue) === null || _diff$origin$fromValu === void 0 ? void 0 : _diff$origin$fromValu.children.find(cld => cld.text && cld.text.match(escapeRegExp(seg.text)));
          };

          const child = block.children[childToIndex] || getChildFromFromValue();
          const childDiff = child && findSpanDiffFromChild(diff.origin, child);

          if (!child) {
            throw new Error('Could not find child');
          }

          const textDiff = childDiff !== null && childDiff !== void 0 && (_childDiff$fields = childDiff.fields) !== null && _childDiff$fields !== void 0 && _childDiff$fields.text ? childDiff === null || childDiff === void 0 ? void 0 : (_childDiff$fields2 = childDiff.fields) === null || _childDiff$fields2 === void 0 ? void 0 : _childDiff$fields2.text : undefined;
          const text = /*#__PURE__*/React.createElement(Text, {
            diff: textDiff,
            key: "text-".concat(child._key, "-").concat(segIndex),
            path: [{
              _key: block._key
            }, 'children', {
              _key: child._key
            }],
            childDiff: childDiff,
            segment: seg
          }, renderTextSegment({
            diff,
            child,
            decoratorTypes,
            seg,
            segIndex,
            spanSchemaType
          })); // Render annotations text changes within the annotation child

          if (activeAnnotations.length > 0) {
            activeAnnotations.forEach(active => {
              annotationSegments[active.mark] = annotationSegments[active.mark] || [];
              annotationSegments[active.mark].push(text);
            });
          }

          if (endedAnnotation) {
            const key = "annotation-".concat(endedAnnotation.object._key);
            const lastChild = returnedChildren[returnedChildren.length - 1];

            if (lastChild && lastChild.key !== key) {
              const annotationDiff = findAnnotationDiff(diff.origin, endedAnnotation.mark);
              const objectSchemaType = endedAnnotation && spanSchemaType.annotations && spanSchemaType.annotations.find(type => endedAnnotation && endedAnnotation.object && type.name === endedAnnotation.object._type);
              returnedChildren.push( /*#__PURE__*/React.createElement(Annotation, {
                object: endedAnnotation.object,
                diff: annotationDiff,
                path: [{
                  _key: block._key
                }, 'children', {
                  _key: child._key
                }],
                schemaType: objectSchemaType,
                key: key
              }, /*#__PURE__*/React.createElement(React.Fragment, null, annotationSegments[endedAnnotation.mark])));
            } // delete annotationSegments[endedAnnotation.mark]


            endedAnnotation = undefined;
          }

          if (activeAnnotations.length === 0) {
            returnedChildren.push(text);
          }
        } // end if seg.text

      });
      return /*#__PURE__*/React.createElement('div', {
        key: block._key
      }, ...returnedChildren);
    }

    throw new Error("'span' schemaType not found");
  }, [block, diff, inlineObjects, schemaType]);
  return /*#__PURE__*/React.createElement(Block, {
    block: diff.displayValue,
    diff: diff
  }, /*#__PURE__*/React.createElement(React.Fragment, null, (diff.displayValue.children || []).map(child => renderChild(child))));
}

function renderTextSegment(_ref) {
  let {
    diff,
    child,
    decoratorTypes,
    seg,
    segIndex,
    spanSchemaType
  } = _ref;

  // Newlines
  if (seg.text === '\n') {
    return /*#__PURE__*/React.createElement("br", null);
  } // Make sure we render trailing spaces correctly


  let children = /*#__PURE__*/React.createElement("span", {
    key: "text-".concat(segIndex)
  }, seg.text.replace(/ /g, TextSymbols.TRAILING_SPACE_SYMBOL));
  const spanDiff = child && findSpanDiffFromChild(diff.origin, child); // Render decorator diff info

  const activeMarks = child.marks || [];

  if (spanDiff) {
    children = renderDecorators({
      activeMarks,
      decoratorTypes,
      diff,
      children,
      seg,
      segIndex,
      spanDiff,
      spanSchemaType
    });
  } // Render the segment with the active marks


  if (activeMarks && activeMarks.length > 0) {
    activeMarks.forEach(mark => {
      if (isDecorator(mark, spanSchemaType)) {
        children =
        /*#__PURE__*/
        // eslint-disable-next-line react/no-array-index-key
        React.createElement(Decorator, {
          mark: mark,
          key: "decorator-".concat(mark, "-").concat(child._key, "-").concat(segIndex)
        }, children);
      }
    });
  }

  return children;
}

function renderDecorators(_ref2) {
  var _spanDiff$fields;

  let {
    activeMarks,
    decoratorTypes,
    diff,
    children,
    seg,
    segIndex,
    spanDiff,
    spanSchemaType
  } = _ref2;
  let returned = /*#__PURE__*/React.createElement("span", {
    key: "text-segment-".concat(segIndex)
  }, children);
  const fromPtDiffText = diff.origin.fromValue && diff.fromValue && diff.fromValue.children[0].text || ''; // Always one child
  // There are cases where we have changed marks, but it's an indirect change in the diff data.
  // For example when '<>normal-text</><>bold-text</>' and 'bold' is unbolded. Then 'bold' is added to first span,
  // and 'bold' is removed from the second span: '<>normal-text-bold</><>-text</>'. No marks are changed.
  // We do however want to indicate to the user that someone removed bold from 'bold'
  // In these cases, fallback to the diff annotation information in the span itself.

  const indirectMarksAnnotation = spanDiff && spanDiff.action !== 'unchanged' && spanDiff.annotation || undefined;
  const marksDiff = spanDiff === null || spanDiff === void 0 ? void 0 : (_spanDiff$fields = spanDiff.fields) === null || _spanDiff$fields === void 0 ? void 0 : _spanDiff$fields.marks;
  const marksAnnotation = marksDiff && marksDiff.action !== 'unchanged' && marksDiff.annotation || indirectMarksAnnotation;
  let marksChanged = [];
  const ptDiffChildren = fromPtDiffText.split(TextSymbols.CHILD_SYMBOL).filter(text => !!text).join('');
  const ptDiffMatchString = ptDiffChildren;
  const controlString = ptDiffMatchString.substring(0, ptDiffMatchString.indexOf(seg.text) + seg.text.length);
  const toTest = controlString.substring(0, controlString.indexOf(seg.text));
  const marks = [];
  const matches = [...toTest.matchAll(markRegex)];
  matches.forEach(match => {
    const sym = match[0];
    const set = TextSymbols.DECORATOR_SYMBOLS.concat(TextSymbols.ANNOTATION_SYMBOLS).find(aSet => aSet.indexOf(sym) > -1);

    if (set) {
      var _decoratorTypes;

      const isMarkStart = sym === set[0];
      const mark = ((_decoratorTypes = decoratorTypes[isMarkStart ? decoratorSymbolsStart.indexOf(sym) : decoratorSymbolsEnd.indexOf(sym)]) === null || _decoratorTypes === void 0 ? void 0 : _decoratorTypes.value) || sym; // Annotation marks are uniqe anyway

      const notClosed = toTest.lastIndexOf(sym) > toTest.lastIndexOf(set[1]);

      if (notClosed) {
        marks.push(mark);
      }
    }
  });
  marksChanged = _xor(activeMarks, _uniq(marks)); // Only for decorators, annotations are taken care of elsewhere

  if (marksAnnotation && marksChanged.length > 0 && marksChanged.some(m => isDecorator(m, spanSchemaType))) {
    returned = /*#__PURE__*/React.createElement(DiffCard, {
      annotation: marksAnnotation,
      key: "diffcard-annotation-".concat(segIndex, "-").concat(marksChanged.join('-')),
      as: 'ins',
      tooltip: {
        description: 'Changed formatting'
      }
    }, returned);
  }

  return returned;
}

function isEmptyTextChange(block, diff) {
  return block.children.length === 1 && block.children[0]._type === 'span' && typeof block.children[0].text === 'string' && block.children[0].text === '' && diff.origin.action !== 'unchanged';
}