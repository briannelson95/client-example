import _isEqual from "lodash/isEqual";
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { RouterContext } from './RouterContext';

/**
 * @example
 * ```tsx
 * import {
 *   NavigateOptions,
 *   route,
 *   RouterProvider,
 *   RouterState
 * } from 'sanity'
 * import {useCallback, useMemo} from 'react'
 *
 * function Root() {
 *   const router = useMemo(() => route.create('/'), [])
 *
 *   const [state, setState] = useState<RouterState>({})
 *
 *   const handleNavigate = useCallback((
 *     path: string,
 *     options?: NavigateOptions
 *   ) => {
 *     console.log('navigate', path, options)
 *
 *     setState(router.decode(path))
 *   }, [router])
 *
 *   return (
 *     <RouterProvider
 *       onNavigate={handleNavigate}
 *       router={router}
 *       state={state}
 *     >
 *       <div>This is a routed application</div>
 *     </RouterProvider>
 *   )
 * }
 * ```
 *
 * @public
 */
export function RouterProvider(props) {
  // TODO: can we do nested routes?
  const {
    onNavigate,
    router: routerProp,
    state: stateProp
  } = props;
  const [state, setState] = useState(stateProp);
  const stateRef = useRef(state);
  const navigateUrl = useCallback(opts => {
    onNavigate(opts);
  }, [onNavigate]);
  const resolveIntentLink = useCallback((intentName, parameters) => {
    const [params, payload] = Array.isArray(parameters) ? parameters : [parameters];
    return routerProp.encode({
      intent: intentName,
      params,
      payload
    });
  }, [routerProp]);
  const resolvePathFromState = useCallback(nextState => {
    return routerProp.encode(nextState);
  }, [routerProp]);
  const navigate = useCallback(function (nextState) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    navigateUrl({
      path: resolvePathFromState(nextState),
      replace: options.replace
    });
  }, [navigateUrl, resolvePathFromState]);
  const navigateIntent = useCallback(function (intentName, params) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    navigateUrl({
      path: resolveIntentLink(intentName, params),
      replace: options.replace
    });
  }, [navigateUrl, resolveIntentLink]);
  const router = useMemo(() => ({
    navigate,
    navigateIntent,
    navigateUrl,
    resolveIntentLink,
    resolvePathFromState,
    state
  }), [navigate, navigateIntent, navigateUrl, resolveIntentLink, resolvePathFromState, state]); // Update state as new `state` prop comes in

  useEffect(() => {
    const prevState = stateRef.current;
    const nextState = stateProp;

    if (!_isEqual(nextState, prevState)) {
      setState(nextState);
    }
  }, [stateProp]);
  return /*#__PURE__*/React.createElement(RouterContext.Provider, {
    value: router
  }, props.children);
}