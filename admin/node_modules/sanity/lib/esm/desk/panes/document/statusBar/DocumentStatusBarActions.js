import React, { memo, // useCallback,
useMemo, useState } from 'react';
import { Box, Flex, Tooltip, Stack, Button, Hotkeys, LayerProvider, Text } from '@sanity/ui';
import { useDocumentPane } from '../useDocumentPane';
import { RenderActionCollectionState, HistoryRestoreAction } from '../../../actions';
import { ActionMenuButton } from './ActionMenuButton';
import { ActionStateDialog } from './ActionStateDialog';

function DocumentStatusBarActionsInner(props) {
  const {
    disabled,
    showMenu,
    states
  } = props;
  const [firstActionState, ...menuActionStates] = states;
  const [buttonElement, setButtonElement] = useState(null);
  const tooltipContent = useMemo(() => {
    if (!firstActionState || !firstActionState.title && !firstActionState.shortcut) return null;
    return /*#__PURE__*/React.createElement(Flex, {
      padding: 2,
      style: {
        maxWidth: 300
      },
      align: "center"
    }, /*#__PURE__*/React.createElement(Text, {
      size: 1
    }, firstActionState.title), firstActionState.shortcut && /*#__PURE__*/React.createElement(Box, {
      marginLeft: firstActionState.title ? 2 : 0
    }, /*#__PURE__*/React.createElement(Hotkeys, {
      keys: String(firstActionState.shortcut).split('+').map(s => s.slice(0, 1).toUpperCase() + s.slice(1).toLowerCase())
    })));
  }, [firstActionState]);
  return /*#__PURE__*/React.createElement(Flex, null, firstActionState && /*#__PURE__*/React.createElement(LayerProvider, {
    zOffset: 200
  }, /*#__PURE__*/React.createElement(Tooltip, {
    disabled: !tooltipContent,
    content: tooltipContent,
    portal: true,
    placement: "top"
  }, /*#__PURE__*/React.createElement(Stack, {
    flex: 1
  }, /*#__PURE__*/React.createElement(Button, {
    "data-testid": "action-".concat(firstActionState.label),
    disabled: disabled || Boolean(firstActionState.disabled),
    icon: firstActionState.icon // eslint-disable-next-line react/jsx-handler-names
    ,
    onClick: firstActionState.onHandle,
    ref: setButtonElement,
    text: firstActionState.label,
    tone: firstActionState.tone || 'primary'
  })))), showMenu && menuActionStates.length > 0 && /*#__PURE__*/React.createElement(Box, {
    marginLeft: 1
  }, /*#__PURE__*/React.createElement(ActionMenuButton, {
    actionStates: menuActionStates,
    disabled: disabled
  })), firstActionState && firstActionState.modal && /*#__PURE__*/React.createElement(ActionStateDialog, {
    modal: firstActionState.modal,
    referenceElement: buttonElement
  }));
}

export const DocumentStatusBarActions = /*#__PURE__*/memo(function DocumentStatusBarActions() {
  const {
    actions,
    connectionState,
    editState
  } = useDocumentPane(); // const [isMenuOpen, setMenuOpen] = useState(false)
  // const handleMenuOpen = useCallback(() => setMenuOpen(true), [])
  // const handleMenuClose = useCallback(() => setMenuOpen(false), [])
  // const handleActionComplete = useCallback(() => setMenuOpen(false), [])

  if (!actions || !editState) {
    return null;
  }

  return /*#__PURE__*/React.createElement(RenderActionCollectionState // component={}
  // onActionComplete={handleActionComplete}
  , {
    actions: actions // @ts-expect-error TODO: fix the document actions
    ,
    actionProps: editState
  }, _ref => {
    let {
      states
    } = _ref;
    return /*#__PURE__*/React.createElement(DocumentStatusBarActionsInner, {
      disabled: connectionState !== 'connected' // isMenuOpen={isMenuOpen}
      // onMenuOpen={handleMenuOpen}
      // onMenuClose={handleMenuClose}
      ,
      showMenu: actions.length > 1,
      states: states
    });
  });
});
export const HistoryStatusBarActions = /*#__PURE__*/memo(function HistoryStatusBarActions() {
  var _historyController$re;

  const {
    connectionState,
    editState,
    historyController
  } = useDocumentPane();
  const revision = ((_historyController$re = historyController.revTime) === null || _historyController$re === void 0 ? void 0 : _historyController$re.id) || '';
  const disabled = ((editState === null || editState === void 0 ? void 0 : editState.draft) || (editState === null || editState === void 0 ? void 0 : editState.published) || {})._rev === revision;
  const actionProps = useMemo(() => ({ ...(editState || {}),
    revision
  }), [editState, revision]);
  const historyActions = useMemo(() => [HistoryRestoreAction], []);
  return /*#__PURE__*/React.createElement(RenderActionCollectionState, {
    actions: historyActions,
    actionProps: actionProps
  }, _ref2 => {
    let {
      states
    } = _ref2;
    return /*#__PURE__*/React.createElement(DocumentStatusBarActionsInner, {
      disabled: connectionState !== 'connected' || Boolean(disabled),
      showMenu: false,
      states: states
    });
  });
});