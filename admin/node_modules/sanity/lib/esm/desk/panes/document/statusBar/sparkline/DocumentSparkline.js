import { Box, Flex, useElementRect } from '@sanity/ui';
import React, { useEffect, useMemo, useState, memo, useLayoutEffect } from 'react';
import { useSyncState } from '../../../../../hooks';
import { useDocumentPane } from '../../useDocumentPane';
import { DocumentBadges } from './DocumentBadges';
import { PublishStatus } from './PublishStatus';
import { ReviewChangesButton } from './ReviewChangesButton';
const SYNCING_TIMEOUT = 1000;
const SAVED_TIMEOUT = 3000;
export const DocumentSparkline = /*#__PURE__*/memo(function DocumentSparkline() {
  var _editState$published;

  const {
    changesOpen,
    documentId,
    documentType,
    editState,
    onHistoryClose,
    onHistoryOpen,
    historyController,
    value
  } = useDocumentPane();
  const syncState = useSyncState(documentId, documentType);
  const lastUpdated = value === null || value === void 0 ? void 0 : value._updatedAt;
  const lastPublished = editState === null || editState === void 0 ? void 0 : (_editState$published = editState.published) === null || _editState$published === void 0 ? void 0 : _editState$published._updatedAt;
  const showingRevision = historyController.onOlderRevision();
  const liveEdit = Boolean(editState === null || editState === void 0 ? void 0 : editState.liveEdit);
  const published = Boolean(editState === null || editState === void 0 ? void 0 : editState.published);
  const changed = Boolean(editState === null || editState === void 0 ? void 0 : editState.draft);
  const [rootFlexElement, setRootFlexElement] = useState(null);
  const rootFlexRect = useElementRect(rootFlexElement);
  const collapsed = !rootFlexRect || (rootFlexRect === null || rootFlexRect === void 0 ? void 0 : rootFlexRect.width) < 300;
  const [status, setStatus] = useState(null); // eslint-disable-next-line consistent-return

  useEffect(() => {
    if (status === 'syncing') {
      // status changed to 'syncing', schedule an update to set it to 'saved'
      const timerId = setTimeout(() => setStatus('saved'), SYNCING_TIMEOUT);
      return () => clearTimeout(timerId);
    }

    if (status === 'saved') {
      // status changed to 'saved', schedule an update to clear it
      const timerId = setTimeout(() => setStatus(null), SAVED_TIMEOUT);
      return () => clearTimeout(timerId);
    }
  }, [status, lastUpdated]);
  useLayoutEffect(() => {
    // clear sync status when documentId changes
    setStatus(null);
  }, [documentId]); // set status to 'syncing' when lastUpdated changes and we go from not syncing to syncing

  useLayoutEffect(() => {
    if (syncState.isSyncing) {
      setStatus('syncing');
    }
  }, [syncState.isSyncing, lastUpdated]);
  const reviewButton = useMemo(() => /*#__PURE__*/React.createElement(ReviewChangesButton, {
    lastUpdated: lastUpdated,
    status: status || (changed ? 'changes' : undefined),
    onClick: changesOpen ? onHistoryClose : onHistoryOpen,
    disabled: showingRevision,
    selected: changesOpen,
    collapsed: collapsed
  }), [changed, changesOpen, onHistoryClose, onHistoryOpen, lastUpdated, showingRevision, status, collapsed]);
  const publishStatus = useMemo(() => (liveEdit || published) && /*#__PURE__*/React.createElement(Box, {
    marginRight: 1
  }, /*#__PURE__*/React.createElement(PublishStatus, {
    disabled: showingRevision,
    lastPublished: lastPublished,
    lastUpdated: lastUpdated,
    liveEdit: liveEdit,
    collapsed: collapsed
  })), [collapsed, lastPublished, lastUpdated, liveEdit, published, showingRevision]);
  return /*#__PURE__*/React.createElement(Flex, {
    align: "center",
    "data-ui": "DocumentSparkline",
    ref: setRootFlexElement
  }, publishStatus, /*#__PURE__*/React.createElement(Flex, {
    align: "center",
    flex: 1
  }, reviewButton, !collapsed && /*#__PURE__*/React.createElement(Box, {
    marginLeft: 3
  }, /*#__PURE__*/React.createElement(DocumentBadges, null))));
});