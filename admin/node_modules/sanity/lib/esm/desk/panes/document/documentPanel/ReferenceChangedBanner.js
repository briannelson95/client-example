var _templateObject, _templateObject2;

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

import { Box, Button, Card, Container, Flex, Text } from '@sanity/ui';
import { WarningOutlineIcon, SyncIcon, CloseIcon } from '@sanity/icons';
import React, { memo, useCallback, useMemo } from 'react';
import styled from 'styled-components';
import { fromString as pathFromString, get as pathGet } from '@sanity/util/paths';
import { debounceTime, map } from 'rxjs/operators';
import { concat, of } from 'rxjs';
import { useMemoObservable } from 'react-rx';
import { useDocumentPreviewStore } from '../../../../datastores';
import { getPublishedId } from '../../../../util';
import { usePaneRouter } from '../../../components';
const Root = styled(Card)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  position: relative;\n  z-index: 50;\n"])));
const TextOneLine = styled(Text)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n  & > * {\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n  }\n"])));
export const ReferenceChangedBanner = /*#__PURE__*/memo(() => {
  var _routerPanesState$gro, _parentSibling$params, _referenceInfo$result2, _referenceInfo$result3, _referenceInfo$result4, _referenceInfo$result5;

  const documentPreviewStore = useDocumentPreviewStore();
  const {
    params,
    groupIndex,
    routerPanesState,
    replaceCurrent,
    BackLink
  } = usePaneRouter();
  const routerReferenceId = (_routerPanesState$gro = routerPanesState[groupIndex]) === null || _routerPanesState$gro === void 0 ? void 0 : _routerPanesState$gro[0].id;
  const parentGroup = routerPanesState[groupIndex - 1];
  const parentSibling = parentGroup === null || parentGroup === void 0 ? void 0 : parentGroup[0];
  const parentId = parentSibling === null || parentSibling === void 0 ? void 0 : parentSibling.id;
  const hasHistoryOpen = Boolean(parentSibling === null || parentSibling === void 0 ? void 0 : (_parentSibling$params = parentSibling.params) === null || _parentSibling$params === void 0 ? void 0 : _parentSibling$params.rev);
  const parentRefPath = useMemo(() => {
    return (params === null || params === void 0 ? void 0 : params.parentRefPath) && pathFromString(params.parentRefPath) || null;
  }, [params === null || params === void 0 ? void 0 : params.parentRefPath]);
  /**
   * Loads information regarding the reference field of the parent pane. This
   * is only applicable to child references (aka references-in-place).
   *
   * It utilizes the pane ID of the parent pane (which is a document ID) along
   * with the `parentRefPath` router param on the current pane to find the
   * current value of the reference field on the parent document.
   *
   * This is used to compare with the current pane's document ID. If the IDs
   * don't match then this banner should reveal itself
   */

  const referenceInfo = useMemoObservable(() => {
    const parentRefPathSegment = parentRefPath === null || parentRefPath === void 0 ? void 0 : parentRefPath[0]; // short-circuit: this document pane is not a child reference pane

    if (!parentId || !parentRefPathSegment || !parentRefPath) {
      return of({
        loading: false
      });
    }

    const publishedId = getPublishedId(parentId);
    const path = pathFromString(parentRefPathSegment); // note: observePaths doesn't support keyed path segments, so we need to select the nearest parent

    const keyedSegmentIndex = path.findIndex(p => typeof p == 'object' && '_key' in p);
    return concat( // emit a loading state instantly
    of({
      loading: true
    }), // then emit the values from watching the published ID's path
    documentPreviewStore.unstable_observePathsDocumentPair({
      _type: 'reference',
      _ref: publishedId
    }, keyedSegmentIndex === -1 ? path : path.slice(0, keyedSegmentIndex)).pipe( // this debounce time is needed to prevent flashing banners due to
    // the router state updating faster than the content-lake state. we
    // debounce to wait for more emissions because the value pulled
    // initially could be stale.
    debounceTime(750), map(_ref => {
      var _pathGet;

      let {
        draft,
        published
      } = _ref;
      return {
        loading: false,
        result: {
          availability: {
            draft: draft.availability,
            published: published.availability
          },
          refValue: (_pathGet = pathGet(draft.snapshot || published.snapshot, parentRefPath)) === null || _pathGet === void 0 ? void 0 : _pathGet._ref
        }
      };
    })));
  }, [parentId, parentRefPath], {
    loading: true
  });
  const handleReloadReference = useCallback(() => {
    var _referenceInfo$result;

    if (referenceInfo.loading) return;

    if ((_referenceInfo$result = referenceInfo.result) !== null && _referenceInfo$result !== void 0 && _referenceInfo$result.refValue) {
      replaceCurrent({
        id: referenceInfo.result.refValue,
        params: params
      });
    }
  }, [referenceInfo.loading, referenceInfo.result, replaceCurrent, params]);
  const shouldHide = // if `parentId` or `parentRefPath` is not present then this banner is n/a
  !parentId || !parentRefPath || // if viewing this pane via history, then hide
  hasHistoryOpen || // if loading, hide
  referenceInfo.loading || // if the parent document is not available (e.g. due to permission denied or
  // not found) we don't want to display a warning here, but instead rely on the
  // parent view to display the appropriate message
  !((_referenceInfo$result2 = referenceInfo.result) !== null && _referenceInfo$result2 !== void 0 && _referenceInfo$result2.availability.draft.available) && !((_referenceInfo$result3 = referenceInfo.result) !== null && _referenceInfo$result3 !== void 0 && _referenceInfo$result3.availability.published.available) || // if the references are the same, then hide the reference changed banner
  ((_referenceInfo$result4 = referenceInfo.result) === null || _referenceInfo$result4 === void 0 ? void 0 : _referenceInfo$result4.refValue) === routerReferenceId;
  if (shouldHide) return null;
  return /*#__PURE__*/React.createElement(Root, {
    shadow: 1,
    tone: "caution",
    "data-testid": "reference-changed-banner"
  }, /*#__PURE__*/React.createElement(Container, {
    paddingX: 4,
    paddingY: 2,
    sizing: "border",
    width: 1
  }, /*#__PURE__*/React.createElement(Flex, {
    align: "center"
  }, /*#__PURE__*/React.createElement(Text, {
    size: 1
  }, /*#__PURE__*/React.createElement(WarningOutlineIcon, null)), (_referenceInfo$result5 = referenceInfo.result) !== null && _referenceInfo$result5 !== void 0 && _referenceInfo$result5.refValue ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Box, {
    flex: 1,
    marginLeft: 3
  }, /*#__PURE__*/React.createElement(TextOneLine, {
    title: "This reference has changed since you opened it.",
    size: 1
  }, "This reference has changed since you opened it.")), /*#__PURE__*/React.createElement(Box, {
    marginLeft: 3
  }, /*#__PURE__*/React.createElement(Button, {
    onClick: handleReloadReference,
    icon: SyncIcon,
    fontSize: 1,
    mode: "ghost",
    padding: 2,
    space: 2,
    text: "Reload reference"
  }))) : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Box, {
    flex: 1,
    marginLeft: 3
  }, /*#__PURE__*/React.createElement(TextOneLine, {
    title: "This reference has been removed since you opened it.",
    size: 1
  }, "This reference has been removed since you opened it.")), /*#__PURE__*/React.createElement(Box, {
    marginLeft: 3
  }, /*#__PURE__*/React.createElement(Button, {
    as: BackLink,
    icon: CloseIcon,
    fontSize: 1,
    mode: "ghost",
    padding: 2,
    space: 2,
    text: "Close reference"
  }))))));
});
ReferenceChangedBanner.displayName = 'ReferenceChangedBanner';