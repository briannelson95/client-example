import { useEffect, useState, useCallback, useMemo, useRef } from 'react';
import { of } from 'rxjs';
import { filter as filterEvents } from 'rxjs/operators';
import { useClient } from '../../../hooks';
import { removePublishedWithDrafts, toOrderClause } from './helpers';
import { DEFAULT_ORDERING, FULL_LIST_LIMIT, PARTIAL_PAGE_LIMIT } from './constants';
import { getQueryResults } from './getQueryResults';

/**
 * @internal
 */
export function useDocumentList(opts) {
  var _result$result;

  const {
    apiVersion,
    defaultOrdering,
    filter,
    params,
    sortOrder
  } = opts;
  const client = useClient();
  const [fullList, setFullList] = useState(false);
  const fullListRef = useRef(fullList);
  const [result, setResult] = useState(null);
  const error = (result === null || result === void 0 ? void 0 : result.error) || null;
  const isLoading = (result === null || result === void 0 ? void 0 : result.loading) || result === null;
  const onRetry = result === null || result === void 0 ? void 0 : result.onRetry;
  const documents = result === null || result === void 0 ? void 0 : (_result$result = result.result) === null || _result$result === void 0 ? void 0 : _result$result.documents;
  const items = useMemo(() => documents ? removePublishedWithDrafts(documents) : null, [documents]);
  const query = useMemo(() => {
    const extendedProjection = sortOrder === null || sortOrder === void 0 ? void 0 : sortOrder.extendedProjection;
    const projectionFields = ['_id', '_type'];
    const finalProjection = projectionFields.join(',');
    const sortBy = defaultOrdering || (sortOrder === null || sortOrder === void 0 ? void 0 : sortOrder.by) || [];
    const limit = fullList ? FULL_LIST_LIMIT : PARTIAL_PAGE_LIMIT;
    const sort = sortBy.length > 0 ? sortBy : DEFAULT_ORDERING.by;
    const order = toOrderClause(sort);

    if (extendedProjection) {
      const firstProjection = projectionFields.concat(extendedProjection).join(',');
      return ["*[".concat(filter, "] {").concat(firstProjection, "}"), "order(".concat(order, ") [0...").concat(limit, "]"), "{".concat(finalProjection, "}")].join('|');
    }

    return "*[".concat(filter, "]|order(").concat(order, ")[0...").concat(limit, "]{").concat(finalProjection, "}");
  }, [defaultOrdering, filter, fullList, sortOrder]);
  const handleListChange = useCallback(_ref => {
    let {
      toIndex
    } = _ref;

    if (isLoading || fullListRef.current) {
      return;
    }

    if (toIndex >= PARTIAL_PAGE_LIMIT / 2) {
      setFullList(true); // Prevent change handler from firing again before setState kicks in

      fullListRef.current = true;
    }
  }, [isLoading]); // Set up the document list listener

  useEffect(() => {
    // @todo: explain what this does
    const filterFn = fullList ? queryResult => Boolean(queryResult.result) : () => true; // Set loading state

    setResult(r => r ? { ...r,
      loading: true
    } : null);
    const queryResults$ = getQueryResults(of({
      client,
      query,
      params
    }), {
      apiVersion,
      tag: 'desk.document-list'
    }).pipe(filterEvents(filterFn));
    const sub = queryResults$.subscribe(setResult);
    return () => sub.unsubscribe();
  }, [apiVersion, client, fullList, query, params]); // If `filter` or `params` changed, set up a new query from scratch.
  // If `sortOrder` changed, set up a new query from scratch as well.

  useEffect(() => {
    setResult(null);
    setFullList(false);
    fullListRef.current = false;
  }, [filter, params, sortOrder, apiVersion]);
  return {
    error,
    fullList,
    handleListChange,
    isLoading,
    items,
    onRetry
  };
}