import _startCase from "lodash/startCase";
import { SplitHorizontalIcon, StackCompactIcon } from '@sanity/icons';
import { MenuItemBuilder, getOrderingMenuItemsForSchemaType } from './MenuItem';
import { DEFAULT_SELECTED_ORDERING_OPTION } from './Sort';
import { ListItemBuilder } from './ListItem';
import { DocumentTypeListBuilder } from './DocumentTypeList';
import { defaultIntentChecker } from './Intent';

function shouldShowIcon(schemaType) {
  const preview = schemaType.preview;
  return Boolean(preview && (preview.prepare || preview.select && preview.select.media));
}

const BUNDLED_DOC_TYPES = ['sanity.imageAsset', 'sanity.fileAsset'];

function isBundledDocType(typeName) {
  return BUNDLED_DOC_TYPES.includes(typeName);
}

function isDocumentType(schemaType) {
  var _schemaType$type;

  return ((_schemaType$type = schemaType.type) === null || _schemaType$type === void 0 ? void 0 : _schemaType$type.name) === 'document';
}

function isList(collection) {
  return collection.type === 'list';
}

export function getDocumentTypes(_ref) {
  let {
    schema
  } = _ref;
  return schema.getTypeNames().filter(n => {
    const schemaType = schema.get(n);
    return schemaType && isDocumentType(schemaType);
  }).filter(n => !isBundledDocType(n));
}
export function getDocumentTypeListItems(context) {
  const types = getDocumentTypes(context);
  return types.map(typeName => getDocumentTypeListItem(context, typeName));
}
export function getDocumentTypeListItem(context, typeName) {
  const {
    schema
  } = context;
  const type = schema.get(typeName);

  if (!type) {
    throw new Error("Schema type with name \"".concat(typeName, "\" not found"));
  }

  const title = type.title || _startCase(typeName);

  return new ListItemBuilder(context).id(typeName).title(title).schemaType(typeName).child((id, childContext) => {
    const parent = childContext.parent;
    const parentItem = isList(parent) ? parent.items.find(item => item.id === id) : null;
    let list = getDocumentTypeList(context, typeName);

    if (parentItem && parentItem.title) {
      list = list.title(parentItem.title);
    }

    return list;
  });
}
export function getDocumentTypeList(context, typeNameOrSpec) {
  const {
    schema,
    resolveDocumentNode
  } = context;
  const schemaType = typeof typeNameOrSpec === 'string' ? typeNameOrSpec : typeNameOrSpec.schemaType;
  const typeName = typeof schemaType === 'string' ? schemaType : schemaType.name;
  const spec = typeof typeNameOrSpec === 'string' ? {
    schemaType
  } : typeNameOrSpec;
  const type = schema.get(typeName);

  if (!type) {
    throw new Error("Schema type with name \"".concat(typeName, "\" not found"));
  }

  const title = type.title || _startCase(typeName);

  const showIcons = shouldShowIcon(type);
  return new DocumentTypeListBuilder(context).id(spec.id || typeName).title(spec.title || title).filter('_type == $type').params({
    type: typeName
  }).schemaType(typeName).showIcons(showIcons).defaultOrdering(DEFAULT_SELECTED_ORDERING_OPTION.by).menuItemGroups(spec.menuItemGroups || [{
    id: 'sorting',
    title: 'Sort'
  }, {
    id: 'layout',
    title: 'Layout'
  }, {
    id: 'actions',
    title: 'Actions'
  }]).child(spec.child || (documentId => resolveDocumentNode({
    schemaType: typeName,
    documentId
  }))).canHandleIntent(spec.canHandleIntent || defaultIntentChecker).menuItems(spec.menuItems || [// Create new (from action button) will be added in serialization step of GenericList
  // Sort by <Y>
  ...getOrderingMenuItemsForSchemaType(context, type), // Display as <Z>
  new MenuItemBuilder(context).group('layout').title('Compact view').icon(StackCompactIcon).action('setLayout').params({
    layout: 'default'
  }), new MenuItemBuilder(context).group('layout').title('Detailed view').icon(SplitHorizontalIcon).action('setLayout').params({
    layout: 'detail'
  }) // Create new (from menu) will be added in serialization step of GenericList
  ]);
}