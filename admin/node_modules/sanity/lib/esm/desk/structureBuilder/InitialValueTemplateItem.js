import _pickBy from "lodash/pickBy";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { ComposeIcon } from '@sanity/icons';
import { HELP_URL, SerializeError } from './SerializeError';
import { MenuItemBuilder } from './MenuItem';
export class InitialValueTemplateItemBuilder {
  constructor(_context, spec) {
    this._context = _context;

    _defineProperty(this, "spec", void 0);

    this.spec = spec ? spec : {};
  }

  id(id) {
    return this.clone({
      id
    });
  }

  getId() {
    return this.spec.id;
  }

  title(title) {
    return this.clone({
      title
    });
  }

  getTitle() {
    return this.spec.title;
  }

  description(description) {
    return this.clone({
      description
    });
  }

  getDescription() {
    return this.spec.description;
  }

  templateId(templateId) {
    // Let's try to be a bit helpful and assign an ID from template ID if none is specified
    const paneId = this.spec.id || templateId;
    return this.clone({
      id: paneId,
      templateId
    });
  }

  getTemplateId() {
    return this.spec.templateId;
  }

  parameters(parameters) {
    return this.clone({
      parameters
    });
  }

  getParameters() {
    return this.spec.parameters;
  }

  serialize() {
    let {
      path = [],
      index,
      hint
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const {
      spec,
      _context
    } = this;
    const {
      templates
    } = _context;

    if (typeof spec.id !== 'string' || !spec.id) {
      throw new SerializeError('`id` is required for initial value template item nodes', path, index, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }

    if (!spec.templateId) {
      throw new SerializeError('template id (`templateId`) is required for initial value template item nodes', path, spec.id, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }

    const template = templates.find(t => t.id === spec.templateId);

    if (!template) {
      throw new SerializeError('template id (`templateId`) is required for initial value template item nodes', path, spec.id, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }

    return {
      id: spec.id,
      templateId: spec.id,
      schemaType: template.schemaType,
      type: 'initialValueTemplateItem',
      description: spec.description || template.description,
      title: spec.title || template.title,
      subtitle: spec.subtitle,
      icon: spec.icon || template.icon,
      initialDocumentId: spec.initialDocumentId,
      parameters: spec.parameters
    };
  }

  clone() {
    let withSpec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const builder = new InitialValueTemplateItemBuilder(this._context);
    builder.spec = { ...this.spec,
      ...withSpec
    };
    return builder;
  }

}
export function defaultInitialValueTemplateItems(context) {
  const {
    schema,
    getStructureBuilder,
    templates
  } = context; // Sort templates by their schema type, in order or definition

  const typeNames = schema.getTypeNames();
  const ordered = templates // Don't list templates that require parameters
  // TODO: this should use the new-document template items instead maybe?
  .filter(tpl => {
    var _tpl$parameters;

    return !((_tpl$parameters = tpl.parameters) !== null && _tpl$parameters !== void 0 && _tpl$parameters.length);
  }).sort((a, b) => typeNames.indexOf(a.schemaType) - typeNames.indexOf(b.schemaType)); // Create actual template items out of the templates

  return ordered.map(tpl => getStructureBuilder().initialValueTemplateItem(tpl.id));
}
export function maybeSerializeInitialValueTemplateItem(item, index, path) {
  return item instanceof InitialValueTemplateItemBuilder ? item.serialize({
    path,
    index
  }) : item;
}
export function menuItemsFromInitialValueTemplateItems(context, templateItems) {
  const {
    schema,
    templates
  } = context;
  return templateItems.map(item => {
    const template = templates.find(t => t.id === item.templateId);
    const title = item.title || (template === null || template === void 0 ? void 0 : template.title) || 'Create new';

    const params = _pickBy({
      type: template && template.schemaType,
      template: item.templateId
    }, Boolean);

    const intentParams = item.parameters ? [params, item.parameters] : params;
    const schemaType = template && schema.get(template.schemaType);
    return new MenuItemBuilder(context).title(title).icon(template && template.icon || (schemaType === null || schemaType === void 0 ? void 0 : schemaType.icon) || ComposeIcon).intent({
      type: 'create',
      params: intentParams
    }).serialize();
  });
}