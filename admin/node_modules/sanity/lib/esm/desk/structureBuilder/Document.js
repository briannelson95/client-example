import _camelCase from "lodash/camelCase";
import _uniq from "lodash/uniq";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { SerializeError, HELP_URL } from './SerializeError';
import { validateId } from './util/validateId';
import { maybeSerializeView } from './views/View';
import { form } from './views';

const createDocumentChildResolver = _ref => {
  let {
    resolveDocumentNode
  } = _ref;
  return (itemId, _ref2) => {
    let {
      params,
      path
    } = _ref2;
    const {
      type
    } = params;
    const parentPath = path.slice(0, path.length - 1);
    const currentSegment = path[path.length - 1];

    if (!type) {
      throw new SerializeError("Invalid link. Your link must contain a `type`.", parentPath, currentSegment);
    }

    return resolveDocumentNode({
      documentId: itemId,
      schemaType: type
    });
  };
};

export class DocumentBuilder {
  constructor(_context, spec) {
    this._context = _context;

    _defineProperty(this, "spec", void 0);

    this.spec = spec ? spec : {};
  }

  id(id) {
    return this.clone({
      id
    });
  }

  getId() {
    return this.spec.id;
  }

  title(title) {
    return this.clone({
      title,
      id: this.spec.id || _camelCase(title)
    });
  }

  getTitle() {
    return this.spec.title;
  }

  child(child) {
    return this.clone({
      child
    });
  }

  getChild() {
    return this.spec.child;
  }

  documentId(documentId) {
    // Let's try to be a bit helpful and assign an ID from document ID if none is specified
    const paneId = this.spec.id || documentId;
    return this.clone({
      id: paneId,
      options: { ...(this.spec.options || {}),
        id: documentId
      }
    });
  }

  getDocumentId() {
    var _this$spec$options;

    return (_this$spec$options = this.spec.options) === null || _this$spec$options === void 0 ? void 0 : _this$spec$options.id;
  }

  schemaType(documentType) {
    return this.clone({
      options: { ...(this.spec.options || {}),
        type: typeof documentType === 'string' ? documentType : documentType.name
      }
    });
  }

  getSchemaType() {
    var _this$spec$options2;

    return (_this$spec$options2 = this.spec.options) === null || _this$spec$options2 === void 0 ? void 0 : _this$spec$options2.type;
  }

  initialValueTemplate(templateId, parameters) {
    return this.clone({
      options: { ...(this.spec.options || {}),
        template: templateId,
        templateParameters: parameters
      }
    });
  }

  getInitialValueTemplate() {
    var _this$spec$options3;

    return (_this$spec$options3 = this.spec.options) === null || _this$spec$options3 === void 0 ? void 0 : _this$spec$options3.template;
  }

  getInitialValueTemplateParameters() {
    var _this$spec$options4;

    return (_this$spec$options4 = this.spec.options) === null || _this$spec$options4 === void 0 ? void 0 : _this$spec$options4.templateParameters;
  }

  views(views) {
    return this.clone({
      views
    });
  }

  getViews() {
    return this.spec.views || [];
  }

  serialize() {
    let {
      path = [],
      index,
      hint
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };
    const urlId = path[index || path.length - 1]; // Try to grab document ID / editor ID from URL if not defined

    const id = this.spec.id || urlId && "".concat(urlId) || '';
    const options = {
      id,
      type: undefined,
      template: undefined,
      templateParameters: undefined,
      ...this.spec.options
    };

    if (typeof id !== 'string' || !id) {
      throw new SerializeError('`id` is required for document nodes', path, index, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }

    if (!options || !options.id) {
      throw new SerializeError('document id (`id`) is required for document nodes', path, id, hint).withHelpUrl(HELP_URL.DOCUMENT_ID_REQUIRED);
    }

    if (!options || !options.type) {
      throw new SerializeError('document type (`schemaType`) is required for document nodes', path, id, hint);
    }

    const views = (this.spec.views && this.spec.views.length > 0 ? this.spec.views : [form()]).map((item, i) => maybeSerializeView(item, i, path));
    const viewIds = views.map(view => view.id);

    const dupes = _uniq(viewIds.filter((viewId, i) => viewIds.includes(viewId, i + 1)));

    if (dupes.length > 0) {
      throw new SerializeError("document node has views with duplicate IDs: ".concat(dupes.join(',  ')), path, id, hint);
    }

    return { ...this.spec,
      child: this.spec.child || createDocumentChildResolver(this._context),
      id: validateId(id, path, index),
      type: 'document',
      options: getDocumentOptions(options),
      views
    };
  }

  clone() {
    let withSpec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const builder = new DocumentBuilder(this._context);
    const options = { ...(this.spec.options || {}),
      ...(withSpec.options || {})
    };
    builder.spec = { ...this.spec,
      ...withSpec,
      options
    };
    return builder;
  }

}

function getDocumentOptions(spec) {
  const opts = {
    id: spec.id || '',
    type: spec.type || '*'
  };

  if (spec.template) {
    opts.template = spec.template;
  }

  if (spec.templateParameters) {
    opts.templateParameters = spec.templateParameters;
  }

  return opts;
}

export function documentFromEditor(context, spec) {
  let doc = spec !== null && spec !== void 0 && spec.type ? // Use user-defined document fragment as base if possible
  context.resolveDocumentNode({
    schemaType: spec.type
  }) : // Fall back to plain old document builder
  new DocumentBuilder(context);
  if (!spec) return doc;
  const {
    id,
    type,
    template,
    templateParameters
  } = spec.options;
  doc = doc.id(spec.id).documentId(id);

  if (type) {
    doc = doc.schemaType(type);
  }

  if (template) {
    doc = doc.initialValueTemplate(template, templateParameters);
  }

  if (spec.child) {
    doc = doc.child(spec.child);
  }

  return doc;
}
export function documentFromEditorWithInitialValue(_ref3, templateId, parameters) {
  let {
    resolveDocumentNode,
    templates
  } = _ref3;
  const template = templates.find(t => t.id === templateId);

  if (!template) {
    throw new Error("Template with ID \"".concat(templateId, "\" not defined"));
  }

  return resolveDocumentNode({
    schemaType: template.schemaType
  }).initialValueTemplate(templateId, parameters);
}