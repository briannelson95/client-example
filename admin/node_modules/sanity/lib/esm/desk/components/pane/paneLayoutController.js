import { PANE_COLLAPSED_WIDTH, PANE_DEFAULT_MIN_WIDTH } from './constants';
import { _calcPaneResize, _sortElements } from './helpers';
export function createPaneLayoutController() {
  const observers = [];
  const elements = [];
  const optionsMap = new WeakMap();
  const userCollapsedElementSet = new Set();
  const cache = {}; // Mutable internal state

  let rootElement = null;
  let rootWidth = 0;
  let expandedElement = null;
  let resizeDataMap = new Map();
  let resizing = false;

  function collapse(element) {
    userCollapsedElementSet.add(element);

    if (expandedElement === element) {
      expandedElement = null;
    }

    _notifyObservers();
  }

  function expand(element) {
    userCollapsedElementSet.delete(element);
    expandedElement = element;

    _notifyObservers();
  }

  function mount(element, options) {
    optionsMap.set(element, { ...options,
      original: options
    });
    elements.push(element);

    if (rootElement) {
      _sortElements(rootElement, elements);
    }

    expand(element);
    return () => {
      const idx = elements.indexOf(element);

      if (idx > -1) {
        elements.splice(idx, 1);
      }

      optionsMap.delete(element);

      _notifyObservers();
    };
  } // eslint-disable-next-line complexity


  function resize(type, leftElement, deltaX) {
    const leftIndex = elements.indexOf(leftElement);
    const leftOptions = optionsMap.get(leftElement);
    if (!leftOptions) return;
    const rightElement = elements[leftIndex + 1];
    const rightOptions = optionsMap.get(rightElement);
    if (!rightOptions) return;

    if (type === 'start') {
      resizing = true;
      cache.left = {
        element: leftElement,
        flex: leftOptions.flex || 1,
        width: leftElement.offsetWidth
      };
      cache.right = {
        element: rightElement,
        flex: rightOptions.flex || 1,
        width: rightElement.offsetWidth
      };

      _notifyObservers();
    }

    if (type === 'move' && cache.left && cache.right) {
      resizeDataMap = new Map();

      const {
        leftW,
        rightW,
        leftFlex,
        rightFlex
      } = _calcPaneResize(cache, leftOptions, rightOptions, deltaX); // update resize cache


      resizeDataMap.set(leftElement, {
        flex: leftFlex,
        width: leftW
      });
      resizeDataMap.set(rightElement, {
        flex: rightFlex,
        width: rightW
      });

      _notifyObservers();
    }

    if (type === 'end') {
      var _leftOptions$maxWidth, _leftResizeData$flex, _leftOptions$maxWidth2, _rightResizeData$flex;

      resizing = false;
      const leftResizeData = resizeDataMap.get(leftElement);
      const rightResizeData = resizeDataMap.get(rightElement); // Update left options

      optionsMap.set(leftElement, { ...leftOptions,
        currentMinWidth: 0,
        currentMaxWidth: (_leftOptions$maxWidth = leftOptions.maxWidth) !== null && _leftOptions$maxWidth !== void 0 ? _leftOptions$maxWidth : Infinity,
        flex: (_leftResizeData$flex = leftResizeData === null || leftResizeData === void 0 ? void 0 : leftResizeData.flex) !== null && _leftResizeData$flex !== void 0 ? _leftResizeData$flex : leftOptions.flex
      }); // Update right options

      optionsMap.set(rightElement, { ...rightOptions,
        currentMinWidth: 0,
        currentMaxWidth: (_leftOptions$maxWidth2 = leftOptions.maxWidth) !== null && _leftOptions$maxWidth2 !== void 0 ? _leftOptions$maxWidth2 : Infinity,
        flex: (_rightResizeData$flex = rightResizeData === null || rightResizeData === void 0 ? void 0 : rightResizeData.flex) !== null && _rightResizeData$flex !== void 0 ? _rightResizeData$flex : rightOptions.flex
      }); // Reset resize data map

      resizeDataMap = new Map(); // Reset cache

      delete cache.left;
      delete cache.right;

      _notifyObservers();
    }
  }

  function setRootElement(nextRootElement) {
    rootElement = nextRootElement;
  }

  function setRootWidth(nextRootWidth) {
    rootWidth = nextRootWidth;

    _notifyObservers();
  }

  function subscribe(observer) {
    observers.push(observer);
    return () => {
      const idx = observers.push(observer);

      if (idx > -1) {
        observers.splice(idx, 1);
      }
    };
  }

  return {
    collapse,
    expand,
    mount,
    resize,
    setRootElement,
    setRootWidth,
    subscribe
  }; // eslint-disable-next-line complexity

  function _notifyObservers() {
    if (!rootWidth) return; // Create a reversed array of pane elements, so we can loop over them backwards.
    // Place the expanded element first (so it has the least chance of being collapsed).

    const _elements = [];

    for (const element of elements) {
      if (element !== expandedElement) {
        _elements.unshift(element);
      }
    }

    if (expandedElement) {
      _elements.unshift(expandedElement);
    }

    const dataMap = new WeakMap();
    const len = _elements.length;
    const lastElement = _elements[0];
    const collapsedWidth = (len - 1) * PANE_COLLAPSED_WIDTH;
    let remaingWidth = rootWidth - collapsedWidth;

    for (const element of _elements) {
      var _resizeData$width, _resizeData$width2, _ref, _resizeData$flex;

      const options = optionsMap.get(element);

      if (!options) {
        continue;
      }

      const minWidth = options.currentMinWidth || options.minWidth || PANE_DEFAULT_MIN_WIDTH;
      const isLast = element === lastElement; // A pane is collapsed if:
      // - it’s explictly collapsed by the user

      const userCollapsed = userCollapsedElementSet.has(element); // - it’s minimum width is larger than the remaining width

      const sizeCollapsed = minWidth > remaingWidth; // - if the element is not the last (expanded pane)

      const collapsed = isLast ? false : userCollapsed || sizeCollapsed;
      const resizeData = resizeDataMap.get(element); // Collect pane data

      dataMap.set(element, {
        element: element,
        collapsed: collapsed,
        currentMinWidth: (_resizeData$width = resizeData === null || resizeData === void 0 ? void 0 : resizeData.width) !== null && _resizeData$width !== void 0 ? _resizeData$width : options.currentMinWidth,
        currentMaxWidth: (_resizeData$width2 = resizeData === null || resizeData === void 0 ? void 0 : resizeData.width) !== null && _resizeData$width2 !== void 0 ? _resizeData$width2 : options.currentMaxWidth,
        flex: (_ref = (_resizeData$flex = resizeData === null || resizeData === void 0 ? void 0 : resizeData.flex) !== null && _resizeData$flex !== void 0 ? _resizeData$flex : options.flex) !== null && _ref !== void 0 ? _ref : 1
      }); // Update remaining width

      if (collapsed) {
        remaingWidth -= PANE_COLLAPSED_WIDTH;
      } else {
        remaingWidth -= minWidth - PANE_COLLAPSED_WIDTH;
      }
    }

    const panes = [];

    for (const element of elements) {
      const data = dataMap.get(element);
      if (data) panes.push(data);
    }

    for (const observer of observers) {
      observer({
        expandedElement: expandedElement || elements[elements.length - 1] || null,
        panes,
        resizing
      });
    }
  }
}