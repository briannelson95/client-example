import _uniqBy from "lodash/uniqBy";
import _partition from "lodash/partition";
import { UnknownIcon } from '@sanity/icons';
import { Box, Button, Inline, Text, Tooltip } from '@sanity/ui';
import React, { memo, useCallback, useMemo } from 'react';
import { useTemplates } from '../../../hooks';
import { IntentButton } from '../IntentButton';
import { PaneContextMenuButton } from '../pane/PaneContextMenuButton';
import { PaneHeaderCreateButton } from './PaneHeaderCreateButton'; // to preserve memory references

const emptyArray = [];
const emptyObject = {};

function isNonNullable(value) {
  return value !== null && value !== undefined;
}
/**
 * hashes an object to a string where the order of the keys don't matter
 */


const hashObject = value => {
  const sortObject = v => {
    if (typeof v !== 'object' || !v) return v;
    if (Array.isArray(v)) return v.map(sortObject);
    return Object.entries(v).sort((_ref, _ref2) => {
      let [keyA] = _ref;
      let [keyB] = _ref2;
      return keyA.localeCompare(keyB, 'en');
    });
  };

  const normalize = v => JSON.parse(JSON.stringify(v));

  return JSON.stringify(sortObject(normalize(value)));
};

export const PaneHeaderActions = /*#__PURE__*/memo(_ref3 => {
  let {
    initialValueTemplateItems: initialValueTemplateItemsFromStructure = emptyArray,
    menuItems = emptyArray,
    menuItemGroups = emptyArray,
    actionHandlers = emptyObject
  } = _ref3;
  const templates = useTemplates();
  const handleAction = useCallback(item => {
    if (typeof item.action === 'string' && !(item.action in actionHandlers)) {
      console.warn('No handler for action:', item.action);
      return false;
    }

    const handler = // eslint-disable-next-line no-nested-ternary
    typeof item.action === 'function' ? item.action : typeof item.action === 'string' ? actionHandlers[item.action] : null;

    if (handler) {
      handler(item.params);
      return true;
    }

    return false;
  }, [actionHandlers]);
  const [actionMenuItems, contextMenuItems] = useMemo(() => {
    const nonCreateMenuItem = menuItems // remove items with `create` intents because those will get combined
    // into one action button later
    .filter(item => {
      var _item$intent;

      return ((_item$intent = item.intent) === null || _item$intent === void 0 ? void 0 : _item$intent.type) !== 'create';
    });
    return _partition(nonCreateMenuItem, item => item.showAsAction);
  }, [menuItems]);
  const initialValueTemplateItemFromMenuItems = useMemo(() => {
    return menuItems.map((item, menuItemIndex) => {
      var _item$intent2;

      if (((_item$intent2 = item.intent) === null || _item$intent2 === void 0 ? void 0 : _item$intent2.type) !== 'create') return null;
      const {
        params
      } = item.intent;
      if (!params) return null;
      const intentParams = Array.isArray(params) ? params[0] : params;
      const templateParams = Array.isArray(params) ? params[1] : undefined; // fallback to the schema type name as the template ID.
      // by default, the initial template values are populated from every
      // document type in the schema

      const templateId = intentParams.template || intentParams.type;
      if (!templateId) return null; // eslint-disable-next-line max-nested-callbacks

      const template = templates.find(t => t.id === templateId); // the template doesn't exist then the action might be disabled

      if (!template) return null;
      const initialDocumentId = intentParams.id;
      return {
        item,
        template,
        templateParams,
        menuItemIndex,
        initialDocumentId
      };
    }).filter(isNonNullable).map(_ref4 => {
      let {
        initialDocumentId,
        item,
        template,
        menuItemIndex,
        templateParams
      } = _ref4;
      const initialValueTemplateItem = {
        id: "menuItem".concat(menuItemIndex),
        initialDocumentId,
        templateId: template.id,
        type: 'initialValueTemplateItem',
        title: item.title || template.title,
        icon: item.icon,
        description: template.description,
        parameters: templateParams,
        schemaType: template.schemaType
      };
      return initialValueTemplateItem;
    });
  }, [menuItems, templates]);
  const combinedInitialValueTemplates = useMemo(() => {
    // this de-dupes create actions
    return _uniqBy([...initialValueTemplateItemFromMenuItems, ...initialValueTemplateItemsFromStructure], item => hashObject([item.initialDocumentId, item.templateId, item.parameters]));
  }, [initialValueTemplateItemFromMenuItems, initialValueTemplateItemsFromStructure]);
  return /*#__PURE__*/React.createElement(Inline, {
    space: 1
  }, [Boolean(combinedInitialValueTemplates.length) && /*#__PURE__*/React.createElement(PaneHeaderCreateButton, {
    key: "$CreateMenuButton",
    templateItems: combinedInitialValueTemplates
  }), //
  ...actionMenuItems.map((actionItem, actionIndex) => {
    return /*#__PURE__*/React.createElement(Tooltip, {
      content: /*#__PURE__*/React.createElement(Box, {
        padding: 2
      }, /*#__PURE__*/React.createElement(Text, {
        size: 1
      }, actionItem.title)) // eslint-disable-next-line react/no-array-index-key
      ,
      key: "".concat(actionIndex, "-").concat(actionItem.title),
      placement: "bottom"
    }, actionItem.intent ? /*#__PURE__*/React.createElement(IntentButton, {
      intent: actionItem.intent,
      "aria-label": actionItem.title,
      icon: actionItem.icon || UnknownIcon,
      mode: "bleed"
    }) : /*#__PURE__*/React.createElement(Button, {
      "aria-label": actionItem.title,
      icon: actionItem.icon || UnknownIcon,
      mode: "bleed" // eslint-disable-next-line react/jsx-no-bind
      ,
      onClick: () => handleAction(actionItem)
    }));
  }), //
  Boolean(contextMenuItems.length) && /*#__PURE__*/React.createElement(PaneContextMenuButton, {
    items: contextMenuItems,
    itemGroups: menuItemGroups,
    key: "$ContextMenu",
    onAction: handleAction
  })]);
});
PaneHeaderActions.displayName = 'PaneHeaderActions';