import { useEffect, useMemo, useState } from 'react';
import { ReplaySubject } from 'rxjs';
import { map } from 'rxjs/operators';
import { useRouter } from '../../router';
import { LOADING_PANE } from '../constants';
import { useDeskTool } from '../useDeskTool';
import { createResolvedPaneNodeStream } from './createResolvedPaneNodeStream';

function useRouterPanesStream() {
  const routerStateSubject = useMemo(() => new ReplaySubject(1), []);
  const routerPanes$ = useMemo(() => routerStateSubject.asObservable().pipe(map(_routerState => (_routerState === null || _routerState === void 0 ? void 0 : _routerState.panes) || [])), [routerStateSubject]);
  const {
    state: routerState
  } = useRouter();
  useEffect(() => {
    routerStateSubject.next(routerState);
  }, [routerState, routerStateSubject]);
  return routerPanes$;
}

export function useResolvedPanes() {
  // used to propagate errors from async effect. throwing inside of the render
  // will bubble the error to react where it can be picked up by standard error
  // boundaries
  const [error, setError] = useState();
  if (error) throw error;
  const {
    structureContext,
    rootPaneNode
  } = useDeskTool();
  const [data, setData] = useState({
    paneDataItems: [],
    resolvedPanes: [],
    routerPanes: []
  });
  const routerPanesStream = useRouterPanesStream();
  useEffect(() => {
    const resolvedPanes$ = createResolvedPaneNodeStream({
      rootPaneNode,
      routerPanesStream,
      structureContext
    }).pipe(map(resolvedPanes => {
      const routerPanes = resolvedPanes.reduce((acc, next) => {
        const currentGroup = acc[next.groupIndex] || [];
        currentGroup[next.siblingIndex] = next.routerPaneSibling;
        acc[next.groupIndex] = currentGroup;
        return acc;
      }, []);
      const groupsLen = routerPanes.length;
      const paneDataItems = resolvedPanes.map(pane => {
        var _nextGroup$0$id;

        const {
          groupIndex,
          flatIndex,
          siblingIndex,
          routerPaneSibling,
          path
        } = pane;
        const itemId = routerPaneSibling.id;
        const nextGroup = routerPanes[groupIndex + 1];
        const paneDataItem = {
          active: groupIndex === groupsLen - 2,
          childItemId: (_nextGroup$0$id = nextGroup === null || nextGroup === void 0 ? void 0 : nextGroup[0].id) !== null && _nextGroup$0$id !== void 0 ? _nextGroup$0$id : null,
          index: flatIndex,
          itemId: routerPaneSibling.id,
          groupIndex,
          key: "".concat(pane.type === 'loading' ? 'unknown' : pane.paneNode.id, "-").concat(itemId, "-").concat(siblingIndex),
          pane: pane.type === 'loading' ? LOADING_PANE : pane.paneNode,
          params: routerPaneSibling.params || {},
          path: path.join(';'),
          payload: routerPaneSibling.payload,
          selected: flatIndex === resolvedPanes.length - 1,
          siblingIndex
        };
        return paneDataItem;
      });
      return {
        paneDataItems,
        routerPanes,
        resolvedPanes: paneDataItems.map(pane => pane.pane)
      };
    }));
    const subscription = resolvedPanes$.subscribe({
      next: result => setData(result),
      error: e => setError(e)
    });
    return () => subscription.unsubscribe();
  }, [rootPaneNode, routerPanesStream, structureContext]);
  return data;
}