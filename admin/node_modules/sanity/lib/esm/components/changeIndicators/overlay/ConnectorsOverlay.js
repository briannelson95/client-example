import _sortBy from "lodash/sortBy";
import React, { useCallback, useMemo, useState } from 'react';
import { ScrollMonitor } from '../../scroll';
import { isNonNullable } from '../../../util/isNonNullable';
import { findMostSpecificTarget } from '../helpers/findMostSpecificTarget';
import { isChangeBar } from '../helpers/isChangeBar';
import { scrollIntoView } from '../helpers/scrollIntoView';
import { DEBUG_LAYER_BOUNDS } from '../constants';
import { getOffsetsTo } from '../helpers/getOffsetsTo';
import { useReportedValues } from '../tracker';
import { Connector } from './Connector';
import { DebugLayers } from './DebugLayers';
import { useResizeObserver } from './useResizeObserver';
import { SvgWrapper } from './ConnectorsOverlay.styled';

function getState(allReportedValues, hovered, byId, rootElement) {
  const changeBarsWithHover = [];
  const changeBarsWithFocus = [];

  for (const value of allReportedValues) {
    if (!isChangeBar(value) || !value[1].isChanged) {
      continue;
    }

    const [id, reportedChangeBar] = value;

    if (id === hovered) {
      changeBarsWithHover.push(value);
      continue;
    }

    if (reportedChangeBar.hasHover) {
      changeBarsWithHover.push(value);
      continue;
    }

    if (reportedChangeBar.hasFocus) {
      changeBarsWithFocus.push(value);
      continue;
    }
  }

  const isHoverConnector = changeBarsWithHover.length > 0;
  const changeBars = isHoverConnector ? changeBarsWithHover : changeBarsWithFocus;
  const connectors = changeBars.map(_ref => {
    let [id] = _ref;
    const field = findMostSpecificTarget('field', id, byId);
    const change = findMostSpecificTarget('change', id, byId);
    if (!field || !change) return null;
    return {
      field: {
        id,
        ...field
      },
      change: {
        id,
        ...change
      }
    };
  }).filter(isNonNullable) // .filter(({field, change}) => field && change && field.element && change.element)
  .map(_ref2 => {
    let {
      field,
      change
    } = _ref2;
    return {
      hasHover: field.hasHover || change.hasHover,
      hasFocus: field.hasFocus,
      hasRevertHover: change.hasRevertHover,
      field: { ...field,
        ...getOffsetsTo(field.element, rootElement)
      },
      change: { ...change,
        ...getOffsetsTo(change.element, rootElement)
      }
    };
  });
  return {
    connectors,
    isHoverConnector
  };
}

export function ConnectorsOverlay(props) {
  const {
    rootElement,
    onSetFocus
  } = props;
  const [hovered, setHovered] = React.useState(null);
  const allReportedValues = useReportedValues();
  const byId = useMemo(() => new Map(allReportedValues), [allReportedValues]);
  const [{
    connectors
  }, setState] = useState(() => getState(allReportedValues, hovered, byId, rootElement));
  const visibleConnectors = useMemo(() => _sortBy(connectors, c => 0 - c.field.path.length).slice(0, 1), [connectors]);
  const handleScrollOrResize = useCallback(() => {
    setState(getState(allReportedValues, hovered, byId, rootElement));
  }, [byId, allReportedValues, hovered, rootElement]);
  useResizeObserver(rootElement, handleScrollOrResize);
  return /*#__PURE__*/React.createElement(ScrollMonitor, {
    onScroll: handleScrollOrResize
  }, /*#__PURE__*/React.createElement(SvgWrapper, {
    style: {
      zIndex: visibleConnectors[0] && visibleConnectors[0].field.zIndex
    }
  }, visibleConnectors.map(_ref3 => {
    let {
      field,
      change
    } = _ref3;

    if (!change) {
      return null;
    }

    return /*#__PURE__*/React.createElement(ConnectorGroup, {
      field: field,
      change: change,
      key: field.id,
      onSetFocus: onSetFocus,
      setHovered: setHovered
    });
  })));
}

function ConnectorGroup(props) {
  const {
    change,
    field,
    onSetFocus,
    setHovered
  } = props;
  const onConnectorClick = useCallback(() => {
    scrollIntoView(field);
    scrollIntoView(change);
    onSetFocus(field.path);
  }, [field, change, onSetFocus]);
  const handleMouseEnter = useCallback(() => setHovered(field.id), [field, setHovered]);
  const handleMouseLeave = useCallback(() => setHovered(null), [setHovered]);
  const from = useMemo(() => ({
    rect: {
      left: field.rect.left + 2,
      top: field.rect.top,
      height: field.rect.height,
      width: field.rect.width
    },
    bounds: field.bounds
  }), [field.bounds, field.rect]);
  const to = useMemo(() => ({
    rect: change.rect,
    bounds: change.bounds
  }), [change.bounds, change.rect]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("g", {
    onClick: onConnectorClick,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave
  }, /*#__PURE__*/React.createElement(Connector, {
    from: from,
    to: to
  })), DEBUG_LAYER_BOUNDS && /*#__PURE__*/React.createElement(DebugLayers, {
    field: field,
    change: change
  }));
}