function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React, { useMemo } from 'react';
import { ScrollContainer } from '../../scroll';
import { ConnectorContext } from '../ConnectorContext';
import { ENABLED } from '../constants';
import { Tracker } from '../tracker';
import { ConnectorsOverlay } from './ConnectorsOverlay';
export function EnabledChangeConnectorRoot(_ref) {
  let {
    children,
    className,
    isReviewChangesOpen,
    onOpenReviewChanges,
    onSetFocus,
    ...restProps
  } = _ref;
  const [rootElement, setRootElement] = React.useState();
  const contextValue = useMemo(() => ({
    isReviewChangesOpen,
    onOpenReviewChanges,
    onSetFocus
  }), [isReviewChangesOpen, onOpenReviewChanges, onSetFocus]);
  return /*#__PURE__*/React.createElement(ConnectorContext.Provider, {
    value: contextValue
  }, /*#__PURE__*/React.createElement(Tracker, null, /*#__PURE__*/React.createElement(ScrollContainer, _extends({}, restProps, {
    ref: setRootElement,
    className: className
  }), children, rootElement && /*#__PURE__*/React.createElement(ConnectorsOverlay, {
    rootElement: rootElement,
    onSetFocus: onSetFocus
  }))));
}
export function DisabledChangeConnectorRoot(_ref2) {
  let {
    children,
    className
  } = _ref2;
  return /*#__PURE__*/React.createElement(ScrollContainer, {
    className: className
  }, children);
}
export const ChangeConnectorRoot = ENABLED ? EnabledChangeConnectorRoot : DisabledChangeConnectorRoot;