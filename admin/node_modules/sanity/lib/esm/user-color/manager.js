import { Observable } from 'rxjs';
import { shareReplay } from 'rxjs/operators';
import { hues, COLOR_HUES } from '@sanity/color';
const defaultCurrentUserHue = 'purple'; // Exclude green and red because they can be confused with "add" and "remove"
// Exclude gray because it looks like "color not found"

const USER_COLOR_EXCLUDE_HUES = ['green', 'red', 'gray'];
const defaultHues = COLOR_HUES.filter(hue => !USER_COLOR_EXCLUDE_HUES.includes(hue));
const defaultColors = defaultHues.reduce((colors, hue) => {
  colors[hue] = {
    name: hue,
    background: hues[hue][100].hex,
    border: hues[hue][300].hex,
    text: hues[hue][700].hex,
    tints: hues[hue]
  };
  return colors;
}, {});
const defaultAnonymousColor = {
  name: 'gray',
  background: hues.gray[100].hex,
  border: hues.gray[300].hex,
  text: hues.gray[700].hex,
  tints: hues.gray
};
export function createUserColorManager(options) {
  const userColors = options && options.colors || defaultColors;
  const anonymousColor = (options === null || options === void 0 ? void 0 : options.anonymousColor) || defaultAnonymousColor;
  const currentUserColor = options && options.currentUserColor || defaultCurrentUserHue;

  if (!userColors.hasOwnProperty(currentUserColor)) {
    throw new Error("'colors' must contain 'currentUserColor' (".concat(currentUserColor, ")"));
  }

  const userColorKeys = Object.keys(userColors);
  const subscriptions = new Map();
  const previouslyAssigned = new Map();
  const assignedCounts = userColorKeys.reduce((counts, color) => {
    counts[color] = 0;
    return counts;
  }, {}); // This isn't really needed because we're reusing subscriptions,
  // but is useful for debugging and poses a minimal overhead

  const assigned = new Map();
  let currentUserId;

  if (options !== null && options !== void 0 && options.userStore) {
    options.userStore.me.subscribe(user => setCurrentUser(user ? user.id : null));
  }

  return {
    get,
    listen
  };

  function get(userId) {
    if (!userId) {
      return anonymousColor;
    }

    return userColors[getUserHue(userId)];
  }

  function getUserHue(userId) {
    if (userId === currentUserId) {
      return currentUserColor;
    }

    const assignedHue = assigned.get(userId);

    if (assignedHue) {
      return assignedHue;
    } // Prefer to reuse the color previously assigned, BUT:
    // ONLY if it's unused -or- there are no other unused colors


    const prevHue = previouslyAssigned.get(userId);

    if (prevHue && (assignedCounts[prevHue] === 0 || !hasUnusedColor())) {
      return assignHue(userId, prevHue);
    } // Prefer "static" color based on user ID if unused


    const preferredHue = getPreferredHue(userId);

    if (assignedCounts[preferredHue] === 0) {
      return assignHue(userId, preferredHue);
    } // Fall back to least used color, with a preference on the previous
    // used color if there are ties for least used


    return assignHue(userId, getLeastUsedHue(prevHue));
  }

  function listen(userId) {
    let subscription = subscriptions.get(userId);

    if (subscription) {
      return subscription;
    }

    const hue = getUserHue(userId);
    subscription = getObservableColor(userId, hue);
    subscriptions.set(userId, subscription);
    return subscription;
  }

  function assignHue(userId, hue) {
    assigned.set(userId, hue);
    previouslyAssigned.set(userId, hue);
    assignedCounts[hue]++;
    return hue;
  }

  function unassignHue(userId, hue) {
    assigned.delete(userId);
    assignedCounts[hue]--;
  }

  function getUnusedColor() {
    return userColorKeys.find(colorHue => assignedCounts[colorHue] === 0);
  }

  function hasUnusedColor() {
    return Boolean(getUnusedColor());
  }

  function getLeastUsedHue(tieBreakerPreference) {
    let leastUses = +Infinity;
    let leastUsed = [];
    userColorKeys.forEach(colorHue => {
      const uses = assignedCounts[colorHue];

      if (uses === leastUses) {
        leastUsed.push(colorHue);
      } else if (uses < leastUses) {
        leastUses = uses;
        leastUsed = [colorHue];
      }
    });
    return tieBreakerPreference && leastUsed.includes(tieBreakerPreference) ? tieBreakerPreference : leastUsed[0];
  }

  function getObservableColor(userId, hue) {
    return new Observable(subscriber => {
      const userColor = userColors[hue];
      subscriber.next(userColor);
      return () => {
        subscriptions.delete(userId);
        unassignHue(userId, hue);
      };
    }).pipe(shareReplay({
      refCount: true
    }));
  }

  function setCurrentUser(userId) {
    currentUserId = userId;
    assignedCounts[currentUserColor] += userId ? 1 : -1;
  }

  function getPreferredHue(userId) {
    let hash = 0;

    for (let i = 0; i < userId.length; i++) {
      // eslint-disable-next-line no-bitwise
      hash = (hash << 5) - hash + userId.charCodeAt(i) | 0;
    }

    return userColorKeys[Math.abs(hash) % userColorKeys.length];
  }
}