import { Box, Code, Stack, Button, Dialog } from '@sanity/ui';
import React, { useMemo, useState, useCallback, useEffect } from 'react';
import { useInitialValue } from '../../datastores';
import { useEditState, useValidationStatus, useConnectionState } from '../../hooks';
import { useSource } from '../../studio';
import { useUnique } from '../../util';
import { DeskToolProvider } from '../DeskToolProvider';
import { DocumentPaneProvider } from '../panes';
export default function InitialValueStory() {
    const documentId = 'test';
    const documentType = 'author';
    const pane = useMemo(() => ({
        id: documentId,
        options: {
            id: documentId,
            type: documentType,
        },
        type: 'document',
        title: 'Workshop',
    }), [documentId, documentType]);
    return (React.createElement(DeskToolProvider, null,
        React.createElement(DocumentPaneProvider, { index: 0, itemId: documentId, pane: pane, paneKey: documentId },
            React.createElement(Debug, { documentId: documentId, documentType: documentType }))));
}
function Debug(props) {
    const { documentId, documentType } = props;
    const templateName = undefined; // 'author-developer'
    const templateParams = undefined; // {}
    const initialValue = useInitialValue({
        documentId,
        documentType,
        templateName,
        templateParams,
    });
    const editState = useEditState(documentId, documentType);
    const { validation } = useValidationStatus(documentId, documentType);
    const connectionState = useConnectionState(documentId, documentType);
    const value = editState?.draft || editState?.published || initialValue.value;
    const documentActions = useDocumentActions(documentId, documentType, editState);
    return (React.createElement(Box, { padding: 4 },
        React.createElement(Code, { language: "json", size: 1 }, JSON.stringify({
            connectionState,
            documentId,
            documentType,
            initialValue,
            validation,
            templateName,
            templateParams,
            value,
        }, null, 2)),
        documentActions.node,
        documentActions.items && (React.createElement(React.Fragment, null,
            React.createElement(Stack, { space: 1 }, documentActions.items.map((actionItem, idx) => actionItem && (React.createElement(Button, { disabled: actionItem.disabled, icon: actionItem.icon, key: idx, 
                // eslint-disable-next-line react/jsx-handler-names
                onClick: actionItem.onHandle, tone: actionItem.tone, text: actionItem.label })))),
            documentActions.items.map((actionItem, idx) => {
                if (actionItem?.modal && actionItem.modal.type === 'dialog') {
                    return (React.createElement(Dialog, { footer: actionItem.modal.footer, header: actionItem.modal.header, id: `document-action-modal-${idx}`, 
                        // eslint-disable-next-line react/jsx-handler-names
                        onClose: actionItem.modal.onClose },
                        React.createElement(Box, { padding: 4 }, actionItem.modal.content)));
                }
                return null;
            })))));
}
function useDocumentActions(documentId, schemaType, editState) {
    const { document } = useSource();
    const actions = useMemo(() => document.actions({ schemaType, documentId }), [document, documentId, schemaType]);
    const [descriptions, setDescriptions] = useState(null);
    const node = (React.createElement(DocumentActionResolver, { actionHooks: actions, editState: editState, onUpdate: setDescriptions }));
    return { items: descriptions, node };
}
function DocumentActionResolver(props) {
    const { actionHooks, editState, onUpdate } = props;
    const [actionDescriptions, setActionDescriptions] = useState(() => actionHooks.map(() => null));
    const updateDescription = useCallback((desc, idx) => {
        setActionDescriptions((arr) => {
            const copy = arr.slice(0);
            copy.splice(idx, 1, desc);
            return copy;
        });
    }, []);
    useEffect(() => {
        onUpdate(actionDescriptions);
    }, [actionDescriptions, onUpdate]);
    return (React.createElement(React.Fragment, null, actionHooks.map((actionHook, idx) => (React.createElement(DocumentActionHook, { actionHook: actionHook, editState: editState, index: idx, key: idx, onUpdate: updateDescription })))));
}
function DocumentActionHook(props) {
    const { actionHook: useActionDescription, editState, index, onUpdate } = props;
    const onComplete = useCallback(() => {
        // @todo
    }, []);
    const actionProps = useMemo(() => ({
        ...editState,
        onComplete,
        // @todo
        revision: undefined,
    }), [editState, onComplete]);
    const actionDescription = useUnique(useActionDescription(actionProps));
    useEffect(() => {
        onUpdate(actionDescription, index);
    }, [actionDescription, index, onUpdate]);
    return null;
}
//# sourceMappingURL=DocumentStateStory.js.map