import { UnknownIcon } from '@sanity/icons';
import { Box, Button, Inline, Text, Tooltip } from '@sanity/ui';
import { partition, uniqBy } from 'lodash';
import React, { memo, useCallback, useMemo } from 'react';
import { useTemplates } from '../../../hooks';
import { IntentButton } from '../IntentButton';
import { PaneContextMenuButton } from '../pane/PaneContextMenuButton';
import { PaneHeaderCreateButton } from './PaneHeaderCreateButton';
// to preserve memory references
const emptyArray = [];
const emptyObject = {};
function isNonNullable(value) {
    return value !== null && value !== undefined;
}
/**
 * hashes an object to a string where the order of the keys don't matter
 */
const hashObject = (value) => {
    const sortObject = (v) => {
        if (typeof v !== 'object' || !v)
            return v;
        if (Array.isArray(v))
            return v.map(sortObject);
        return Object.entries(v).sort(([keyA], [keyB]) => keyA.localeCompare(keyB, 'en'));
    };
    const normalize = (v) => JSON.parse(JSON.stringify(v));
    return JSON.stringify(sortObject(normalize(value)));
};
export const PaneHeaderActions = memo(({ initialValueTemplateItems: initialValueTemplateItemsFromStructure = emptyArray, menuItems = emptyArray, menuItemGroups = emptyArray, actionHandlers = emptyObject, }) => {
    const templates = useTemplates();
    const handleAction = useCallback((item) => {
        if (typeof item.action === 'string' && !(item.action in actionHandlers)) {
            console.warn('No handler for action:', item.action);
            return false;
        }
        const handler = 
        // eslint-disable-next-line no-nested-ternary
        typeof item.action === 'function'
            ? item.action
            : typeof item.action === 'string'
                ? actionHandlers[item.action]
                : null;
        if (handler) {
            handler(item.params);
            return true;
        }
        return false;
    }, [actionHandlers]);
    const [actionMenuItems, contextMenuItems] = useMemo(() => {
        const nonCreateMenuItem = menuItems
            // remove items with `create` intents because those will get combined
            // into one action button later
            .filter((item) => item.intent?.type !== 'create');
        return partition(nonCreateMenuItem, (item) => item.showAsAction);
    }, [menuItems]);
    const initialValueTemplateItemFromMenuItems = useMemo(() => {
        return menuItems
            .map((item, menuItemIndex) => {
            if (item.intent?.type !== 'create')
                return null;
            const { params } = item.intent;
            if (!params)
                return null;
            const intentParams = Array.isArray(params) ? params[0] : params;
            const templateParams = Array.isArray(params) ? params[1] : undefined;
            // fallback to the schema type name as the template ID.
            // by default, the initial template values are populated from every
            // document type in the schema
            const templateId = intentParams.template || intentParams.type;
            if (!templateId)
                return null;
            // eslint-disable-next-line max-nested-callbacks
            const template = templates.find((t) => t.id === templateId);
            // the template doesn't exist then the action might be disabled
            if (!template)
                return null;
            const initialDocumentId = intentParams.id;
            return {
                item,
                template,
                templateParams,
                menuItemIndex,
                initialDocumentId,
            };
        })
            .filter(isNonNullable)
            .map(({ initialDocumentId, item, template, menuItemIndex, templateParams }) => {
            const initialValueTemplateItem = {
                id: `menuItem${menuItemIndex}`,
                initialDocumentId,
                templateId: template.id,
                type: 'initialValueTemplateItem',
                title: item.title || template.title,
                icon: item.icon,
                description: template.description,
                parameters: templateParams,
                schemaType: template.schemaType,
            };
            return initialValueTemplateItem;
        });
    }, [menuItems, templates]);
    const combinedInitialValueTemplates = useMemo(() => {
        // this de-dupes create actions
        return uniqBy([...initialValueTemplateItemFromMenuItems, ...initialValueTemplateItemsFromStructure], (item) => hashObject([item.initialDocumentId, item.templateId, item.parameters]));
    }, [initialValueTemplateItemFromMenuItems, initialValueTemplateItemsFromStructure]);
    return (React.createElement(Inline, { space: 1 }, [
        Boolean(combinedInitialValueTemplates.length) && (React.createElement(PaneHeaderCreateButton, { key: "$CreateMenuButton", templateItems: combinedInitialValueTemplates })),
        //
        ...actionMenuItems.map((actionItem, actionIndex) => {
            return (React.createElement(Tooltip, { content: React.createElement(Box, { padding: 2 },
                    React.createElement(Text, { size: 1 }, actionItem.title)), 
                // eslint-disable-next-line react/no-array-index-key
                key: `${actionIndex}-${actionItem.title}`, placement: "bottom" }, actionItem.intent ? (React.createElement(IntentButton, { intent: actionItem.intent, "aria-label": actionItem.title, icon: actionItem.icon || UnknownIcon, mode: "bleed" })) : (React.createElement(Button, { "aria-label": actionItem.title, icon: actionItem.icon || UnknownIcon, mode: "bleed", 
                // eslint-disable-next-line react/jsx-no-bind
                onClick: () => handleAction(actionItem) }))));
        }),
        //
        Boolean(contextMenuItems.length) && (React.createElement(PaneContextMenuButton, { items: contextMenuItems, itemGroups: menuItemGroups, key: "$ContextMenu", onAction: handleAction })),
    ]));
});
PaneHeaderActions.displayName = 'PaneHeaderActions';
//# sourceMappingURL=PaneHeaderActions.js.map