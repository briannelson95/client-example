import { useEffect, useMemo, useState } from 'react';
import { ReplaySubject } from 'rxjs';
import { map } from 'rxjs/operators';
import { useRouter } from '../../router';
import { LOADING_PANE } from '../constants';
import { useDeskTool } from '../useDeskTool';
import { createResolvedPaneNodeStream } from './createResolvedPaneNodeStream';
function useRouterPanesStream() {
    const routerStateSubject = useMemo(() => new ReplaySubject(1), []);
    const routerPanes$ = useMemo(() => routerStateSubject
        .asObservable()
        .pipe(map((_routerState) => (_routerState?.panes || []))), [routerStateSubject]);
    const { state: routerState } = useRouter();
    useEffect(() => {
        routerStateSubject.next(routerState);
    }, [routerState, routerStateSubject]);
    return routerPanes$;
}
export function useResolvedPanes() {
    // used to propagate errors from async effect. throwing inside of the render
    // will bubble the error to react where it can be picked up by standard error
    // boundaries
    const [error, setError] = useState();
    if (error)
        throw error;
    const { structureContext, rootPaneNode } = useDeskTool();
    const [data, setData] = useState({
        paneDataItems: [],
        resolvedPanes: [],
        routerPanes: [],
    });
    const routerPanesStream = useRouterPanesStream();
    useEffect(() => {
        const resolvedPanes$ = createResolvedPaneNodeStream({
            rootPaneNode,
            routerPanesStream,
            structureContext,
        }).pipe(map((resolvedPanes) => {
            const routerPanes = resolvedPanes.reduce((acc, next) => {
                const currentGroup = acc[next.groupIndex] || [];
                currentGroup[next.siblingIndex] = next.routerPaneSibling;
                acc[next.groupIndex] = currentGroup;
                return acc;
            }, []);
            const groupsLen = routerPanes.length;
            const paneDataItems = resolvedPanes.map((pane) => {
                const { groupIndex, flatIndex, siblingIndex, routerPaneSibling, path } = pane;
                const itemId = routerPaneSibling.id;
                const nextGroup = routerPanes[groupIndex + 1];
                const paneDataItem = {
                    active: groupIndex === groupsLen - 2,
                    childItemId: nextGroup?.[0].id ?? null,
                    index: flatIndex,
                    itemId: routerPaneSibling.id,
                    groupIndex,
                    key: `${pane.type === 'loading' ? 'unknown' : pane.paneNode.id}-${itemId}-${siblingIndex}`,
                    pane: pane.type === 'loading' ? LOADING_PANE : pane.paneNode,
                    params: routerPaneSibling.params || {},
                    path: path.join(';'),
                    payload: routerPaneSibling.payload,
                    selected: flatIndex === resolvedPanes.length - 1,
                    siblingIndex,
                };
                return paneDataItem;
            });
            return {
                paneDataItems,
                routerPanes,
                resolvedPanes: paneDataItems.map((pane) => pane.pane),
            };
        }));
        const subscription = resolvedPanes$.subscribe({
            next: (result) => setData(result),
            error: (e) => setError(e),
        });
        return () => subscription.unsubscribe();
    }, [rootPaneNode, routerPanesStream, structureContext]);
    return data;
}
//# sourceMappingURL=useResolvedPanes.js.map