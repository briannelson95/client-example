import * as PathUtils from '@sanity/util/paths';
import { isIndexSegment, isKeySegment, isReferenceSchemaType, } from '@sanity/types';
import { getPublishedId, collate } from '../../../util';
export function getDocumentKey(value, index) {
    return value._id ? getPublishedId(value._id) : `item-${index}`;
}
export function removePublishedWithDrafts(documents) {
    return collate(documents).map((entry) => {
        const doc = entry.draft || entry.published;
        return {
            ...doc,
            hasPublished: !!entry.published,
            hasDraft: !!entry.draft,
        };
    });
}
const RE_TYPE_NAME_IN_FILTER = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type\b/;
export function getTypeNameFromSingleTypeFilter(filter, params = {}) {
    const matches = filter.match(RE_TYPE_NAME_IN_FILTER);
    if (!matches) {
        return null;
    }
    const match = (matches[1] || matches[2]).trim().replace(/^["']|["']$/g, '');
    if (match[0] === '$') {
        const k = match.slice(1);
        const v = params[k];
        return typeof v === 'string' ? v : null;
    }
    return match;
}
export function isSimpleTypeFilter(filter) {
    return /^_type\s*==\s*['"$]\w+['"]?\s*$/.test(filter.trim());
}
export function toOrderClause(orderBy) {
    return orderBy
        .map((ordering) => [wrapFieldWithFn(ordering), (ordering.direction || '').toLowerCase()]
        .map((str) => str.trim())
        .filter(Boolean)
        .join(' '))
        .join(',');
}
function wrapFieldWithFn(ordering) {
    return ordering.mapWith ? `${ordering.mapWith}(${ordering.field})` : ordering.field;
}
export function applyOrderingFunctions(order, schemaType) {
    const orderBy = order.by.map((by) => {
        // Skip those that already have a mapper
        if (by.mapWith) {
            return by;
        }
        const fieldType = tryResolveSchemaTypeForPath(schemaType, by.field);
        if (!fieldType) {
            return by;
        }
        // Note: order matters here, since the jsonType of a date field is `string`,
        // but we want to apply `datetime()`, not `lower()`
        if (fieldExtendsType(fieldType, 'datetime')) {
            return { ...by, mapWith: 'dateTime' };
        }
        if (fieldType.jsonType === 'string') {
            return { ...by, mapWith: 'lower' };
        }
        return by;
    });
    return orderBy.every((item, index) => item === order.by[index]) ? order : { ...order, by: orderBy };
}
function tryResolveSchemaTypeForPath(baseType, path) {
    const pathSegments = PathUtils.fromString(path);
    let current = baseType;
    for (const segment of pathSegments) {
        if (!current) {
            return undefined;
        }
        if (typeof segment === 'string') {
            current = getFieldTypeByName(current, segment);
            continue;
        }
        const isArrayAccessor = isKeySegment(segment) || isIndexSegment(segment);
        if (!isArrayAccessor || current.jsonType !== 'array') {
            return undefined;
        }
        const [memberType, otherType] = current.of || [];
        if (otherType || !memberType) {
            // Can't figure out the type without knowing the value
            return undefined;
        }
        if (!isReferenceSchemaType(memberType)) {
            current = memberType;
            continue;
        }
        const [refType, otherRefType] = memberType.to || [];
        if (otherRefType || !refType) {
            // Can't figure out the type without knowing the value
            return undefined;
        }
        current = refType;
    }
    return current;
}
function getFieldTypeByName(type, fieldName) {
    if (!('fields' in type)) {
        return undefined;
    }
    const fieldType = type.fields.find((field) => field.name === fieldName);
    return fieldType ? fieldType.type : undefined;
}
export function fieldExtendsType(field, ofType) {
    let current = field.type;
    while (current) {
        if (current.name === ofType) {
            return true;
        }
        if (!current.type && current.jsonType === ofType) {
            return true;
        }
        current = current.type;
    }
    return false;
}
//# sourceMappingURL=helpers.js.map