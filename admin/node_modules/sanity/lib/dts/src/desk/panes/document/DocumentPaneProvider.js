import React, { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { omit } from 'lodash';
import { useToast } from '@sanity/ui';
import { fromString as pathFromString } from '@sanity/util/paths';
import isHotkey from 'is-hotkey';
import { useMemoObservable } from 'react-rx';
import { useHistoryStore, useInitialValue, usePresenceStore, } from '../../../datastores';
import { useClient, useConnectionState, useDocumentOperation, useEditState, useSchema, useTemplates, useValidationStatus, } from '../../../hooks';
import { isDev } from '../../../environment';
import { useSource } from '../../../studio';
import { getPublishedId, useUnique } from '../../../util';
import { usePaneRouter } from '../../components';
import { toMutationPatches } from '../../../form';
import { useFormState } from '../../../form/store/useFormState';
import { setAtPath } from '../../../form/store/stateTreeHelper';
import { getExpandOperations } from '../../../form/store/utils/getExpandOperations';
import { useDeskTool } from '../../useDeskTool';
import { DocumentPaneContext } from './DocumentPaneContext';
import { getMenuItems } from './menuItems';
import { usePreviewUrl } from './usePreviewUrl';
import { getInitialValueTemplateOpts } from './getInitialValueTemplateOpts';
const emptyObject = {};
/**
 * @internal
 */
// eslint-disable-next-line complexity, max-statements
export const DocumentPaneProvider = memo((props) => {
    const { children, index, pane, paneKey } = props;
    const client = useClient();
    const schema = useSchema();
    const templates = useTemplates();
    const { actions: documentActions, badges: documentBadges, unstable_languageFilter: languageFilterResolver, } = useSource().document;
    const historyStore = useHistoryStore();
    const presenceStore = usePresenceStore();
    const paneRouter = usePaneRouter();
    const { features } = useDeskTool();
    const { push: pushToast } = useToast();
    const { options, menuItemGroups, title = null, views: viewsProp = [] } = pane;
    const paneOptions = useUnique(options);
    const documentIdRaw = paneOptions.id;
    const documentId = getPublishedId(documentIdRaw);
    const documentType = options.type;
    const paneParams = useUnique(paneRouter.params);
    const panePayload = useUnique(paneRouter.payload);
    const { templateName, templateParams } = useMemo(() => getInitialValueTemplateOpts(templates, {
        documentType,
        templateName: paneOptions.template,
        templateParams: paneOptions.templateParameters,
        panePayload,
        urlTemplate: paneParams?.template,
    }), [documentType, paneOptions, paneParams, panePayload, templates]);
    const initialValueRaw = useInitialValue({
        documentId,
        documentType,
        templateName,
        templateParams,
    });
    const initialValue = useUnique(initialValueRaw);
    const { patch } = useDocumentOperation(documentId, documentType);
    const editState = useEditState(documentId, documentType);
    const { validation: validationRaw } = useValidationStatus(documentId, documentType);
    const connectionState = useConnectionState(documentId, documentType);
    const schemaType = schema.get(documentType);
    const value = editState?.draft || editState?.published || initialValue.value;
    // Resolve document actions
    const actions = useMemo(() => documentActions({ schemaType: documentType, documentId }), [documentActions, documentId, documentType]);
    // Resolve document badges
    const badges = useMemo(() => documentBadges({ schemaType: documentType, documentId }), [documentBadges, documentId, documentType]);
    // Resolve document language filter
    const languageFilter = useMemo(() => languageFilterResolver({ schemaType: documentType, documentId }), [documentId, documentType, languageFilterResolver]);
    const validation = useUnique(validationRaw);
    const views = useUnique(viewsProp);
    const params = paneRouter.params || emptyObject;
    const [focusPath, setFocusPath] = useState(() => params.path ? pathFromString(params.path) : []);
    const activeViewId = params.view || (views[0] && views[0].id) || null;
    const timeline = useMemo(() => historyStore.getTimeline({ publishedId: documentId, enableTrace: isDev }), [documentId, historyStore]);
    const [timelineMode, setTimelineMode] = useState('closed');
    // NOTE: this emits sync so can never be null
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const { historyController } = useMemoObservable(() => historyStore.getTimelineController({ client, documentId, documentType, timeline }), [client, documentId, documentType, timeline]);
    // @todo: this will now happen on each render, but should be refactored so it happens only when
    // the `rev`, `since` or `historyController` values change.
    historyController.setRange(params.since || null, params.rev || null);
    const changesOpen = historyController.changesPanelActive();
    // TODO: this may cause a lot of churn. May be a good idea to prevent these
    // requests unless the menu is open somehow
    const previewUrl = usePreviewUrl(value);
    const [presence, setPresence] = useState([]);
    useEffect(() => {
        const subscription = presenceStore.documentPresence(documentId).subscribe((nextPresence) => {
            setPresence(nextPresence);
        });
        return () => {
            subscription.unsubscribe();
        };
    }, [documentId, presenceStore]);
    const hasValue = Boolean(value);
    const menuItems = useMemo(() => getMenuItems({ features, hasValue, changesOpen, previewUrl }), [features, hasValue, changesOpen, previewUrl]);
    const inspectOpen = params.inspect === 'on';
    const compareValue = changesOpen
        ? historyController.sinceAttributes()
        : editState?.published || null;
    const ready = connectionState === 'connected' && editState.ready;
    const viewOlderVersion = historyController.onOlderRevision();
    const displayed = useMemo(() => (viewOlderVersion ? historyController.displayed() : value), 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [historyController, params.rev, params.since, value, viewOlderVersion]);
    const setTimelineRange = useCallback((newSince, newRev) => {
        paneRouter.setParams({
            ...paneRouter.params,
            since: newSince,
            rev: newRev || undefined,
        });
    }, [paneRouter]);
    const handleFocus = useCallback((nextFocusPath) => {
        setFocusPath(nextFocusPath);
        presenceStore.setLocation([
            {
                type: 'document',
                documentId,
                path: nextFocusPath,
                lastActiveAt: new Date().toISOString(),
            },
        ]);
    }, [documentId, presenceStore, setFocusPath]);
    const handleBlur = useCallback((blurredPath) => {
        setFocusPath([]);
        // note: we're deliberately not syncing presence here since it would make the user avatar disappear when a
        // user clicks outside a field without focusing another one
    }, [setFocusPath]);
    const patchRef = useRef(() => {
        throw new Error('Nope');
    });
    patchRef.current = (event) => {
        patch.execute(toMutationPatches(event.patches), initialValue.value);
    };
    const handleChange = useCallback((event) => patchRef.current(event), []);
    const handleHistoryClose = useCallback(() => {
        paneRouter.setParams({ ...params, since: undefined });
    }, [paneRouter, params]);
    const handleHistoryOpen = useCallback(() => {
        paneRouter.setParams({ ...params, since: '@lastPublished' });
    }, [paneRouter, params]);
    const handlePaneClose = useCallback(() => paneRouter.closeCurrent(), [paneRouter]);
    const handlePaneSplit = useCallback(() => paneRouter.duplicateCurrent(), [paneRouter]);
    const toggleInspect = useCallback((toggle = !inspectOpen) => {
        if (toggle) {
            paneRouter.setParams({ ...params, inspect: 'on' });
        }
        else {
            paneRouter.setParams(omit(params, 'inspect'));
        }
    }, [inspectOpen, paneRouter, params]);
    const handleMenuAction = useCallback((item) => {
        if (item.action === 'production-preview' && previewUrl) {
            window.open(previewUrl);
            return true;
        }
        if (item.action === 'inspect') {
            toggleInspect(true);
            return true;
        }
        if (item.action === 'reviewChanges') {
            handleHistoryOpen();
            return true;
        }
        return false;
    }, [handleHistoryOpen, previewUrl, toggleInspect]);
    const handleKeyUp = useCallback((event) => {
        for (const item of menuItems) {
            if (item.shortcut) {
                if (isHotkey(item.shortcut, event)) {
                    event.preventDefault();
                    event.stopPropagation();
                    handleMenuAction(item);
                    return;
                }
            }
        }
    }, [handleMenuAction, menuItems]);
    const handleInspectClose = useCallback(() => toggleInspect(false), [toggleInspect]);
    const [openPath, onSetOpenPath] = useState([]);
    const [fieldGroupState, onSetFieldGroupState] = useState();
    const [collapsedPaths, onSetCollapsedPath] = useState();
    const [collapsedFieldSets, onSetCollapsedFieldSets] = useState();
    const handleOnSetCollapsedPath = useCallback((path, collapsed) => {
        onSetCollapsedPath((prevState) => setAtPath(prevState, path, collapsed));
    }, []);
    const handleOnSetCollapsedFieldSet = useCallback((path, collapsed) => {
        onSetCollapsedFieldSets((prevState) => setAtPath(prevState, path, collapsed));
    }, []);
    const handleSetActiveFieldGroup = useCallback((path, groupName) => onSetFieldGroupState((prevState) => setAtPath(prevState, path, groupName)), []);
    const formState = useFormState(schemaType, {
        value,
        comparisonValue: compareValue,
        focusPath,
        openPath,
        collapsedPaths,
        presence,
        validation,
        collapsedFieldSets: collapsedFieldSets,
        fieldGroupState,
    });
    const formStateRef = useRef(formState);
    formStateRef.current = formState;
    const handleOpenPath = useCallback((path) => {
        const ops = getExpandOperations(formStateRef.current, path);
        ops.forEach((op) => {
            if (op.type === 'expandPath') {
                onSetCollapsedPath((prevState) => setAtPath(prevState, op.path, false));
            }
            if (op.type === 'expandFieldSet') {
                onSetCollapsedFieldSets((prevState) => setAtPath(prevState, op.path, false));
            }
            if (op.type === 'setSelectedGroup') {
                onSetFieldGroupState((prevState) => setAtPath(prevState, op.path, op.groupName));
            }
        });
        onSetOpenPath(path);
    }, [formStateRef]);
    const documentPane = {
        actions,
        activeViewId,
        badges,
        changesOpen,
        collapsedFieldSets,
        collapsedPaths,
        compareValue,
        connectionState,
        displayed,
        documentId,
        documentIdRaw,
        documentType,
        editState,
        focusPath,
        menuItems,
        onBlur: handleBlur,
        onChange: handleChange,
        onFocus: handleFocus,
        onPathOpen: handleOpenPath,
        onHistoryClose: handleHistoryClose,
        onHistoryOpen: handleHistoryOpen,
        onInspectClose: handleInspectClose,
        onKeyUp: handleKeyUp,
        onMenuAction: handleMenuAction,
        onPaneClose: handlePaneClose,
        onPaneSplit: handlePaneSplit,
        onSetActiveFieldGroup: handleSetActiveFieldGroup,
        onSetCollapsedPath: handleOnSetCollapsedPath,
        onSetCollapsedFieldSet: handleOnSetCollapsedFieldSet,
        historyController,
        index,
        inspectOpen,
        validation,
        menuItemGroups: menuItemGroups || [],
        paneKey,
        previewUrl,
        ready,
        schemaType: schemaType,
        setTimelineMode,
        setTimelineRange,
        timeline,
        timelineMode,
        title,
        value,
        views,
        formState,
        unstable_languageFilter: languageFilter,
    };
    useEffect(() => {
        if (connectionState === 'reconnecting') {
            pushToast({
                id: 'sanity/desk/reconnecting',
                status: 'warning',
                title: React.createElement(React.Fragment, null, "Connection lost. Reconnecting\u2026"),
            });
        }
    }, [connectionState, pushToast]);
    // Reset `focusPath` when `documentId` or `params.path` changes
    useEffect(() => {
        // Reset focus path
        setFocusPath(params.path ? pathFromString(params.path) : []);
    }, [documentId, params.path]);
    return (React.createElement(DocumentPaneContext.Provider, { value: documentPane }, children));
});
DocumentPaneProvider.displayName = 'DocumentPaneProvider';
//# sourceMappingURL=DocumentPaneProvider.js.map