import { ComposeIcon } from '@sanity/icons';
import { SerializeError, HELP_URL } from './SerializeError';
import { GenericListBuilder, } from './GenericList';
import { DocumentBuilder } from './Document';
const resolveTypeForDocument = async (client, id) => {
    const query = '*[_id in [$documentId, $draftId]]._type';
    const documentId = id.replace(/^drafts\./, '');
    const draftId = `drafts.${documentId}`;
    const types = await client
        // For structure-internal requests that we have control of the filter on,
        // we'll use this client with a more modern API version
        .withConfig({ apiVersion: '2021-06-07' })
        .fetch(query, { documentId, draftId }, { tag: 'structure.resolve-type' });
    return types[0];
};
const validateFilter = (spec, options) => {
    const filter = spec.options?.filter.trim() || '';
    if (['*', '{'].includes(filter[0])) {
        throw new SerializeError(`\`filter\` cannot start with \`${filter[0]}\` - looks like you are providing a query, not a filter`, options.path, spec.id, spec.title).withHelpUrl(HELP_URL.QUERY_PROVIDED_FOR_FILTER);
    }
    return filter;
};
const createDocumentChildResolverForItem = (context) => (itemId, options) => {
    const parentItem = options.parent;
    const template = options.params?.template
        ? context.templates.find((tpl) => tpl.id === options.params.template)
        : undefined;
    const type = template
        ? template.schemaType
        : parentItem.schemaTypeName || resolveTypeForDocument(context.client, itemId);
    return Promise.resolve(type).then((schemaType) => schemaType
        ? context.resolveDocumentNode({ schemaType, documentId: itemId })
        : new DocumentBuilder(context).id('editor').documentId(itemId).schemaType(''));
};
export class DocumentListBuilder extends GenericListBuilder {
    constructor(_context, spec) {
        super();
        this._context = _context;
        this.spec = spec || {};
        this.initialValueTemplatesSpecified = Boolean(spec?.initialValueTemplates);
    }
    apiVersion(apiVersion) {
        return this.clone({ options: { ...(this.spec.options || { filter: '' }), apiVersion } });
    }
    getApiVersion() {
        return this.spec.options?.apiVersion;
    }
    filter(filter) {
        return this.clone({ options: { ...(this.spec.options || {}), filter } });
    }
    getFilter() {
        return this.spec.options?.filter;
    }
    schemaType(type) {
        const schemaTypeName = typeof type === 'string' ? type : type.name;
        return this.clone({ schemaTypeName });
    }
    getSchemaType() {
        return this.spec.schemaTypeName;
    }
    params(params) {
        return this.clone({
            options: { ...(this.spec.options || { filter: '' }), params },
        });
    }
    getParams() {
        return this.spec.options?.params;
    }
    defaultOrdering(ordering) {
        if (!Array.isArray(ordering)) {
            throw new Error('`defaultOrdering` must be an array of order clauses');
        }
        return this.clone({
            options: { ...(this.spec.options || { filter: '' }), defaultOrdering: ordering },
        });
    }
    getDefaultOrdering() {
        return this.spec.options?.defaultOrdering;
    }
    serialize(options = { path: [] }) {
        if (typeof this.spec.id !== 'string' || !this.spec.id) {
            throw new SerializeError('`id` is required for document lists', options.path, options.index, this.spec.title).withHelpUrl(HELP_URL.ID_REQUIRED);
        }
        if (!this.spec.options || !this.spec.options.filter) {
            throw new SerializeError('`filter` is required for document lists', options.path, this.spec.id, this.spec.title).withHelpUrl(HELP_URL.FILTER_REQUIRED);
        }
        return {
            ...super.serialize(options),
            type: 'documentList',
            schemaTypeName: this.spec.schemaTypeName,
            child: this.spec.child || createDocumentChildResolverForItem(this._context),
            options: {
                ...this.spec.options,
                apiVersion: this.spec.options.apiVersion ||
                    // If this is a simple type filter, use modern API version - otherwise default to v1
                    (this.spec.options?.filter === '_type == $type' ? '2021-06-07' : '1'),
                filter: validateFilter(this.spec, options),
            },
        };
    }
    clone(withSpec) {
        const builder = new DocumentListBuilder(this._context);
        builder.spec = { ...this.spec, ...(withSpec || {}) };
        if (!this.initialValueTemplatesSpecified) {
            builder.spec.initialValueTemplates = inferInitialValueTemplates(this._context, builder.spec);
        }
        if (!builder.spec.schemaTypeName) {
            builder.spec.schemaTypeName = inferTypeName(builder.spec);
        }
        return builder;
    }
    getSpec() {
        return this.spec;
    }
}
function inferInitialValueTemplates(context, spec) {
    const { document } = context;
    const { schemaTypeName, options } = spec;
    const { filter, params } = options || { filter: '', params: {} };
    const typeNames = schemaTypeName
        ? [schemaTypeName]
        : Array.from(new Set(getTypeNamesFromFilter(filter, params)));
    if (typeNames.length === 0) {
        return undefined;
    }
    return typeNames
        .flatMap((schemaType) => document.resolveNewDocumentOptions({
        type: 'structure',
        schemaType,
    }))
        .map((option) => ({ ...option, icon: ComposeIcon }));
}
function inferTypeName(spec) {
    const { options } = spec;
    const { filter, params } = options || { filter: '', params: {} };
    const typeNames = getTypeNamesFromFilter(filter, params);
    return typeNames.length === 1 ? typeNames[0] : undefined;
}
export function getTypeNamesFromFilter(filter, params = {}) {
    let typeNames = getTypeNamesFromEqualityFilter(filter, params);
    if (typeNames.length === 0) {
        typeNames = getTypeNamesFromInTypesFilter(filter, params);
    }
    return typeNames;
}
// From _type == "movie" || _type == $otherType
function getTypeNamesFromEqualityFilter(filter, params = {}) {
    const pattern = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type/g;
    const matches = [];
    let match;
    while ((match = pattern.exec(filter)) !== null) {
        matches.push(match[1] || match[2]);
    }
    return matches
        .map((candidate) => {
        const typeName = candidate[0] === '$' ? params[candidate.slice(1)] : candidate;
        const normalized = (typeName || '').trim().replace(/^["']|["']$/g, '');
        return normalized;
    })
        .filter(Boolean);
}
// From _type in ["dog", "cat", $otherSpecies]
function getTypeNamesFromInTypesFilter(filter, params = {}) {
    const pattern = /\b_type\s+in\s+\[(.*?)\]/;
    const matches = filter.match(pattern);
    if (!matches) {
        return [];
    }
    return matches[1]
        .split(/,\s*/)
        .map((match) => match.trim().replace(/^["']+|["']+$/g, ''))
        .map((item) => (item[0] === '$' ? params[item.slice(1)] : item))
        .filter(Boolean);
}
//# sourceMappingURL=DocumentList.js.map