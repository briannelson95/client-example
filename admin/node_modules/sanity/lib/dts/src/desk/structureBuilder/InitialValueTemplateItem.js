import { pickBy } from 'lodash';
import { ComposeIcon } from '@sanity/icons';
import { HELP_URL, SerializeError } from './SerializeError';
import { MenuItemBuilder } from './MenuItem';
export class InitialValueTemplateItemBuilder {
    constructor(_context, spec) {
        this._context = _context;
        this.spec = spec ? spec : {};
    }
    id(id) {
        return this.clone({ id });
    }
    getId() {
        return this.spec.id;
    }
    title(title) {
        return this.clone({ title });
    }
    getTitle() {
        return this.spec.title;
    }
    description(description) {
        return this.clone({ description });
    }
    getDescription() {
        return this.spec.description;
    }
    templateId(templateId) {
        // Let's try to be a bit helpful and assign an ID from template ID if none is specified
        const paneId = this.spec.id || templateId;
        return this.clone({
            id: paneId,
            templateId,
        });
    }
    getTemplateId() {
        return this.spec.templateId;
    }
    parameters(parameters) {
        return this.clone({ parameters });
    }
    getParameters() {
        return this.spec.parameters;
    }
    serialize({ path = [], index, hint } = { path: [] }) {
        const { spec, _context } = this;
        const { templates } = _context;
        if (typeof spec.id !== 'string' || !spec.id) {
            throw new SerializeError('`id` is required for initial value template item nodes', path, index, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
        }
        if (!spec.templateId) {
            throw new SerializeError('template id (`templateId`) is required for initial value template item nodes', path, spec.id, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
        }
        const template = templates.find((t) => t.id === spec.templateId);
        if (!template) {
            throw new SerializeError('template id (`templateId`) is required for initial value template item nodes', path, spec.id, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
        }
        return {
            id: spec.id,
            templateId: spec.id,
            schemaType: template.schemaType,
            type: 'initialValueTemplateItem',
            description: spec.description || template.description,
            title: spec.title || template.title,
            subtitle: spec.subtitle,
            icon: spec.icon || template.icon,
            initialDocumentId: spec.initialDocumentId,
            parameters: spec.parameters,
        };
    }
    clone(withSpec = {}) {
        const builder = new InitialValueTemplateItemBuilder(this._context);
        builder.spec = { ...this.spec, ...withSpec };
        return builder;
    }
}
export function defaultInitialValueTemplateItems(context) {
    const { schema, getStructureBuilder, templates } = context;
    // Sort templates by their schema type, in order or definition
    const typeNames = schema.getTypeNames();
    const ordered = templates
        // Don't list templates that require parameters
        // TODO: this should use the new-document template items instead maybe?
        .filter((tpl) => !tpl.parameters?.length)
        .sort((a, b) => typeNames.indexOf(a.schemaType) - typeNames.indexOf(b.schemaType));
    // Create actual template items out of the templates
    return ordered.map((tpl) => getStructureBuilder().initialValueTemplateItem(tpl.id));
}
export function maybeSerializeInitialValueTemplateItem(item, index, path) {
    return item instanceof InitialValueTemplateItemBuilder ? item.serialize({ path, index }) : item;
}
export function menuItemsFromInitialValueTemplateItems(context, templateItems) {
    const { schema, templates } = context;
    return templateItems.map((item) => {
        const template = templates.find((t) => t.id === item.templateId);
        const title = item.title || template?.title || 'Create new';
        const params = pickBy({ type: template && template.schemaType, template: item.templateId }, Boolean);
        const intentParams = item.parameters ? [params, item.parameters] : params;
        const schemaType = template && schema.get(template.schemaType);
        return new MenuItemBuilder(context)
            .title(title)
            .icon((template && template.icon) || schemaType?.icon || ComposeIcon)
            .intent({ type: 'create', params: intentParams })
            .serialize();
    });
}
//# sourceMappingURL=InitialValueTemplateItem.js.map