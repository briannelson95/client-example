import { SortIcon } from '@sanity/icons';
import { getExtendedProjection } from './util/getExtendedProjection';
import { DEFAULT_ORDERING_OPTIONS } from './Sort';
import { SerializeError, HELP_URL } from './SerializeError';
export function maybeSerializeMenuItem(item, index, path) {
    return item instanceof MenuItemBuilder ? item.serialize({ path, index }) : item;
}
export class MenuItemBuilder {
    constructor(_context, spec) {
        this._context = _context;
        this.spec = spec ? spec : {};
    }
    action(action) {
        return this.clone({ action });
    }
    getAction() {
        return this.spec.action;
    }
    intent(intent) {
        return this.clone({ intent });
    }
    getIntent() {
        return this.spec.intent;
    }
    title(title) {
        return this.clone({ title });
    }
    getTitle() {
        return this.spec.title;
    }
    group(group) {
        return this.clone({ group });
    }
    getGroup() {
        return this.spec.group;
    }
    icon(icon) {
        return this.clone({ icon });
    }
    getIcon() {
        return this.spec.icon;
    }
    params(params) {
        return this.clone({ params });
    }
    getParams() {
        return this.spec.params;
    }
    showAsAction(showAsAction = true) {
        return this.clone({ showAsAction: Boolean(showAsAction) });
    }
    getShowAsAction() {
        return this.spec.showAsAction;
    }
    serialize(options = { path: [] }) {
        const { title, action, intent } = this.spec;
        if (!title) {
            const hint = typeof action === 'string' ? `action: "${action}"` : undefined;
            throw new SerializeError('`title` is required for menu item', options.path, options.index, hint).withHelpUrl(HELP_URL.TITLE_REQUIRED);
        }
        if (!action && !intent) {
            throw new SerializeError(`\`action\` or \`intent\` required for menu item with title ${this.spec.title}`, options.path, options.index, `"${title}"`).withHelpUrl(HELP_URL.ACTION_OR_INTENT_REQUIRED);
        }
        if (intent && action) {
            throw new SerializeError('cannot set both `action` AND `intent`', options.path, options.index, `"${title}"`).withHelpUrl(HELP_URL.ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE);
        }
        return { ...this.spec, title };
    }
    clone(withSpec) {
        const builder = new MenuItemBuilder(this._context);
        builder.spec = { ...this.spec, ...(withSpec || {}) };
        return builder;
    }
}
export function getOrderingMenuItem(context, ordering, extendedProjection) {
    return new MenuItemBuilder(context)
        .group('sorting')
        .title(`Sort by ${ordering.title}`)
        .icon(SortIcon)
        .action('setSortOrder')
        .params({ by: ordering.by, extendedProjection });
}
export function getOrderingMenuItemsForSchemaType(context, typeName) {
    const { schema } = context;
    const type = typeof typeName === 'string' ? schema.get(typeName) : typeName;
    if (!type || !('orderings' in type)) {
        return [];
    }
    return (type.orderings ? type.orderings.concat(DEFAULT_ORDERING_OPTIONS) : DEFAULT_ORDERING_OPTIONS).map((ordering) => getOrderingMenuItem(context, ordering, getExtendedProjection(type, ordering.by)));
}
//# sourceMappingURL=MenuItem.js.map