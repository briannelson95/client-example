import { uniq, camelCase } from 'lodash';
import { SerializeError, HELP_URL } from './SerializeError';
import { validateId } from './util/validateId';
import { maybeSerializeView } from './views/View';
import { form } from './views';
const createDocumentChildResolver = ({ resolveDocumentNode }) => (itemId, { params, path }) => {
    const { type } = params;
    const parentPath = path.slice(0, path.length - 1);
    const currentSegment = path[path.length - 1];
    if (!type) {
        throw new SerializeError(`Invalid link. Your link must contain a \`type\`.`, parentPath, currentSegment);
    }
    return resolveDocumentNode({ documentId: itemId, schemaType: type });
};
export class DocumentBuilder {
    constructor(_context, spec) {
        this._context = _context;
        this.spec = spec ? spec : {};
    }
    id(id) {
        return this.clone({ id });
    }
    getId() {
        return this.spec.id;
    }
    title(title) {
        return this.clone({ title, id: this.spec.id || camelCase(title) });
    }
    getTitle() {
        return this.spec.title;
    }
    child(child) {
        return this.clone({ child });
    }
    getChild() {
        return this.spec.child;
    }
    documentId(documentId) {
        // Let's try to be a bit helpful and assign an ID from document ID if none is specified
        const paneId = this.spec.id || documentId;
        return this.clone({
            id: paneId,
            options: {
                ...(this.spec.options || {}),
                id: documentId,
            },
        });
    }
    getDocumentId() {
        return this.spec.options?.id;
    }
    schemaType(documentType) {
        return this.clone({
            options: {
                ...(this.spec.options || {}),
                type: typeof documentType === 'string' ? documentType : documentType.name,
            },
        });
    }
    getSchemaType() {
        return this.spec.options?.type;
    }
    initialValueTemplate(templateId, parameters) {
        return this.clone({
            options: {
                ...(this.spec.options || {}),
                template: templateId,
                templateParameters: parameters,
            },
        });
    }
    getInitialValueTemplate() {
        return this.spec.options?.template;
    }
    getInitialValueTemplateParameters() {
        return this.spec.options?.templateParameters;
    }
    views(views) {
        return this.clone({ views });
    }
    getViews() {
        return this.spec.views || [];
    }
    serialize({ path = [], index, hint } = { path: [] }) {
        const urlId = path[index || path.length - 1];
        // Try to grab document ID / editor ID from URL if not defined
        const id = this.spec.id || (urlId && `${urlId}`) || '';
        const options = {
            id,
            type: undefined,
            template: undefined,
            templateParameters: undefined,
            ...this.spec.options,
        };
        if (typeof id !== 'string' || !id) {
            throw new SerializeError('`id` is required for document nodes', path, index, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
        }
        if (!options || !options.id) {
            throw new SerializeError('document id (`id`) is required for document nodes', path, id, hint).withHelpUrl(HELP_URL.DOCUMENT_ID_REQUIRED);
        }
        if (!options || !options.type) {
            throw new SerializeError('document type (`schemaType`) is required for document nodes', path, id, hint);
        }
        const views = (this.spec.views && this.spec.views.length > 0 ? this.spec.views : [form()]).map((item, i) => maybeSerializeView(item, i, path));
        const viewIds = views.map((view) => view.id);
        const dupes = uniq(viewIds.filter((viewId, i) => viewIds.includes(viewId, i + 1)));
        if (dupes.length > 0) {
            throw new SerializeError(`document node has views with duplicate IDs: ${dupes.join(',  ')}`, path, id, hint);
        }
        return {
            ...this.spec,
            child: this.spec.child || createDocumentChildResolver(this._context),
            id: validateId(id, path, index),
            type: 'document',
            options: getDocumentOptions(options),
            views,
        };
    }
    clone(withSpec = {}) {
        const builder = new DocumentBuilder(this._context);
        const options = { ...(this.spec.options || {}), ...(withSpec.options || {}) };
        builder.spec = { ...this.spec, ...withSpec, options };
        return builder;
    }
}
function getDocumentOptions(spec) {
    const opts = {
        id: spec.id || '',
        type: spec.type || '*',
    };
    if (spec.template) {
        opts.template = spec.template;
    }
    if (spec.templateParameters) {
        opts.templateParameters = spec.templateParameters;
    }
    return opts;
}
export function documentFromEditor(context, spec) {
    let doc = spec?.type
        ? // Use user-defined document fragment as base if possible
            context.resolveDocumentNode({ schemaType: spec.type })
        : // Fall back to plain old document builder
            new DocumentBuilder(context);
    if (!spec)
        return doc;
    const { id, type, template, templateParameters } = spec.options;
    doc = doc.id(spec.id).documentId(id);
    if (type) {
        doc = doc.schemaType(type);
    }
    if (template) {
        doc = doc.initialValueTemplate(template, templateParameters);
    }
    if (spec.child) {
        doc = doc.child(spec.child);
    }
    return doc;
}
export function documentFromEditorWithInitialValue({ resolveDocumentNode, templates }, templateId, parameters) {
    const template = templates.find((t) => t.id === templateId);
    if (!template) {
        throw new Error(`Template with ID "${templateId}" not defined`);
    }
    return resolveDocumentNode({ schemaType: template.schemaType }).initialValueTemplate(templateId, parameters);
}
//# sourceMappingURL=Document.js.map