import { ChevronDownIcon } from '@sanity/icons';
import { isKeySegment } from '@sanity/types';
import { Card, Flex, Label, Popover, useClickOutside } from '@sanity/ui';
import { FOCUS_TERMINATOR, toString } from '@sanity/util/paths';
import React, { useCallback, useContext, useState, useEffect, useMemo } from 'react';
import styled from 'styled-components';
import { ConnectorContext, useReportedValues } from '../../../../../components/changeIndicators';
import { SanityPreview } from '../../../../../preview';
import { ChangeList, DiffContext, DiffTooltip, useDiffAnnotationColor } from '../../../../diff';
import { isEmptyObject } from '../helpers';
import { InlineBox, InlineText, PopoverContainer, PreviewContainer } from './styledComponents';
const InlineObjectWrapper = styled(Card) `
  &:not([hidden]) {
    display: inline;
    cursor: pointer;
    white-space: nowrap;
    align-items: center;

    &[data-removed] {
      text-decoration: line-through;
    }

    ${InlineBox} {
      display: inline-flex;
    }
  }
`;
export function InlineObject({ diff, object, schemaType, ...restProps }) {
    if (!schemaType) {
        return (React.createElement(InlineObjectWrapper, { ...restProps, border: true, radius: 1 },
            "Unknown schema type: ",
            object._type));
    }
    if (diff) {
        return (React.createElement(InlineObjectWithDiff, { ...restProps, diff: diff, object: object, schemaType: schemaType }));
    }
    return (React.createElement(InlineObjectWrapper, null,
        React.createElement(SanityPreview, { schemaType: schemaType, value: object, layout: "inline" })));
}
function InlineObjectWithDiff({ diff, object, path, schemaType, ...restProps }) {
    const { path: fullPath } = useContext(DiffContext);
    const { onSetFocus } = useContext(ConnectorContext);
    const color = useDiffAnnotationColor(diff, []);
    const style = useMemo(() => (color ? { background: color.background, color: color.text } : {}), [color]);
    const [open, setOpen] = useState(false);
    const emptyObject = object && isEmptyObject(object);
    const isRemoved = diff.action === 'removed';
    const prefix = fullPath.slice(0, fullPath.findIndex((seg) => isKeySegment(seg) && seg._key === object._key));
    const myPath = prefix.concat(path);
    const myValue = `field-${toString(myPath)}`;
    const values = useReportedValues();
    const isEditing = values.filter(([p]) => p.startsWith(myValue)).length > 0;
    const focusPath = fullPath.slice(0, -1).concat(path).concat([FOCUS_TERMINATOR]);
    useEffect(() => {
        if (isEditing) {
            setOpen(true);
            onSetFocus(focusPath);
        }
    }, [isEditing]);
    const handleOpenPopup = useCallback((event) => {
        event.stopPropagation();
        setOpen(true);
        if (!isRemoved) {
            onSetFocus(focusPath);
            return;
        }
        event.preventDefault();
    }, [focusPath]);
    const handleClose = useCallback(() => {
        setOpen(false);
    }, []);
    const popoverContent = (React.createElement(DiffContext.Provider, { value: { path: myPath } },
        React.createElement(PopoverContent, { diff: diff, emptyObject: emptyObject, onClose: handleClose, schemaType: schemaType })));
    const annotation = (diff.action !== 'unchanged' && diff.annotation) || null;
    const annotations = annotation ? [annotation] : [];
    return (React.createElement(InlineObjectWrapper, { ...restProps, onClick: handleOpenPopup, style: style, "data-removed": diff.action === 'removed' ? '' : undefined, border: true, radius: 2 },
        React.createElement(Popover, { content: popoverContent, open: open, portal: true },
            React.createElement(PreviewContainer, null,
                React.createElement(DiffTooltip, { annotations: annotations, description: `${diff.action} inline object` },
                    React.createElement(InlineBox, null,
                        React.createElement(SanityPreview, { schemaType: schemaType, value: object, layout: "inline" }),
                        React.createElement(Flex, { align: "center", paddingX: 1 },
                            React.createElement(InlineText, { size: 0 },
                                React.createElement(ChevronDownIcon, null)))))))));
}
function PopoverContent({ diff, emptyObject, onClose, schemaType, }) {
    const [popoverElement, setPopoverElement] = useState(null);
    // const {isTopLayer} = useLayer()
    const handleClickOutside = useCallback(() => {
        // Popover doesn't close at all when using this condition
        // if (!isTopLayer) return
        onClose();
    }, [onClose]);
    useClickOutside(handleClickOutside, [popoverElement]);
    return (React.createElement(PopoverContainer, { ref: setPopoverElement, padding: 3 },
        emptyObject && (React.createElement(Label, { size: 1, muted: true },
            "Empty ",
            schemaType.title)),
        !emptyObject && React.createElement(ChangeList, { diff: diff, schemaType: schemaType })));
}
//# sourceMappingURL=InlineObject.js.map