// Takes a observable-returning function and returns a new function that limits on the number of
// concurrent observables.
import { first, mergeMap } from 'rxjs/operators';
import { Subject, Observable, from as observableFrom } from 'rxjs';
const DEFAULT_CONCURRENCY = 4;
function remove(array, item) {
    const index = array.indexOf(item);
    if (index > -1) {
        array.splice(index, 1);
    }
    return array;
}
export function withMaxConcurrency(func, concurrency = DEFAULT_CONCURRENCY) {
    const throttler = createThrottler(concurrency);
    return (...args) => observableFrom(throttler(func(...args)));
}
export function createThrottler(concurrency = DEFAULT_CONCURRENCY) {
    const currentSubscriptions = [];
    const pendingObservables = [];
    const ready$ = new Subject();
    return request;
    function request(observable) {
        return new Observable((observer) => {
            if (currentSubscriptions.length >= concurrency) {
                return scheduleAndWait(observable)
                    .pipe(mergeMap(request))
                    .subscribe(observer);
            }
            const subscription = observable.subscribe(observer);
            currentSubscriptions.push(subscription);
            return () => {
                remove(currentSubscriptions, subscription);
                remove(pendingObservables, observable);
                subscription.unsubscribe();
                check();
            };
        });
    }
    function scheduleAndWait(observable) {
        pendingObservables.push(observable);
        return ready$.asObservable().pipe(first((obs) => obs === observable));
    }
    function check() {
        while (pendingObservables.length > 0 && currentSubscriptions.length < concurrency) {
            ready$.next(pendingObservables.shift());
        }
    }
}
//# sourceMappingURL=withMaxConcurrency.js.map