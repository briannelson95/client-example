import { Box, Flex, Text, useToast } from '@sanity/ui';
import React from 'react';
import { sortBy } from 'lodash';
import styled from 'styled-components';
import { fileTarget } from '../../../common/fileTarget';
import { DropMessage } from '../../../files/common/DropMessage';
import { Overlay } from './styles';
const Root = styled.div `
  position: relative;
`;
function getUploadCandidates(types, resolveUploader, file) {
    return types
        .map((memberType) => ({
        type: memberType,
        uploader: resolveUploader(memberType, file),
    }))
        .filter((member) => member.uploader);
}
export function uploadTarget(Component) {
    const FileTarget = fileTarget(Component);
    return React.forwardRef(function UploadTarget(props, forwardedRef) {
        const { children, resolveUploader, onUpload, types, ...rest } = props;
        const { push: pushToast } = useToast();
        const uploadFile = React.useCallback((file, resolvedUploader) => {
            const { type, uploader } = resolvedUploader;
            onUpload?.({ file, type, uploader });
        }, [onUpload]);
        const handleFiles = React.useCallback((files) => {
            if (!resolveUploader) {
                return;
            }
            const tasks = files.map((file) => ({
                file,
                uploaderCandidates: getUploadCandidates(types, resolveUploader, file),
            }));
            const ready = tasks.filter((task) => task.uploaderCandidates.length > 0);
            const rejected = tasks.filter((task) => task.uploaderCandidates.length === 0);
            if (rejected.length > 0) {
                const plural = rejected.length > 1;
                pushToast({
                    closable: true,
                    status: 'warning',
                    title: `The following item${plural ? 's' : ''} can't be uploaded because there's no known conversion from content type${plural ? 's' : ''} to array item:`,
                    description: rejected.map((task, i) => (React.createElement(Flex, { key: i, padding: 2 },
                        React.createElement(Box, { marginLeft: 1 },
                            React.createElement(Text, { weight: "semibold" }, task.file.name)),
                        React.createElement(Box, { paddingLeft: 2 },
                            React.createElement(Text, { size: 1 },
                                "(",
                                task.file.type,
                                ")"))))),
                });
            }
            // todo: consider if we should to ask the user here
            // the list of candidates is sorted by their priority and the first one is selected
            // const ambiguous = tasks
            //   .filter(task => task.uploaderCandidates.length > 1)
            ready.forEach((task) => {
                uploadFile(task.file, 
                // eslint-disable-next-line max-nested-callbacks
                sortBy(task.uploaderCandidates, (candidate) => candidate.uploader.priority)[0]);
            });
        }, [pushToast, resolveUploader, types, uploadFile]);
        const [hoveringFiles, setHoveringFiles] = React.useState([]);
        const handleFilesOut = React.useCallback(() => setHoveringFiles([]), []);
        return (React.createElement(Root, null,
            React.createElement(FileTarget, { ...rest, ref: forwardedRef, onFiles: handleFiles, onFilesOver: setHoveringFiles, onFilesOut: handleFilesOut },
                resolveUploader && hoveringFiles.length > 0 && (React.createElement(Overlay, { zOffset: 10 },
                    React.createElement(DropMessage, { hoveringFiles: hoveringFiles, types: types, resolveUploader: resolveUploader }))),
                children)));
    });
}
//# sourceMappingURL=uploadTarget.js.map