import React from 'react';
import { get, startCase } from 'lodash';
import { Box, Checkbox, Flex, Text } from '@sanity/ui';
import { resolveTypeName } from '@sanity/util/content';
import { set, unset } from '../../../patch';
import { ItemWithMissingType } from '../ArrayOfObjectsInput/item/ItemWithMissingType';
import { Item, List } from '../common/list';
import { ChangeIndicator } from '../../../../components/changeIndicators';
import { resolveValueWithLegacyOptionsSupport, isLegacyOptionsItem } from './legacyOptionsSupport';
const changeIndicatorOptions = { compareDeep: true };
function isEqual(item, otherItem) {
    if (isLegacyOptionsItem(item) || isLegacyOptionsItem(otherItem)) {
        return item.value === otherItem.value;
    }
    if (item === otherItem) {
        return true;
    }
    if (typeof item !== typeof otherItem) {
        return false;
    }
    if (typeof item !== 'object' && !Array.isArray(item)) {
        return item === otherItem;
    }
    if (item._key && item._key === otherItem._key) {
        return true;
    }
    if (Array.isArray(item)) {
        if (!item.length !== otherItem.length) {
            return false;
        }
        return item.every((it, i) => isEqual(item[i], otherItem[i]));
    }
    const keys = Object.keys(item);
    const otherKeys = Object.keys(item);
    if (keys.length !== otherKeys.length) {
        return false;
    }
    return keys.every((keyName) => isEqual(item[keyName], otherItem[keyName]));
}
function inArray(array, candidate) {
    return array ? array.some((item) => isEqual(item, candidate)) : false;
}
export class OptionsArrayInput extends React.PureComponent {
    constructor() {
        super(...arguments);
        this._element = null;
        this.handleChange = (isChecked, optionValue) => {
            const { schemaType, value = [] } = this.props;
            const list = get(schemaType.options, 'list');
            if (!isChecked && optionValue._key) {
                // This is an optimization that only works if list items are _keyed
                this.props.onChange(unset([{ _key: optionValue._key }]));
            }
            const nextValue = list
                .filter((item) => isEqual(optionValue, item)
                ? isChecked
                : inArray(value, resolveValueWithLegacyOptionsSupport(item)))
                .map(resolveValueWithLegacyOptionsSupport);
            this.props.onChange(nextValue.length > 0 ? set(nextValue) : unset());
        };
        this.setElement = (el) => {
            this._element = el;
        };
        this.handleFocus = (index) => {
            const { onFocusIndex } = this.props;
            onFocusIndex(index);
        };
    }
    getMemberTypeOfItem(option) {
        const { schemaType } = this.props;
        return schemaType.of.find((memberType) => memberType.name === resolveTypeName(resolveValueWithLegacyOptionsSupport(option)));
    }
    focus() {
        if (this._element) {
            this._element.focus();
        }
    }
    render() {
        const { changed, focused, onBlur, onFocus, path, renderPreview, schemaType, value, readOnly } = this.props;
        const options = schemaType.options?.list || [];
        // note: direction was never documented and makes more sense to use "grid" for it too
        const isGrid = schemaType.options?.direction === 'horizontal' || schemaType.options?.layout === 'grid';
        return (React.createElement(ChangeIndicator, { path: path, isChanged: changed, hasFocus: !!focused },
            React.createElement(List, { isGrid: isGrid }, options.map((option, index) => {
                const optionType = this.getMemberTypeOfItem(option);
                const checked = inArray(value || [], resolveValueWithLegacyOptionsSupport(option));
                const disabled = !optionType;
                const title = option?.title || startCase(option?.value) || option;
                return (React.createElement(Item, { index: index, isGrid: isGrid, key: index },
                    React.createElement(Flex, { align: "center", as: "label", muted: disabled },
                        React.createElement(WrappedCheckbox, { disabled: disabled, checked: checked, onChange: (e) => this.handleChange(e.currentTarget.checked, option), onFocus: () => this.handleFocus(index), onBlur: onBlur, readOnly: readOnly }),
                        optionType &&
                            (title ? (React.createElement(Box, { padding: 2 },
                                React.createElement(Text, null, title))) : (React.createElement(Box, { marginLeft: 2 }, renderPreview({
                                layout: 'media',
                                schemaType: optionType,
                                value: resolveValueWithLegacyOptionsSupport(option),
                            })))),
                        !optionType && (React.createElement(ItemWithMissingType, { value: option, onFocus: (event) => onFocus(event) })))));
            }))));
    }
}
const WrappedCheckbox = (props) => {
    const { disabled, checked, onChange, onFocus, readOnly, onBlur } = props;
    return (React.createElement(Checkbox, { disabled: disabled, checked: checked, readOnly: readOnly, onChange: onChange, onFocus: onFocus, onBlur: onBlur }));
};
//# sourceMappingURL=OptionsArrayInput.js.map