/* eslint-disable complexity, max-nested-callbacks, no-nested-ternary */
import React, { useCallback, useMemo, useRef, useState } from 'react';
import { EllipsisVerticalIcon, ResetIcon as ClearIcon, SyncIcon as ReplaceIcon } from '@sanity/icons';
import { concat, of } from 'rxjs';
import { useId } from '@reach/auto-id';
import { catchError, distinctUntilChanged, filter, map, scan, switchMap, tap } from 'rxjs/operators';
import { Box, Button, Card, Flex, Inline, Menu, MenuButton, MenuItem, Stack, Text, useForwardedRef, useToast, } from '@sanity/ui';
import { useObservableCallback } from 'react-rx';
import { set, unset } from '../../patch';
import { AlertStrip } from '../../components/AlertStrip';
import { useOnClickOutside } from '../../hooks/useOnClickOutside';
import { isNonNullable } from '../../utils/isNonNullable';
import { getPublishedId } from '../../../util';
import { ChangeIndicator } from '../../../components/changeIndicators';
import { OptionPreview } from './OptionPreview';
import { useReferenceInfo } from './useReferenceInfo';
import { PreviewReferenceValue } from './PreviewReferenceValue';
import { ReferenceAutocomplete } from './ReferenceAutocomplete';
import { PreviewCard } from './PreviewCard';
const INITIAL_SEARCH_STATE = {
    hits: [],
    isLoading: false,
};
const NO_FILTER = () => true;
const REF_PATH = ['_ref'];
export function CrossDatasetReferenceInput(props) {
    const { changed, focused, focusPath, focusRef, getReferenceInfo, onBlur, onChange, onFocusPath, onSearch, path, readOnly, schemaType, validation, value, } = props;
    const forwardedRef = useForwardedRef(focusRef);
    const [searchState, setSearchState] = useState(INITIAL_SEARCH_STATE);
    const handleChange = useCallback((id) => {
        if (!id) {
            onChange(unset());
            onFocusPath([]);
            return;
        }
        const hit = searchState.hits.find((h) => h.id === id);
        if (!hit) {
            throw new Error('Selected an item that wasnt part of the result set');
        }
        onChange(set({
            _type: schemaType.name,
            _ref: getPublishedId(id),
            _projectId: schemaType.projectId,
            _dataset: schemaType.dataset,
            _weak: schemaType.weak,
            // persist _key between mutations if the value is in an array
            _key: value?._key,
        }));
        onFocusPath([]);
    }, [
        value?._key,
        searchState.hits,
        schemaType.name,
        schemaType.projectId,
        schemaType.dataset,
        schemaType.weak,
        onChange,
        onFocusPath,
    ]);
    const handleClear = useCallback(() => {
        onChange(unset());
    }, [onChange]);
    const handleAutocompleteKeyDown = useCallback((event) => {
        // escape
        if (event.keyCode === 27) {
            onFocusPath?.([]);
        }
    }, [onFocusPath]);
    const getReferenceInfoMemo = useCallback((doc) => getReferenceInfo(doc, schemaType), [getReferenceInfo, schemaType]);
    const refDoc = useMemo(() => ({ _id: value?._ref }), [value?._ref]);
    const loadableReferenceInfo = useReferenceInfo(refDoc, getReferenceInfoMemo);
    const autocompletePopoverReferenceElementRef = useRef(null);
    const hasFocusAtRef = focusPath.length === 1 && focusPath[0] === '_ref';
    // --- focus handling
    // const focusElementRef = useForwardedRef(forwardedRef)
    // useDidUpdate({hasFocusAt: hasFocusAtRef, ref: value?._ref}, (prev, current) => {
    //   const refUpdated = prev?.ref !== current.ref
    //   const focusAtUpdated = prev?.hasFocusAt !== current.hasFocusAt
    //   if ((focusAtUpdated || refUpdated) && current.hasFocusAt) {
    //     // if search mode changed and we're having focus always ensure the
    //     // ref element gets focus
    //     focusElementRef.current?.focus()
    //   }
    // })
    const weakIs = value?._weak ? 'weak' : 'strong';
    const weakShouldBe = schemaType.weak === true ? 'weak' : 'strong';
    const hasRef = Boolean(value?._ref);
    const handleFixStrengthMismatch = useCallback(() => {
        onChange(schemaType.weak === true ? set(true, ['_weak']) : unset(['_weak']));
    }, [onChange, schemaType]);
    const { push } = useToast();
    const errors = useMemo(() => validation.filter((item) => item.level === 'error'), [validation]);
    const handleFocus = useCallback((event) => {
        if (onFocusPath && event.currentTarget === forwardedRef.current) {
            onFocusPath([]);
        }
    }, [forwardedRef, onFocusPath]);
    const handleAutocompleteFocus = useCallback((event) => {
        if (onFocusPath && event.currentTarget === forwardedRef.current) {
            onFocusPath(REF_PATH);
        }
    }, [forwardedRef, onFocusPath]);
    const handleQueryChange = useObservableCallback((inputValue$) => {
        return inputValue$.pipe(filter(isNonNullable), distinctUntilChanged(), switchMap((searchString) => concat(of({ isLoading: true }), onSearch(searchString).pipe(map((hits) => ({ hits, searchString, isLoading: false })), catchError((error) => {
            push({
                title: 'Reference search failed',
                description: error.message,
                status: 'error',
                id: `reference-search-fail-${inputId}`,
            });
            console.error(error);
            return of({ hits: [] });
        })))), scan((prevState, nextState) => ({ ...prevState, ...nextState }), INITIAL_SEARCH_STATE), tap(setSearchState));
    }, []);
    const handleAutocompleteOpenButtonClick = useCallback(() => {
        handleQueryChange('');
    }, [handleQueryChange]);
    const showWeakRefMismatch = !loadableReferenceInfo.isLoading && hasRef && weakIs !== weakShouldBe;
    const inputId = useId();
    const studioUrl = (value?._ref &&
        schemaType.studioUrl?.({
            id: value?._ref,
            type: loadableReferenceInfo?.result?.type,
        })) ||
        null;
    const renderOption = useCallback((option) => {
        return (React.createElement(PreviewCard, { forwardedAs: "button", type: "button", radius: 2 },
            React.createElement(Box, { paddingX: 3, paddingY: 1 },
                React.createElement(OptionPreview, { referenceType: schemaType, document: option.hit.published, getReferenceInfo: getReferenceInfoMemo }))));
    }, [schemaType, getReferenceInfoMemo]);
    const preview = loadableReferenceInfo.result?.preview.published;
    const isEditing = hasFocusAtRef || !value?._ref;
    // --- click outside handling
    const clickOutsideBoundaryRef = useRef(null);
    const autocompletePortalRef = useRef(null);
    const createButtonMenuPortalRef = useRef(null);
    useOnClickOutside([clickOutsideBoundaryRef, autocompletePortalRef, createButtonMenuPortalRef], () => {
        if (hasFocusAtRef) {
            onFocusPath([]);
        }
    });
    return (React.createElement(Stack, { space: 1, marginY: isEditing ? 2 : 0 }, isEditing ? (React.createElement(Stack, { space: 2, ref: clickOutsideBoundaryRef },
        React.createElement(ChangeIndicator, { path: path, isChanged: changed, hasFocus: !!focused },
            React.createElement("div", { ref: autocompletePopoverReferenceElementRef },
                React.createElement(ReferenceAutocomplete, { "data-testid": "autocomplete", loading: searchState.isLoading, ref: forwardedRef, referenceElement: autocompletePopoverReferenceElementRef.current, portalRef: autocompletePortalRef, id: inputId || '', options: searchState.hits.map((hit) => ({
                        value: hit.id,
                        hit: hit,
                    })), onFocus: handleAutocompleteFocus, onBlur: onBlur, radius: 1, placeholder: "Type to search", onKeyDown: handleAutocompleteKeyDown, readOnly: readOnly, disabled: loadableReferenceInfo.isLoading, onQueryChange: handleQueryChange, searchString: searchState.searchString, onChange: handleChange, filterOption: NO_FILTER, renderOption: renderOption, openButton: { onClick: handleAutocompleteOpenButtonClick } }))))) : (React.createElement(ChangeIndicator, { path: path, isChanged: changed, hasFocus: !!focused },
        React.createElement(Card, { padding: 0, border: true, radius: 1, tone: readOnly
                ? 'transparent'
                : loadableReferenceInfo.error || errors.length > 0
                    ? 'critical'
                    : 'default' },
            React.createElement(Flex, { align: "center", padding: 1 },
                studioUrl ? (React.createElement(PreviewCard, { forwardedAs: "a", target: "_blank", rel: "noopener noreferrer", href: studioUrl, "data-as": "a", flex: 1, padding: 1, paddingRight: 3, radius: 2, tone: "inherit", __unstable_focusRing: true, tabIndex: 0, onFocus: handleFocus, ref: forwardedRef },
                    React.createElement(PreviewReferenceValue, { value: value, referenceInfo: loadableReferenceInfo, showStudioUrlIcon: true, hasStudioUrl: !!studioUrl, type: schemaType }))) : (React.createElement(PreviewCard, { flex: 1, padding: 1, paddingRight: 3, radius: 2, tone: "inherit", __unstable_focusRing: true, tabIndex: 0, onFocus: handleFocus, ref: forwardedRef },
                    React.createElement(PreviewReferenceValue, { value: value, referenceInfo: loadableReferenceInfo, showStudioUrlIcon: true, type: schemaType }))),
                React.createElement(Inline, { paddingX: 1 },
                    React.createElement(MenuButton, { button: React.createElement(Button, { padding: 2, mode: "bleed", icon: EllipsisVerticalIcon, "data-testid": "menu-button" }), id: `${inputId}-menuButton`, menu: React.createElement(Menu, null, !readOnly && (React.createElement(React.Fragment, null,
                            React.createElement(MenuItem, { text: "Clear", tone: "critical", icon: ClearIcon, "data-testid": "menu-item-clear", onClick: handleClear }),
                            React.createElement(MenuItem, { text: "Replace", icon: ReplaceIcon, "data-testid": "menu-item-replace", onClick: () => {
                                    onFocusPath(REF_PATH);
                                } })))), placement: "right", popover: { portal: true, tone: 'default' } }))),
            showWeakRefMismatch && (React.createElement(AlertStrip, { padding: 1, title: "Reference strength mismatch", status: "warning", "data-testid": "alert-reference-strength-mismatch" },
                React.createElement(Stack, { space: 3 },
                    React.createElement(Text, { as: "p", muted: true, size: 1 },
                        "This reference is ",
                        React.createElement("em", null, weakIs),
                        ", but according to the current schema it should be ",
                        React.createElement("em", null,
                            weakShouldBe,
                            ".")),
                    React.createElement(Text, { as: "p", muted: true, size: 1 }, schemaType.weak ? (React.createElement(React.Fragment, null,
                        "It will not be possible to delete the \"",
                        preview?.title,
                        "\"-document without first removing this reference.")) : (React.createElement(React.Fragment, null,
                        "This makes it possible to delete the \"",
                        preview?.title,
                        "\"-document without first deleting this reference, leaving this field referencing a nonexisting document."))),
                    React.createElement(Button, { onClick: handleFixStrengthMismatch, text: React.createElement(React.Fragment, null,
                            "Convert to ",
                            weakShouldBe,
                            " reference"), tone: "caution" })))),
            loadableReferenceInfo.error && (React.createElement(AlertStrip, { padding: 1, title: "Unable to load reference metadata", status: "warning", "data-testid": "alert-reference-info-failed" },
                React.createElement(Stack, { space: 3 },
                    React.createElement(Text, { as: "p", muted: true, size: 1 },
                        "Error: ",
                        loadableReferenceInfo.error.message),
                    React.createElement(Button, { onClick: loadableReferenceInfo.retry, text: React.createElement(React.Fragment, null, "Retry"), tone: "primary" })))))))));
}
//# sourceMappingURL=CrossDatasetReferenceInput.js.map