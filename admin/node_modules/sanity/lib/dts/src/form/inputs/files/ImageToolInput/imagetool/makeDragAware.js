import React from 'react';
import Debug from 'debug';
const debug = Debug('sanity-imagetool');
const supportsTouch = typeof window !== 'undefined' && 'ontouchstart' in window;
export function makeDragAware(Component) {
    return class DragAware extends React.PureComponent {
        constructor() {
            super(...arguments);
            this.domNode = null;
            this.currentPos = null;
            this.isDragging = false;
            this.handleTouchMove = (event) => {
                // Disables mobile scroll by touch
                if (this.isDragging) {
                    event.preventDefault();
                }
            };
            this.handleDragStart = (event) => {
                const { onDragStart, readOnly } = this.props;
                if (readOnly || !this.domNode) {
                    return;
                }
                if (this.isDragging) {
                    debug('Start cancelled, already a drag in progress');
                    return;
                }
                this.isDragging = true;
                const nextPos = getPos(event);
                debug('Drag started %o', nextPos);
                onDragStart(getPositionRelativeToRect(nextPos.x, nextPos.y, this.domNode.getBoundingClientRect()));
                this.currentPos = nextPos;
            };
            this.handleDrag = (event) => {
                if (!this.isDragging || this.props.readOnly || !this.currentPos) {
                    return;
                }
                const { onDrag } = this.props;
                const nextPos = getPos(event);
                const diff = diffPos(nextPos, this.currentPos);
                onDrag(diff);
                debug('moving by %o', diff);
                this.currentPos = nextPos;
            };
            this.handleDragEnd = (event) => {
                const { onDragEnd, readOnly } = this.props;
                if (!this.isDragging || readOnly || !this.domNode) {
                    return;
                }
                const nextPos = getPos(event);
                onDragEnd(getPositionRelativeToRect(nextPos.x, nextPos.y, this.domNode.getBoundingClientRect()));
                this.isDragging = false;
                this.currentPos = null;
                debug('Done moving %o', nextPos);
            };
            this.handleDragCancel = () => {
                if (!this.isDragging || this.props.readOnly || !this.currentPos || !this.domNode) {
                    return;
                }
                const { onDragEnd } = this.props;
                this.isDragging = false;
                onDragEnd(getPositionRelativeToRect(this.currentPos.x, this.currentPos.y, this.domNode.getBoundingClientRect()));
                this.currentPos = null;
            };
            this.setDomNode = (node) => {
                this.domNode = node;
            };
        }
        componentDidMount() {
            if (supportsTouch) {
                document.body.addEventListener('touchmove', this.handleTouchMove, { passive: false });
                document.body.addEventListener('touchend', this.handleDragEnd);
                document.body.addEventListener('touchcancel', this.handleDragCancel);
            }
            else {
                document.body.addEventListener('mousemove', this.handleDrag);
                document.body.addEventListener('mouseup', this.handleDragEnd);
                document.body.addEventListener('mouseleave', this.handleDragCancel);
            }
        }
        componentWillUnmount() {
            if (supportsTouch) {
                document.body.removeEventListener('touchmove', this.handleTouchMove);
                document.body.removeEventListener('touchend', this.handleDragEnd);
                document.body.removeEventListener('touchcancel', this.handleDragCancel);
            }
            else {
                document.body.removeEventListener('mousemove', this.handleDrag);
                document.body.removeEventListener('mouseup', this.handleDragEnd);
                document.body.removeEventListener('mouseleave', this.handleDragCancel);
            }
        }
        render() {
            const { readOnly, onDragStart, onDragEnd, onDrag, ...rest } = this.props;
            return (React.createElement(Component, { ref: this.setDomNode, onTouchStart: readOnly ? undefined : this.handleDragStart, onMouseDown: readOnly ? undefined : this.handleDragStart, onTouchMove: readOnly ? undefined : this.handleDrag, ...rest }));
        }
    };
}
function getPositionRelativeToRect(x, y, rect) {
    return {
        x: x - rect.left,
        y: y - rect.top,
    };
}
function getPos(event) {
    if ('touches' in event) {
        return event.touches.length > 0
            ? { x: event.touches[0].clientX, y: event.touches[0].clientY }
            : { x: 0, y: 0 };
    }
    return {
        x: event.clientX,
        y: event.clientY,
    };
}
function diffPos(pos, otherPos) {
    return {
        x: pos.x - otherPos.x,
        y: pos.y - otherPos.y,
    };
}
//# sourceMappingURL=makeDragAware.js.map