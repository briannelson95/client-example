import { Box, Button, Flex, Grid, Select, Text, useForwardedRef } from '@sanity/ui';
import { ChevronLeftIcon, ChevronRightIcon } from '@sanity/icons';
import { addDays, addMonths, setDate, setHours, setMinutes, setMonth, setYear } from 'date-fns';
import { range } from 'lodash';
import React, { forwardRef, useCallback, useEffect } from 'react';
import { CalendarMonth } from './CalendarMonth';
import { ARROW_KEYS, HOURS_24, MONTH_NAMES, DEFAULT_TIME_PRESETS } from './constants';
import { features } from './features';
import { formatTime } from './utils';
import { YearInput } from './YearInput';
// This is used to maintain focus on a child element of the calendar-grid between re-renders
// When using arrow keys to move focus from a day in one month to another we are setting focus at the button for the day
// after it has changed but *only* if we *already* had focus inside the calendar grid (e.g not if focus was on the "next
// year" button, or any of the other controls)
// When moving from the last day of a month that displays 6 weeks in the grid to a month that displays 5 weeks, current
// focus gets lost on render, so this provides us with a stable element to help us preserve focus on a child element of
// the calendar grid between re-renders
const PRESERVE_FOCUS_ELEMENT = (React.createElement("span", { "data-preserve-focus": true, style: { overflow: 'hidden', position: 'absolute', outline: 'none' }, tabIndex: -1 }));
export const Calendar = forwardRef(function Calendar(props, forwardedRef) {
    const { selectTime, onFocusedDateChange, selectedDate = new Date(), focusedDate = selectedDate, timeStep = 1, onSelect, ...restProps } = props;
    const setFocusedDate = useCallback((date) => onFocusedDateChange(date), [onFocusedDateChange]);
    const setFocusedDateMonth = useCallback((month) => setFocusedDate(setDate(setMonth(focusedDate, month), 1)), [focusedDate, setFocusedDate]);
    const handleFocusedMonthChange = useCallback((e) => setFocusedDateMonth(Number(e.currentTarget.value)), [setFocusedDateMonth]);
    const moveFocusedDate = useCallback((by) => setFocusedDate(addMonths(focusedDate, by)), [focusedDate, setFocusedDate]);
    const setFocusedDateYear = useCallback((year) => setFocusedDate(setYear(focusedDate, year)), [focusedDate, setFocusedDate]);
    const handleDateChange = useCallback((date) => {
        onSelect(setMinutes(setHours(date, selectedDate.getHours()), selectedDate.getMinutes()));
    }, [onSelect, selectedDate]);
    const handleMinutesChange = useCallback((event) => {
        const m = Number(event.currentTarget.value);
        onSelect(setMinutes(selectedDate, m));
    }, [onSelect, selectedDate]);
    const handleHoursChange = useCallback((event) => {
        const m = Number(event.currentTarget.value);
        onSelect(setHours(selectedDate, m));
    }, [onSelect, selectedDate]);
    const handleTimeChange = useCallback((hours, mins) => {
        onSelect(setHours(setMinutes(selectedDate, mins), hours));
    }, [onSelect, selectedDate]);
    const ref = useForwardedRef(forwardedRef);
    const focusCurrentWeekDay = useCallback(() => {
        ref.current?.querySelector(`[data-focused="true"]`)?.focus();
    }, [ref]);
    const handleKeyDown = useCallback((event) => {
        if (!ARROW_KEYS.includes(event.key)) {
            return;
        }
        event.preventDefault();
        if (event.target.hasAttribute('data-calendar-grid')) {
            focusCurrentWeekDay();
            return;
        }
        if (event.key === 'ArrowUp') {
            onFocusedDateChange(addDays(focusedDate, -7));
        }
        if (event.key === 'ArrowDown') {
            onFocusedDateChange(addDays(focusedDate, 7));
        }
        if (event.key === 'ArrowLeft') {
            onFocusedDateChange(addDays(focusedDate, -1));
        }
        if (event.key === 'ArrowRight') {
            onFocusedDateChange(addDays(focusedDate, 1));
        }
        // set focus temporarily on this element to make sure focus is still inside the calendar-grid after re-render
        ref.current?.querySelector('[data-preserve-focus]')?.focus();
    }, [ref, focusCurrentWeekDay, onFocusedDateChange, focusedDate]);
    useEffect(() => {
        focusCurrentWeekDay();
    }, [focusCurrentWeekDay]);
    useEffect(() => {
        const currentFocusInCalendarGrid = document.activeElement?.matches('[data-calendar-grid], [data-calendar-grid] [data-preserve-focus]');
        if (
        // Only move focus if it's currently in the calendar grid
        currentFocusInCalendarGrid) {
            focusCurrentWeekDay();
        }
    }, [ref, focusCurrentWeekDay, focusedDate]);
    const handleYesterdayClick = useCallback(() => handleDateChange(addDays(new Date(), -1)), [handleDateChange]);
    const handleTodayClick = useCallback(() => handleDateChange(new Date()), [handleDateChange]);
    const handleTomorrowClick = useCallback(() => handleDateChange(addDays(new Date(), 1)), [handleDateChange]);
    const handleNowClick = useCallback(() => onSelect(new Date()), [onSelect]);
    return (React.createElement(Box, { "data-ui": "Calendar", ...restProps, ref: ref },
        React.createElement(Box, { padding: 2 },
            features.dayPresets && (React.createElement(Grid, { columns: 3, "data-ui": "CalendaryDayPresets", gap: 1 },
                React.createElement(Button, { text: "Yesterday", mode: "bleed", fontSize: 1, onClick: handleYesterdayClick }),
                React.createElement(Button, { text: "Today", mode: "bleed", fontSize: 1, onClick: handleTodayClick }),
                React.createElement(Button, { text: "Tomorrow", mode: "bleed", fontSize: 1, onClick: handleTomorrowClick }))),
            React.createElement(Flex, null,
                React.createElement(Box, { flex: 1 },
                    React.createElement(CalendarMonthSelect, { moveFocusedDate: moveFocusedDate, onChange: handleFocusedMonthChange, value: focusedDate?.getMonth() })),
                React.createElement(Box, { marginLeft: 2 },
                    React.createElement(CalendarYearSelect, { moveFocusedDate: moveFocusedDate, onChange: setFocusedDateYear, value: focusedDate.getFullYear() }))),
            React.createElement(Box, { "data-calendar-grid": true, onKeyDown: handleKeyDown, marginTop: 2, overflow: "hidden", tabIndex: 0 },
                React.createElement(CalendarMonth, { date: focusedDate, focused: focusedDate, onSelect: handleDateChange, selected: selectedDate }),
                PRESERVE_FOCUS_ELEMENT)),
        selectTime && (React.createElement(Box, { padding: 2, style: { borderTop: '1px solid var(--card-border-color)' } },
            React.createElement(Flex, { align: "center" },
                React.createElement(Flex, { align: "center", flex: 1 },
                    React.createElement(Box, null,
                        React.createElement(Select, { "aria-label": "Select hour", value: selectedDate?.getHours(), onChange: handleHoursChange }, HOURS_24.map((h) => (React.createElement("option", { key: h, value: h }, `${h}`.padStart(2, '0')))))),
                    React.createElement(Box, { paddingX: 1 },
                        React.createElement(Text, null, ":")),
                    React.createElement(Box, null,
                        React.createElement(Select, { "aria-label": "Select minutes", value: selectedDate?.getMinutes(), onChange: handleMinutesChange }, range(0, 60, timeStep).map((m) => (React.createElement("option", { key: m, value: m }, `${m}`.padStart(2, '0'))))))),
                React.createElement(Box, { marginLeft: 2 },
                    React.createElement(Button, { text: "Set to current time", mode: "bleed", onClick: handleNowClick }))),
            features.timePresets && (React.createElement(Flex, { direction: "row", justify: "center", align: "center", style: { marginTop: 5 } }, DEFAULT_TIME_PRESETS.map(([hours, minutes]) => {
                return (React.createElement(CalendarTimePresetButton, { key: `${hours}-${minutes}`, hours: hours, minutes: minutes, onTimeChange: handleTimeChange, selectedDate: selectedDate }));
            })))))));
});
function CalendarTimePresetButton(props) {
    const { hours, minutes, onTimeChange, selectedDate } = props;
    const formatted = formatTime(hours, minutes);
    const handleClick = useCallback(() => {
        onTimeChange(hours, minutes);
    }, [hours, minutes, onTimeChange]);
    return (React.createElement(Button, { text: formatted, "aria-label": `${formatted} on ${selectedDate.toDateString()}`, mode: "bleed", fontSize: 1, onClick: handleClick }));
}
function CalendarMonthSelect(props) {
    const { moveFocusedDate, onChange, value } = props;
    const handlePrevMonthClick = useCallback(() => moveFocusedDate(-1), [moveFocusedDate]);
    const handleNextMonthClick = useCallback(() => moveFocusedDate(1), [moveFocusedDate]);
    return (React.createElement(Flex, { flex: 1 },
        React.createElement(Button, { "aria-label": "Go to previous month", onClick: handlePrevMonthClick, mode: "bleed", icon: ChevronLeftIcon, paddingX: 2, radius: 0 }),
        React.createElement(Box, { flex: 1 },
            React.createElement(Select, { radius: 0, value: value, onChange: onChange }, MONTH_NAMES.map((m, i) => (
            // eslint-disable-next-line react/no-array-index-key
            React.createElement("option", { key: i, value: i }, m))))),
        React.createElement(Button, { "aria-label": "Go to next month", mode: "bleed", icon: ChevronRightIcon, onClick: handleNextMonthClick, paddingX: 2, radius: 0 })));
}
function CalendarYearSelect(props) {
    const { moveFocusedDate, onChange, value } = props;
    const handlePrevYearClick = useCallback(() => moveFocusedDate(-12), [moveFocusedDate]);
    const handleNextYearClick = useCallback(() => moveFocusedDate(12), [moveFocusedDate]);
    return (React.createElement(Flex, null,
        React.createElement(Button, { "aria-label": "Previous year", onClick: handlePrevYearClick, mode: "bleed", icon: ChevronLeftIcon, paddingX: 2, radius: 0 }),
        React.createElement(YearInput, { value: value, onChange: onChange, radius: 0, style: { width: 65 } }),
        React.createElement(Button, { "aria-label": "Next year", onClick: handleNextYearClick, mode: "bleed", icon: ChevronRightIcon, paddingX: 2, radius: 0 })));
}
//# sourceMappingURL=Calendar.js.map