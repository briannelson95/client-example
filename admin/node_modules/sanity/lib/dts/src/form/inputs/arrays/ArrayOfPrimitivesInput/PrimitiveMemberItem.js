import * as React from 'react';
import { useCallback, useMemo, useRef } from 'react';
import { useDidUpdate } from '../../../hooks/useDidUpdate';
import { useFormCallbacks } from '../../../studio/contexts/FormCallbacks';
import { insert, PatchEvent, set, unset } from '../../../patch';
import { getEmptyValue } from './getEmptyValue';
/**
 * @alpha
 */
export function PrimitiveMemberItem(props) {
    const focusRef = useRef();
    const { member, renderItem, renderInput } = props;
    const { onPathBlur, onPathFocus, onChange } = useFormCallbacks();
    useDidUpdate(member.item.focused, (hadFocus, hasFocus) => {
        if (!hadFocus && hasFocus) {
            focusRef.current?.focus();
        }
    });
    const handleBlur = useCallback((event) => {
        onPathBlur(member.item.path);
    }, [member.item.path, onPathBlur]);
    const handleFocus = useCallback((event) => {
        onPathFocus(member.item.path);
    }, [member.item.path, onPathFocus]);
    const handleChange = useCallback((event) => {
        const patches = PatchEvent.from(event).patches.map((patch) => 
        // Map direct unset patches to empty value instead in order to not *remove* elements as the user clears out the value
        // note: this creates the rather "weird" case where the input renders ´0´ when you try to clear it
        patch.path.length === 0 && patch.type === 'unset'
            ? set(getEmptyValue(member.item.schemaType))
            : patch);
        onChange(PatchEvent.from(patches).prefixAll(member.index));
    }, [onChange, member.item.schemaType, member.index]);
    const inputProps = useMemo(() => {
        return {
            changed: member.item.changed,
            level: member.item.level,
            value: member.item.value,
            readOnly: member.item.readOnly,
            schemaType: member.item.schemaType,
            focusRef: focusRef,
            id: member.item.id,
            onBlur: handleBlur,
            onFocus: handleFocus,
            path: member.item.path,
            focused: member.item.focused,
            onChange: handleChange,
            validation: member.item.validation,
            presence: member.item.presence,
        };
    }, [
        member.item.level,
        member.item.value,
        member.item.readOnly,
        member.item.schemaType,
        member.item.id,
        member.item.path,
        member.item.focused,
        member.item.validation,
        member.item.presence,
        member.item.changed,
        handleBlur,
        handleFocus,
        handleChange,
    ]);
    const renderedInput = useMemo(() => renderInput(inputProps), [inputProps, renderInput]);
    const onRemove = useCallback(() => {
        onChange(PatchEvent.from([unset([member.index])]));
    }, [member.index, onChange]);
    const onInsert = useCallback((event) => {
        onChange(PatchEvent.from([insert(event.items, event.position, [member.index])]));
    }, [member.index, onChange]);
    const itemProps = useMemo(() => {
        return {
            key: member.key,
            index: member.index,
            level: member.item.level,
            value: member.item.value,
            title: member.item.schemaType.title,
            description: member.item.schemaType.description,
            schemaType: member.item.schemaType,
            onInsert,
            onRemove,
            presence: member.item.presence,
            validation: member.item.validation,
            readOnly: member.item.readOnly,
            focused: member.item.focused,
            onFocus: handleFocus,
            inputId: member.item.id,
            path: member.item.path,
            children: renderedInput,
        };
    }, [
        member.key,
        member.index,
        member.item.level,
        member.item.value,
        member.item.schemaType,
        member.item.presence,
        member.item.validation,
        member.item.readOnly,
        member.item.focused,
        member.item.id,
        member.item.path,
        onInsert,
        onRemove,
        handleFocus,
        renderedInput,
    ]);
    return React.createElement(React.Fragment, null, useMemo(() => renderItem(itemProps), [itemProps, renderItem]));
}
//# sourceMappingURL=PrimitiveMemberItem.js.map