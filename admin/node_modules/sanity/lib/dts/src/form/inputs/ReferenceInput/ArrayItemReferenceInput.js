/* eslint-disable complexity */
/* eslint-disable max-nested-callbacks,no-nested-ternary */
import React, { forwardRef, useCallback, useMemo, useRef, useState, } from 'react';
import { EllipsisVerticalIcon, LaunchIcon as OpenInNewTabIcon, SyncIcon as ReplaceIcon, TrashIcon, CopyIcon as DuplicateIcon, } from '@sanity/icons';
import { concat, of } from 'rxjs';
import { catchError, distinctUntilChanged, filter, map, scan, switchMap, tap } from 'rxjs/operators';
import { Badge, Box, Button, Card, Flex, Inline, Menu, MenuButton, MenuDivider, MenuItem, Stack, Text, Tooltip, useForwardedRef, useToast, } from '@sanity/ui';
import { useObservableCallback } from 'react-rx';
import { uuid } from '@sanity/uuid';
import { useId } from '@reach/auto-id';
import styled from 'styled-components';
import { FormField, FormFieldValidationStatus } from '../../components/formField';
import { PreviewCard } from '../../../components/PreviewCard';
import { FieldPresence } from '../../../presence';
import { IntentLink } from '../../../router';
import { set, setIfMissing, unset } from '../../patch';
import { EMPTY_ARRAY } from '../../utils/empty';
// import {useDidUpdate} from '../../hooks/useDidUpdate'
import { isNonNullable } from '../../utils/isNonNullable';
import { AlertStrip } from '../../components/AlertStrip';
import { RowWrapper } from '../arrays/ArrayOfObjectsInput/item/components/RowWrapper';
import { DragHandle } from '../arrays/common/DragHandle';
import { InsertMenu } from '../arrays/ArrayOfObjectsInput/InsertMenu';
import { useOnClickOutside } from '../../hooks/useOnClickOutside';
import { getPublishedId } from '../../../util';
import { OptionPreview } from './OptionPreview';
import { useReferenceInfo } from './useReferenceInfo';
import { PreviewReferenceValue } from './PreviewReferenceValue';
import { CreateButton } from './CreateButton';
import { ReferenceAutocomplete } from './ReferenceAutocomplete';
import { AutocompleteContainer } from './AutocompleteContainer';
const StyledPreviewCard = styled(PreviewCard) `
  /* this is a hack to avoid layout jumps while previews are loading
  there's probably better ways of solving this */
  min-height: 36px;
`;
const INITIAL_SEARCH_STATE = {
    hits: [],
    isLoading: false,
};
const NO_FILTER = () => true;
const dragHandle = React.createElement(DragHandle, { paddingX: 1, paddingY: 3 });
function valueHasRef(value) {
    return typeof value._ref === 'string';
}
export function ArrayItemReferenceInput(props) {
    const { schemaType: type, value, validation, liveEdit, onSearch, onChange, insertableTypes, focusPath = EMPTY_ARRAY, presence, createOptions, isSortable, level, onInsert, selectedState, editReferenceLinkComponent: EditReferenceLink, onEditReference, getReferenceInfo, onBlur, onFocus, onFocusPath, readOnly, focusRef, renderPreview, } = props;
    const forwardedRef = useForwardedRef(focusRef);
    const [searchState, setSearchState] = useState(INITIAL_SEARCH_STATE);
    const handleCreateNew = (option) => {
        const id = uuid();
        const patches = [
            setIfMissing({}),
            set(type.name, ['_type']),
            set(id, ['_ref']),
            set(true, ['_weak']),
            set({ type: option.type, weak: type.weak, template: option.template }, [
                '_strengthenOnPublish',
            ]),
        ];
        onChange(patches);
        onEditReference({ id, type: option.type, template: option.template });
        onFocusPath([]);
    };
    const handleDuplicate = useCallback(() => {
        if (value?._key) {
            // todo
            // onInsert?.({
            //   items: [{...value, _key: randomKey()}],
            //   position: 'after',
            // })
        }
    }, [onInsert, value]);
    const handleInsert = useCallback((pos) => {
        if (value?._key) {
            // todo
            // onInsert?.({
            //   item: {_type: type.name, _key: randomKey()},
            //   position: pos,
            // })
        }
    }, [onInsert, type.name, value?._key]);
    const handleChange = useCallback((id) => {
        if (!id) {
            onChange(unset());
            onFocusPath([]);
            return;
        }
        const hit = searchState.hits.find((h) => h.id === id);
        if (!hit) {
            throw new Error('Selected an item that wasnt part of the result set');
        }
        const patches = [
            setIfMissing({}),
            set(type.name, ['_type']),
            set(getPublishedId(id), ['_ref']),
            // if there's no published version of this document, set the reference to weak
            hit.published && !type.weak ? unset(['_weak']) : set(true, ['_weak']),
            hit.published
                ? unset(['_strengthenOnPublish'])
                : set({ type: hit?.type, weak: type.weak }, ['_strengthenOnPublish']),
        ].filter(isNonNullable);
        onChange(patches);
        onFocusPath([]);
    }, [searchState.hits, type.name, type.weak, onChange, onFocusPath]);
    const handleClear = useCallback(() => {
        onChange(unset());
    }, [onChange]);
    const handlePreviewKeyPress = useCallback((event) => {
        if (event.key !== 'Enter' && event.key !== 'Space') {
            // enable "search for reference"-mode
            onFocusPath(['_ref']);
        }
    }, [onFocusPath]);
    const handleCancelEdit = useCallback(() => {
        if (!value?._ref) {
            onChange(unset());
        }
        onFocusPath([]);
    }, [onChange, onFocus, value?._ref]);
    const handleAutocompleteKeyDown = useCallback((event) => {
        // escape
        if (event.keyCode === 27) {
            handleCancelEdit();
        }
    }, [handleCancelEdit]);
    const getReferenceInfoMemo = useCallback((id) => getReferenceInfo(id, type), [getReferenceInfo, type]);
    const loadableReferenceInfo = useReferenceInfo(value?._ref, getReferenceInfoMemo);
    const refTypeName = loadableReferenceInfo.result?.type || value?._strengthenOnPublish?.type;
    const refType = refTypeName ? type.to.find((toType) => toType.name === refTypeName) : undefined;
    // --- focus handling
    const hasFocusAtRef = focusPath.length === 1 && (focusPath[0] === '_ref' || focusPath[0] === '$');
    // const focusElementRef = useForwardedRef(forwardedRef)
    // useDidUpdate({hasFocusAt: hasFocusAtRef, ref: value?._ref}, (prev, current) => {
    //   const refUpdated = prev?.ref !== current.ref
    //   const focusAtUpdated = prev?.hasFocusAt !== current.hasFocusAt
    //   if ((focusAtUpdated || refUpdated) && current.hasFocusAt) {
    //     // if search mode changed and we're having focus always ensure the
    //     // ref element gets focus
    //     focusElementRef.current?.focus()
    //   }
    // })
    const weakIs = value?._weak ? 'weak' : 'strong';
    const weakShouldBe = type.weak === true ? 'weak' : 'strong';
    const hasRef = value && valueHasRef(value);
    // If the reference value is marked with _strengthenOnPublish,
    // we allow weak references if the reference points to a document that has a draft but not a published
    // In all other cases we should display a "weak mismatch" warning
    const weakWarningOverride = hasRef && !loadableReferenceInfo.isLoading && value?._strengthenOnPublish;
    const handleFixStrengthMismatch = useCallback(() => {
        onChange(type.weak === true ? set(true, ['_weak']) : unset(['_weak']));
    }, [onChange, type]);
    const referenceExists = hasRef && loadableReferenceInfo.result?.preview?.published?._id;
    const handleRemoveStrengthenOnPublish = useCallback(() => {
        onChange([
            type.weak === true ? set(true, ['_weak']) : unset(['_weak']),
            unset(['_strengthenOnPublish']),
        ]);
    }, [onChange, type]);
    const { push } = useToast();
    const errors = useMemo(() => validation.filter((item) => item.level === 'error'), [validation]);
    const pressed = selectedState === 'pressed';
    const selected = selectedState === 'selected';
    const handleFocus = useCallback((event) => {
        if (event.currentTarget === forwardedRef.current) {
            onFocus(event);
        }
    }, [onFocus, forwardedRef]);
    const handleAutocompleteFocus = useCallback((event) => {
        if (onFocusPath && event.currentTarget === forwardedRef.current) {
            onFocusPath(['_ref']);
        }
    }, [onFocusPath, forwardedRef]);
    const handleQueryChange = useObservableCallback((inputValue$) => {
        return inputValue$.pipe(filter(isNonNullable), distinctUntilChanged(), switchMap((searchString) => concat(of({ isLoading: true }), onSearch(searchString).pipe(map((hits) => ({ hits, isLoading: false, searchString })), catchError((error) => {
            push({
                title: 'Reference search failed',
                description: error.message,
                status: 'error',
                id: `reference-search-fail-${inputId}`,
            });
            console.error(error);
            return of({ hits: [] });
        })))), scan((prevState, nextState) => ({ ...prevState, ...nextState }), INITIAL_SEARCH_STATE), tap(setSearchState));
    }, []);
    const handleAutocompleteOpenButtonClick = useCallback(() => {
        handleQueryChange('');
    }, [handleQueryChange]);
    const showWeakRefMismatch = !loadableReferenceInfo.isLoading && hasRef && weakIs !== weakShouldBe && !weakWarningOverride;
    const inputId = useId();
    const handleCreateButtonKeyDown = useCallback((e) => {
        if (e.key === 'Escape') {
            forwardedRef.current?.focus();
        }
    }, [forwardedRef]);
    const renderOption = useCallback((option) => {
        const id = option.hit.draft?._id || option.hit.published?._id;
        return (React.createElement(PreviewCard, { as: "button", type: "button", radius: 2 },
            React.createElement(Box, { paddingX: 3, paddingY: 1 },
                React.createElement(OptionPreview, { getReferenceInfo: getReferenceInfoMemo, id: id, renderPreview: renderPreview, type: type }))));
    }, [type, getReferenceInfoMemo, renderPreview]);
    const OpenLink = useMemo(() => 
    // eslint-disable-next-line @typescript-eslint/no-shadow
    forwardRef(function OpenLink(restProps, _ref) {
        const template = (value?._strengthenOnPublish || {}).template;
        return (React.createElement(IntentLink, { ...restProps, intent: "edit", params: [
                { id: value?._ref, type: refType?.name, template: template?.id },
                { params: template?.params },
            ], target: "_blank", rel: "noopener noreferrer", ref: _ref }));
    }), [refType?.name, value?._ref, value?._strengthenOnPublish]);
    const preview = loadableReferenceInfo.result?.preview.draft || loadableReferenceInfo.result?.preview.published;
    const isEditing = hasFocusAtRef;
    // --- click outside handling
    const clickOutsideBoundaryRef = useRef(null);
    const autocompletePortalRef = useRef(null);
    const createButtonMenuPortalRef = useRef(null);
    useOnClickOutside([clickOutsideBoundaryRef, autocompletePortalRef, createButtonMenuPortalRef], () => {
        if (isEditing) {
            handleCancelEdit();
        }
    });
    const autocompletePopoverReferenceElementRef = useRef(null);
    return (React.createElement(RowWrapper, { radius: 2, padding: 1, tone: (isEditing
            ? ' default'
            : readOnly
                ? 'transparent'
                : loadableReferenceInfo.error || errors.length > 0
                    ? 'critical'
                    : showWeakRefMismatch
                        ? 'caution'
                        : 'default') },
        React.createElement(Flex, { align: "center" },
            !isEditing && isSortable && !readOnly && (React.createElement(Card, { className: "dragHandle", tone: "inherit", marginRight: 1 }, dragHandle)),
            isEditing ? (React.createElement(Box, { flex: 1, padding: 1, ref: clickOutsideBoundaryRef },
                React.createElement(FormField, { validation: validation, __unstable_presence: presence, inputId: inputId, title: type.title, level: level, description: type.description },
                    React.createElement(AutocompleteContainer, { ref: autocompletePopoverReferenceElementRef },
                        React.createElement(ReferenceAutocomplete, { "data-testid": "autocomplete", loading: searchState.isLoading, portalRef: autocompletePortalRef, ref: forwardedRef, id: inputId || '', options: searchState.hits.map((hit) => ({
                                value: hit.id,
                                hit: hit,
                            })), onFocus: handleAutocompleteFocus, onBlur: onBlur, radius: 1, placeholder: "Type to search", onKeyDown: handleAutocompleteKeyDown, readOnly: readOnly, disabled: loadableReferenceInfo.isLoading, onQueryChange: handleQueryChange, searchString: searchState.searchString, onChange: handleChange, referenceElement: autocompletePopoverReferenceElementRef.current, filterOption: NO_FILTER, renderOption: renderOption, openButton: { onClick: handleAutocompleteOpenButtonClick } }),
                        !readOnly && createOptions.length > 0 && (React.createElement(CreateButton, { menuRef: createButtonMenuPortalRef, id: `${inputId}-selectTypeMenuButton`, createOptions: createOptions, onCreate: handleCreateNew, onKeyDown: handleCreateButtonKeyDown })))))) : (React.createElement(Box, { flex: 1 },
                React.createElement(Flex, { align: "center" },
                    hasRef ? (React.createElement(StyledPreviewCard, { flex: 1, padding: 1, paddingRight: 3, radius: 2, forwardedAs: EditReferenceLink, documentId: value?._ref, documentType: refType?.name, "data-as": "a", tone: selected ? 'default' : 'inherit', __unstable_focusRing: true, tabIndex: 0, selected: selected, pressed: pressed, onKeyPress: handlePreviewKeyPress, onFocus: handleFocus, "data-selected": selected ? true : undefined, "data-pressed": pressed ? true : undefined, ref: forwardedRef },
                        React.createElement(PreviewReferenceValue, { value: value, referenceInfo: loadableReferenceInfo, renderPreview: renderPreview, type: type }))) : (React.createElement(Card, { flex: 1, padding: 3, marginRight: 1, radius: 2, tone: "inherit", as: "button", __unstable_focusRing: true, tabIndex: 0, onClick: () => onFocusPath(['_ref']), ref: forwardedRef },
                        React.createElement(Box, { marginY: 1 },
                            React.createElement(Text, { muted: true }, "Empty reference")))),
                    React.createElement(Inline, { marginLeft: !readOnly && presence.length > 0 ? 2 : undefined },
                        !readOnly && presence.length > 0 && (React.createElement(Box, { marginLeft: 1 },
                            React.createElement(FieldPresence, { presence: presence, maxAvatars: 1 }))),
                        validation.length > 0 && (React.createElement(Box, { marginLeft: 1, paddingX: 1, paddingY: 3 },
                            React.createElement(FormFieldValidationStatus, { validation: validation }))),
                        !value?._key && (React.createElement(Box, { marginLeft: 1 },
                            React.createElement(Tooltip, { content: React.createElement(Box, { padding: 2 },
                                    React.createElement(Text, { muted: true, size: 1 },
                                        "This item is missing the required ",
                                        React.createElement("code", null, "_key"),
                                        " property.")), placement: "top" },
                                React.createElement(Badge, { mode: "outline", tone: "caution" }, "Missing key")))))))),
            !isEditing && (React.createElement(Box, { marginLeft: 1 },
                React.createElement(MenuButton, { button: React.createElement(Button, { paddingY: 3, paddingX: 2, mode: "bleed", icon: EllipsisVerticalIcon }), id: `${inputId}-menuButton`, menu: React.createElement(Menu, null,
                        !readOnly && (React.createElement(React.Fragment, null,
                            React.createElement(MenuItem, { text: "Remove", tone: "critical", icon: TrashIcon, onClick: handleClear }),
                            React.createElement(MenuItem, { text: "Replace", icon: ReplaceIcon, onClick: () => {
                                    onFocusPath(['_ref']);
                                } }),
                            React.createElement(MenuItem, { text: "Duplicate", icon: DuplicateIcon, onClick: handleDuplicate }),
                            React.createElement(InsertMenu, { onInsert: handleInsert, types: insertableTypes }))),
                        !readOnly && hasRef && React.createElement(MenuDivider, null),
                        hasRef && (React.createElement(MenuItem, { as: OpenLink, "data-as": "a", text: "Open in new tab", icon: OpenInNewTabIcon }))), placement: "right", popover: { portal: true, tone: 'default' } })))),
        liveEdit && referenceExists && value._strengthenOnPublish && (React.createElement(AlertStrip, { padding: 1, title: type.weak ? 'Finalize reference' : 'Convert to strong reference', status: "info", "data-testid": "alert-reference-published" },
            React.createElement(Stack, { space: 3 },
                React.createElement(Text, { as: "p", muted: true, size: 1 },
                    React.createElement("strong", null, loadableReferenceInfo.result?.preview.published?.title),
                    " is published and this reference should now be",
                    ' ',
                    type.weak ? React.createElement(React.Fragment, null, "finalized") : React.createElement(React.Fragment, null, "converted to a strong reference"),
                    "."),
                React.createElement(Button, { onClick: handleRemoveStrengthenOnPublish, text: React.createElement(React.Fragment, null, "Convert to strong reference"), tone: "positive" })))),
        showWeakRefMismatch && (React.createElement(AlertStrip, { padding: 1, title: "Reference strength mismatch", status: "warning", "data-testid": "alert-reference-strength-mismatch" },
            React.createElement(Stack, { space: 3 },
                React.createElement(Text, { as: "p", muted: true, size: 1 },
                    "This reference is ",
                    React.createElement("em", null, weakIs),
                    ", but according to the current schema it should be",
                    ' ',
                    React.createElement("em", null,
                        weakShouldBe,
                        ".")),
                React.createElement(Text, { as: "p", muted: true, size: 1 }, type.weak ? (React.createElement(React.Fragment, null,
                    "It will not be possible to delete the \"",
                    preview?.title,
                    "\"-document without first removing this reference.")) : (React.createElement(React.Fragment, null,
                    "This makes it possible to delete the \"",
                    preview?.title,
                    "\"-document without first deleting this reference, leaving this field referencing a nonexisting document."))),
                React.createElement(Button, { onClick: handleFixStrengthMismatch, text: React.createElement(React.Fragment, null,
                        "Convert to ",
                        weakShouldBe,
                        " reference"), tone: "caution" })))),
        loadableReferenceInfo.error && (React.createElement(AlertStrip, { padding: 1, title: "Unable to load reference metadata", status: "warning", "data-testid": "alert-reference-info-failed" },
            React.createElement(Stack, { space: 3 },
                React.createElement(Text, { as: "p", muted: true, size: 1 },
                    "Error: ",
                    loadableReferenceInfo.error.message),
                React.createElement(Button, { onClick: loadableReferenceInfo.retry, text: React.createElement(React.Fragment, null, "Retry"), tone: "primary" }))))));
}
//# sourceMappingURL=ArrayItemReferenceInput.js.map