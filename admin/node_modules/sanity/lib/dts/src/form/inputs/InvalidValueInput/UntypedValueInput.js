import React, { useCallback, useMemo } from 'react';
import { Button, Card, Code, Grid, Stack, Text } from '@sanity/ui';
import { useSchema } from '../../../hooks';
import { PatchEvent, setIfMissing, unset } from '../../patch';
import { Alert } from '../../components/Alert';
import { Details } from '../../components/Details';
import { isDev } from '../../../environment';
function SetMissingTypeButton({ value, targetType, onChange, }) {
    const itemValue = useMemo(() => ({ ...value, _type: targetType }), [targetType, value]);
    const handleClick = useCallback(() => onChange(PatchEvent.from(setIfMissing(targetType, ['_type'])), itemValue), [itemValue, onChange, targetType]);
    return (React.createElement(Button, { onClick: handleClick, text: React.createElement(React.Fragment, null,
            "Convert to ",
            React.createElement("code", null, targetType)) }));
}
function UnsetItemButton({ value, onChange, validTypes, }) {
    // Doesn't matter which `_type` we use as long as it's allowed by the array
    const itemValue = useMemo(() => ({ ...value, _type: validTypes[0] }), [validTypes, value]);
    const handleClick = useCallback(() => onChange(PatchEvent.from(unset()), itemValue), [itemValue, onChange]);
    return React.createElement(Button, { onClick: handleClick, tone: "critical", text: "Unset value" });
}
/**
 * When the value does not have an `_type` property,
 * but the schema has a named type
 */
export function UntypedValueInput({ validTypes, value, onChange }) {
    const schema = useSchema();
    const isSingleValidType = validTypes.length === 1;
    const isHoistedType = schema.has(validTypes[0]);
    return (React.createElement(Alert, { status: "warning", title: React.createElement(React.Fragment, null,
            "Property value missing ",
            React.createElement("code", null, "_type")) },
        React.createElement(Details, { open: isDev, title: React.createElement(React.Fragment, null, "Developer info") },
            React.createElement(Stack, { space: 3 },
                React.createElement(Text, { as: "p", muted: true, size: 1 },
                    "Encountered an object value without a ",
                    React.createElement("code", null, "_type"),
                    " property."),
                isSingleValidType && !isHoistedType && (React.createElement(Text, { as: "p", muted: true, size: 1 },
                    "Either remove the ",
                    React.createElement("code", null, "name"),
                    " property of the object declaration, or set",
                    ' ',
                    React.createElement("code", null, "_type"),
                    " property on items.")),
                !isSingleValidType && (React.createElement(Text, { as: "p", muted: true, size: 1 }, "The following types are valid here according to schema:")),
                !isSingleValidType && (React.createElement(Stack, { as: "ul", space: 2 }, validTypes.map((validType) => (React.createElement(Text, { as: "li", key: validType, muted: true, size: 1 },
                    React.createElement("code", null, validType)))))),
                React.createElement(Stack, { space: 2 },
                    React.createElement(Text, { as: "h4", weight: "semibold", size: 1 },
                        "Current value (",
                        React.createElement("code", null, "object"),
                        "):"),
                    React.createElement(Card, { border: true, overflow: "auto", padding: 2, radius: 2, tone: "inherit" },
                        React.createElement(Code, { language: "json" }, JSON.stringify(value, null, 2)))),
                React.createElement(Grid, { columns: [1, 2, 2], gap: 1 },
                    isSingleValidType && (React.createElement(SetMissingTypeButton, { onChange: onChange, targetType: validTypes[0], value: value })),
                    React.createElement(UnsetItemButton, { onChange: onChange, validTypes: validTypes, value: value }))))));
}
//# sourceMappingURL=UntypedValueInput.js.map