import { useCallback, useMemo } from 'react';
import { catchError, concatMap, map, startWith } from 'rxjs/operators';
import { concat, of, Subject } from 'rxjs';
import { useObservable } from 'react-rx';
import { usePrevious } from '../../hooks/usePrevious';
const noop = () => undefined;
const INITIAL_LOADING_STATE = {
    isLoading: true,
    result: undefined,
    error: undefined,
    retry: noop,
};
const EMPTY_STATE = {
    isLoading: false,
    result: undefined,
    error: undefined,
    retry: noop,
};
export function useReferenceInfo(id, getReferenceInfo) {
    // NOTE: this is a small message queue to handle retries
    const msgSubject = useMemo(() => new Subject(), []);
    const msg$ = useMemo(() => msgSubject.asObservable(), [msgSubject]);
    const retry = useCallback(() => {
        msgSubject.next({ type: 'retry' });
    }, [msgSubject]);
    const stream$ = useMemo(() => concat(of(null), msg$).pipe(map(() => id), concatMap((refId) => refId
        ? getReferenceInfo(refId).pipe(map((result) => {
            return {
                isLoading: false,
                result,
                error: undefined,
                retry,
            };
        }), startWith(INITIAL_LOADING_STATE), catchError((err) => {
            console.error(err);
            return of({ isLoading: false, result: undefined, error: err, retry });
        }))
        : of(EMPTY_STATE))), [getReferenceInfo, id, retry, msg$]);
    const referenceInfo = useObservable(stream$, INITIAL_LOADING_STATE);
    // const referenceInfo = useMemoObservable(
    //   () => stream$,
    //   [retryAttempt, getReferenceInfo, id, retry],
    //   INITIAL_LOADING_STATE
    // )
    // workaround for a "bug" with useMemoObservable that doesn't
    // return the initial value upon resubscription
    const previousId = usePrevious(id, id);
    if (previousId !== id) {
        return INITIAL_LOADING_STATE;
    }
    return referenceInfo;
}
//# sourceMappingURL=useReferenceInfo.js.map