import { BlockElementIcon, BoldIcon, CodeIcon, InlineElementIcon, ItalicIcon, LinkIcon, OlistIcon, StrikethroughIcon, UnderlineIcon, UnknownIcon, UlistIcon, } from '@sanity/icons';
import { PortableTextEditor,
// Type,
 } from '@sanity/portable-text-editor';
import { get } from 'lodash';
import React from 'react';
import { CustomIcon } from './CustomIcon';
function getPTEFormatActions(editor, disabled, hotkeyOpts) {
    const features = PortableTextEditor.getPortableTextFeatures(editor);
    return features.decorators.map((decorator) => {
        const shortCutKey = Object.keys(hotkeyOpts.marks || {}).find((key) => hotkeyOpts.marks?.[key] === decorator.value);
        let hotkeys = [];
        if (shortCutKey) {
            hotkeys = [shortCutKey];
        }
        return {
            type: 'format',
            disabled: disabled,
            icon: decorator.blockEditor?.icon,
            key: decorator.value,
            handle: () => {
                PortableTextEditor.toggleMark(editor, decorator.value);
                PortableTextEditor.focus(editor);
            },
            hotkeys,
            title: decorator.title,
        };
    });
}
function getPTEListActions(editor, disabled) {
    const features = PortableTextEditor.getPortableTextFeatures(editor);
    return features.lists.map((listItem) => {
        return {
            type: 'listStyle',
            key: listItem.value,
            disabled: disabled,
            icon: listItem.blockEditor?.icon,
            handle: () => {
                PortableTextEditor.toggleList(editor, listItem.value);
            },
            title: listItem.title,
        };
    });
}
function getAnnotationIcon(item) {
    return (get(item, 'icon') ||
        get(item, 'blockEditor.icon') ||
        get(item, 'type.icon') ||
        get(item, 'type.to.icon') ||
        get(item, 'type.to[0].icon'));
}
function getPTEAnnotationActions(editor, disabled, onInsert) {
    const features = PortableTextEditor.getPortableTextFeatures(editor);
    const focusChild = PortableTextEditor.focusChild(editor);
    const hasText = focusChild && focusChild.text;
    return features.annotations.map((item) => {
        return {
            type: 'annotation',
            disabled: !hasText || disabled,
            icon: getAnnotationIcon(item),
            key: item.value,
            handle: (active) => {
                if (active) {
                    PortableTextEditor.removeAnnotation(editor, item.type);
                    PortableTextEditor.focus(editor);
                }
                else {
                    onInsert(item.type);
                }
            },
            title: item.title,
        };
    });
}
export function getPTEToolbarActionGroups(editor, disabled, onInsertAnnotation, hotkeyOpts) {
    return [
        { name: 'format', actions: getPTEFormatActions(editor, disabled, hotkeyOpts) },
        { name: 'list', actions: getPTEListActions(editor, disabled) },
        { name: 'annotation', actions: getPTEAnnotationActions(editor, disabled, onInsertAnnotation) },
    ];
}
export function getBlockStyles(features) {
    return features.styles.map((style) => {
        return {
            key: `style-${style.value}`,
            style: style.value,
            styleComponent: style && style.blockEditor && style.blockEditor.render,
            title: style.title,
        };
    });
}
function getInsertMenuIcon(type, fallbackIcon) {
    const referenceIcon = get(type, 'to[0].icon');
    return type.icon || (type.type && type.type.icon) || referenceIcon || fallbackIcon;
}
export function getInsertMenuItems(features, disabled, onInsertBlock, onInsertInline) {
    const blockItems = features.types.blockObjects.map((type, index) => ({
        handle: () => onInsertBlock(type),
        icon: getInsertMenuIcon(type, BlockElementIcon),
        inline: false,
        key: `block-${index}`,
        type: type,
    }));
    const inlineItems = features.types.inlineObjects.map((type, index) => ({
        handle: () => onInsertInline(type),
        icon: getInsertMenuIcon(type, InlineElementIcon),
        inline: true,
        key: `inline-${index}`,
        type: type,
    }));
    // Do not include items that are supposed to be hidden
    const filteredBlockItems = blockItems.concat(inlineItems).filter((item) => !item.type?.hidden);
    return filteredBlockItems;
}
const annotationIcons = {
    link: LinkIcon,
};
const formatIcons = {
    strong: BoldIcon,
    em: ItalicIcon,
    'strike-through': StrikethroughIcon,
    underline: UnderlineIcon,
    code: CodeIcon,
};
const listStyleIcons = {
    number: OlistIcon,
    bullet: UlistIcon,
};
export function getActionIcon(action, active) {
    if (action.icon) {
        if (typeof action.icon === 'string') {
            return React.createElement(CustomIcon, { active: active, icon: action.icon });
        }
        return action.icon;
    }
    if (action.type === 'annotation') {
        return annotationIcons[action.key] || UnknownIcon;
    }
    if (action.type === 'listStyle') {
        return listStyleIcons[action.key] || UnknownIcon;
    }
    return formatIcons[action.key] || UnknownIcon;
}
//# sourceMappingURL=helpers.js.map