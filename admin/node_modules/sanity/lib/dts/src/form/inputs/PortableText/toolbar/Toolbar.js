import { usePortableTextEditor, usePortableTextEditorSelection, 
// Type,
PortableTextEditor, } from '@sanity/portable-text-editor';
import React, { memo, useCallback, useMemo, useState } from 'react';
import { Box, Button, Flex, Hotkeys, Text, Tooltip, useElementRect, useToast } from '@sanity/ui';
import { CollapseIcon, ExpandIcon } from '@sanity/icons';
import styled, { css } from 'styled-components';
import { useRovingFocus } from '../../../../components/rovingFocus';
import { resolveInitialValueForType } from '../../../../templates';
import { ActionMenu } from './ActionMenu';
import { BlockStyleSelect } from './BlockStyleSelect';
import { InsertMenu } from './InsertMenu';
import { getBlockStyles, getInsertMenuItems } from './helpers';
import { useActionGroups, useFeatures } from './hooks';
const RootFlex = styled(Flex) `
  width: 100%;
`;
const StyleSelectBox = styled(Box) `
  width: 8em;
`;
const StyleSelectFlex = styled(Flex) `
  border-right: 1px solid var(--card-border-color);
`;
const ActionMenuBox = styled(Box) `
  ${({ $withInsertMenu }) => $withInsertMenu &&
    css `
      max-width: max-content;
      border-right: 1px solid var(--card-border-color);
    `}
`;
const FullscreenButtonBox = styled(Box) `
  border-left: 1px solid var(--card-border-color);
`;
const SLOW_INITIAL_VALUE_LIMIT = 300;
const IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
const InnerToolbar = memo(function InnerToolbar({ actionGroups, blockStyles, disabled, insertMenuItems, isFullscreen, onToggleFullscreen, }) {
    const actionsLen = actionGroups.reduce((acc, x) => acc + x.actions.length, 0);
    const showActionMenu = actionsLen > 0;
    const showInsertMenu = insertMenuItems.length > 0;
    const [rootElement, setRootElement] = useState(null);
    const rootElementRect = useElementRect(rootElement);
    const collapsed = rootElementRect ? rootElementRect?.width < 400 : false;
    useRovingFocus({
        rootElement: rootElement,
    });
    return (React.createElement(RootFlex, { align: "center", ref: setRootElement },
        React.createElement(StyleSelectFlex, { flex: collapsed ? 1 : undefined },
            React.createElement(StyleSelectBox, { padding: isFullscreen ? 2 : 1 },
                React.createElement(BlockStyleSelect, { disabled: disabled, items: blockStyles }))),
        React.createElement(Flex, { flex: 1 },
            showActionMenu && (React.createElement(ActionMenuBox, { flex: collapsed ? undefined : 1, padding: isFullscreen ? 2 : 1, "$withInsertMenu": showInsertMenu },
                React.createElement(ActionMenu, { disabled: disabled, collapsed: collapsed, groups: actionGroups, isFullscreen: isFullscreen }))),
            showInsertMenu && (React.createElement(Box, { flex: collapsed ? undefined : 1, padding: isFullscreen ? 2 : 1 },
                React.createElement(InsertMenu, { disabled: disabled, collapsed: collapsed, items: insertMenuItems, isFullscreen: isFullscreen })))),
        React.createElement(FullscreenButtonBox, { padding: isFullscreen ? 2 : 1 },
            React.createElement(Tooltip, { content: React.createElement(Flex, { align: "center", padding: 1 },
                    React.createElement(Box, { flex: 1, paddingX: 1 },
                        React.createElement(Text, { size: 1 }, `${isFullscreen ? 'Collapse' : 'Expand'} editor`)),
                    React.createElement(Box, { marginLeft: 1 },
                        React.createElement(Hotkeys, { keys: [`${IS_MAC ? 'Cmd' : 'Ctrl'}`, 'Enter'] }))), placement: isFullscreen ? 'bottom' : 'top', portal: "default" },
                React.createElement(Button, { padding: 2, icon: isFullscreen ? CollapseIcon : ExpandIcon, mode: "bleed", onClick: onToggleFullscreen })))));
});
export function Toolbar(props) {
    const { hotkeys, isFullscreen, readOnly, onExpand, onToggleFullscreen } = props;
    const features = useFeatures();
    const editor = usePortableTextEditor();
    const selection = usePortableTextEditorSelection();
    const disabled = readOnly || !selection;
    const { push } = useToast();
    const resolveInitialValue = useCallback((type) => {
        let isSlow = false;
        const slowTimer = setTimeout(() => {
            isSlow = true;
            push({
                id: 'resolving-initial-value',
                status: 'info',
                title: 'Resolving initial value…',
            });
        }, SLOW_INITIAL_VALUE_LIMIT);
        return resolveInitialValueForType(type, {})
            .then((value) => {
            if (isSlow) {
                // I found no way to close an existing toast, so this will replace the message in the
                // "Resolving initial value…"-toast and then make sure it gets closed.
                push({
                    id: 'resolving-initial-value',
                    status: 'info',
                    duration: 500,
                    title: 'Initial value resolved',
                });
            }
            return value;
        })
            .catch((error) => {
            push({
                title: `Could not resolve initial value`,
                id: 'resolving-initial-value',
                description: `Unable to resolve initial value for type: ${type.name}: ${error.message}.`,
                status: 'error',
            });
            return undefined;
        })
            .finally(() => clearTimeout(slowTimer));
    }, [push]);
    const handleInsertBlock = useCallback(async (type) => {
        const initialValue = await resolveInitialValue(type);
        const path = PortableTextEditor.insertBlock(editor, type, initialValue);
        if (path) {
            PortableTextEditor.blur(editor);
            onExpand(path);
        }
    }, [editor, onExpand, resolveInitialValue]);
    const handleInsertInline = useCallback(async (type) => {
        const initialValue = await resolveInitialValue(type);
        const path = PortableTextEditor.insertChild(editor, type, initialValue);
        if (path) {
            PortableTextEditor.blur(editor);
            onExpand(path);
        }
    }, [editor, onExpand, resolveInitialValue]);
    const actionGroups = useActionGroups({
        hotkeys,
        onExpand,
        resolveInitialValue,
        disabled: true,
    });
    const blockStyles = useMemo(() => getBlockStyles(features), [features]);
    const insertMenuItems = useMemo(() => getInsertMenuItems(features, disabled, handleInsertBlock, handleInsertInline), [disabled, features, handleInsertBlock, handleInsertInline]);
    return (React.createElement(InnerToolbar, { actionGroups: actionGroups, blockStyles: blockStyles, disabled: disabled, insertMenuItems: insertMenuItems, isFullscreen: isFullscreen, onToggleFullscreen: onToggleFullscreen }));
}
//# sourceMappingURL=Toolbar.js.map