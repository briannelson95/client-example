import { Box, Tooltip } from '@sanity/ui';
import React, { useCallback, useMemo, useState } from 'react';
import { useFormBuilder } from '../../../useFormBuilder';
import { BlockActions } from '../BlockActions';
import { ReviewChangesHighlightBlock, StyledChangeIndicatorWithProvidedFullPath } from '../_common';
import { useMemberValidation } from '../hooks/useMemberValidation';
import { usePortableTextMarkers } from '../hooks/usePortableTextMarkers';
import { usePortableTextMemberItem } from '../hooks/usePortableTextMembers';
import { pathToString } from '../../../../field/paths';
import { TEXT_STYLE_PADDING } from './constants';
import { BlockActionsInner, BlockActionsOuter, BlockExtrasContainer, ChangeIndicatorWrapper, ListPrefixWrapper, TextBlockFlexWrapper, TextFlex, TextRoot, TooltipBox, } from './TextBlock.styles';
import { TEXT_STYLES } from './textStyles';
const DEBUG_RENDERING = false;
function getRandomColor() {
    const letters = '0123456789ABCDEF';
    let color = '#';
    for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}
export function TextBlock(props) {
    const { attributes: { path, focused }, block, children, isFullscreen, onChange, readOnly, renderBlockActions, renderCustomMarkers, spellCheck, } = props;
    const { Markers } = useFormBuilder().__internal.components;
    const [reviewChangesHovered, setReviewChangesHovered] = useState(false);
    const markers = usePortableTextMarkers(path);
    const memberItem = usePortableTextMemberItem(pathToString(path));
    const handleChangeIndicatorMouseEnter = useCallback(() => setReviewChangesHovered(true), []);
    const handleChangeIndicatorMouseLeave = useCallback(() => setReviewChangesHovered(false), []);
    const { validation, hasError, hasWarning, hasInfo } = useMemberValidation(memberItem?.node);
    const hasMarkers = Boolean(renderCustomMarkers) && markers.length > 0;
    const tooltipEnabled = hasError || hasWarning || hasMarkers || hasInfo;
    const text = useMemo(() => {
        const TextStyle = TEXT_STYLES[block.style] || TEXT_STYLES.normal;
        return (React.createElement(TextFlex, { align: "flex-start", "$level": block?.level },
            block.listItem && (React.createElement(ListPrefixWrapper, { contentEditable: false },
                React.createElement(TextStyle, { "data-list-prefix": "" }))),
            React.createElement(TextStyle, { "data-text": "", style: DEBUG_RENDERING ? { color: getRandomColor() } : undefined }, children)));
    }, [block.style, block.listItem, block.level, children]);
    const innerPaddingProps = useMemo(() => {
        if (isFullscreen && !renderBlockActions) {
            return { paddingX: 5 };
        }
        if (isFullscreen && renderBlockActions) {
            return { paddingLeft: 5, paddingRight: 2 };
        }
        if (renderBlockActions) {
            return {
                paddingLeft: 3,
                paddingRight: 2,
            };
        }
        return { paddingX: 3 };
    }, [isFullscreen, renderBlockActions]);
    const outerPaddingProps = useMemo(() => {
        if (block.listItem) {
            return { paddingY: 2 };
        }
        return TEXT_STYLE_PADDING[block.style] || { paddingY: 2 };
    }, [block]);
    return (React.createElement(Box, { "data-testid": "text-block", ...outerPaddingProps },
        React.createElement(TextBlockFlexWrapper, { "data-testid": "text-block__wrapper" },
            React.createElement(Box, { flex: 1, ...innerPaddingProps, ref: memberItem?.elementRef },
                React.createElement(Tooltip, { placement: "top", portal: "editor", disabled: !tooltipEnabled, content: tooltipEnabled && (React.createElement(TooltipBox, { padding: 2 },
                        React.createElement(Markers, { markers: markers, validation: validation, renderCustomMarkers: renderCustomMarkers }))) },
                    React.createElement(TextRoot, { "$level": block.level, "data-error": hasError ? '' : undefined, "data-warning": hasWarning ? '' : undefined, "data-list-item": block.listItem, "data-custom-markers": hasMarkers ? '' : undefined, "data-testid": "text-block__text", spellCheck: spellCheck }, text)),
                React.createElement("div", { contentEditable: false },
                    React.createElement(BlockExtrasContainer, null,
                        renderBlockActions && (React.createElement(BlockActionsOuter, { marginRight: 1 },
                            React.createElement(BlockActionsInner, null, focused && !readOnly && (React.createElement(BlockActions, { onChange: onChange, block: block, renderBlockActions: renderBlockActions }))))),
                        isFullscreen && memberItem && (React.createElement(ChangeIndicatorWrapper, { "$hasChanges": memberItem.member.item.changed, onMouseEnter: handleChangeIndicatorMouseEnter, onMouseLeave: handleChangeIndicatorMouseLeave },
                            React.createElement(StyledChangeIndicatorWithProvidedFullPath, { hasFocus: focused, isChanged: memberItem.member.item.changed, path: memberItem.member.item.path, withHoverEffect: false })))),
                    reviewChangesHovered && React.createElement(ReviewChangesHighlightBlock, null))))));
}
//# sourceMappingURL=TextBlock.js.map