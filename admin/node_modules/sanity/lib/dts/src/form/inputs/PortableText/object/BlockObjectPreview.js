import { EditIcon, LinkIcon, TrashIcon, EyeOpenIcon, EllipsisVerticalIcon } from '@sanity/icons';
import { PortableTextEditor, usePortableTextEditor, } from '@sanity/portable-text-editor';
import { Box, Button, Flex, Menu, MenuButton, MenuItem, useGlobalKeyDown, useLayer, } from '@sanity/ui';
import React, { forwardRef, useCallback, useMemo, useRef } from 'react';
import { useId } from '@reach/auto-id';
import { IntentLink } from '../../../../router';
import { is } from '../../../utils/is';
const POPOVER_PROPS = {
    constrainSize: true,
    placement: 'bottom',
    portal: 'default',
    tone: 'default',
};
export function BlockObjectPreview(props) {
    const { focused, value, type, readOnly, onClickingEdit, onClickingDelete, renderPreview } = props;
    const { isTopLayer } = useLayer();
    const editor = usePortableTextEditor();
    const menuButtonId = useId() || '';
    const menuButton = useRef(null);
    const isTabbing = useRef(false);
    const isCustomPreviewComponent = Boolean(type.preview?.component);
    const isImageType = is('image', type);
    const referenceLink = useMemo(() => forwardRef(function ReferenceLink(linkProps, ref) {
        return React.createElement(IntentLink, { ...linkProps, intent: "edit", params: { id: value._ref }, ref: ref });
    }), [value?._ref]);
    // Go to menu when tabbed to
    // Focus block on escape
    useGlobalKeyDown(useCallback((event) => {
        if (!focused) {
            return;
        }
        if (event.key === 'Escape' && isTopLayer) {
            // event.preventDefault()
            // event.stopPropagation()
            isTabbing.current = false;
            PortableTextEditor.focus(editor);
        }
        if (event.key === 'Tab') {
            if (menuButton.current && !isTabbing.current) {
                event.preventDefault();
                event.stopPropagation();
                menuButton.current.focus();
                isTabbing.current = true;
            }
        }
    }, [focused, isTopLayer, editor]));
    const actions = (React.createElement(MenuButton, { button: React.createElement(Button, { "aria-label": "Open menu", fontSize: 1, iconRight: EllipsisVerticalIcon, mode: "bleed", paddingX: 2 }), ref: menuButton, id: menuButtonId, menu: React.createElement(Menu, null,
            value?._ref && (React.createElement(MenuItem, { as: referenceLink, "data-as": "a", icon: LinkIcon, text: "Open reference" })),
            readOnly && React.createElement(MenuItem, { icon: EyeOpenIcon, onClick: onClickingEdit, text: "View" }),
            !readOnly && React.createElement(MenuItem, { icon: EditIcon, onClick: onClickingEdit, text: "Edit" }),
            !readOnly && (React.createElement(MenuItem, { icon: TrashIcon, onClick: onClickingDelete, text: "Delete", tone: "critical" }))), popover: POPOVER_PROPS }));
    if (isCustomPreviewComponent) {
        return (React.createElement(Flex, null,
            React.createElement(Box, { flex: 1 }, renderPreview({
                layout: isImageType ? 'blockImage' : 'block',
                schemaType: type,
                value,
            })),
            React.createElement(Box, { marginLeft: 1 }, actions)));
    }
    return (React.createElement(React.Fragment, null, renderPreview({
        actions,
        layout: isImageType ? 'blockImage' : 'block',
        schemaType: type,
        value,
    })));
}
//# sourceMappingURL=BlockObjectPreview.js.map