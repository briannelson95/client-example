import { PortableTextEditor, } from '@sanity/portable-text-editor';
import React, { useEffect, useState, useMemo, useCallback, useRef, useImperativeHandle, createRef, } from 'react';
import { Subject } from 'rxjs';
import { Box, Text, useToast } from '@sanity/ui';
import scrollIntoView from 'scroll-into-view-if-needed';
import { debounce } from 'lodash';
import { EMPTY_ARRAY } from '../../utils/empty';
import { isMemberArrayOfObjects } from '../../members/fields/asserters';
import { pathToString } from '../../../field/paths';
import { Compositor } from './Compositor';
import { InvalidValue as RespondToInvalidContent } from './InvalidValue';
import { usePatches } from './usePatches';
import { VisibleOnFocusButton } from './VisibleOnFocusButton';
import { PortableTextMarkersProvider } from './contexts/PortableTextMarkers';
import { PortableTextMemberItemsProvider } from './contexts/PortableTextMembers';
import { _isArrayOfObjectsFieldMember, _isBlockType } from './_helpers';
/**
 * The root Portable Text Input component
 *
 * @alpha
 */
export function PortableTextInput(props) {
    const { focused, focusPath, focusRef, hotkeys, markers = EMPTY_ARRAY, members, onChange, onCopy, onFocusPath, onInsert, onPaste, path, readOnly: readOnlyFromProps, renderBlockActions, renderCustomMarkers, schemaType: type, value, } = props;
    // Make the PTE focusable from the outside
    useImperativeHandle(focusRef, () => ({
        focus() {
            if (editorRef.current) {
                PortableTextEditor.focus(editorRef.current);
            }
        },
    }));
    const { subscribe } = usePatches({ path });
    const editorRef = useRef(null);
    const [hasFocus, setHasFocus] = useState(false);
    const [ignoreValidationError, setIgnoreValidationError] = useState(false);
    const [invalidValue, setInvalidValue] = useState(null);
    const [isFullscreen, setIsFullscreen] = useState(false);
    const [isActive, setIsActive] = useState(false);
    const readOnly = useMemo(() => {
        return isActive ? Boolean(readOnlyFromProps) : true;
    }, [isActive, readOnlyFromProps]);
    const toast = useToast();
    const portableTextMemberItemsRef = useRef([]);
    // Memoized patch stream
    const patchSubject = useMemo(() => new Subject(), []);
    const remotePatch$ = useMemo(() => patchSubject.asObservable(), [patchSubject]);
    const innerElementRef = useRef(null);
    const handleToggleFullscreen = useCallback(() => {
        if (editorRef.current) {
            const prevSel = PortableTextEditor.getSelection(editorRef.current);
            setIsFullscreen((v) => !v);
            setTimeout(() => {
                if (editorRef.current) {
                    PortableTextEditor.focus(editorRef.current);
                    if (prevSel) {
                        PortableTextEditor.select(editorRef.current, { ...prevSel });
                    }
                }
            });
        }
    }, []);
    // Reset invalidValue if new value is coming in from props
    useEffect(() => {
        if (invalidValue && value !== invalidValue.value) {
            setInvalidValue(null);
        }
    }, [invalidValue, value]);
    // Subscribe to patches
    useEffect(() => {
        return subscribe(({ patches, snapshot }) => {
            patchSubject.next({ patches, snapshot });
        });
    }, [patchSubject, subscribe]);
    // Populate the portableTextMembers Map
    const portableTextMemberItems = useMemo(() => {
        const result = [];
        for (const member of members) {
            if (member.kind === 'item') {
                if (!_isBlockType(member.item.schemaType)) {
                    result.push({ kind: 'objectBlock', member, node: member.item });
                }
                else if (member.item.validation.length > 0 || member.item.changed) {
                    // Only text blocks that have validation or changes
                    result.push({ kind: 'textBlock', member, node: member.item });
                }
                if (_isBlockType(member.item.schemaType)) {
                    // Inline objects
                    const childrenField = member.item.members.find((f) => f.kind === 'field' && f.name === 'children');
                    if (childrenField &&
                        childrenField.kind === 'field' &&
                        isMemberArrayOfObjects(childrenField)) {
                        // eslint-disable-next-line max-depth
                        for (const child of childrenField.field.members) {
                            // eslint-disable-next-line max-depth
                            if (child.kind === 'item' && child.item.schemaType.name !== 'span') {
                                result.push({ kind: 'inlineObject', member: child, node: child.item });
                            }
                        }
                    }
                    // Markdefs
                    const markDefArrayMember = member.item.members
                        .filter(_isArrayOfObjectsFieldMember)
                        .find((f) => f.name === 'markDefs');
                    if (markDefArrayMember) {
                        // eslint-disable-next-line max-depth
                        for (const child of markDefArrayMember.field.members) {
                            // eslint-disable-next-line max-depth
                            if (child.kind === 'item' && child.item.schemaType.jsonType === 'object') {
                                result.push({
                                    kind: 'annotation',
                                    member: child,
                                    node: child.item,
                                });
                            }
                        }
                    }
                }
            }
        }
        const items = result.map((r) => {
            const key = pathToString(r.node.path.slice(path.length));
            const existingItem = portableTextMemberItemsRef.current.find((ref) => ref.key === key);
            if (existingItem) {
                existingItem.member = r.member;
                existingItem.node = r.node;
                return existingItem;
            }
            return {
                kind: r.kind,
                key,
                member: r.member,
                node: r.node,
                elementRef: createRef(),
            };
        });
        portableTextMemberItemsRef.current = items;
        return items;
    }, [members, path]);
    const hasOpenItem = useMemo(() => {
        return portableTextMemberItems.some((item) => item.member.open);
    }, [portableTextMemberItems]);
    // Sets the focusPath from editor selection (when typing, moving the cursor, clicking around)
    // This doesn't need to be immediate, so debounce it as it impacts performance.
    const setFocusPathDebounced = useMemo(() => debounce((sel) => {
        if (sel && hasFocus)
            onFocusPath(sel.focus.path);
    }, 500, { trailing: true, leading: false }), [hasFocus, onFocusPath]);
    // Handle editor changes
    const handleEditorChange = useCallback((change) => {
        switch (change.type) {
            case 'mutation':
                onChange(change.patches);
                break;
            case 'selection':
                setFocusPathDebounced(change.selection);
                break;
            case 'focus':
                setHasFocus(true);
                break;
            case 'blur':
                setHasFocus(false);
                break;
            case 'undo':
            case 'redo':
                onChange(change.patches);
                break;
            case 'invalidValue':
                setInvalidValue(change);
                break;
            case 'error':
                toast.push({
                    status: change.level,
                    description: change.description,
                });
                break;
            default:
        }
    }, [onChange, toast, setFocusPathDebounced]);
    const handleFocusSkipperClick = useCallback(() => {
        if (editorRef.current) {
            PortableTextEditor.focus(editorRef.current);
        }
    }, [editorRef]);
    const handleIgnoreInvalidValue = useCallback(() => {
        setIgnoreValidationError(true);
    }, []);
    const respondToInvalidContent = useMemo(() => {
        if (invalidValue && invalidValue.resolution) {
            return (React.createElement(Box, { marginBottom: 2 },
                React.createElement(RespondToInvalidContent, { onChange: handleEditorChange, onIgnore: handleIgnoreInvalidValue, resolution: invalidValue.resolution })));
        }
        return null;
    }, [handleEditorChange, handleIgnoreInvalidValue, invalidValue]);
    const handleActivate = useCallback(() => {
        if (!isActive) {
            setIsActive(true);
            // Focus the editor in the next tick if needed
            // Next tick because we are in a re-rendering phase of the editor at this point (activating it).
            if (!hasFocus) {
                setTimeout(() => {
                    if (editorRef.current) {
                        PortableTextEditor.focus(editorRef.current);
                    }
                });
            }
        }
    }, [hasFocus, isActive]);
    // If the editor that has an opened item and isn't focused - scroll to the input if needed.
    useEffect(() => {
        if (!hasFocus && hasOpenItem && innerElementRef.current) {
            scrollIntoView(innerElementRef.current, {
                scrollMode: 'if-needed',
            });
        }
    }, [focused, hasFocus, hasOpenItem]);
    return (React.createElement(Box, { ref: innerElementRef },
        !readOnly && (React.createElement(VisibleOnFocusButton, { onClick: handleFocusSkipperClick },
            React.createElement(Text, null, "Go to content"))),
        !ignoreValidationError && respondToInvalidContent,
        (!invalidValue || ignoreValidationError) && (React.createElement(PortableTextMarkersProvider, { markers: markers },
            React.createElement(PortableTextMemberItemsProvider, { memberItems: portableTextMemberItems },
                React.createElement(PortableTextEditor, { ref: editorRef, "incomingPatches$": remotePatch$, onChange: handleEditorChange, maxBlocks: undefined, readOnly: readOnly, type: type, value: value },
                    React.createElement(Compositor, { ...props, focused: focused, focusPath: focusPath, hasFocus: hasFocus, hotkeys: hotkeys, isActive: isActive, isFullscreen: isFullscreen, onActivate: handleActivate, onChange: onChange, onCopy: onCopy, onInsert: onInsert, onPaste: onPaste, onToggleFullscreen: handleToggleFullscreen, readOnly: readOnly, renderBlockActions: renderBlockActions, renderCustomMarkers: renderCustomMarkers, value: value })))))));
}
//# sourceMappingURL=PortableTextInput.js.map