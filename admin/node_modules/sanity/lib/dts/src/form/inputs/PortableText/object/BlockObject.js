import { PortableTextEditor, usePortableTextEditor, } from '@sanity/portable-text-editor';
import { Tooltip, Flex } from '@sanity/ui';
import React, { useCallback, useMemo, useRef, useState } from 'react';
import { BlockActions } from '../BlockActions';
import { ReviewChangesHighlightBlock, StyledChangeIndicatorWithProvidedFullPath } from '../_common';
import { useFormBuilder } from '../../../useFormBuilder';
import { useMemberValidation } from '../hooks/useMemberValidation';
import { usePortableTextMarkers } from '../hooks/usePortableTextMarkers';
import { usePortableTextMemberItem } from '../hooks/usePortableTextMembers';
import { pathToString } from '../../../../field/paths';
import { BlockObjectPreview } from './BlockObjectPreview';
import { Root, PreviewContainer, ChangeIndicatorWrapper, InnerFlex, BlockActionsOuter, BlockActionsInner, TooltipBox, BlockPreview, } from './BlockObject.styles';
export function BlockObject(props) {
    const { attributes: { focused, selected, path }, block, isFullscreen, onChange, onOpenItem, readOnly, renderBlockActions, renderCustomMarkers, renderPreview, type, } = props;
    const { Markers } = useFormBuilder().__internal.components;
    const elementRef = useRef(null);
    const [reviewChangesHovered, setReviewChangesHovered] = useState(false);
    const markers = usePortableTextMarkers(path);
    const editor = usePortableTextEditor();
    const memberItem = usePortableTextMemberItem(pathToString(path));
    const handleMouseOver = useCallback(() => setReviewChangesHovered(true), []);
    const handleMouseOut = useCallback(() => setReviewChangesHovered(false), []);
    const handleEdit = useCallback(() => {
        if (memberItem) {
            onOpenItem(memberItem.node.path);
        }
    }, [onOpenItem, memberItem]);
    const handleDoubleClickToOpen = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        PortableTextEditor.blur(editor);
        handleEdit();
    }, [editor, handleEdit]);
    const handleDelete = useCallback((e) => {
        e.stopPropagation();
        e.preventDefault();
        const sel = { focus: { path, offset: 0 }, anchor: { path, offset: 0 } };
        PortableTextEditor.delete(editor, sel, { mode: 'blocks' });
        // Focus will not stick unless this is done through a timeout when deleted through clicking the menu button.
        setTimeout(() => PortableTextEditor.focus(editor));
    }, [editor, path]);
    const blockPreview = useMemo(() => {
        return (React.createElement(BlockObjectPreview, { type: type, focused: focused, value: block, readOnly: readOnly, onClickingDelete: handleDelete, onClickingEdit: handleEdit, renderPreview: renderPreview }));
    }, [focused, type, block, readOnly, handleDelete, handleEdit, renderPreview]);
    const tone = selected || focused ? 'primary' : 'default';
    const innerPaddingProps = useMemo(() => {
        if (isFullscreen && !renderBlockActions) {
            return { paddingX: 5 };
        }
        if (isFullscreen && renderBlockActions) {
            return { paddingLeft: 5, paddingRight: 2 };
        }
        if (renderBlockActions) {
            return {
                paddingLeft: 3,
                paddingRight: 2,
            };
        }
        return { paddingX: 3 };
    }, [isFullscreen, renderBlockActions]);
    const { validation, hasError, hasWarning, hasInfo } = useMemberValidation(memberItem?.node);
    const hasMarkers = Boolean(markers.length > 0);
    const isImagePreview = memberItem?.node.schemaType.name === 'image';
    const tooltipEnabled = hasError || hasWarning || hasInfo || (hasMarkers && renderCustomMarkers);
    return (React.createElement(Flex, { paddingBottom: 1, marginY: 3, contentEditable: false },
        React.createElement(InnerFlex, { flex: 1 },
            React.createElement(PreviewContainer, { flex: 1, ...innerPaddingProps },
                React.createElement(Tooltip, { placement: "top", portal: "editor", disabled: !tooltipEnabled, content: tooltipEnabled && (React.createElement(TooltipBox, { padding: 2 },
                        React.createElement(Markers, { markers: markers, validation: validation, renderCustomMarkers: renderCustomMarkers }))) },
                    React.createElement(Root, { "data-focused": focused ? '' : undefined, "data-image-preview": isImagePreview ? '' : undefined, "data-invalid": hasError ? '' : undefined, "data-markers": hasMarkers && renderCustomMarkers ? '' : undefined, "data-selected": selected ? '' : undefined, "data-testid": "pte-block-object", "data-warning": hasWarning ? '' : undefined, flex: 1, onDoubleClick: handleDoubleClickToOpen, padding: isImagePreview ? 0 : 1, ref: elementRef, tone: tone },
                        React.createElement(BlockPreview, { ref: memberItem?.elementRef }, blockPreview)))),
            React.createElement(BlockActionsOuter, { marginRight: 1 },
                React.createElement(BlockActionsInner, null, renderBlockActions && block && focused && !readOnly && (React.createElement(BlockActions, { onChange: onChange, block: block, renderBlockActions: renderBlockActions })))),
            isFullscreen && memberItem && (React.createElement(ChangeIndicatorWrapper, { onMouseOver: handleMouseOver, onMouseOut: handleMouseOut, "$hasChanges": memberItem.member.item.changed },
                React.createElement(StyledChangeIndicatorWithProvidedFullPath, { withHoverEffect: false, hasFocus: focused, path: memberItem.member.item.path, isChanged: memberItem.member.item.changed }))),
            reviewChangesHovered && React.createElement(ReviewChangesHighlightBlock, null))));
}
//# sourceMappingURL=BlockObject.js.map