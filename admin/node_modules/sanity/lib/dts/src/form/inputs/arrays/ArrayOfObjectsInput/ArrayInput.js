/* eslint-disable camelcase */
/* eslint-disable react/default-props-match-prop-types */
/* eslint-disable react/jsx-handler-names */
import { isKeySegment, isObjectSchemaType, isReferenceSchemaType, } from '@sanity/types';
import { isPlainObject } from 'lodash';
import { Box, Button, Card, Dialog, Flex, Spinner, Stack, Text } from '@sanity/ui';
import React from 'react';
import { map } from 'rxjs/operators';
import { randomKey, resolveTypeName } from '@sanity/util/content';
import { getSchemaTypeTitle } from '../../../../schema/helpers';
import { isDev } from '../../../../environment';
import { Alert } from '../../../components/Alert';
import { Details } from '../../../components/Details';
import { Item, List } from '../common/list';
import { applyAll } from '../../../patch/applyPatch';
import { PatchEvent, unset } from '../../../patch';
import { DefaultArrayInputFunctions } from '../common/ArrayFunctions';
import { isObjectItemProps } from '../../../types/asserters';
import { withFocusRing } from '../../../components/withFocusRing';
import { MemberItem, MemberItemError } from '../../../members';
import { uploadTarget } from './uploadTarget/uploadTarget';
import { isEmpty } from './item/helpers';
import { ArrayItem } from './item/ArrayItem';
export function createProtoValue(type) {
    if (!isObjectSchemaType(type)) {
        throw new Error(`Invalid item type: "${type.type}". Default array input can only contain objects (for now)`);
    }
    const _key = randomKey(12);
    return type.name === 'object' ? { _key } : { _type: type.name, _key };
}
const UploadTarget = uploadTarget(withFocusRing(Card));
export class ArrayInput extends React.PureComponent {
    constructor() {
        super(...arguments);
        this._focusArea = null;
        this.toast = null;
        this.uploadSubscriptions = {};
        this.state = {
            isResolvingInitialValue: false,
        };
        this.insert = (item, position, referenceItem) => {
            const { onInsert } = this.props;
            onInsert({ items: [item], position, referenceItem });
        };
        this.handlePrepend = (value) => {
            this.handleInsert({ item: value, position: 'before', referenceItem: 0 });
        };
        this.handleAppend = (value) => {
            this.handleInsert({ item: value, position: 'after', referenceItem: -1 });
        };
        this.handleInsert = (event) => {
            const { onFocusPath, onOpenItem, resolveInitialValue } = this.props;
            this.setState({ isResolvingInitialValue: true });
            const memberType = this.getMemberTypeOfItem(event.item);
            if (!memberType) {
                throw new Error(`Type "${event.item._type}" not valid for this array`);
            }
            const resolvedInitialValue = isEmpty(event.item) && resolveInitialValue
                ? resolveInitialValue(memberType, event.item)
                : Promise.resolve({});
            resolvedInitialValue
                .then((initial) => ({ ...event.item, ...initial }))
                .then((value) => {
                this.insert(value, event.position, event.referenceItem);
            }, (error) => {
                this.toast?.push({
                    title: `Could not resolve initial value`,
                    description: `Unable to resolve initial value for type: ${memberType.name}: ${error.message}.`,
                    status: 'error',
                });
                this.insert(event.item, event.position, event.referenceItem);
            })
                .finally(() => {
                this.setState({ isResolvingInitialValue: false });
                if (event.edit !== false) {
                    onOpenItem(this.props.path.concat([{ _key: event.item._key }]));
                }
                onFocusPath([{ _key: event.item._key }]);
            });
        };
        this.handleRemoveItem = (item) => {
            this.removeItem(item);
        };
        this.handleFocus = (event) => {
            const { onFocus } = this.props;
            // We want to handle focus when the array input *itself* element receives
            // focus, not when a child element receives focus, but React has decided
            // to let focus bubble, so this workaround is needed
            // Background: https://github.com/facebook/react/issues/6410#issuecomment-671915381
            if (event.currentTarget === event.target && event.currentTarget === this._focusArea) {
                onFocus(event);
            }
        };
        this.handleBlur = (event) => {
            const { onBlur } = this.props;
            // We want to handle blur when the array input *itself* element receives
            // blur, not when a child element receives blur, but React has decided
            // to let focus events bubble, so this workaround is needed
            // Background: https://github.com/facebook/react/issues/6410#issuecomment-671915381
            if (event.currentTarget === event.target && event.currentTarget === this._focusArea) {
                onBlur(event);
            }
        };
        this.handleSortEnd = (event) => {
            const { value, onMoveItem } = this.props;
            const item = value?.[event.oldIndex];
            const refItem = value?.[event.newIndex];
            if (!item?._key || !refItem?._key) {
                // eslint-disable-next-line no-console
                console.error('Neither the item you are moving nor the item you are moving to have a key. Cannot continue.');
                return;
            }
            if (event.oldIndex === event.newIndex || item._key === refItem._key) {
                return;
            }
            onMoveItem({ fromIndex: event.oldIndex, toIndex: event.newIndex });
        };
        this.setFocusArea = (el) => {
            this._focusArea = el;
        };
        this.setToast = (toast) => {
            this.toast = toast;
        };
        this.handleRemoveNonObjectValues = () => {
            const { onChange, value } = this.props;
            const nonObjects = (value || [])
                .reduce((acc, val, i) => (isPlainObject(val) ? acc : acc.concat(i)), [])
                .reverse();
            const patches = nonObjects.map((index) => unset([index]));
            onChange(patches);
        };
        this.handleUpload = ({ file, type, uploader }) => {
            const { onChange, client } = this.props;
            const item = createProtoValue(type);
            const key = item._key;
            this.insert(item, 'after', -1);
            const events$ = uploader
                .upload(client, file, type)
                .pipe(map((uploadEvent) => PatchEvent.from(uploadEvent.patches || []).prefixAll({ _key: key })));
            this.uploadSubscriptions = {
                ...this.uploadSubscriptions,
                [key]: events$.subscribe((event) => onChange(event.patches)),
            };
        };
        this.renderItem = (itemProps) => {
            if (!isObjectItemProps(itemProps)) {
                throw new Error('Expected item to be of object type');
            }
            const { id, renderPreview, schemaType } = this.props;
            if (isReferenceSchemaType(itemProps.schemaType)) {
                return itemProps.children;
            }
            const typeTitle = getSchemaTypeTitle(itemProps.schemaType);
            return (React.createElement(React.Fragment, null,
                React.createElement(ArrayItem, { changed: itemProps.changed, validation: itemProps.validation, readOnly: itemProps.readOnly, onInsert: itemProps.onInsert, onRemove: itemProps.onRemove, onFocus: itemProps.onFocus, index: itemProps.index, schemaType: itemProps.schemaType, layout: schemaType.options?.layout, insertableTypes: schemaType.of, value: itemProps.value, focused: itemProps.focused, open: itemProps.open, path: itemProps.path, onClick: itemProps.onOpen, presence: itemProps.presence, renderPreview: renderPreview }, itemProps.open ? (React.createElement(Dialog, { width: 1, header: `Edit ${typeTitle}`, id: `${id}-item-${itemProps.key}-dialog`, onClose: itemProps.onClose },
                    React.createElement(Box, { padding: 4 }, itemProps.children))) : null)));
        };
    }
    getMemberTypeOfItem(item) {
        const { schemaType } = this.props;
        const itemTypeName = resolveTypeName(item);
        return schemaType.of.find((memberType) => memberType.name === itemTypeName);
    }
    removeItem(item) {
        const { onChange, onFocusPath, value } = this.props;
        // create a patch for removing the item
        const patch = unset(isKeySegment(item) ? [{ _key: item._key }] : [value?.indexOf(item) || -1]);
        // apply the patch to the current value
        const result = applyAll(value || [], [patch]);
        // if the result is an empty array
        if (Array.isArray(result) && !result.length) {
            // then unset the value
            onChange(unset());
        }
        else {
            // otherwise apply the patch
            onChange(patch);
        }
        if (item._key in this.uploadSubscriptions) {
            this.uploadSubscriptions[item._key].unsubscribe();
        }
        // move focus to the nearest sibling
        const idx = value?.indexOf(item) || -1;
        const nearestSibling = value?.[idx + 1] || value?.[idx - 1];
        // if there's no siblings we want to focus the input itself
        onFocusPath(nearestSibling ? [{ _key: nearestSibling._key }] : []);
    }
    focus() {
        if (this._focusArea) {
            this._focusArea.focus();
        }
    }
    renderMember(member) {
        const { renderField, renderInput, renderPreview } = this.props;
        if (member.kind === 'item') {
            return (React.createElement(MemberItem, { member: member, renderItem: this.renderItem, renderField: renderField, renderInput: renderInput, renderPreview: renderPreview }));
        }
        if (member.kind === 'error') {
            return React.createElement(MemberItemError, { member: member });
        }
        //@ts-expect-error all possible cases should be covered
        return React.createElement(React.Fragment, null,
            "Unknown member kind: $",
            member.kind);
    }
    render() {
        const { schemaType, onChange, value = [], readOnly, members, resolveUploader } = this.props;
        const { isResolvingInitialValue } = this.state;
        const hasNonObjectValues = (value || []).some((item) => !isPlainObject(item));
        if (hasNonObjectValues) {
            return (React.createElement(Alert, { status: "error", suffix: React.createElement(Stack, { padding: 2 },
                    React.createElement(Button, { onClick: this.handleRemoveNonObjectValues, text: "Remove non-object values", tone: "critical" })), title: React.createElement(React.Fragment, null, "Invalid list values") },
                React.createElement(Text, { as: "p", muted: true, size: 1 }, "Some items in this list are not objects. This must be fixed in order to edit the list."),
                React.createElement(Details, { marginTop: 4, open: isDev, title: React.createElement(React.Fragment, null, "Developer info") },
                    React.createElement(Stack, { space: 3 },
                        React.createElement(Text, { as: "p", muted: true, size: 1 }, "This usually happens when items are created using an API client, or when a custom input component has added invalid data to the list.")))));
        }
        const options = schemaType.options || {};
        const isSortable = options.sortable !== false;
        const isGrid = options.layout === 'grid';
        return (React.createElement(Stack, { space: 3 },
            React.createElement(UploadTarget, { types: schemaType.of, resolveUploader: resolveUploader, onUpload: this.handleUpload, onFocus: this.handleFocus, onBlur: this.handleBlur, ref: this.setFocusArea, tabIndex: 0 },
                React.createElement(Stack, { "data-ui": "ArrayInput__content", space: 3 },
                    members?.length === 0 && (React.createElement(Card, { padding: 3, border: true, style: { borderStyle: 'dashed' }, radius: 2 },
                        React.createElement(Text, { align: "center", muted: true, size: 1 }, schemaType.placeholder || React.createElement(React.Fragment, null, "No items")))),
                    (members?.length > 0 || isResolvingInitialValue) && (React.createElement(Card, { border: true, radius: 1, paddingY: isGrid ? 2 : 1, paddingX: isGrid ? 2 : undefined },
                        React.createElement(List, { onSortEnd: this.handleSortEnd, isSortable: isSortable, isGrid: isGrid },
                            members.map((member, index) => {
                                return (React.createElement(Item, { key: member.key, isSortable: isSortable, isGrid: isGrid, index: index }, this.renderMember(member)));
                            }),
                            isResolvingInitialValue && (React.createElement(Item, { isGrid: isGrid, index: -1 },
                                React.createElement(Card, { radius: 1, padding: 1 },
                                    React.createElement(Flex, { align: "center", justify: "center", padding: 3 },
                                        React.createElement(Box, { marginX: 3 },
                                            React.createElement(Spinner, { muted: true })),
                                        React.createElement(Text, null, "Resolving initial value\u2026")))))))))),
            React.createElement(DefaultArrayInputFunctions, { type: schemaType, value: value, readOnly: readOnly, onAppendItem: this.handleAppend, onPrependItem: this.handlePrepend, onCreateValue: createProtoValue, onChange: onChange })));
    }
}
//# sourceMappingURL=ArrayInput.js.map