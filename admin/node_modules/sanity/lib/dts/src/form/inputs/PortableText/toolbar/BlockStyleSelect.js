import React, { memo, useCallback, useEffect, useMemo, useState } from 'react';
import { PortableTextEditor, usePortableTextEditor } from '@sanity/portable-text-editor';
import { Button, Menu, MenuButton, MenuItem, Text } from '@sanity/ui';
import { SelectIcon } from '@sanity/icons';
import styled from 'styled-components';
import { Heading1, Heading2, Heading3, Heading4, Heading5, Heading6, BlockQuote, Normal, } from '../text/textStyles';
import { useActiveStyleKeys, useFeatures, useFocusBlock } from './hooks';
const MenuButtonMemo = memo(MenuButton);
const StyledMenuItem = styled(MenuItem) `
  // Change the border color variable used by BlockQuote
  // to make the border visible when the MenuItem is selected
  &[data-selected] {
    [data-option='blockquote'] {
      --card-border-color: var(--card-muted-fg-color);
    }
  }
`;
const StyledButton = styled(Button) `
  width: 100%;
`;
const MENU_POPOVER_PROPS = {
    constrainSize: true,
    placement: 'bottom-start',
    portal: 'default',
};
const TEXT_STYLE_OPTIONS = {
    h1: (title) => React.createElement(Heading1, null, title),
    h2: (title) => React.createElement(Heading2, null, title),
    h3: (title) => React.createElement(Heading3, null, title),
    h4: (title) => React.createElement(Heading4, null, title),
    h5: (title) => React.createElement(Heading5, null, title),
    h6: (title) => React.createElement(Heading6, null, title),
    normal: (title) => React.createElement(Normal, null, title),
    blockquote: (title) => React.createElement(BlockQuote, { "data-option": "blockquote" }, title),
};
const TEXT_STYLE_KEYS = Object.keys(TEXT_STYLE_OPTIONS);
const preventDefault = (event) => event.preventDefault();
const emptyStyle = {
    key: 'style-none',
    style: '',
    title: 'No style',
};
export const BlockStyleSelect = memo(function BlockStyleSelect(props) {
    const { disabled, items: itemsProp } = props;
    const editor = usePortableTextEditor();
    const features = useFeatures();
    const focusBlock = useFocusBlock();
    const [changed, setChanged] = useState(false);
    const _disabled = disabled || (focusBlock ? features.types.block.name !== focusBlock._type : false);
    // @todo: Explain what this does
    const activeKeys = useActiveStyleKeys({ items: itemsProp });
    const { activeItems, items } = useMemo(() => {
        const _activeItems = itemsProp.filter((item) => activeKeys.includes(item.style));
        let _items = itemsProp;
        if (_activeItems.length === 0 && _items.length > 1) {
            _items = _items.concat([emptyStyle]);
            _activeItems.push(emptyStyle);
        }
        return { activeItems: _activeItems, items: _items };
    }, [activeKeys, itemsProp]);
    const menuButtonText = useMemo(() => {
        if (activeItems.length > 1)
            return 'Multiple';
        if (activeItems.length === 1)
            return activeItems[0].title;
        return emptyStyle.title;
    }, [activeItems]);
    const handleChange = useCallback((item) => {
        if (focusBlock && item.style !== focusBlock.style) {
            PortableTextEditor.toggleBlockStyle(editor, item.style);
        }
        setChanged(true);
    }, [editor, focusBlock]);
    const renderOption = useCallback((style, title) => {
        const hasTextStyle = TEXT_STYLE_KEYS.includes(style);
        const renderStyle = TEXT_STYLE_OPTIONS[style];
        if (hasTextStyle) {
            return renderStyle(title);
        }
        return React.createElement(Text, null, title);
    }, []);
    const button = useMemo(() => (React.createElement(StyledButton, { disabled: _disabled, iconRight: SelectIcon, mode: "bleed", onClick: preventDefault, padding: 2, text: menuButtonText })), [_disabled, menuButtonText]);
    const menu = useMemo(() => (React.createElement(Menu, { disabled: _disabled }, items.map((item) => {
        return (React.createElement(StyledMenuItem, { key: item.key, pressed: activeItems.includes(item), 
            // eslint-disable-next-line react/jsx-no-bind
            onClick: _disabled ? undefined : () => handleChange(item) }, renderOption(item.style, item?.title || item.style)));
    }))), [_disabled, activeItems, handleChange, items, renderOption]);
    // Set focus back into the editor when the new value get's in
    // This must be the last registered hook or it will not be able to focus properly.
    useEffect(() => {
        if (changed) {
            PortableTextEditor.focus(editor);
            setChanged(false);
        }
    }, [activeItems, changed, editor]);
    return (React.createElement(MenuButtonMemo, { popover: MENU_POPOVER_PROPS, id: "block-style-select", button: button, menu: menu }));
});
//# sourceMappingURL=BlockStyleSelect.js.map