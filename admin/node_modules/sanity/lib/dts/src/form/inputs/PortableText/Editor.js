import { PortableTextEditable, } from '@sanity/portable-text-editor';
import { BoundaryElementProvider, useBoundaryElement, useGlobalKeyDown, useLayer } from '@sanity/ui';
import React, { useCallback, useMemo, useRef } from 'react';
import { Toolbar } from './toolbar';
import { Decorator } from './text';
import { EditableCard, EditableContainer, EditableWrapper, Root, Scroller, ToolbarCard, } from './Editor.styles';
import { useSpellcheck } from './hooks/useSpellCheck';
import { useScrollSelectionIntoView } from './hooks/useScrollSelectionIntoView';
const renderDecorator = (mark, mType, attributes, defaultRender) => {
    return React.createElement(Decorator, { mark: mark }, defaultRender());
};
export function Editor(props) {
    const { hotkeys, initialSelection, isFullscreen, onCopy, onOpenItem, onPaste, onToggleFullscreen, path, readOnly, renderAnnotation, renderBlock, renderChild, scrollElement, setPortalElement, setScrollElement, } = props;
    const { isTopLayer } = useLayer();
    const editableRef = useRef(null);
    const { element: boundaryElement } = useBoundaryElement();
    // Let escape close fullscreen mode
    useGlobalKeyDown(useCallback((event) => {
        if (!isTopLayer || !isFullscreen) {
            return;
        }
        if (event.key === 'Escape') {
            onToggleFullscreen();
        }
    }, [onToggleFullscreen, isFullscreen, isTopLayer]));
    // Keep the editor focused even though we are clicking on the background or the toolbar of the editor.
    const handleMouseDown = useCallback((event) => {
        if (event.target instanceof Node && !editableRef.current?.contains(event.target)) {
            event.preventDefault();
            event.stopPropagation();
        }
    }, []);
    const renderPlaceholder = useCallback(() => React.createElement(React.Fragment, null, "Empty"), []);
    const spellcheck = useSpellcheck();
    const scrollSelectionIntoView = useScrollSelectionIntoView(scrollElement);
    const editable = useMemo(() => (React.createElement(PortableTextEditable, { hotkeys: hotkeys, onCopy: onCopy, onPaste: onPaste, ref: editableRef, readOnly: readOnly, renderAnnotation: renderAnnotation, renderBlock: renderBlock, renderChild: renderChild, renderDecorator: renderDecorator, renderPlaceholder: renderPlaceholder, scrollSelectionIntoView: scrollSelectionIntoView, selection: initialSelection, spellCheck: spellcheck })), [
        hotkeys,
        initialSelection,
        onCopy,
        onPaste,
        readOnly,
        renderAnnotation,
        renderBlock,
        renderChild,
        renderPlaceholder,
        scrollSelectionIntoView,
        spellcheck,
    ]);
    const handleToolBarOnExpand = useCallback((relativePath) => {
        onOpenItem(path.concat(relativePath));
    }, [onOpenItem, path]);
    return (React.createElement(Root, { "$fullscreen": isFullscreen, "data-testid": "pt-editor", onMouseDown: handleMouseDown },
        !readOnly && (React.createElement(ToolbarCard, { "data-testid": "pt-editor__toolbar-card", shadow: 1 },
            React.createElement(Toolbar, { isFullscreen: isFullscreen, hotkeys: hotkeys, onExpand: handleToolBarOnExpand, readOnly: readOnly, onToggleFullscreen: onToggleFullscreen }))),
        React.createElement(EditableCard, { flex: 1 },
            React.createElement(Scroller, { ref: setScrollElement },
                React.createElement(EditableContainer, { padding: isFullscreen ? 2 : 0, sizing: "border", width: 1 },
                    React.createElement(EditableWrapper, { "$isFullscreen": isFullscreen, "$readOnly": readOnly },
                        React.createElement(BoundaryElementProvider, { element: isFullscreen ? scrollElement : boundaryElement }, editable)))),
            React.createElement("div", { "data-portal": "", ref: setPortalElement }))));
}
//# sourceMappingURL=Editor.js.map