import { PortableTextEditor, usePortableTextEditor, usePortableTextEditorSelection, } from '@sanity/portable-text-editor';
import { useCallback, useMemo } from 'react';
import { useUnique } from '../../../../util';
import { getPTEToolbarActionGroups } from './helpers';
export function useFocusBlock() {
    const editor = usePortableTextEditor();
    const selection = usePortableTextEditorSelection();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    return useMemo(() => PortableTextEditor.focusBlock(editor), [editor, selection]); // selection must be an additional dep here
}
export function useFocusChild() {
    const editor = usePortableTextEditor();
    const selection = usePortableTextEditorSelection();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    return useMemo(() => PortableTextEditor.focusChild(editor), [editor, selection]); // selection must be an additional dep here
}
export function useFeatures() {
    const editor = usePortableTextEditor();
    return useMemo(() => PortableTextEditor.getPortableTextFeatures(editor), [editor]);
}
export function useActionGroups({ hotkeys, onExpand, resolveInitialValue, disabled, }) {
    const editor = usePortableTextEditor();
    const handleInsertAnnotation = useCallback(async (type) => {
        const initialValue = await resolveInitialValue(type);
        const paths = PortableTextEditor.addAnnotation(editor, type, initialValue);
        if (paths && paths.markDefPath) {
            PortableTextEditor.blur(editor);
            onExpand(paths.markDefPath);
        }
    }, [editor, onExpand, resolveInitialValue]);
    return useMemo(() => editor ? getPTEToolbarActionGroups(editor, disabled, handleInsertAnnotation, hotkeys) : [], [disabled, editor, handleInsertAnnotation, hotkeys]);
}
export function useActiveActionKeys({ actions, }) {
    const editor = usePortableTextEditor();
    const selection = usePortableTextEditorSelection();
    return useUnique(useMemo(() => {
        const activeAnnotationKeys = PortableTextEditor.activeAnnotations(editor).map((a) => a._type);
        return actions
            .filter((a) => {
            if (a.type === 'annotation') {
                return activeAnnotationKeys.includes(a.key);
            }
            if (a.type === 'listStyle') {
                return PortableTextEditor.hasListStyle(editor, a.key);
            }
            return PortableTextEditor.isMarkActive(editor, a.key);
        })
            .map((a) => a.key);
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        editor,
        // This is needed so that active actions update as `selection` changes
        selection,
    ]));
}
export function useActiveStyleKeys({ items }) {
    const editor = usePortableTextEditor();
    const focusBlock = useFocusBlock();
    const selection = usePortableTextEditorSelection();
    return useUnique(useMemo(() => items.filter((i) => PortableTextEditor.hasBlockStyle(editor, i.style)).map((i) => i.style), 
    //  eslint-disable-next-line react-hooks/exhaustive-deps
    [
        focusBlock,
        // This is needed so that active styles update as `selection` changes
        selection,
    ]));
}
//# sourceMappingURL=hooks.js.map