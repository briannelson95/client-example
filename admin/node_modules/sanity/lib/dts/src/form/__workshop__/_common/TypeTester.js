import React, { useCallback, useEffect, useRef, useState, useMemo } from 'react';
import { Button, Card, Label, Stack, Text, TextArea } from '@sanity/ui';
import styled, { createGlobalStyle } from 'styled-components';
import { runTest } from './typer';
const HIGHLIGHT_CLASSNAME = 'js-highlight-selected-input';
const GlobalStyle = createGlobalStyle `
  .${HIGHLIGHT_CLASSNAME} {
    outline: 2px solid red;
  }
`;
function getNameFromInput(input) {
    const classNames = input.classList
        .toString()
        .split(' ')
        .filter((name) => name !== HIGHLIGHT_CLASSNAME)
        .join('.');
    return `${input.tagName.toLowerCase()}.${classNames}`;
}
const Sticky = styled.div `
  position: sticky;
  top: 1rem;
  z-index: 2;
`;
export function TypeTester({ readOnly }) {
    const textAreaRef = useRef(null);
    const [focusedInput, setFocusedInput] = useState();
    const [testOutput, setTestOutput] = useState('');
    const [isRunning, setIsRunning] = useState(false);
    const cancelTypeTester = useRef(() => true);
    const handleFocus = useCallback((e) => {
        if (textAreaRef.current && e.target === textAreaRef.current) {
            return;
        }
        if ((e.type === 'focusin' && e.target instanceof HTMLInputElement) ||
            e.target instanceof HTMLTextAreaElement) {
            setFocusedInput(e.target);
        }
    }, [textAreaRef]);
    useEffect(() => {
        document.addEventListener('focusin', handleFocus);
        return () => {
            document.removeEventListener('focusin', handleFocus);
            if (cancelTypeTester.current) {
                cancelTypeTester.current();
            }
        };
    }, [handleFocus]);
    const handleRunTest = useCallback(() => {
        setIsRunning(true);
        setTestOutput('Running test...');
        cancelTypeTester.current = runTest({
            inputElement: focusedInput,
            times: 4,
            gracePeriod: 4000,
            onRun: (output) => {
                setTestOutput((existing) => `${existing}\n${output}`);
            },
            onFinished: () => {
                setIsRunning(false);
            },
        });
    }, [focusedInput]);
    const handleHighlightMouseOver = useCallback((event) => {
        if (event.type === 'mouseover') {
            focusedInput.classList.add(HIGHLIGHT_CLASSNAME);
        }
        if (event.type === 'mouseout') {
            focusedInput.classList.remove(HIGHLIGHT_CLASSNAME);
        }
    }, [focusedInput]);
    const handleHighlightClick = useCallback(() => {
        if (focusedInput) {
            focusedInput.focus();
        }
    }, [focusedInput]);
    const isDisabled = useMemo(() => {
        return (isRunning ||
            !focusedInput ||
            !['INPUT', 'TEXTAREA'].includes(focusedInput.tagName) ||
            readOnly);
    }, [focusedInput, isRunning, readOnly]);
    return (React.createElement(Sticky, null,
        React.createElement(Card, { padding: 4, tone: "default", border: true },
            React.createElement(Stack, { space: 4 },
                React.createElement(Label, { size: 0 }, "Type Performance Tester"),
                React.createElement(Text, { title: isDisabled ? undefined : `Click to focus input`, size: 1, onClick: handleHighlightClick, onMouseOver: handleHighlightMouseOver, onMouseOut: handleHighlightMouseOver }, isDisabled && !isRunning
                    ? 'No input selected'
                    : `Selected input: ${focusedInput ? getNameFromInput(focusedInput) : '<none>'}`),
                React.createElement(TextArea, { ref: textAreaRef, readOnly: true, rows: 6, value: testOutput }),
                React.createElement(Button, { text: "Run test", onClick: handleRunTest, disabled: isDisabled, loading: isRunning }))),
        React.createElement(GlobalStyle, null)));
}
//# sourceMappingURL=TypeTester.js.map