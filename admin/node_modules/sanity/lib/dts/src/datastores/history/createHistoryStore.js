import { isReference, } from '@sanity/types';
import jsonReduce from 'json-reduce';
import { from } from 'rxjs';
import { map, mergeMap } from 'rxjs/operators';
import { getDraftId, getPublishedId, isRecord } from '../../util';
import { Timeline, createObservableController } from './history';
const documentRevisionCache = Object.create(null);
const getHistory = (client, documentIds, options = {}) => {
    const ids = Array.isArray(documentIds) ? documentIds : [documentIds];
    const { time, revision } = options;
    if (time && revision) {
        throw new Error(`getHistory can't handle both time and revision parameters`);
    }
    const dataset = client.clientConfig.dataset;
    let url = `/data/history/${dataset}/documents/${ids.join(',')}`;
    if (revision) {
        url = `${url}?revision=${revision}`;
    }
    else {
        const timestamp = time || new Date().toISOString();
        url = `${url}?time=${timestamp}`;
    }
    return client.request({ url });
};
const getDocumentAtRevision = (client, documentId, revision) => {
    const publishedId = getPublishedId(documentId);
    const draftId = getDraftId(documentId);
    const cacheKey = `${publishedId}@${revision}`;
    const cached = documentRevisionCache[cacheKey];
    if (cached) {
        return cached;
    }
    const dataset = client.clientConfig.dataset;
    const url = `/data/history/${dataset}/documents/${publishedId},${draftId}?revision=${revision}`;
    const entry = client.request({ url }).then((result) => {
        const documents = result.documents || [];
        const published = documents.find((res) => res._id === publishedId);
        const draft = documents.find((res) => res._id === draftId);
        return draft || published;
    });
    documentRevisionCache[cacheKey] = entry;
    return entry;
};
const getTransactions = async (client, documentIds) => {
    const ids = Array.isArray(documentIds) ? documentIds : [documentIds];
    const dataset = client.clientConfig.dataset;
    const query = { excludeContent: 'true', includeIdentifiedDocumentsOnly: 'true' };
    const url = `/data/history/${dataset}/transactions/${ids.join(',')}`;
    const result = await client.request({ url, query });
    const transactions = result
        .toString('utf8')
        .split('\n')
        .filter(Boolean)
        .map((line) => JSON.parse(line));
    return transactions;
};
const getAllRefIds = (doc) => jsonReduce(doc, (acc, node) => (isReference(node) && !acc.includes(node._ref) ? [...acc, node._ref] : acc), []);
function jsonMap(value, mapFn) {
    if (Array.isArray(value)) {
        return mapFn(value.map((item) => jsonMap(item, mapFn)).filter((item) => typeof item !== 'undefined'));
    }
    if (isRecord(value)) {
        return mapFn(Object.keys(value).reduce((res, key) => {
            const mappedValue = jsonMap(value[key], mapFn);
            if (typeof mappedValue !== 'undefined') {
                res[key] = mappedValue;
            }
            return res;
        }, {}));
    }
    return mapFn(value);
}
const mapRefNodes = (doc, mapFn) => jsonMap(doc, (node) => (isReference(node) ? mapFn(node) : node));
export const removeMissingReferences = (doc, existingIds) => mapRefNodes(doc, (refNode) => {
    const documentExists = existingIds[refNode._ref];
    return documentExists ? refNode : undefined;
});
function restore(client, documentId, targetDocumentId, rev) {
    return from(getDocumentAtRevision(client, documentId, rev)).pipe(mergeMap((documentAtRevision) => {
        if (!documentAtRevision) {
            throw new Error(`Unable to find document with ID ${documentId} at revision ${rev}`);
        }
        const existingIdsQuery = getAllRefIds(documentAtRevision)
            .map((refId) => `"${refId}": defined(*[_id=="${refId}"]._id)`)
            .join(',');
        return client.observable
            .fetch(`{${existingIdsQuery}}`)
            .pipe(map((existingIds) => removeMissingReferences(documentAtRevision, existingIds)));
    }), map((documentAtRevision) => {
        // Remove _updatedAt and create a new draft from the document at given revision
        const { _updatedAt, ...document } = documentAtRevision;
        return { ...document, _id: targetDocumentId };
    }), mergeMap((restoredDraft) => client.observable.createOrReplace(restoredDraft, { visibility: 'async' })));
}
export function createHistoryStore({ client }) {
    return {
        getDocumentAtRevision: (documentId, revision) => getDocumentAtRevision(client, documentId, revision),
        getHistory: (documentIds, options) => getHistory(client, documentIds, options),
        getTransactions: (documentIds) => getTransactions(client, documentIds),
        restore: (id, targetId, rev) => restore(client, id, targetId, rev),
        getTimeline: (options) => new Timeline(options),
        getTimelineController: (options) => createObservableController(options),
    };
}
//# sourceMappingURL=createHistoryStore.js.map