import { from, of } from 'rxjs';
import { filter, map, mergeMap, toArray } from 'rxjs/operators';
const TOKEN_DOCUMENT_ID_BASE = `secrets.sanity.sharedContent`;
function isNonNullable(value) {
    return value !== null;
}
// eslint-disable-next-line camelcase
export function __tmp_wrap_crossProjectToken({ client: _client, }) {
    const versionedClient = _client.withConfig({ apiVersion: '1' });
    function fetchTokenDocument(client, id) {
        return client.observable.fetch(`*[_id == $id]{_id, _type, _updatedAt, token}[0]`, {
            id,
        });
    }
    return {
        getTokenDocumentId,
        getProjectIdFromTokenDocumentId,
        fetchCrossProjectToken,
        fetchAllCrossProjectTokens,
    };
    // export
    function getTokenDocumentId({ tokenId, projectId }) {
        return [TOKEN_DOCUMENT_ID_BASE, projectId, tokenId].filter(Boolean).join('.');
    }
    // export
    function getProjectIdFromTokenDocumentId(id) {
        if (!id.startsWith(TOKEN_DOCUMENT_ID_BASE)) {
            return null;
        }
        //prettier-ignore
        const [/*secrets*/ , /*sanity*/ , /*sharedContent*/ , projectId] = id.split('.');
        return projectId;
    }
    // export
    function fetchCrossProjectToken(client, { projectId, tokenId }) {
        if (client.config().projectId === projectId) {
            return of(undefined);
        }
        return fetchTokenDocument(client, getTokenDocumentId({ projectId, tokenId })).pipe(map((tokenDoc) => tokenDoc.token));
    }
    // export
    function fetchAllCrossProjectTokens() {
        return versionedClient.observable
            .fetch(`*[_id in path("${TOKEN_DOCUMENT_ID_BASE}.**")]{_id, _type, _updatedAt, token}`)
            .pipe(mergeMap((tokenDocs) => from(tokenDocs)), map((doc) => {
            const projectId = getProjectIdFromTokenDocumentId(doc._id);
            return projectId ? { projectId, token: doc.token } : null;
        }), filter(isNonNullable), toArray());
    }
}
//# sourceMappingURL=crossProjectToken.js.map