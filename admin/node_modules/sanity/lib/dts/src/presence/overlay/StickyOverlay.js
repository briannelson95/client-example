/* eslint-disable @typescript-eslint/no-use-before-define */
import React, { memo, useMemo } from 'react';
import { flatten, groupBy, orderBy, sortBy } from 'lodash';
import { AVATAR_ARROW_HEIGHT, AVATAR_DISTANCE, AVATAR_SIZE, DEBUG, MAX_AVATARS_DOCK, SLIDE_RIGHT_THRESHOLD_BOTTOM, SLIDE_RIGHT_THRESHOLD_TOP, } from '../constants';
import { FieldPresenceInner } from '../FieldPresence';
import { RegionsWithIntersections } from './RegionsWithIntersections';
import { useReportedValues } from './tracker';
const ITEM_TRANSITION = {
    transitionProperty: 'transform',
    transitionDuration: '200ms',
    transitionTimingFunction: 'cubic-bezier(0.85, 0, 0.15, 1)',
};
const bottom = (rect) => rect.top + rect.height;
function withSpacerHeight(regionsWithIntersectionDetails) {
    return regionsWithIntersectionDetails.map((withIntersection, idx, _regionsWithIntersectionDetails) => {
        const prevRect = _regionsWithIntersectionDetails[idx - 1]?.region.rect;
        const prevBottom = prevRect ? bottom(prevRect) : 0;
        return { ...withIntersection, spacerHeight: withIntersection.region.rect.top - prevBottom };
    });
}
const orderByTop = (regionsWithIntersectionDetails) => orderBy(regionsWithIntersectionDetails, (withIntersection) => withIntersection.region.rect.top);
const plus = (a, b) => a + b;
const sum = (array) => array.reduce(plus, 0);
function group(regionsWithIntersectionDetails) {
    const regionsWithSpacerHeight = withSpacerHeight(orderByTop(regionsWithIntersectionDetails));
    const grouped = {
        top: [],
        inside: [],
        bottom: [],
        ...groupBy(regionsWithSpacerHeight, (_withSpacerHeight) => _withSpacerHeight.position),
    };
    return {
        top: orderByTop(grouped.top).map((withIntersection, i, grp) => ({
            ...withIntersection,
            indent: grp
                .slice(i + 1)
                .reduce((w, _withIntersection) => w + _withIntersection.region.rect.width, 0),
        })),
        inside: orderByTop(grouped.inside).map((withIntersection) => ({
            ...withIntersection,
            indent: 0,
        })),
        bottom: orderByTop(grouped.bottom).map((withIntersection, i, grp) => ({
            ...withIntersection,
            indent: grp
                .slice(0, i)
                .reduce((w, _withIntersection) => w + _withIntersection.region.rect.width, 0),
        })),
    };
}
const Spacer = ({ height, ...rest }) => (React.createElement("div", { style: { height: Math.max(0, height), ...rest?.style } }));
const DEFAULT_MARGINS = [0, 0, 0, 0];
const getOffsetsTo = (source, target) => {
    let el = source;
    let top = -el.scrollTop;
    let left = 0;
    while (el && el !== target) {
        top += el.offsetTop - el.scrollTop;
        left += el.offsetLeft;
        el = el.offsetParent instanceof HTMLElement ? el.offsetParent : null;
    }
    return { top, left };
};
function getRelativeRect(element, parent) {
    return {
        ...getOffsetsTo(element, parent),
        width: element.offsetWidth,
        height: element.offsetHeight,
    };
}
function regionsWithComputedRects(regions, parent) {
    return regions.map(([id, region]) => ({
        ...region,
        id,
        rect: getRelativeRect(region.element, parent),
    }));
}
export function StickyOverlay(props) {
    const { children, margins = DEFAULT_MARGINS } = props;
    const reportedValues = useReportedValues();
    const ref = React.useRef(null);
    const regions = React.useMemo(() => (ref.current ? regionsWithComputedRects(reportedValues, ref.current) : EMPTY_ARRAY), [reportedValues]);
    const renderCallback = React.useCallback((regionsWithIntersectionDetails, containerWidth) => {
        const grouped = group(regionsWithIntersectionDetails.filter((item) => item.region.presence.length > 0));
        const topSpacing = sum(grouped.top.map((n) => n.region.rect.height + n.spacerHeight));
        const bottomSpacing = sum([...grouped.inside, ...grouped.bottom].map((n) => n.region.rect.height + n.spacerHeight));
        // todo: this needs cleaning up, should process all the needed layout data in one go
        const counts = grouped.inside.reduce((_counts, withIntersection) => {
            const { distanceTop, distanceBottom } = withIntersection;
            const nearTop = distanceTop <= SLIDE_RIGHT_THRESHOLD_TOP;
            const nearBottom = distanceBottom <= SLIDE_RIGHT_THRESHOLD_BOTTOM;
            return {
                nearTop: _counts.nearTop + (nearTop ? withIntersection.region.presence.length : 0),
                nearBottom: _counts.nearBottom + (nearBottom ? withIntersection.region.presence.length : 0),
            };
        }, { nearTop: 0, nearBottom: 0 });
        return (React.createElement(React.Fragment, null,
            React.createElement(PresenceDock, { closeCount: counts.nearTop, margins: margins, position: "top", regionsWithIntersectionDetails: grouped.top }),
            React.createElement(Spacer, { height: topSpacing }),
            React.createElement(PresenceInside, { containerWidth: containerWidth, regionsWithIntersectionDetails: grouped.inside }),
            React.createElement(Spacer, { height: bottomSpacing }),
            React.createElement(PresenceDock, { closeCount: counts.nearBottom, margins: margins, position: "bottom", regionsWithIntersectionDetails: grouped.bottom })));
    }, [margins]);
    return (React.createElement(RegionsWithIntersections, { ref: ref, margins: margins, regions: regions, render: renderCallback }, children));
}
const EMPTY_ARRAY = [];
const PresenceDock = memo(function PresenceDock(props) {
    const { closeCount, margins, position, regionsWithIntersectionDetails } = props;
    const dir = position === 'top' ? 1 : -1;
    const allPresenceItems = useMemo(() => {
        if (!regionsWithIntersectionDetails.length) {
            return EMPTY_ARRAY;
        }
        return flatten(sortBy(regionsWithIntersectionDetails, (r) => r.region.rect.top * dir).map((withIntersection) => withIntersection.region.presence || EMPTY_ARRAY));
    }, [dir, regionsWithIntersectionDetails]);
    const [topMargin, rightMargin, bottomMargin, leftMargin] = margins;
    const leftOffset = (leftMargin || 0) +
        (allPresenceItems.length > 0 ? -closeCount * (AVATAR_SIZE + AVATAR_DISTANCE) : 0) -
        rightMargin;
    const margin = position === 'top' ? topMargin : bottomMargin;
    const style = useMemo(() => ({
        zIndex: 2,
        position: 'sticky',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'flex-end',
        ...ITEM_TRANSITION,
        transform: `translate3d(${leftOffset}px, 0px, 0px)`,
        top: AVATAR_ARROW_HEIGHT + 1 + margin,
        bottom: AVATAR_ARROW_HEIGHT + 1 + margin,
    }), [leftOffset, margin]);
    return (React.createElement("div", { "data-dock": position, key: `sticky-${position}`, style: style },
        React.createElement(FieldPresenceInner, { position: position, maxAvatars: MAX_AVATARS_DOCK, presence: allPresenceItems })));
});
function PresenceInside(props) {
    const { regionsWithIntersectionDetails, containerWidth } = props;
    return (React.createElement(React.Fragment, null, regionsWithIntersectionDetails.map((withIntersection) => {
        const originalLeft = withIntersection.region.rect.left;
        const { distanceTop, distanceBottom } = withIntersection;
        const nearTop = distanceTop <= SLIDE_RIGHT_THRESHOLD_TOP;
        const nearBottom = distanceBottom <= SLIDE_RIGHT_THRESHOLD_BOTTOM;
        const diffRight = containerWidth - originalLeft - withIntersection.region.rect.width;
        const { presence, maxAvatars } = withIntersection.region;
        return (React.createElement(React.Fragment, { key: withIntersection.region.id },
            React.createElement("div", { style: {
                    zIndex: 2,
                    position: 'absolute',
                    pointerEvents: 'all',
                    ...ITEM_TRANSITION,
                    left: originalLeft,
                    transform: `translate3d(${nearTop || nearBottom ? diffRight : 0}px, 0px, 0px)`,
                    height: withIntersection.region.rect.height,
                    top: withIntersection.region.rect.top,
                } },
                React.createElement(DebugValue, { value: () => `⤒${distanceTop} | ${distanceBottom}⤓` },
                    React.createElement(FieldPresenceInner, { stack: !nearTop && !nearBottom, 
                        // eslint-disable-next-line no-nested-ternary
                        position: nearTop ? 'top' : nearBottom ? 'bottom' : 'inside', maxAvatars: maxAvatars, presence: presence })))));
    })));
}
const PassThrough = (props) => props.children;
const DebugValue = DEBUG
    ? function DebugValue(props) {
        return (React.createElement("div", { style: { position: 'absolute' } },
            props.children,
            React.createElement("span", { style: {
                    top: 0,
                    left: -15,
                    fontSize: 11,
                    right: -15,
                    textAlign: 'center',
                    height: AVATAR_SIZE,
                    color: 'white',
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    position: 'absolute',
                    zIndex: 1000,
                } }, props.value())));
    }
    : PassThrough;
//# sourceMappingURL=StickyOverlay.js.map