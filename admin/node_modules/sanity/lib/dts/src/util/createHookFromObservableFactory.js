import { useAsObservable, useObservable } from 'react-rx';
import { concat, of } from 'rxjs';
import { catchError, distinctUntilChanged, map, scan, switchMap } from 'rxjs/operators';
import shallowEquals from 'shallow-equals';
import { useUnique } from './useUnique';
function defaultArgsAreEqual(prev, next) {
    if (prev.length !== next.length)
        return false;
    for (let i = 0; i < next.length; i++) {
        if (!shallowEquals(prev[i], next[i]))
            return false;
    }
    return true;
}
/**
 * A function that will create a hook from a function that returns an
 * observable. The parameters of the hook will be the parameters of the function
 * and the return of the hook will be a loading tuple with the value of the
 * observable at the first index and a boolean with the loading state as the
 * second index.
 *
 * The loading state will become true as soon as new incoming args are given and
 * will flip to false when the observable from the function emits the next
 * value.
 */
export function createHookFromObservableFactory(observableFactory, options) {
    const { initialValue, argsAreEqual = defaultArgsAreEqual } = options || {};
    const initialLoadingTuple = [initialValue, true];
    const asLoadingTuple = (args$) => args$.pipe(distinctUntilChanged(argsAreEqual), switchMap((distinctArgs) => concat(of({ type: 'loading' }), observableFactory(...distinctArgs).pipe(map((value) => ({ type: 'value', value }))))), scan(([prevValue], next) => {
        if (next.type === 'loading')
            return [prevValue, true];
        return [next.value, false];
    }, initialLoadingTuple), distinctUntilChanged(([prevValue, prevIsLoading], [nextValue, nextIsLoading]) => {
        if (prevValue !== nextValue)
            return false;
        if (prevIsLoading !== nextIsLoading)
            return false;
        return true;
    }), map((tuple) => ({ type: 'tuple', tuple })), catchError((error) => of({ type: 'error', error })));
    return function useLoadableFromCreateLoadable(...args) {
        const _args = useUnique(args);
        const tuple$ = useAsObservable(_args, asLoadingTuple);
        const result = useObservable(tuple$, { type: 'tuple', tuple: initialLoadingTuple });
        if (result.type === 'error')
            throw result.error;
        return result.tuple;
    };
}
//# sourceMappingURL=createHookFromObservableFactory.js.map