import { isEqual } from 'lodash';
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { RouterContext } from './RouterContext';
/**
 * @example
 * ```tsx
 * import {
 *   NavigateOptions,
 *   route,
 *   RouterProvider,
 *   RouterState
 * } from 'sanity'
 * import {useCallback, useMemo} from 'react'
 *
 * function Root() {
 *   const router = useMemo(() => route.create('/'), [])
 *
 *   const [state, setState] = useState<RouterState>({})
 *
 *   const handleNavigate = useCallback((
 *     path: string,
 *     options?: NavigateOptions
 *   ) => {
 *     console.log('navigate', path, options)
 *
 *     setState(router.decode(path))
 *   }, [router])
 *
 *   return (
 *     <RouterProvider
 *       onNavigate={handleNavigate}
 *       router={router}
 *       state={state}
 *     >
 *       <div>This is a routed application</div>
 *     </RouterProvider>
 *   )
 * }
 * ```
 *
 * @public
 */
export function RouterProvider(props) {
    // TODO: can we do nested routes?
    const { onNavigate, router: routerProp, state: stateProp } = props;
    const [state, setState] = useState(stateProp);
    const stateRef = useRef(state);
    const navigateUrl = useCallback((opts) => {
        onNavigate(opts);
    }, [onNavigate]);
    const resolveIntentLink = useCallback((intentName, parameters) => {
        const [params, payload] = Array.isArray(parameters) ? parameters : [parameters];
        return routerProp.encode({ intent: intentName, params, payload });
    }, [routerProp]);
    const resolvePathFromState = useCallback((nextState) => {
        return routerProp.encode(nextState);
    }, [routerProp]);
    const navigate = useCallback((nextState, options = {}) => {
        navigateUrl({ path: resolvePathFromState(nextState), replace: options.replace });
    }, [navigateUrl, resolvePathFromState]);
    const navigateIntent = useCallback((intentName, params, options = {}) => {
        navigateUrl({ path: resolveIntentLink(intentName, params), replace: options.replace });
    }, [navigateUrl, resolveIntentLink]);
    const router = useMemo(() => ({
        navigate,
        navigateIntent,
        navigateUrl,
        resolveIntentLink,
        resolvePathFromState,
        state,
    }), [navigate, navigateIntent, navigateUrl, resolveIntentLink, resolvePathFromState, state]);
    // Update state as new `state` prop comes in
    useEffect(() => {
        const prevState = stateRef.current;
        const nextState = stateProp;
        if (!isEqual(nextState, prevState)) {
            setState(nextState);
        }
    }, [stateProp]);
    return React.createElement(RouterContext.Provider, { value: router }, props.children);
}
//# sourceMappingURL=RouterProvider.js.map