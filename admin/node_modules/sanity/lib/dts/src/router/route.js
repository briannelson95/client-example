import { parseRoute } from './parseRoute';
import { resolveStateFromPath } from './resolveStateFromPath';
import { resolvePathFromState } from './resolvePathFromState';
import { decodeJsonParams, encodeJsonParams } from './utils/jsonParamsEncoding';
import { decodeParams, encodeParams } from './utils/paramsEncoding';
function normalizeChildren(children) {
    if (Array.isArray(children) || typeof children === 'function') {
        return children;
    }
    return children ? [children] : [];
}
function isRoute(val) {
    return val && '_isRoute' in val;
}
function normalizeArgs(path, childrenOrOpts, children) {
    if (typeof path === 'object') {
        return path;
    }
    if (Array.isArray(childrenOrOpts) ||
        typeof childrenOrOpts === 'function' ||
        isRoute(childrenOrOpts)) {
        return { path, children: normalizeChildren(childrenOrOpts) };
    }
    if (children) {
        return { path, ...childrenOrOpts, children: normalizeChildren(children) };
    }
    return { path, ...childrenOrOpts };
}
/**
 * @public
 */
export const route = { create: createRoute, scope: routeScope, intents: routeIntents };
function createRoute(routeOrOpts, childrenOrOpts, children) {
    return createNode(normalizeArgs(routeOrOpts, childrenOrOpts, children));
}
function routeScope(scopeName, ...rest) {
    const options = normalizeArgs(...rest);
    return createNode({
        ...options,
        scope: scopeName,
    });
}
function normalize(...paths) {
    return paths.reduce((acc, path) => acc.concat(path.split('/')), []).filter(Boolean);
}
function routeIntents(base) {
    const basePath = normalize(base).join('/');
    return route.create(`${basePath}/:intent`, [
        route.create(':params', {
            transform: {
                params: {
                    toState: decodeParams,
                    toPath: encodeParams,
                },
            },
        }, [
            route.create(':payload', {
                transform: {
                    payload: {
                        toState: decodeJsonParams,
                        toPath: encodeJsonParams,
                    },
                },
            }),
        ]),
    ]);
}
const EMPTY_STATE = {};
function isRoot(pathname) {
    // it is the root if every segment is an empty string
    return pathname.split('/').every((segment) => !segment);
}
function createNode(options) {
    const { path, scope, transform, children } = options;
    if (!path) {
        throw new TypeError('Missing path');
    }
    const parsedRoute = parseRoute(path);
    return {
        _isRoute: true,
        scope,
        route: parsedRoute,
        children: children || [],
        transform,
        encode(state) {
            return resolvePathFromState(this, state);
        },
        decode(_path) {
            return resolveStateFromPath(this, _path);
        },
        isRoot: isRoot,
        isNotFound(pathname) {
            return this.decode(pathname) === null;
        },
        getBasePath() {
            return this.encode(EMPTY_STATE);
        },
        getRedirectBase(pathname) {
            if (isRoot(pathname)) {
                const basePath = this.getBasePath();
                // Check if basepath is something different than given
                if (pathname !== basePath) {
                    return basePath;
                }
            }
            return null;
        },
    };
}
//# sourceMappingURL=route.js.map