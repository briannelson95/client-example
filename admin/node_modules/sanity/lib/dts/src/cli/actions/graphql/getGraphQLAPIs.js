import { Worker, isMainThread, parentPort, workerData } from 'worker_threads';
import oneline from 'oneline';
import { isPlainObject } from 'lodash';
import { getStudioConfig } from '../../util/getStudioConfig';
import { createSchema } from '../../../schema';
if (!isMainThread && parentPort) {
    getGraphQLAPIsForked(parentPort);
}
async function getGraphQLAPIsForked(parent) {
    const { cliConfig, cliConfigPath, workDir } = workerData;
    const resolved = await resolveGraphQLApis({ cliConfig, cliConfigPath, workDir });
    parent.postMessage(resolved);
}
export async function getGraphQLAPIs(cliContext) {
    if (!isModernCliConfig(cliContext)) {
        throw new Error('Expected Sanity studio of version 3 or above');
    }
    if (!isMainThread) {
        throw new Error('getGraphQLAPIs() must be called from the main thread');
    }
    const defaultSchema = createSchema({ name: 'default', types: [] });
    const defaultTypes = defaultSchema.getTypeNames();
    const isCustomType = (type) => !defaultTypes.includes(type.name);
    const apis = await getApisWithSchemaTypes(cliContext);
    const resolved = apis.map(({ schemaTypes, ...api }) => ({
        schema: createSchema({ name: 'default', types: schemaTypes.filter(isCustomType) }),
        ...api,
    }));
    return resolved;
}
function getApisWithSchemaTypes(cliContext) {
    return new Promise((resolve, reject) => {
        const { cliConfig, cliConfigPath, workDir } = cliContext;
        const worker = new Worker(__filename, { workerData: { cliConfig, cliConfigPath, workDir } });
        worker.on('message', resolve);
        worker.on('error', reject);
        worker.on('exit', (code) => {
            if (code !== 0)
                reject(new Error(`Worker stopped with exit code ${code}`));
        });
    });
}
async function resolveGraphQLApis({ cliConfig, cliConfigPath, workDir, }) {
    const workspaces = await getStudioConfig({ basePath: workDir });
    const numSources = workspaces.reduce((count, workspace) => count + workspace.unstable_sources.length, 0);
    const multiSource = numSources > 1;
    const multiWorkspace = workspaces.length > 1;
    const hasGraphQLConfig = Boolean(cliConfig?.graphql);
    if (workspaces.length === 0) {
        throw new Error('No studio configuration found');
    }
    if (numSources === 0) {
        throw new Error('No sources (project ID / dataset) configured');
    }
    // We can only automatically configure if there is a single workspace + source in play
    if ((multiWorkspace || multiSource) && !hasGraphQLConfig) {
        throw new Error(oneline `
      Multiple workspaces/sources configured.
      You must define an array of GraphQL APIs in ${cliConfigPath || 'sanity.cli.js'}
      and specify which workspace/source to use.
    `);
    }
    // No config is defined, but we have a single workspace + source, so use that
    if (!hasGraphQLConfig) {
        const { projectId, dataset, schema } = workspaces[0].unstable_sources[0];
        return [{ schemaTypes: getStrippedSchemaTypes(schema), projectId, dataset }];
    }
    // Explicity defined config
    const apiDefs = validateCliConfig(cliConfig?.graphql || []);
    return resolveGraphQLAPIsFromConfig(apiDefs, workspaces);
}
function resolveGraphQLAPIsFromConfig(apiDefs, workspaces) {
    const resolvedApis = [];
    for (const apiDef of apiDefs) {
        const { workspace: workspaceName, source: sourceName } = apiDef;
        if (!workspaceName && workspaces.length > 0) {
            throw new Error('Must define `workspace` name in GraphQL API config when multiple workspaces are defined');
        }
        // If we only have a single workspace defined, we can assume that is the intended one,
        // even if no `workspace` is defined for the GraphQL API
        const workspace = !workspaceName && workspaces.length === 1
            ? workspaces[0]
            : workspaces.find((space) => space.name === (workspaceName || 'default'));
        if (!workspace) {
            throw new Error(`Workspace "${workspaceName || 'default'}" not found`);
        }
        // If we only have a single source defined, we can assume that is the intended one,
        // even if no `source` is defined for the GraphQL API
        const source = !sourceName && workspace.unstable_sources.length === 1
            ? workspace.unstable_sources[0]
            : workspace.unstable_sources.find((src) => src.name === (sourceName || 'default'));
        if (!source) {
            throw new Error(`Source "${sourceName || 'default'}" not found in workspace "${workspaceName || 'default'}"`);
        }
        resolvedApis.push({
            ...apiDef,
            dataset: source.dataset,
            projectId: source.projectId,
            schemaTypes: getStrippedSchemaTypes(source.schema),
        });
    }
    return resolvedApis;
}
function validateCliConfig(config, configPath = 'sanity.cli.js') {
    if (!Array.isArray(config)) {
        throw new Error(`"graphql" key in "${configPath}" must be an array if defined`);
    }
    if (config.length === 0) {
        throw new Error(`No GraphQL APIs defined in "${configPath}"`);
    }
    return config;
}
function isModernCliConfig(config) {
    return config.sanityMajorVersion >= 3;
}
function getStrippedSchemaTypes(schema) {
    const schemaDef = schema._original || { types: [] };
    return schemaDef.types.map((type) => stripType(type));
}
function stripType(input) {
    return strip(input);
}
function strip(input) {
    if (Array.isArray(input)) {
        return input.map((item) => strip(item)).filter((item) => typeof item !== 'undefined');
    }
    if (isPlainishObject(input)) {
        return Object.keys(input).reduce((stripped, key) => {
            stripped[key] = strip(input[key]);
            return stripped;
        }, {});
    }
    return isBasicType(input) ? input : undefined;
}
function isPlainishObject(input) {
    return isPlainObject(input);
}
function isBasicType(input) {
    const type = typeof input;
    if (type === 'boolean' || type === 'number' || type === 'string') {
        return true;
    }
    if (type !== 'object') {
        return false;
    }
    return Array.isArray(input) || input === null || isPlainishObject(input);
}
//# sourceMappingURL=getGraphQLAPIs.js.map