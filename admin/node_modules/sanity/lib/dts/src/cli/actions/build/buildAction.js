import path from 'path';
import { promisify } from 'util';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore This may not yet be built.
import { buildStaticFiles } from '@sanity/server';
import chalk from 'chalk';
import rimrafCallback from 'rimraf';
import { checkStudioDependencyVersions } from '../../util/checkStudioDependencyVersions';
import { checkRequiredDependencies } from '../../util/checkRequiredDependencies';
import { getTimer } from '../../util/timing';
const rimraf = promisify(rimrafCallback);
export default async function buildSanityStudio(args, context, overrides) {
    const timer = getTimer();
    const { output, prompt, workDir, cliConfig } = context;
    const flags = {
        minify: true,
        stats: false,
        'source-maps': false,
        ...args.extOptions,
    };
    const unattendedMode = Boolean(flags.yes || flags.y);
    const defaultOutputDir = path.resolve(path.join(workDir, 'dist'));
    const outputDir = path.resolve(args.argsWithoutOptions[0] || defaultOutputDir);
    await checkStudioDependencyVersions(workDir);
    // If the check resulted in a dependency install, the CLI command will be re-run,
    // thus we want to exit early
    if ((await checkRequiredDependencies(context)).didInstall) {
        return { didCompile: false };
    }
    const envVarKeys = getSanityEnvVars();
    if (envVarKeys.length > 0) {
        output.print('\nIncluding the following environment variables as part of the JavaScript bundle:');
        envVarKeys.forEach((key) => output.print(`- ${key}`));
        output.print('');
    }
    let shouldClean = true;
    if (outputDir !== defaultOutputDir && !unattendedMode) {
        shouldClean = await prompt.single({
            type: 'confirm',
            message: `Do you want to delete the existing directory (${outputDir}) first?`,
            default: true,
        });
    }
    let spin;
    if (shouldClean) {
        timer.start('cleanOutputFolder');
        spin = output.spinner('Clean output folder').start();
        await rimraf(outputDir);
        const cleanDuration = timer.end('cleanOutputFolder');
        spin.text = `Clean output folder (${cleanDuration.toFixed()}ms)`;
        spin.succeed();
    }
    spin = output.spinner('Build Sanity Studio').start();
    try {
        timer.start('bundleStudio');
        const bundle = await buildStaticFiles({
            cwd: workDir,
            outputDir,
            basePath: overrides?.basePath || cliConfig?.project?.basePath || '/',
            sourceMap: Boolean(flags['source-maps']),
            minify: Boolean(flags.minify),
            vite: cliConfig && 'vite' in cliConfig ? cliConfig.vite : undefined,
        });
        const buildDuration = timer.end('bundleStudio');
        spin.text = `Build Sanity Studio (${buildDuration.toFixed()}ms)`;
        spin.succeed();
        if (flags.stats) {
            output.print('\nLargest module files:');
            output.print(formatModuleSizes(sortModulesBySize(bundle.chunks).slice(0, 15)));
        }
    }
    catch (err) {
        spin.fail();
        throw err;
    }
    return { didCompile: true };
}
// eslint-disable-next-line no-process-env
function getSanityEnvVars(env = process.env) {
    return Object.keys(env).filter((key) => key.toUpperCase().startsWith('SANITY_STUDIO_'));
}
function sortModulesBySize(chunks) {
    return chunks
        .flatMap((chunk) => chunk.modules)
        .sort((modA, modB) => modB.renderedLength - modA.renderedLength);
}
function formatModuleSizes(modules) {
    const lines = [];
    for (const mod of modules) {
        lines.push(` - ${formatModuleName(mod.name)} (${formatSize(mod.renderedLength)})`);
    }
    return lines.join('\n');
}
function formatModuleName(modName) {
    const delimiter = '/node_modules/';
    const nodeIndex = modName.lastIndexOf(delimiter);
    return nodeIndex === -1 ? modName : modName.slice(nodeIndex + delimiter.length);
}
function formatSize(bytes) {
    return chalk.cyan(`${(bytes / 1024).toFixed()} kB`);
}
//# sourceMappingURL=buildAction.js.map