import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { map, filter, scan, catchError } from 'rxjs/operators';
import { combineLatest, of } from 'rxjs';
import { ErrorBoundary } from '@sanity/ui';
import { createHookFromObservableFactory } from '../../util';
import { ConfigResolutionError } from '../../config';
import { RouterProvider } from '../../router';
import { createRouter, createRouterEventStream } from '../router';
import { useActiveWorkspace } from '../activeWorkspaceMatcher';
import { WorkspaceProvider } from '../workspace';
import { SourceProvider } from '../source';
// TODO: work on error handler
// import {flattenErrors} from './flattenErrors'
const isStateEvent = (e) => e.type === 'state';
const initialState = { isNotFound: true, state: {} };
const useRouterState = createHookFromObservableFactory(({ tools, unstable_history, router }) => {
    if (!router || !tools)
        return of(initialState);
    return createRouterEventStream({
        unstable_history,
        router,
        tools,
    }).pipe(filter(isStateEvent), scan((prevState, event) => {
        return {
            ...prevState,
            isNotFound: event.isNotFound,
            state: event.state,
        };
    }, initialState));
}, { initialValue: initialState });
function WorkspaceLoader({ children, LoadingComponent, }) {
    const [error, handleError] = useState(null);
    if (error)
        throw error;
    const { activeWorkspace, __internal: { history }, } = useActiveWorkspace();
    const [workspace, setWorkspace] = useState(null);
    const handleNavigate = useCallback((opts) => {
        if (opts.replace) {
            history.replace(opts.path);
        }
        else {
            history.push(opts.path);
        }
    }, [history]);
    useEffect(() => {
        const subscription = combineLatest(activeWorkspace.__internal.sources.map(({ source }) => source.pipe(catchError((err) => {
            if (err instanceof ConfigResolutionError)
                return of(err);
            throw err;
        }))))
            .pipe(map((results) => {
            const errors = results.filter((result) => result instanceof ConfigResolutionError);
            if (errors.length) {
                throw new ConfigResolutionError({
                    name: activeWorkspace.name,
                    causes: errors,
                    type: 'workspace',
                });
            }
            return results;
        }), map(([rootSource, ...restOfSources]) => ({
            ...activeWorkspace,
            ...rootSource,
            unstable_sources: [rootSource, ...restOfSources],
            type: 'workspace',
        })))
            .subscribe({
            next: setWorkspace,
            error: handleError,
        });
        return () => subscription.unsubscribe();
    }, [activeWorkspace]);
    const tools = workspace?.tools;
    const router = useMemo(() => {
        if (!workspace)
            return undefined;
        return createRouter(workspace);
    }, [workspace]);
    const [routerState] = useRouterState({ unstable_history: history, router, tools });
    if (!router || !workspace)
        return React.createElement(LoadingComponent, null);
    // TODO: may need a screen if one of the sources is not logged in. e.g. it
    // is currently possible for the user to be logged into the current workspace
    // but not all of its nested sources.
    // if (!allSourcesLoggedIn) return <NotAllSourcesAuthenticatedComponent />
    return (React.createElement(WorkspaceProvider, { workspace: workspace },
        React.createElement(SourceProvider
        // the first source is always the root source and is always present
        , { 
            // the first source is always the root source and is always present
            source: workspace.unstable_sources[0] },
            React.createElement(RouterProvider, { onNavigate: handleNavigate, router: router, state: routerState.state }, children))));
}
function WorkspaceLoaderBoundary({ ConfigErrorsComponent, ...props }) {
    const [{ error }, setError] = useState({ error: null });
    // TODO: implement this
    // const errors = useMemo(() => flattenErrors(error, []), [error])
    if (error instanceof ConfigResolutionError)
        return React.createElement(ConfigErrorsComponent, null);
    // otherwise hand off to other boundaries
    if (error)
        throw error;
    return (React.createElement(ErrorBoundary, { onCatch: setError },
        React.createElement(WorkspaceLoader, { ...props })));
}
export { WorkspaceLoaderBoundary as WorkspaceLoader };
//# sourceMappingURL=WorkspaceLoader.js.map