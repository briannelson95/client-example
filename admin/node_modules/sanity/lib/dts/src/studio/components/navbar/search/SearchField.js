import React, { useCallback, useMemo, useState } from 'react';
import { Text, Flex, Autocomplete, Box, PortalProvider } from '@sanity/ui';
import { SearchIcon } from '@sanity/icons';
import styled from 'styled-components';
import { useDocumentSearchResults } from '../../../../search';
import { SearchFullscreenContent } from './SearchFullscreenContent';
import { SearchItem } from './SearchItem';
import { SearchPopoverContent } from './SearchPopoverContent';
const StyledText = styled(Text) `
  word-break: break-word;
`;
const filterOption = () => true;
export function SearchField(props) {
    const { fullScreen, onSearchItemClick, portalElement, relatedElements, setSearchInputElement } = props;
    const [query, setQuery] = useState(null);
    const results = useDocumentSearchResults({
        includeDrafts: true,
        query: query || '',
    });
    const handleClickItem = useCallback(() => {
        if (fullScreen && onSearchItemClick) {
            onSearchItemClick();
        }
    }, [fullScreen, onSearchItemClick]);
    const renderOption = useCallback((option) => {
        const { data } = option.payload;
        const documentId = data.hit._id;
        const documentType = data.hit._type;
        return (React.createElement(SearchItem, { key: documentId, onClick: handleClickItem, padding: 2, documentId: documentId, documentType: documentType }));
    }, [handleClickItem]);
    const renderPopoverFullscreen = useCallback((popoverProps, ref) => {
        if (!popoverProps.hidden && results.error) {
            return (React.createElement(SearchFullscreenContent, { tone: "critical" },
                React.createElement(Flex, { align: "center", flex: 1, height: "fill", justify: "center", padding: 4, sizing: "border" },
                    React.createElement(StyledText, { align: "center", muted: true }, results?.error?.message || 'Something went wrong while searching'))));
        }
        if (!popoverProps.hidden && query && !results.loading && results.value.length === 0) {
            return (React.createElement(SearchFullscreenContent, null,
                React.createElement(Flex, { align: "center", flex: 1, height: "fill", justify: "center", padding: 4, sizing: "border" },
                    React.createElement(StyledText, { align: "center", muted: true },
                        "No results for ",
                        React.createElement("strong", null,
                            "\u2018",
                            query,
                            "\u2019")))));
        }
        if (!popoverProps.hidden && results.value.length > 0) {
            return (React.createElement(SearchFullscreenContent, { hidden: popoverProps.hidden, ref: ref }, popoverProps.content));
        }
        return undefined;
    }, [query, results]);
    const renderPopover = useCallback((popoverProps, ref) => {
        if (!popoverProps.hidden && results.error) {
            return (React.createElement(SearchPopoverContent, { content: React.createElement(Box, { padding: 4 },
                    React.createElement(Flex, { align: "center", height: "fill", justify: "center" },
                        React.createElement(StyledText, { align: "center", muted: true }, results?.error?.message || 'Something went wrong while searching'))), open: !popoverProps.hidden, ref: ref, referenceElement: popoverProps.inputElement }));
        }
        if (!popoverProps.hidden && query && !results.loading && results.value.length === 0) {
            return (React.createElement(SearchPopoverContent, { content: React.createElement(Box, { padding: 4 },
                    React.createElement(Flex, { align: "center", height: "fill", justify: "center" },
                        React.createElement(StyledText, { align: "center", muted: true },
                            "No results for ",
                            React.createElement("strong", null,
                                "\u201C",
                                query,
                                "\u201D")))), open: !popoverProps.hidden, ref: ref, referenceElement: popoverProps.inputElement }));
        }
        if (!popoverProps.hidden && results.value.length > 0) {
            return (React.createElement(SearchPopoverContent, { content: popoverProps.content, open: !popoverProps.hidden, ref: ref, referenceElement: popoverProps.inputElement }));
        }
        return undefined;
    }, [query, results]);
    const autoComplete = useMemo(() => (React.createElement(Autocomplete, { filterOption: filterOption, icon: SearchIcon, id: "studio-search", key: "studio-search", listBox: { padding: fullScreen ? 2 : 1 }, loading: results.loading, onQueryChange: setQuery, options: results.value.map((hit) => {
            return {
                value: hit.hit._id,
                payload: {
                    data: hit,
                },
            };
        }), placeholder: "Search", radius: 2, ref: setSearchInputElement, relatedElements: relatedElements, renderOption: renderOption, renderPopover: fullScreen ? renderPopoverFullscreen : renderPopover })), [
        fullScreen,
        relatedElements,
        renderOption,
        renderPopover,
        renderPopoverFullscreen,
        results.loading,
        results.value,
        setSearchInputElement,
    ]);
    return React.createElement(PortalProvider, { element: fullScreen ? portalElement : null }, autoComplete);
}
//# sourceMappingURL=SearchField.js.map