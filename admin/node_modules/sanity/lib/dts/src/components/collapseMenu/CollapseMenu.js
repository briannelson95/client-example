import { EllipsisVerticalIcon } from '@sanity/icons';
import { Box, Button, Flex, Text, Tooltip, useElementRect } from '@sanity/ui';
import React, { cloneElement, forwardRef, useCallback, useMemo, useState } from 'react';
import styled, { css } from 'styled-components';
import { CollapseOverflowMenu } from './CollapseOverflowMenu';
import { ObserveElement } from './ObserveElement';
import { CollapseMenuDivider } from './CollapseMenuDivider';
const FOCUS_RING_PADDING = 3;
const OPTION_STYLE = css `
  list-style: none;
  display: flex;
  white-space: nowrap;

  &[data-hidden='true'] {
    opacity: 0;
    visibility: hidden;
  }
`;
const OuterFlex = styled(Flex) `
  padding: ${FOCUS_RING_PADDING}px;
  margin: -${FOCUS_RING_PADDING}px;
  box-sizing: border-box;
`;
const RootFlex = styled(Flex) `
  border-radius: inherit;
  position: relative;
`;
const RowFlex = styled(Flex) `
  width: max-content;

  &[data-hidden='true'] {
    height: 0px;
    visibility: hidden;
  }
`;
const OptionObserveElement = styled(ObserveElement) `
  ${OPTION_STYLE}
`;
const OptionHiddenFlex = styled(Flex) `
  ${OPTION_STYLE}
`;
function _isReactElement(node) {
    return Boolean(node);
}
export const CollapseMenu = forwardRef(function CollapseMenu(props, ref) {
    const { children: childrenProp, collapsed, collapseText = true, disableRestoreFocusOnClose, gap, menuButtonProps, onMenuClose, } = props;
    const [rootEl, setRootEl] = useState(null);
    const [hiddenRowEl, setHiddenRowEl] = useState(null);
    const rootRect = useElementRect(rootEl);
    const [menuOptions, setMenuOptions] = useState([]);
    const hasOverflow = useMemo(() => {
        if (rootRect && rootEl && hiddenRowEl) {
            return rootRect.width < hiddenRowEl.scrollWidth;
        }
        return false;
    }, [hiddenRowEl, rootEl, rootRect]);
    const menuButton = useMemo(() => menuButtonProps?.button || React.createElement(Button, { icon: EllipsisVerticalIcon, mode: "bleed" }), [menuButtonProps]);
    const intersectionOptions = useMemo(() => ({
        root: rootEl,
        threshold: 1,
        rootMargin: '2px',
    }), [rootEl]);
    const children = useMemo(() => React.Children.toArray(childrenProp).filter(_isReactElement), [childrenProp]);
    const menuOptionsArray = useMemo(
    // eslint-disable-next-line max-nested-callbacks
    () => children.filter(({ key }) => menuOptions.find((o) => o.key === key)), [children, menuOptions]);
    const menuIsVisible = useMemo(() => collapsed || menuOptionsArray.length > 0, [collapsed, menuOptionsArray.length]);
    const isInMenu = useCallback((childKey) => menuOptionsArray.some((o) => o.key === childKey), [menuOptionsArray]);
    const handleIntersection = useCallback((e, child) => {
        const exists = isInMenu(child.key);
        if (!e.isIntersecting && !exists) {
            setMenuOptions((prev) => [child, ...prev]);
        }
        if (e.isIntersecting && exists) {
            const updatedOptions = menuOptionsArray.filter(({ key }) => key !== child.key);
            setMenuOptions(updatedOptions);
        }
    }, [isInMenu, menuOptionsArray]);
    const items = useMemo(() => children.map((child) => {
        const { collapsedProps, expandedProps } = child.props;
        const modeProps = hasOverflow ? collapsedProps : expandedProps;
        const text = hasOverflow && collapseText ? undefined : child.props.text;
        return cloneElement(child, {
            ...modeProps,
            text: text,
        });
    }), [children, collapseText, hasOverflow]);
    if (collapsed) {
        return (React.createElement(CollapseOverflowMenu, { disableRestoreFocusOnClose: disableRestoreFocusOnClose, menuButton: menuButton, menuButtonProps: menuButtonProps, menuOptionsArray: children, onMenuClose: onMenuClose }));
    }
    return (React.createElement(OuterFlex, { align: "center", "data-ui": "CollapseMenu", overflow: "hidden", sizing: "border", ref: ref },
        React.createElement(RootFlex, { direction: "column", flex: 1, justify: "center", ref: setRootEl },
            React.createElement(RowFlex, { gap: gap }, items.map((child, index) => {
                const { dividerBefore, tooltipText = '', tooltipProps = {} } = child.props;
                const hidden = isInMenu(child.key);
                return (React.createElement(React.Fragment, { key: child.key },
                    dividerBefore && index !== 0 && React.createElement(CollapseMenuDivider, { hidden: hidden }),
                    React.createElement(OptionObserveElement, { options: intersectionOptions, 
                        // eslint-disable-next-line react/jsx-no-bind
                        callback: (e) => handleIntersection(e[0], child), "aria-hidden": hidden, "data-hidden": hidden },
                        React.createElement(Tooltip, { portal: true, disabled: !tooltipText, content: React.createElement(Box, { padding: 2, sizing: "border" },
                                React.createElement(Text, { size: 1 }, tooltipText)), ...tooltipProps },
                            React.createElement(Flex, null, cloneElement(child, {
                                disabled: child.props.disabled || hidden,
                                'aria-hidden': hidden,
                            }))))));
            })),
            React.createElement(RowFlex, { "data-hidden": true, "aria-hidden": "true", gap: gap, ref: setHiddenRowEl }, children.map((child, index) => {
                const { dividerBefore } = child.props;
                return (React.createElement(React.Fragment, { key: child.key },
                    dividerBefore && index !== 0 && React.createElement(CollapseMenuDivider, null),
                    React.createElement(OptionHiddenFlex, { key: child.key }, cloneElement(child, {
                        disabled: true,
                        'aria-hidden': true,
                    }))));
            }))),
        menuIsVisible && (React.createElement(Flex, { marginLeft: gap },
            React.createElement(CollapseOverflowMenu, { disableRestoreFocusOnClose: disableRestoreFocusOnClose, menuButton: menuButton, menuButtonProps: menuButtonProps, menuOptionsArray: menuOptionsArray, onMenuClose: onMenuClose })))));
});
//# sourceMappingURL=CollapseMenu.js.map