import React, { useCallback, useMemo, useState } from 'react';
import { sortBy } from 'lodash';
import { ScrollMonitor } from '../../scroll';
import { isNonNullable } from '../../../util/isNonNullable';
import { findMostSpecificTarget } from '../helpers/findMostSpecificTarget';
import { isChangeBar } from '../helpers/isChangeBar';
import { scrollIntoView } from '../helpers/scrollIntoView';
import { DEBUG_LAYER_BOUNDS } from '../constants';
import { getOffsetsTo } from '../helpers/getOffsetsTo';
import { useReportedValues } from '../tracker';
import { Connector } from './Connector';
import { DebugLayers } from './DebugLayers';
import { useResizeObserver } from './useResizeObserver';
import { SvgWrapper } from './ConnectorsOverlay.styled';
function getState(allReportedValues, hovered, byId, rootElement) {
    const changeBarsWithHover = [];
    const changeBarsWithFocus = [];
    for (const value of allReportedValues) {
        if (!isChangeBar(value) || !value[1].isChanged) {
            continue;
        }
        const [id, reportedChangeBar] = value;
        if (id === hovered) {
            changeBarsWithHover.push(value);
            continue;
        }
        if (reportedChangeBar.hasHover) {
            changeBarsWithHover.push(value);
            continue;
        }
        if (reportedChangeBar.hasFocus) {
            changeBarsWithFocus.push(value);
            continue;
        }
    }
    const isHoverConnector = changeBarsWithHover.length > 0;
    const changeBars = isHoverConnector ? changeBarsWithHover : changeBarsWithFocus;
    const connectors = changeBars
        .map(([id]) => {
        const field = findMostSpecificTarget('field', id, byId);
        const change = findMostSpecificTarget('change', id, byId);
        if (!field || !change)
            return null;
        return { field: { id, ...field }, change: { id, ...change } };
    })
        .filter(isNonNullable)
        // .filter(({field, change}) => field && change && field.element && change.element)
        .map(({ field, change }) => ({
        hasHover: field.hasHover || change.hasHover,
        hasFocus: field.hasFocus,
        hasRevertHover: change.hasRevertHover,
        field: { ...field, ...getOffsetsTo(field.element, rootElement) },
        change: { ...change, ...getOffsetsTo(change.element, rootElement) },
    }));
    return { connectors, isHoverConnector };
}
export function ConnectorsOverlay(props) {
    const { rootElement, onSetFocus } = props;
    const [hovered, setHovered] = React.useState(null);
    const allReportedValues = useReportedValues();
    const byId = useMemo(() => new Map(allReportedValues), [allReportedValues]);
    const [{ connectors }, setState] = useState(() => getState(allReportedValues, hovered, byId, rootElement));
    const visibleConnectors = useMemo(() => sortBy(connectors, (c) => 0 - c.field.path.length).slice(0, 1), [connectors]);
    const handleScrollOrResize = useCallback(() => {
        setState(getState(allReportedValues, hovered, byId, rootElement));
    }, [byId, allReportedValues, hovered, rootElement]);
    useResizeObserver(rootElement, handleScrollOrResize);
    return (React.createElement(ScrollMonitor, { onScroll: handleScrollOrResize },
        React.createElement(SvgWrapper, { style: { zIndex: visibleConnectors[0] && visibleConnectors[0].field.zIndex } }, visibleConnectors.map(({ field, change }) => {
            if (!change) {
                return null;
            }
            return (React.createElement(ConnectorGroup, { field: field, change: change, key: field.id, onSetFocus: onSetFocus, setHovered: setHovered }));
        }))));
}
function ConnectorGroup(props) {
    const { change, field, onSetFocus, setHovered } = props;
    const onConnectorClick = useCallback(() => {
        scrollIntoView(field);
        scrollIntoView(change);
        onSetFocus(field.path);
    }, [field, change, onSetFocus]);
    const handleMouseEnter = useCallback(() => setHovered(field.id), [field, setHovered]);
    const handleMouseLeave = useCallback(() => setHovered(null), [setHovered]);
    const from = useMemo(() => ({
        rect: {
            left: field.rect.left + 2,
            top: field.rect.top,
            height: field.rect.height,
            width: field.rect.width,
        },
        bounds: field.bounds,
    }), [field.bounds, field.rect]);
    const to = useMemo(() => ({ rect: change.rect, bounds: change.bounds }), [change.bounds, change.rect]);
    return (React.createElement(React.Fragment, null,
        React.createElement("g", { onClick: onConnectorClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave },
            React.createElement(Connector, { from: from, to: to })),
        DEBUG_LAYER_BOUNDS && React.createElement(DebugLayers, { field: field, change: change })));
}
//# sourceMappingURL=ConnectorsOverlay.js.map