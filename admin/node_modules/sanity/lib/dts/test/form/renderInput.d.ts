/// <reference types="jest" />
import { SanityClient } from '@sanity/client';
import { Path, Schema, SchemaType } from '@sanity/types';
import React, { FocusEvent } from 'react';
import { FIXME, NodePresence, NodeValidation, PatchArg, PatchEvent } from '../../src/form';
import { FormState } from '../../src/form/store/useFormState';
import { TestRenderProps } from './types';
export interface TestRenderInputContext {
    client: SanityClient;
    formState: FormState;
}
export interface TestRenderInputProps {
    focusPath: Path;
    focusRef: React.Ref<FIXME>;
    id: string;
    level: number;
    onBlur: (event: FocusEvent) => void;
    onChange: (path: PatchArg | PatchEvent) => void;
    onFocus: (event: FocusEvent) => void;
    onPathBlur: (path: Path) => void;
    onPathFocus: (path: Path) => void;
    path: Path;
    presence: NodePresence[];
    readOnly: boolean | undefined;
    schemaType: SchemaType;
    validation: NodeValidation[];
    value: unknown;
}
export declare type TestRenderInputCallback = (inputProps: TestRenderInputProps, context: TestRenderInputContext) => React.ReactElement;
export declare function renderInput(props: {
    fieldDefinition: Schema.TypeDefinition;
    props?: TestRenderProps;
    render: TestRenderInputCallback;
}): Promise<{
    focusRef: jest.Mock<any, any>;
    onBlur: jest.Mock<any, any>;
    onChange: jest.Mock<any, any>;
    onFocus: jest.Mock<any, any>;
    onPathBlur: jest.Mock<any, any>;
    onPathFocus: jest.Mock<any, any>;
    onFieldGroupSelect: jest.Mock<any, any>;
    onSetFieldSetCollapsed: jest.Mock<any, any>;
    rerender: (subsequentRender: TestRenderInputCallback) => void;
    result: import("@testing-library/react").RenderResult<typeof import("@testing-library/dom/types/queries"), HTMLElement>;
}>;
//# sourceMappingURL=renderInput.d.ts.map