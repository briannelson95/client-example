import { render } from '@testing-library/react';
import React from 'react';
import { createPatchChannel, StudioFormBuilderProvider, useFormState, } from '../../src/form';
import { EMPTY_ARRAY } from '../../src/form/utils/empty';
import { useSchema } from '../../src/hooks';
import { createMockSanityClient } from '../mocks/mockSanityClient';
import { createTestProvider } from '../testUtils/TestProvider';
export async function renderInput(props) {
    const { render: initialRender, fieldDefinition, props: initialTestProps } = props;
    const name = fieldDefinition.name;
    const client = createMockSanityClient();
    const patchChannel = createPatchChannel();
    const TestProvider = await createTestProvider({
        client,
        config: {
            name: 'default',
            projectId: 'test',
            dataset: 'test',
            schema: {
                types: [
                    {
                        type: 'document',
                        name: 'test',
                        fields: [fieldDefinition],
                    },
                ],
            },
        },
    });
    const focusRef = jest.fn();
    const onBlur = jest.fn();
    const onChange = jest.fn();
    const onFocus = jest.fn();
    const onPathBlur = jest.fn();
    const onPathFocus = jest.fn();
    const onPathOpen = jest.fn();
    const onFieldGroupSelect = jest.fn();
    const onSetFieldSetCollapsed = jest.fn();
    const onSetPathCollapsed = jest.fn();
    function TestForm(renderProps) {
        const { documentValue, focusPath = EMPTY_ARRAY, openPath = EMPTY_ARRAY, presence = EMPTY_ARRAY, render: renderFn, validation = EMPTY_ARRAY, } = renderProps;
        const schema = useSchema();
        const docType = schema.get('test');
        if (!docType)
            throw new Error(`no document type: test`);
        const formState = useFormState(docType, {
            comparisonValue: documentValue,
            value: documentValue,
            focusPath,
            collapsedPaths: undefined,
            collapsedFieldSets: undefined,
            fieldGroupState: undefined,
            presence,
            validation,
            openPath,
        });
        if (!formState) {
            throw new Error('no form state');
        }
        const fieldMember = formState.members.find((m) => m.kind === 'field' && m.name === name);
        if (!fieldMember) {
            throw new Error(`no field member: ${name}`);
        }
        const { level, path, readOnly, schemaType } = fieldMember.field;
        return (React.createElement(StudioFormBuilderProvider, { __internal_patchChannel: patchChannel, changesOpen: false, collapsedFieldSets: undefined, collapsedPaths: undefined, focusPath: formState.focusPath, focused: formState.focused, groups: formState.groups || EMPTY_ARRAY, id: formState.id, members: formState.members || EMPTY_ARRAY, onChange: onChange, onPathBlur: onPathBlur, onPathFocus: onPathFocus, onPathOpen: onPathOpen, onFieldGroupSelect: onFieldGroupSelect, onSetFieldSetCollapsed: onSetFieldSetCollapsed, onSetPathCollapsed: onSetPathCollapsed, presence: presence, readOnly: formState.readOnly, schemaType: docType, validation: validation, value: undefined }, renderFn({
            focusPath: formState.focusPath,
            focusRef,
            id: formState.id || name,
            level,
            onBlur,
            onChange,
            onFocus,
            onPathBlur,
            onPathFocus,
            path,
            readOnly,
            schemaType,
            validation: formState.validation,
            presence: formState.presence,
            value: formState.value?.[name],
        }, { client, formState })));
    }
    const result = render(React.createElement(TestProvider, null,
        React.createElement(TestForm, { ...initialTestProps, render: initialRender })));
    function rerender(subsequentRender) {
        render(React.createElement(TestProvider, null,
            React.createElement(TestForm, { ...initialTestProps, render: subsequentRender })));
    }
    return {
        focusRef,
        onBlur,
        onChange,
        onFocus,
        onPathBlur,
        onPathFocus,
        onFieldGroupSelect,
        onSetFieldSetCollapsed,
        rerender,
        result,
    };
}
//# sourceMappingURL=renderInput.js.map