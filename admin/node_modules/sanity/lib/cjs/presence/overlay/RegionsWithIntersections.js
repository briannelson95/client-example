"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RegionsWithIntersections = void 0;

var _react = _interopRequireWildcard(require("react"));

var _constants = require("../constants");

var _intersectionObserver = require("./intersectionObserver");

var _RegionsWithIntersections = require("./RegionsWithIntersections.styled");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const toPx = num => "".concat(num, "px");

const negate = num => 0 - num;

const RegionsWithIntersections = /*#__PURE__*/(0, _react.forwardRef)(function RegionsWithIntersections(props, ref) {
  const {
    regions,
    render,
    children,
    margins: marginsProp
  } = props;
  const overlayRef = (0, _react.useRef)(null); // Make sure `margins` is memoized
  // eslint-disable-next-line react-hooks/exhaustive-deps

  const margins = (0, _react.useMemo)(() => marginsProp, [JSON.stringify(marginsProp)]);
  const io = (0, _react.useMemo)(() => (0, _intersectionObserver.createIntersectionObserver)({
    rootMargin: margins.map(negate).map(toPx).join(' '),
    threshold: _constants.INTERSECTION_THRESHOLDS
  }), [margins]);
  const [intersections, setIntersections] = (0, _react.useState)({});
  const onIntersection = (0, _react.useCallback)((id, entry) => {
    setIntersections(current => ({ ...current,
      [id]: entry
    }));
  }, []);
  const top = intersections['::top'];
  const bottom = intersections['::bottom'];
  const regionsWithIntersectionDetails = (0, _react.useMemo)(() => top && bottom ? regions.filter(region => {
    var _region$presence;

    return ((_region$presence = region.presence) === null || _region$presence === void 0 ? void 0 : _region$presence.length) > 0;
  }).map(region => {
    const intersection = intersections[region.id];

    if (!intersection) {
      return null;
    }

    const {
      bottom: boundsBottom,
      top: boundsTop
    } = intersection.boundingClientRect;
    const aboveTop = intersection.boundingClientRect.top < top.boundingClientRect.bottom;
    const belowBottom = intersection.boundingClientRect.top < bottom.boundingClientRect.top; // eslint-disable-next-line no-nested-ternary

    const distanceTop = intersection.isIntersecting ? boundsTop - (intersection.intersectionRect.top - _constants.INTERSECTION_ELEMENT_PADDING) : aboveTop ? -top.boundingClientRect.bottom : bottom.boundingClientRect.top; // eslint-disable-next-line no-nested-ternary

    const distanceBottom = intersection.isIntersecting ? -(boundsBottom - (intersection.intersectionRect.bottom + _constants.INTERSECTION_ELEMENT_PADDING)) : belowBottom ? bottom.boundingClientRect.top : -top.boundingClientRect.bottom;
    const position = // eslint-disable-next-line no-nested-ternary
    distanceTop <= _constants.SNAP_TO_DOCK_DISTANCE_TOP ? 'top' : distanceBottom <= _constants.SNAP_TO_DOCK_DISTANCE_BOTTOM ? 'bottom' : 'inside';
    return {
      distanceTop,
      distanceBottom,
      region,
      position
    };
  }).filter(Boolean) : [], [bottom, intersections, regions, top]);
  return /*#__PURE__*/_react.default.createElement(_RegionsWithIntersections.RootWrapper, {
    ref: ref
  }, /*#__PURE__*/_react.default.createElement(_RegionsWithIntersections.TopRegionWrapper, {
    $debug: _constants.DEBUG,
    io: io,
    id: "::top",
    onIntersection: onIntersection,
    margins: margins
  }), /*#__PURE__*/_react.default.createElement("div", null, children), /*#__PURE__*/_react.default.createElement(_RegionsWithIntersections.OverlayWrapper, {
    ref: overlayRef
  }, overlayRef.current && render(regionsWithIntersectionDetails, overlayRef.current.offsetWidth)), regions.map(region => {
    const forceWidth = region.rect.width === 0;
    return /*#__PURE__*/_react.default.createElement(_RegionsWithIntersections.MiddleRegionWrapper, {
      $debug: _constants.DEBUG,
      io: io,
      onIntersection: onIntersection,
      key: region.id,
      id: region.id,
      style: {
        width: forceWidth ? 1 : region.rect.width,
        left: region.rect.left - (forceWidth ? 1 : 0),
        top: region.rect.top - _constants.INTERSECTION_ELEMENT_PADDING,
        height: region.rect.height + _constants.INTERSECTION_ELEMENT_PADDING * 2
      }
    });
  }), /*#__PURE__*/_react.default.createElement(_RegionsWithIntersections.BottomRegionWrapper, {
    $debug: _constants.DEBUG,
    id: "::bottom",
    io: io,
    onIntersection: onIntersection
  }));
});
exports.RegionsWithIntersections = RegionsWithIntersections;