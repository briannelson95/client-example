"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGrantsStore = createGrantsStore;

var _groqJs = require("groq-js");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _operators2 = require("rxjs-etc/operators");

var _shallowEquals = _interopRequireDefault(require("shallow-equals"));

var _debug = require("./debug");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function getDatasetGrants(client, projectId, dataset) {
  // `acl` stands for access control list and returns a list of grants
  const grants = await client.request({
    uri: "/projects/".concat(projectId, "/datasets/").concat(dataset, "/acl"),
    tag: 'acl.get',
    withCredentials: true
  });
  return grants;
}

function getParams(currentUser) {
  const params = {};

  if (currentUser !== null) {
    params.identity = currentUser.id;
  }

  return params;
}

const PARSED_FILTERS_MEMO = new Map();

async function matchesFilter(currentUser, filter, document) {
  if (!PARSED_FILTERS_MEMO.has(filter)) {
    // note: it might be tempting to also memoize the result of the evaluation here,
    // Currently these filters are typically evaluated whenever a document change, which means they will be evaluated
    // quite frequently with different versions of the document. There might be some gains in finding out which subset of document
    // properties to use as key (e.g. by looking at the parsed filter and see what properties the filter cares about)
    // But as always, it's worth considering if the complexity/memory usage is worth the potential perf gainâ€¦
    PARSED_FILTERS_MEMO.set(filter, (0, _groqJs.parse)("*[".concat(filter, "]")));
  }

  const parsed = PARSED_FILTERS_MEMO.get(filter);
  const params = getParams(currentUser);
  const data = await (await (0, _groqJs.evaluate)(parsed, {
    dataset: [document],
    params
  })).get();
  return (data === null || data === void 0 ? void 0 : data.length) === 1;
}

function createGrantsStore(_ref) {
  let {
    client,
    currentUser
  } = _ref;
  const versionedClient = client.withConfig({
    apiVersion: '2021-06-07'
  });
  const datasetGrants$ = (0, _rxjs.defer)(() => (0, _rxjs.of)(versionedClient.config())).pipe((0, _operators.switchMap)(_ref2 => {
    let {
      projectId,
      dataset
    } = _ref2;

    if (!projectId || !dataset) {
      throw new Error('Missing projectId or dataset');
    }

    return getDatasetGrants(versionedClient, projectId, dataset);
  }));

  const currentUserDatasetGrants = _debug.debugGrants$.pipe((0, _operators.switchMap)(debugGrants => debugGrants ? (0, _rxjs.of)(debugGrants) : datasetGrants$), (0, _operators.publishReplay)(1), (0, _operators2.refCountDelay)(1000));

  return {
    checkDocumentPermission(permission, document) {
      return currentUserDatasetGrants.pipe((0, _operators.switchMap)(grants => grantsPermissionOn(currentUser, grants, permission, document)), (0, _operators.distinctUntilChanged)(_shallowEquals.default));
    }

  };
}
/**
 * takes a grants object, a permission and a document
 * checks whether the the permission is granted for the given document
 */


async function grantsPermissionOn(currentUser, grants, permission, document) {
  if (!document) {
    // we say it's granted if null due to initial states
    return {
      granted: true,
      reason: 'Null document, nothing to check'
    };
  }

  if (!grants.length) {
    return {
      granted: false,
      reason: 'No document grants'
    };
  }

  const matchingGrants = [];

  for (const grant of grants) {
    if (await matchesFilter(currentUser, grant.filter, document)) {
      matchingGrants.push(grant);
    }
  }

  const foundMatch = matchingGrants.some(grant => grant.permissions.some(p => p === permission));
  return {
    granted: foundMatch,
    reason: foundMatch ? "Matching grant" : "No matching grants found"
  };
}