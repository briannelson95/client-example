"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.listenQuery = void 0;

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _rxjsExhaustmapWithTrailing = require("rxjs-exhaustmap-with-trailing");

const fetch = (client, query, params, options) => (0, _rxjs.defer)(() => // getVersionedClient(options.apiVersion)
client.observable.fetch(query, params, {
  tag: options.tag,
  filterResponse: true
}));

const listen = (client, query, params, options) => (0, _rxjs.defer)(() => // getVersionedClient(options.apiVersion)
client.listen(query, params, {
  events: ['welcome', 'mutation', 'reconnect'],
  includeResult: false,
  visibility: 'query',
  tag: options.tag
}));

function isWelcomeEvent(event) {
  return event.type === 'welcome';
} // todo: promote as building block for better re-use
// todo: optimize by patching collection in-place


const listenQuery = function (client, query) {
  let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const fetchQuery = typeof query === 'string' ? query : query.fetch;
  const listenerQuery = typeof query === 'string' ? query : query.listen;
  const fetchOnce$ = fetch(client, fetchQuery, params, options);
  const events$ = listen(client, listenerQuery, params, options).pipe((0, _operators.mergeMap)((ev, i) => {
    const isFirst = i === 0;

    if (isFirst && !isWelcomeEvent(ev)) {
      // if the first event is not welcome, it is most likely a reconnect and
      // if it's not a reconnect something is very wrong
      return (0, _rxjs.throwError)(new Error(ev.type === 'reconnect' ? 'Could not establish EventSource connection' : "Received unexpected type of first event \"".concat(ev.type, "\"")));
    }

    return (0, _rxjs.of)(ev);
  }), (0, _operators.share)());
  const [welcome$, mutationAndReconnect$] = (0, _rxjs.partition)(events$, isWelcomeEvent);

  const isRelevantEvent = event => {
    if (!options.transitions || event.type !== 'mutation') {
      return true;
    }

    return options.transitions.includes(event.transition);
  };

  return (0, _rxjs.merge)(welcome$.pipe((0, _operators.take)(1)), mutationAndReconnect$.pipe((0, _operators.filter)(isRelevantEvent), (0, _operators.throttleTime)(options.throttleTime || 1000, _rxjs.asyncScheduler, {
    leading: true,
    trailing: true
  }))).pipe((0, _rxjsExhaustmapWithTrailing.exhaustMapToWithTrailing)(fetchOnce$));
};

exports.listenQuery = listenQuery;