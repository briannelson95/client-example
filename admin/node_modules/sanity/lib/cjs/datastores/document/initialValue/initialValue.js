"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInitialValueStream = getInitialValueStream;

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _templates = require("../../../templates");

var _util = require("../../../util");

const LOADING_MSG = {
  type: 'loading'
};
/**
 * @internal
 */

function getInitialValueStream(schema, initialValueTemplates, documentPreviewStore, opts) {
  const draft$ = documentPreviewStore.observePaths({
    _type: 'reference',
    _ref: (0, _util.getDraftId)(opts.documentId)
  }, ['_type']);
  const published$ = documentPreviewStore.observePaths({
    _type: 'reference',
    _ref: (0, _util.getPublishedId)(opts.documentId)
  }, ['_type']);
  const value$ = (0, _rxjs.merge)(draft$.pipe((0, _operators.map)(draft => ({
    draft
  }))), published$.pipe((0, _operators.map)(published => ({
    published
  })))).pipe((0, _operators.scan)((prev, res) => ({ ...prev,
    ...res
  }), {}), // Wait until we know the state of both draft and published
  (0, _operators.filter)(res => 'draft' in res && 'published' in res), (0, _operators.map)(res => res.draft || res.published), // Only update if we didn't previously have a document but we now do
  (0, _operators.distinctUntilChanged)((prev, next) => Boolean(prev) !== Boolean(next)), // Prevent rapid re-resolving when transitioning between different templates
  (0, _operators.debounceTime)(25));
  return value$.pipe((0, _operators.switchMap)(document => {
    // Already exists, so no initial value is needed
    if (document) {
      return (0, _rxjs.of)({
        type: 'success',
        value: null
      });
    }

    if (!opts.templateName) {
      // @todo: Make sure this is the correct behavior
      return (0, _rxjs.of)({
        isResolving: false,
        initialValue: undefined
      });
    }

    const template = initialValueTemplates.find(t => t.id === opts.templateName);

    if (!template) {
      // eslint-disable-next-line no-console
      console.warn('Template "%s" not defined, using empty initial value', opts.templateName);
      return (0, _rxjs.of)({
        isResolving: false,
        initialValue: undefined
      });
    }

    const initialValueWithParams$ = (0, _rxjs.from)((0, _templates.resolveInitialValue)(schema, template, opts.templateParams)).pipe((0, _operators.map)(initialValue => ({
      isResolving: false,
      initialValue
    }))).pipe((0, _operators.catchError)(resolveError => {
      /* eslint-disable no-console */
      console.group('Failed to resolve initial value');
      console.error(resolveError);
      console.error('Template ID: %s', opts.templateName);
      console.error('Parameters: %o', opts.templateParams);
      console.groupEnd();
      /* eslint-enable no-console */

      const msg = {
        type: 'error',
        error: resolveError
      };
      return (0, _rxjs.of)(msg);
    }));
    return (0, _rxjs.merge)((0, _rxjs.of)({
      isResolving: true
    }), initialValueWithParams$).pipe((0, _operators.switchMap)(_ref => {
      let {
        isResolving,
        initialValue,
        resolveError
      } = _ref;

      if (resolveError) {
        return (0, _rxjs.of)({
          type: 'error',
          message: 'Failed to resolve initial value'
        });
      }

      if (isResolving) {
        return (0, _rxjs.of)(LOADING_MSG);
      }

      const msg = {
        type: 'success',
        value: initialValue
      };
      return (0, _rxjs.of)(msg);
    }));
  }), (0, _operators.startWith)(LOADING_MSG), (0, _operators.distinctUntilChanged)());
}