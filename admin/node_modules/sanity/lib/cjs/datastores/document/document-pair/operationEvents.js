"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.emitOperation = emitOperation;
exports.getOperationEvents = getOperationEvents;

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _operationArgs = require("./operationArgs");

var _delete = require("./operations/delete");

var _publish = require("./operations/publish");

var _patch = require("./operations/patch");

var _commit = require("./operations/commit");

var _discardChanges = require("./operations/discardChanges");

var _unpublish = require("./operations/unpublish");

var _duplicate = require("./operations/duplicate");

var _restore = require("./operations/restore");

var _consistencyStatus = require("./consistencyStatus");

function maybeObservable(v) {
  return typeof v === 'undefined' ? (0, _rxjs.of)(null) : v;
}

const operationImpls = {
  del: _delete.del,
  delete: _delete.del,
  publish: _publish.publish,
  patch: _patch.patch,
  commit: _commit.commit,
  discardChanges: _discardChanges.discardChanges,
  unpublish: _unpublish.unpublish,
  duplicate: _duplicate.duplicate,
  restore: _restore.restore
};

const execute = (operationName, operationArguments, extraArgs) => {
  const operation = operationImpls[operationName];
  return (0, _rxjs.defer)(() => (0, _rxjs.merge)((0, _rxjs.of)(null), maybeObservable(operation.execute(operationArguments, ...extraArgs)))).pipe((0, _operators.last)());
};

const operationCalls$ = new _rxjs.Subject();

function emitOperation(operationName, idPair, typeName, extraArgs) {
  operationCalls$.next({
    operationName,
    idPair,
    typeName,
    extraArgs
  });
} // These are the operations that cannot be performed while the document is in an inconsistent state


const REQUIRES_CONSISTENCY = ['publish', 'unpublish', 'discardChanges', 'delete'];
const listenerCache = new Map();

function getOperationEvents(ctx) {
  const {
    dataset,
    projectId
  } = ctx.client.config();
  const cacheKey = "".concat(projectId, "-").concat(dataset);

  if (listenerCache.has(cacheKey)) {
    return listenerCache.get(cacheKey);
  }

  const result$ = operationCalls$.pipe((0, _operators.groupBy)(op => op.idPair.publishedId), (0, _operators.mergeMap)(groups$ => groups$.pipe( // although it might look like a but, dropping pending async operations here is actually a feature
  // E.g. if the user types `publish` which is async and then starts patching (sync) then the publish
  // should be cancelled
  (0, _operators.switchMap)(args => (0, _operationArgs.operationArgs)(ctx, args.idPair, args.typeName).pipe((0, _operators.take)(1), (0, _operators.switchMap)(operationArguments => {
    const requiresConsistency = REQUIRES_CONSISTENCY.includes(args.operationName);

    if (requiresConsistency) {
      operationArguments.published.commit();
      operationArguments.draft.commit();
    }

    const isConsistent$ = (0, _consistencyStatus.consistencyStatus)(ctx.client, args.idPair, args.typeName).pipe((0, _operators.filter)(Boolean));
    const ready$ = requiresConsistency ? isConsistent$.pipe((0, _operators.take)(1)) : (0, _rxjs.of)(null);
    return ready$.pipe( // eslint-disable-next-line max-nested-callbacks
    (0, _operators.mergeMap)(() => execute(args.operationName, operationArguments, args.extraArgs)));
  }), (0, _operators.map)(() => ({
    type: 'success',
    args
  })), (0, _operators.catchError)(err => (0, _rxjs.of)({
    type: 'error',
    args,
    error: err
  })))))), (0, _operators.share)()); // this enables autocommit after patch operations

  const AUTOCOMMIT_INTERVAL = 1000;
  const autoCommit$ = result$.pipe((0, _operators.filter)(result => result.type === 'success' && result.args.operationName === 'patch'), (0, _operators.throttleTime)(AUTOCOMMIT_INTERVAL, _rxjs.asyncScheduler, {
    leading: true,
    trailing: true
  }), (0, _operators.tap)(result => {
    emitOperation('commit', result.args.idPair, result.args.typeName, []);
  }));
  const cache = new Map();

  function listener(idPair, typeName) {
    const key = "".concat(idPair.publishedId, ":").concat(typeName);
    let ret = cache.get(key);

    if (!ret) {
      ret = (0, _rxjs.merge)(result$, autoCommit$.pipe((0, _operators.mergeMapTo)(_rxjs.EMPTY))).pipe((0, _operators.filter)(result => result.args.idPair.publishedId === idPair.publishedId), (0, _operators.map)(result => {
        const {
          operationName,
          idPair: documentIds
        } = result.args;
        return result.type === 'success' ? {
          type: 'success',
          op: operationName,
          id: documentIds.publishedId
        } : {
          type: 'error',
          op: operationName,
          id: documentIds.publishedId,
          error: result.error
        };
      }));
      cache.set(key, ret);
    }

    return ret;
  }

  listenerCache.set(cacheKey, listener);
  return listener;
}