"use strict";

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _schema = require("../../../schema");

var _mockSanityClient = require("../../../../test/mocks/mockSanityClient");

var _editState = require("./editState");

var _validation = require("./validation");

// Mock `./editState`
const mockEditState = _editState.editState;
jest.mock('./editState', () => ({
  editState: jest.fn()
}));
const schema = (0, _schema.createSchema)({
  name: 'default',
  types: [{
    name: 'movie',
    title: 'Movie',
    type: 'document',
    fields: [{
      name: 'title',
      type: 'string'
    }, {
      name: 'exampleRef',
      type: 'reference',
      to: [{
        type: 'movie'
      }]
    }, {
      name: 'exampleRefTwo',
      type: 'reference',
      to: [{
        type: 'movie'
      }]
    }]
  }]
}); // A fixture used to set up a validation stream/subscription and wait
// for certain events (e.g. when validation is finished running)

function createSubscription(client, documentPreviewStore) {
  const stream = (0, _validation.validation)({
    client,
    documentPreviewStore,
    schema
  }, {
    publishedId: 'example-id',
    draftId: 'drafts.example-id'
  }, 'movie').pipe((0, _operators.publish)()) // Publish and connect this for the tests
  ;
  stream.connect(); // Create a subject we can use to notify via `done.next()`

  const done = new _rxjs.Subject(); // Create a subscription that collects all emissions until `done.next()`

  const subscription = stream.pipe((0, _operators.buffer)(done), (0, _operators.first)()).toPromise();
  return {
    subscription,
    closeSubscription: () => done.next(),
    doneValidating: () => {
      return stream.pipe((0, _operators.takeWhile)(e => e.isValidating, true)).toPromise();
    }
  };
}

describe('validation', () => {
  beforeEach(() => {
    mockEditState.mockReset();
  });
  it('runs `editState` through `validateDocument` to create a stream of validation statuses', async () => {
    const client = (0, _mockSanityClient.createMockSanityClient)();
    const mockEditStateSubject = new _rxjs.Subject();
    mockEditState.mockImplementation(() => mockEditStateSubject.asObservable());
    const {
      subscription,
      closeSubscription,
      doneValidating
    } = createSubscription(client); // simulate first emission from validation listener

    mockEditStateSubject.next({
      id: 'example-id',
      draft: {
        _id: 'example-id',
        _createdAt: '2021-09-07T16:23:52.256Z',
        _rev: 'exampleRev',
        _type: 'movie',
        _updatedAt: '2021-09-07T16:23:52.256Z',
        title: 5
      },
      liveEdit: false,
      published: null,
      type: 'movie',
      ready: true
    });
    await doneValidating();
    closeSubscription();
    await expect(subscription).resolves.toMatchObject([{
      isValidating: true,
      validation: []
    }, {
      isValidating: false,
      validation: [{
        item: {
          message: 'Expected type "String", got "Number"'
        },
        level: 'error',
        path: ['title']
      }]
    }]);
  });
  it.skip('re-runs validation when the edit state changes', async () => {
    const client = (0, _mockSanityClient.createMockSanityClient)();
    const mockEditStateSubject = new _rxjs.Subject();
    mockEditState.mockImplementation(() => mockEditStateSubject.asObservable());
    const {
      subscription,
      closeSubscription,
      doneValidating
    } = createSubscription(client); // simulate first emission from validation listener

    mockEditStateSubject.next({
      id: 'example-id',
      draft: {
        _id: 'example-id',
        _createdAt: '2021-09-07T16:23:52.256Z',
        _rev: 'exampleRev',
        _type: 'movie',
        _updatedAt: '2021-09-07T16:23:52.256Z',
        title: 5
      },
      liveEdit: false,
      published: null,
      type: 'movie',
      ready: true
    }); // wait till validation is done before pushing a valid value

    await doneValidating(); // push a valid value

    mockEditStateSubject.next({
      id: 'example-id',
      draft: {
        _id: 'example-id',
        _createdAt: '2021-09-07T16:23:52.256Z',
        _rev: 'exampleRev',
        _type: 'movie',
        _updatedAt: '2021-09-07T16:23:52.256Z',
        title: 'valid title'
      },
      liveEdit: false,
      published: null,
      type: 'movie',
      ready: true
    });
    await doneValidating();
    closeSubscription();
    await expect(subscription).resolves.toMatchObject([{
      isValidating: true,
      validation: []
    }, {
      isValidating: false,
      validation: [{
        item: {
          message: 'Expected type "String", got "Number"'
        }
      }]
    }, {
      isValidating: true,
      validation: [{
        item: {
          message: 'Expected type "String", got "Number"'
        }
      }]
    }, {
      isValidating: false,
      validation: []
    }]);
  });
  it.skip('re-runs validation when dependency events change', async () => {
    const client = (0, _mockSanityClient.createMockSanityClient)();
    const subject = new _rxjs.Subject();
    const mockPreviewStore = {}; // Mock `editState`

    const mockEditStateSubject = new _rxjs.Subject();
    mockEditState.mockImplementation(() => mockEditStateSubject.asObservable());
    const {
      subscription,
      closeSubscription,
      doneValidating
    } = createSubscription(client, mockPreviewStore);

    mockPreviewStore.unstable_observeDocumentPairAvailability = () => (0, _rxjs.concat)((0, _rxjs.of)({
      published: {
        available: true
      }
    }), subject.pipe((0, _operators.mapTo)({
      published: {
        available: false
      }
    }))); // simulate first emission from validation listener


    mockEditStateSubject.next({
      id: 'example-id',
      draft: {
        _id: 'example-id',
        _createdAt: '2021-09-07T16:23:52.256Z',
        _rev: 'exampleRev',
        _type: 'movie',
        _updatedAt: '2021-09-07T16:23:52.256Z',
        title: 'testing',
        exampleRef: {
          _ref: 'example-ref-id'
        },
        exampleRefTwo: {
          _ref: 'example-ref-other'
        }
      },
      liveEdit: false,
      published: null,
      type: 'movie',
      ready: true
    });
    await doneValidating();

    mockPreviewStore.unstable_observeDocumentPairAvailability = id => id === 'example-ref-id' ? (0, _rxjs.of)({
      published: {
        available: false
      }
    }) : (0, _rxjs.of)({
      published: {
        available: true
      }
    });

    subject.next();
    await doneValidating(); // close the buffer

    closeSubscription();
    await expect(subscription).resolves.toMatchObject([{
      isValidating: true,
      validation: []
    }, {
      isValidating: false,
      validation: []
    }, {
      isValidating: true,
      validation: []
    }, {
      isValidating: false,
      validation: [{
        item: {
          message: /.+/
        },
        level: 'error',
        path: ['exampleRef']
      }]
    }]);
  }); // this means that when you subscribe to the same document, you'll
  // immediately get the previous value emitted to you

  it.skip('replays the last known version via `memoize` and `publishReplay`', async () => {
    const client = (0, _mockSanityClient.createMockSanityClient)(); // Mock `editState`

    const mockEditStateSubject = new _rxjs.Subject();
    mockEditState.mockImplementation(() => mockEditStateSubject.asObservable());
    const subscription = (0, _validation.validation)({
      client,
      schema
    }, {
      publishedId: 'example-id',
      draftId: 'drafts.example-id'
    }, 'movie').pipe((0, _operators.buffer)((0, _rxjs.timer)(500))).toPromise(); // simulate first emission from validation listener

    mockEditStateSubject.next({
      id: 'example-id',
      draft: {
        _id: 'example-id',
        _createdAt: '2021-09-07T16:23:52.256Z',
        _rev: 'exampleRev',
        _type: 'movie',
        _updatedAt: '2021-09-07T16:23:52.256Z',
        title: 5
      },
      liveEdit: false,
      published: null,
      type: 'movie',
      ready: true
    });
    const result = await subscription;
    expect(result).toMatchObject([{
      isValidating: true,
      validation: []
    }, {
      isValidating: false,
      validation: [{
        item: {
          message: 'Expected type "String", got "Number"'
        },
        level: 'error',
        path: ['title']
      }]
    }]);
    const immediatePlayback = await (0, _validation.validation)({
      client,
      schema
    }, {
      publishedId: 'example-id',
      draftId: 'drafts.example-id'
    }, 'movie').pipe((0, _operators.first)()).toPromise();
    const immediatePlaybackAgain = await (0, _validation.validation)({
      client,
      schema
    }, {
      publishedId: 'example-id',
      draftId: 'drafts.example-id'
    }, 'movie').pipe((0, _operators.first)()).toPromise();
    expect(result[result.length - 1]).toEqual(immediatePlayback);
    expect(immediatePlayback).toEqual(immediatePlaybackAgain);
  });
  it.skip('returns empty validation message arrays if there is no available published or draft snapshot', async () => {
    const client = (0, _mockSanityClient.createMockSanityClient)(); // Mock `editState`

    const mockEditStateSubject = new _rxjs.Subject();
    mockEditState.mockImplementation(() => mockEditStateSubject.asObservable());
    const {
      subscription,
      closeSubscription,
      doneValidating
    } = createSubscription(client);
    mockEditStateSubject.next({
      id: 'example-id',
      draft: null,
      liveEdit: false,
      published: null,
      type: 'movie',
      ready: true
    });
    await doneValidating();
    closeSubscription();
    await expect(subscription).resolves.toMatchObject([{
      isValidating: true,
      validation: []
    }, {
      isValidating: false,
      validation: []
    }]);
  });
});