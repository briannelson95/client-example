"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validation = void 0;

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _validation = require("@sanity/validation");

var _types = require("@sanity/types");

var _jsonReduce = _interopRequireDefault(require("json-reduce"));

var _createMemoizer = require("../utils/createMemoizer");

var _editState = require("./editState");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const INITIAL_VALIDATION_STATUS = {
  isValidating: true,
  validation: []
};

function findReferenceIds(obj) {
  return (0, _jsonReduce.default)(obj, (acc, node) => {
    if ((0, _types.isReference)(node)) {
      acc.add(node._ref);
    }

    return acc;
  }, new Set());
}

const listenDocumentExists = (previewStore, id) => previewStore.unstable_observeDocumentPairAvailability({
  _type: 'reference',
  _ref: id
}).pipe((0, _operators.map)(_ref => {
  let {
    published
  } = _ref;
  return published.available;
}));

const validation = (0, _createMemoizer.memoize)((ctx, _ref2, typeName) => {
  let {
    draftId,
    publishedId
  } = _ref2;

  const getDocumentExists = _ref3 => {
    let {
      id
    } = _ref3;
    return listenDocumentExists(ctx.documentPreviewStore, id).pipe((0, _operators.first)()).toPromise();
  };

  const document$ = (0, _editState.editState)(ctx, {
    draftId,
    publishedId
  }, typeName).pipe((0, _operators.map)(_ref4 => {
    let {
      draft,
      published
    } = _ref4;
    return draft || published;
  }), // this debounce is needed for performance. it prevents the validation
  // from being run on every keypress
  (0, _operators.debounceTime)(300), (0, _operators.share)());
  const referenceIds$ = document$.pipe((0, _operators.map)(document => findReferenceIds(document)), (0, _operators.distinctUntilChanged)((curr, next) => {
    if (curr.size !== next.size) return false;

    for (const item of curr) {
      if (!next.has(item)) return false;
    }

    return true;
  }));
  const referencedDocumentUpdate$ = referenceIds$.pipe((0, _operators.switchMap)(idSet => (0, _rxjs.from)(idSet).pipe((0, _operators.mergeMap)(id => listenDocumentExists(ctx.documentPreviewStore, id).pipe((0, _operators.map)( // eslint-disable-next-line max-nested-callbacks
  result => [id, result]))), // the `debounceTime` in the next stream removes multiple emissions
  // caused by this scan
  (0, _operators.scan)((acc, _ref5) => {
    let [id, result] = _ref5;
    return { ...acc,
      [id]: result
    };
  }, {}))), (0, _operators.distinctUntilChanged)((curr, next) => {
    const currKeys = Object.keys(curr);
    const nextKeys = Object.keys(next);
    if (currKeys.length !== nextKeys.length) return false;

    for (const key of currKeys) {
      if (curr[key] !== next[key]) return false;
    }

    return true;
  }));
  return (0, _rxjs.combineLatest)([// from document edits
  document$, // and from document dependency events
  (0, _rxjs.concat)( // note: that the `referencedDocumentUpdate$` may not pre-emit any
  // events (unlike `editState` which includes `publishReplay(1)`), so
  // we `concat` the stream with an empty emission so `combineLatest` will
  // emit as soon as `editState` emits
  //
  // > Be aware that `combineLatest` will not emit an initial value until
  // > each observable emits at least one value.
  // https://www.learnrxjs.io/learn-rxjs/operators/combination/combinelatest#why-use-combinelatest
  (0, _rxjs.of)(null), referencedDocumentUpdate$).pipe( // don't remove, see `debounceTime` comment above
  (0, _operators.debounceTime)(50))]).pipe((0, _operators.map)(_ref6 => {
    let [document] = _ref6;
    return document;
  }), (0, _operators.switchMap)(document => (0, _rxjs.concat)((0, _rxjs.of)({
    isValidating: true
  }), (0, _rxjs.defer)(async () => {
    if (!(document !== null && document !== void 0 && document._type)) {
      return {
        validation: [],
        isValidating: false
      };
    } // TODO: consider cancellation eventually


    const markers = await (0, _validation.validateDocument)(ctx.client, document, ctx.schema, {
      getDocumentExists
    });
    return {
      validation: markers,
      isValidating: false
    };
  }))), (0, _operators.scan)((acc, next) => ({ ...acc,
    ...next
  }), INITIAL_VALIDATION_STATUS), (0, _operators.publishReplay)(1), (0, _operators.refCount)());
}, (_ctx, idPair) => idPair.publishedId);
exports.validation = validation;