"use strict";

var _reactHooks = require("@testing-library/react-hooks");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _mockSanityClient = require("../../../../../test/mocks/mockSanityClient");

var _config = require("../../../../config");

var _useDocumentType = require("../useDocumentType");

var _TestProvider = require("../../../../../test/testUtils/TestProvider");

function createWrapperComponent(client) {
  const config = (0, _config.createConfig)({
    projectId: 'foo',
    dataset: 'test'
  });
  return (0, _TestProvider.createTestProvider)({
    client,
    config
  });
}

test('should return passed document type if already resolved', async () => {
  const client = (0, _mockSanityClient.createMockSanityClient)();
  const wrapper = await createWrapperComponent(client);
  const {
    result,
    rerender
  } = (0, _reactHooks.renderHook)(() => (0, _useDocumentType.useDocumentType)('grrm', 'author'), {
    wrapper
  });
  expect(result.current).toEqual({
    isLoaded: true,
    documentType: 'author'
  });
  (0, _reactHooks.act)(() => {
    rerender();
  }); // Should be referentially the same

  const first = result.all[0];

  for (const value of result.all) {
    expect(value).toBe(first);
  }
});
test('should resolve document type from API on undefined type (with loading state)', async () => {
  const client = (0, _mockSanityClient.createMockSanityClient)();
  const response = (0, _rxjs.defer)(() => (0, _rxjs.of)(['book']).pipe((0, _operators.observeOn)(_rxjs.asyncScheduler)));
  client.observable.fetch = jest.fn().mockReturnValueOnce(response);
  const {
    result,
    waitForNextUpdate
  } = (0, _reactHooks.renderHook)(() => (0, _useDocumentType.useDocumentType)('asoiaf-got', undefined), {
    wrapper: await createWrapperComponent(client)
  });
  expect(result.current).toEqual({
    isLoaded: false,
    documentType: undefined
  });
  await waitForNextUpdate();
  expect(result.current).toEqual({
    isLoaded: true,
    documentType: 'book'
  });
  expect(client.observable.fetch).toHaveBeenCalledTimes(1);
});
test('should return correct document type on document type transition', async () => {
  const client = (0, _mockSanityClient.createMockSanityClient)();
  client.observable.fetch = jest.fn();
  let documentType = 'book';
  const {
    result,
    rerender
  } = (0, _reactHooks.renderHook)(() => (0, _useDocumentType.useDocumentType)('abc123', documentType), {
    wrapper: await createWrapperComponent(client)
  }); // At this point, it is a book

  expect(result.current).toEqual({
    isLoaded: true,
    documentType: 'book'
  });
  expect(client.observable.fetch).not.toHaveBeenCalled(); // Now switch the document type variable to an author and rerender

  documentType = 'author';
  rerender(); // We should still not have triggered a request, since we explicitly passed it a type,
  // but the _value_ should be different now

  expect(client.observable.fetch).not.toHaveBeenCalled();
  expect(result.current).toEqual({
    isLoaded: true,
    documentType: 'author'
  });
});
test('should return correct document type on document ID transition', async () => {
  const client = (0, _mockSanityClient.createMockSanityClient)();
  const responseGrrm = (0, _rxjs.defer)(() => (0, _rxjs.of)(['author']).pipe((0, _operators.observeOn)(_rxjs.asyncScheduler)));
  const responseGot = (0, _rxjs.defer)(() => (0, _rxjs.of)(['book']).pipe((0, _operators.observeOn)(_rxjs.asyncScheduler)));

  client.observable.fetch = (_query, params) => params.documentId === 'grrm' ? responseGrrm : responseGot;

  let documentId = 'grrm';
  const {
    result,
    rerender,
    waitForNextUpdate
  } = (0, _reactHooks.renderHook)(() => (0, _useDocumentType.useDocumentType)(documentId, undefined), {
    wrapper: await createWrapperComponent(client)
  }); // First lookup (author)

  expect(result.current).toEqual({
    isLoaded: false,
    documentType: undefined
  });
  await waitForNextUpdate();
  expect(result.current).toEqual({
    isLoaded: true,
    documentType: 'author'
  }); // Change to look up a book instead

  documentId = 'agot';
  rerender(); // Second lookup (book)

  expect(result.current).toEqual({
    isLoaded: false,
    documentType: undefined
  });
  await waitForNextUpdate();
  expect(result.current).toEqual({
    isLoaded: true,
    documentType: 'book'
  });
});
test('should return correct document type when transitioning from undefined type to specified type', async () => {
  const client = (0, _mockSanityClient.createMockSanityClient)();
  const responseGrrm = (0, _rxjs.defer)(() => (0, _rxjs.of)(['author']).pipe((0, _operators.observeOn)(_rxjs.asyncScheduler)));
  client.observable.fetch = jest.fn().mockReturnValue(responseGrrm); // eslint-disable-next-line no-undef-init

  let documentType = undefined;
  const {
    result,
    rerender,
    waitForNextUpdate
  } = (0, _reactHooks.renderHook)(() => (0, _useDocumentType.useDocumentType)('grrm', documentType), {
    wrapper: await createWrapperComponent(client)
  }); // First lookup - undefined type specified, but is an author

  expect(result.current).toEqual({
    isLoaded: false,
    documentType: undefined
  });
  await waitForNextUpdate();
  expect(result.current).toEqual({
    isLoaded: true,
    documentType: 'author'
  });
  expect(client.observable.fetch).toHaveBeenCalled(); // Now lets say we for some reason decide that document type is something else

  documentType = 'person';
  rerender(); // We shouldn't need to look anything up, since the value is passed

  expect(result.current).toEqual({
    isLoaded: true,
    documentType: 'person'
  }); // Should not have been called again on updated document type

  expect(client.observable.fetch).toHaveBeenCalledTimes(1);
});
test('should return correct document type when transitioning from specified to undefined type', async () => {
  const client = (0, _mockSanityClient.createMockSanityClient)();
  const responseGrrm = (0, _rxjs.defer)(() => (0, _rxjs.of)(['person']).pipe((0, _operators.observeOn)(_rxjs.asyncScheduler)));
  client.observable.fetch = jest.fn().mockReturnValue(responseGrrm); // eslint-disable-next-line no-undef-init

  let documentType = 'author';
  const {
    result,
    rerender,
    waitForNextUpdate
  } = (0, _reactHooks.renderHook)(() => (0, _useDocumentType.useDocumentType)('grrm', documentType), {
    wrapper: await createWrapperComponent(client)
  }); // First lookup - specified type, so is an author

  expect(result.current).toEqual({
    isLoaded: true,
    documentType: 'author'
  });
  expect(client.observable.fetch).not.toHaveBeenCalled(); // Now lets say we for some reason decide that we don't know the document type

  documentType = undefined;
  rerender(); // We must look up the type, thus loading state

  expect(result.current).toEqual({
    isLoaded: false,
    documentType: undefined
  });
  await waitForNextUpdate();
  expect(result.current).toEqual({
    isLoaded: true,
    documentType: 'person'
  }); // Should have been called only once (when transitioning)

  expect(client.observable.fetch).toHaveBeenCalledTimes(1);
});
test('should cancel ongoing requests when transitioning document ID', async () => {
  const client = (0, _mockSanityClient.createMockSanityClient)();
  const hasResolvedFirst = jest.fn();
  const responseDelayedGrrm = (0, _rxjs.defer)(() => (0, _rxjs.of)(['person']).pipe((0, _operators.observeOn)(_rxjs.asyncScheduler), (0, _operators.delay)(5000), (0, _operators.tap)(hasResolvedFirst)));
  const responseGot = (0, _rxjs.defer)(() => (0, _rxjs.of)(['book']).pipe((0, _operators.observeOn)(_rxjs.asyncScheduler)));
  client.observable.fetch = jest.fn().mockReturnValueOnce(responseDelayedGrrm).mockReturnValueOnce(responseGot);
  let documentId = 'grrm';
  const {
    result,
    rerender,
    waitForNextUpdate
  } = (0, _reactHooks.renderHook)(() => (0, _useDocumentType.useDocumentType)(documentId, undefined), {
    wrapper: await createWrapperComponent(client)
  }); // First lookup - must be looked up

  expect(result.current).toEqual({
    isLoaded: false,
    documentType: undefined
  });
  expect(client.observable.fetch).toHaveBeenCalled(); // Now, before the request has time to resolve, switch the ID

  documentId = 'agot';
  rerender(); // Should still be in loading state

  expect(result.current).toEqual({
    isLoaded: false,
    documentType: undefined
  });
  await waitForNextUpdate();
  expect(result.current).toEqual({
    isLoaded: true,
    documentType: 'book'
  }); // Should have been called twice (once for each document ID)

  expect(client.observable.fetch).toHaveBeenCalledTimes(2); // Should never have resolved the first one

  expect(hasResolvedFirst).not.toHaveBeenCalled();
});