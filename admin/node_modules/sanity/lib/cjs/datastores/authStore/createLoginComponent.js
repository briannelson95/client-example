"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLoginComponent = createLoginComponent;

var _ui = require("@sanity/ui");

var _react = _interopRequireWildcard(require("react"));

var _util = require("../../util");

var _providerLogos = require("./providerLogos");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

async function getProviders(_ref) {
  let {
    client,
    mode,
    providers: customProviders = []
  } = _ref;
  const {
    providers,
    thirdPartyLogin,
    sso
  } = await client.request({
    uri: '/auth/providers'
  });
  if (!customProviders.length) return providers;
  const custom = customProviders.map(provider => {
    // taken from here:
    // https://github.com/sanity-io/sanity/blob/795637999b67c23de1657a3701091a337383f632/packages/%40sanity/default-login/src/util/getProviders.js#L19
    // A user may want to remove certain login options (eg GitHub) and thus
    // provide "official" login options through the config. These shouldn't be
    // treated as custom login providers which require the third-party login
    // feature, but as the official provider
    const isOfficial = providers.some(official => official.url === provider.url);
    const isSupported = isOfficial || thirdPartyLogin || sso && Object.values(sso).some(Boolean);
    return { ...provider,
      custom: !isOfficial,
      supported: isSupported
    };
  });
  if (mode === 'replace') return custom; // Append to the list of official providers, but replace any provider that has
  // the same URL with the custom one (allows customizing the title, name)

  return providers.filter(official => custom.some(provider => provider.url !== official.url)).concat(custom);
}

function createHrefForProvider(_ref2) {
  let {
    loginMethod,
    projectId,
    url,
    basePath
  } = _ref2;
  const params = new URLSearchParams();
  params.set('origin', "".concat(window.location.origin).concat(basePath));
  params.set('projectId', projectId);
  params.set('type', loginMethod);
  return "".concat(url, "?").concat(params);
}

function createLoginComponent(_ref3) {
  let {
    getClient,
    loginMethod,
    redirectOnSingle,
    ...providerOptions
  } = _ref3;
  const useClient = (0, _util.createHookFromObservableFactory)(getClient);

  function LoginComponent(_ref4) {
    let {
      projectId,
      basePath
    } = _ref4;
    const [providers, setProviders] = (0, _react.useState)(null);
    const [error, setError] = (0, _react.useState)(null);
    if (error) throw error;
    const [client] = useClient();
    (0, _react.useEffect)(() => {
      if (!client) return;
      getProviders({
        client,
        ...providerOptions
      }).then(setProviders).catch(setError);
    }, [client]); // only create a direct URL if `redirectOnSingle` is true and there is only
    // one provider available

    const redirectUrl = redirectOnSingle && (providers === null || providers === void 0 ? void 0 : providers.length) === 1 && (providers === null || providers === void 0 ? void 0 : providers[0]) && createHrefForProvider({
      loginMethod,
      projectId,
      url: providers[0].url,
      basePath
    });
    const loading = !providers || redirectUrl;
    (0, _react.useEffect)(() => {
      if (redirectUrl) {
        window.location.href = redirectUrl;
      }
    }, [redirectUrl]);

    if (loading) {
      return /*#__PURE__*/_react.default.createElement(_ui.Flex, {
        align: "center",
        direction: "column",
        gap: 4,
        justify: "center",
        padding: 6,
        sizing: "border"
      }, /*#__PURE__*/_react.default.createElement(_ui.Text, {
        muted: true
      }, "Loading\u2026"), /*#__PURE__*/_react.default.createElement(_ui.Spinner, {
        muted: true
      }));
    }

    return /*#__PURE__*/_react.default.createElement(_ui.Stack, {
      space: 4
    }, /*#__PURE__*/_react.default.createElement(_ui.Heading, {
      align: "center",
      size: 1
    }, "Choose login provider"), /*#__PURE__*/_react.default.createElement(_ui.Stack, {
      space: 2
    }, providers.map((provider, index) => /*#__PURE__*/_react.default.createElement(_ui.Button // eslint-disable-next-line react/no-array-index-key
    , {
      icon: _providerLogos.providerLogos[provider.name],
      key: "".concat(provider.url, "_").concat(index),
      as: "a",
      href: createHrefForProvider({
        loginMethod,
        projectId,
        url: provider.url,
        basePath
      }),
      mode: "ghost",
      text: provider.title
    }))));
  }

  return LoginComponent;
}