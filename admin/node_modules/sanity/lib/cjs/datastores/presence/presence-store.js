"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SESSION_ID = void 0;
exports.__tmp_wrap_presenceStore = __tmp_wrap_presenceStore;

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _omit2 = _interopRequireDefault(require("lodash/omit"));

var _groupBy2 = _interopRequireDefault(require("lodash/groupBy"));

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _nanoid = require("nanoid");

var _debugParams = require("../debugParams");

var _mockEvents = require("./mock-events");

var _bifurTransport = require("./message-transports/bifurTransport");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable camelcase */
const KEY = 'presence_session_id';

const generate = () => (0, _nanoid.nanoid)(16); // We're keeping the session id in sessionStorage as it will survive page reloads.
// todo:
//  There's a potential issue with window.open(...) here as it inherits the top level session storage and thus will
//  re-use session ids:
//    > Opening a page in a new tab or window creates a new session with the value of the top-level browsing context,
//      which differs from how session cookies work.
//      More at https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage
//  This is _probably_ a quite marginal case and not going to be much of a issue in practice


function getSessionId() {
  try {
    return window.sessionStorage.getItem(KEY);
  } catch (err) {// We don't want to fail hard if session storage can't be accessed for some reason
  }

  return null;
}

function setSessionId(id) {
  try {
    window.sessionStorage.setItem(KEY, id);
  } catch (err) {// We don't want to fail hard if session storage can't be accessed for some reason
  }

  return id;
}

const SESSION_ID = getSessionId() || setSessionId(generate());
exports.SESSION_ID = SESSION_ID;

function __tmp_wrap_presenceStore(context) {
  const {
    bifur,
    connectionStatusStore,
    userStore
  } = context;
  const [presenceEvents$, sendMessage] = (0, _bifurTransport.createBifurTransport)(bifur, SESSION_ID);
  const currentLocation$ = new _rxjs.BehaviorSubject([]);
  const locationChange$ = currentLocation$.pipe((0, _operators.distinctUntilChanged)()); // export

  const setLocation = nextLocation => {
    currentLocation$.next(nextLocation);
  }; // export


  const reportLocations = locations => sendMessage({
    type: 'state',
    locations: locations
  });

  const requestRollCall = () => sendMessage({
    type: 'rollCall'
  });

  const rollCallRequests$ = presenceEvents$.pipe((0, _operators.filter)(event => event.type === 'rollCall'), // do not respond to my own rollcall requests
  (0, _operators.filter)(event => event.sessionId !== SESSION_ID));
  const REPORT_MIN_INTERVAL = 30000; // Interval to report my own location at

  const reportLocationInterval$ = (0, _rxjs.timer)(0, REPORT_MIN_INTERVAL);
  const reportLocation$ = (0, _rxjs.defer)(() => (0, _rxjs.merge)(locationChange$, rollCallRequests$)).pipe((0, _operators.switchMap)(() => reportLocationInterval$), (0, _operators.withLatestFrom)(currentLocation$), (0, _operators.map)(_ref => {
    let [, locations] = _ref;
    return locations;
  }), (0, _operators.auditTime)(200), (0, _operators.switchMap)(locations => reportLocations(locations)), (0, _operators.mergeMapTo)(_rxjs.EMPTY), (0, _operators.share)()); // This represents my rollcall request to other clients
  // Note: We are requesting a rollcall whenever we (re)connect

  const myRollCall$ = (0, _rxjs.defer)(() => requestRollCall()).pipe((0, _operators.mergeMapTo)(_rxjs.EMPTY));
  const connectionChange$ = connectionStatusStore.connectionStatus$.pipe((0, _operators.map)(status => status.type), (0, _operators.filter)(statusType => statusType === 'connected' || statusType === 'error'), (0, _operators.distinctUntilChanged)()); // export

  const debugPresenceParam$ = _debugParams.debugParams$.pipe((0, _operators.map)(args => args.find(arg => arg.startsWith('presence='))), (0, _operators.map)(arg => (arg === null || arg === void 0 ? void 0 : arg.split('presence=')[1].split(',').map(r => r.trim())) || []));

  const useMock$ = debugPresenceParam$.pipe((0, _operators.filter)(args => args.includes('fake_others')), (0, _operators.tap)(() => {
    // eslint-disable-next-line no-console
    console.log('Faking other users present in the studio. They will hang out in the document with _type: "presence" and _id: "presence-debug"');
  }), (0, _operators.switchMapTo)(_mockEvents.mock$));
  const debugIntrospect$ = debugPresenceParam$.pipe((0, _operators.map)(args => args.includes('show_own')));
  const syncEvent$ = (0, _rxjs.merge)(myRollCall$, presenceEvents$).pipe((0, _operators.filter)(event => event.type === 'state' || event.type === 'disconnect'));

  const stateEventToSession = stateEvent => {
    return {
      lastActiveAt: stateEvent.timestamp,
      locations: stateEvent.locations,
      sessionId: stateEvent.sessionId,
      userId: stateEvent.userId
    };
  };

  const states$ = (0, _rxjs.merge)(syncEvent$, useMock$).pipe((0, _operators.scan)((keyed, event) => event.type === 'disconnect' ? (0, _omit2.default)(keyed, event.sessionId) : { ...keyed,
    [event.sessionId]: stateEventToSession(event)
  }, {}));
  const allSessions$ = connectionChange$.pipe((0, _operators.switchMap)(status => status === 'connected' ? (0, _rxjs.merge)(states$, reportLocation$) : _rxjs.NEVER), (0, _operators.map)(keyedSessions => Object.values(keyedSessions)), (0, _operators.switchMap)(sessions => {
    const userIds = (0, _uniq2.default)(sessions.map(sess => sess.userId));
    return (0, _rxjs.from)(userStore.getUsers(userIds)).pipe((0, _operators.map)(users => sessions.map(session => ({
      // eslint-disable-next-line max-nested-callbacks
      user: users.find(res => res.id === session.userId),
      session: session
    })) // If we failed to find a user profile for a session, remove it
    .filter(userSessionPairHasUser)));
  }), (0, _operators.takeUntil)((0, _rxjs.fromEvent)(window, 'beforeunload').pipe((0, _operators.switchMap)(() => sendMessage({
    type: 'disconnect'
  })))), (0, _operators.shareReplay)({
    refCount: true,
    bufferSize: 1
  }));

  function userSessionPairHasUser(pair) {
    return Boolean(pair.user && pair.session);
  } // export


  const globalPresence$ = allSessions$.pipe((0, _operators.map)(sessions => {
    const grouped = (0, _groupBy2.default)(sessions.map(s => s.session), e => e.userId);
    return Object.keys(grouped).map(userId => {
      var _sessions$find;

      return {
        user: (_sessions$find = sessions.find(s => s.user.id === userId)) === null || _sessions$find === void 0 ? void 0 : _sessions$find.user,
        sessions: grouped[userId]
      };
    });
  }), (0, _operators.withLatestFrom)(debugIntrospect$), (0, _operators.map)(_ref2 => {
    let [userAndSessions, debugIntrospect] = _ref2;
    return userAndSessions.filter(userAndSession => {
      if (debugIntrospect) {
        return true;
      }

      const isCurrent = userAndSession.sessions.some(sess => sess.sessionId === SESSION_ID);
      return !isCurrent;
    });
  }), (0, _operators.map)(userAndSessions => userAndSessions.map(userAndSession => {
    var _userAndSession$sessi;

    return {
      user: userAndSession.user,
      status: 'online',
      lastActiveAt: (_userAndSession$sessi = userAndSession.sessions.sort()[0]) === null || _userAndSession$sessi === void 0 ? void 0 : _userAndSession$sessi.lastActiveAt,
      locations: (0, _flatten2.default)((userAndSession.sessions || []).map(session => session.locations || [])).map(location => ({
        type: location.type,
        documentId: location.documentId,
        path: location.path,
        lastActiveAt: location.lastActiveAt
      })).reduce((prev, curr) => prev.concat(curr), [])
    };
  }))); // export

  const documentPresence = documentId => {
    return allSessions$.pipe((0, _operators.withLatestFrom)(debugIntrospect$), (0, _operators.switchMap)(_ref3 => {
      let [userAndSessions, debugIntrospect] = _ref3;
      return (0, _rxjs.from)(userAndSessions).pipe((0, _operators.filter)(userAndSession => debugIntrospect || userAndSession.session.sessionId !== SESSION_ID), (0, _operators.flatMap)(userAndSession => (userAndSession.session.locations || []).filter(item => item.documentId === documentId).map(location => ({
        user: userAndSession.user,
        lastActiveAt: userAndSession.session.lastActiveAt,
        path: location.path || [],
        sessionId: userAndSession.session.sessionId
      }))), (0, _operators.toArray)());
    }));
  };

  return {
    setLocation,
    reportLocations,
    debugPresenceParam$,
    globalPresence$,
    documentPresence
  };
}