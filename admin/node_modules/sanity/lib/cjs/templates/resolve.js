"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getItemType = getItemType;
exports.isBuilder = isBuilder;
exports.resolveInitialObjectValue = resolveInitialObjectValue;
exports.resolveInitialValue = resolveInitialValue;
exports.resolveInitialValueForType = resolveInitialValueForType;
exports.resolveValue = resolveValue;

var _types = require("@sanity/types");

var _content = require("@sanity/util/content");

var _isRecord = require("./util/isRecord");

var _validate = require("./validate");

var _deepAssign = _interopRequireDefault(require("./util/deepAssign"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBuilder(template) {
  return (0, _isRecord.isRecord)(template) && typeof template.serialize === 'function';
} // returns the "resolved" value from an initial value property (e.g. type.initialValue)
// eslint-disable-next-line require-await


async function resolveValue(initialValueOpt, params) {
  return typeof initialValueOpt === 'function' ? initialValueOpt(params) : initialValueOpt;
}

async function resolveInitialValue(schema, template) {
  let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // Template builder?
  if (isBuilder(template)) {
    return resolveInitialValue(schema, template.serialize(), params);
  }

  const {
    id,
    schemaType: schemaTypeName,
    value
  } = template;

  if (!value) {
    throw new Error("Template \"".concat(id, "\" has invalid \"value\" property"));
  }

  let resolvedValue = await resolveValue(value, params);

  if (!(0, _isRecord.isRecord)(resolvedValue)) {
    throw new Error("Template \"".concat(id, "\" has invalid \"value\" property - must be a plain object or a resolver function returning a plain object"));
  } // validate default document initial values


  resolvedValue = (0, _validate.validateInitialObjectValue)(resolvedValue, template); // Get deep initial values from schema types (note: the initial value from template overrides the types)

  const schemaType = schema.get(schemaTypeName);

  if (!schemaType) {
    throw new Error("Could not find schema type with name \"".concat(schemaTypeName, "\"."));
  }

  const newValue = (0, _deepAssign.default)((await resolveInitialValueForType(schemaType, params)) || {}, resolvedValue); // revalidate and return new initial values
  // todo: would be better to do validation as part of type resolution

  return (0, _validate.validateInitialObjectValue)(newValue, template);
}

function getItemType(arrayType, item) {
  const itemTypeName = (0, _content.resolveTypeName)(item);
  return itemTypeName === 'object' && arrayType.of.length === 1 ? arrayType.of[0] : arrayType.of.find(memberType => memberType.name === itemTypeName);
}

const DEFAULT_MAX_RECURSION_DEPTH = 10;
/**
 * Resolve initial value for the given schema type (recursively)
 */

function resolveInitialValueForType(
/**
 * This is the name of the document.
 */
type,
/**
 * Params is a sanity context object passed to every initial value function.
 */
params) {
  let maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_MAX_RECURSION_DEPTH;

  if (maxDepth <= 0) {
    return Promise.resolve(undefined);
  }

  if ((0, _types.isObjectSchemaType)(type)) {
    return resolveInitialObjectValue(type, params, maxDepth);
  }

  if ((0, _types.isArraySchemaType)(type)) {
    return resolveInitialArrayValue(type, params, maxDepth);
  }

  return resolveValue(type.initialValue, params);
}

async function resolveInitialArrayValue(type, params, maxDepth) {
  const initialArray = await resolveValue(type.initialValue);

  if (!Array.isArray(initialArray)) {
    return undefined;
  }

  return Promise.all(initialArray.map(async initialItem => {
    const itemType = getItemType(type, initialItem);
    return (0, _types.isObjectSchemaType)(itemType) ? { ...initialItem,
      ...(await resolveInitialValueForType(itemType, params, maxDepth - 1)),
      _key: (0, _content.randomKey)()
    } : initialItem;
  }));
}

async function resolveInitialObjectValue(type, params, maxDepth) {
  const initialObject = { ...((await resolveValue(type.initialValue, params)) || {})
  };
  const fieldValues = {};
  await Promise.all(type.fields.map(async field => {
    const initialFieldValue = await resolveInitialValueForType(field.type, params, maxDepth - 1);

    if (initialFieldValue !== undefined && initialFieldValue !== null) {
      fieldValues[field.name] = initialFieldValue;
    }
  }));
  const merged = (0, _deepAssign.default)(fieldValues, initialObject);

  if ((0, _content.isEmpty)(merged)) {
    return undefined;
  }

  if (type.name !== 'object') {
    merged._type = type.name;
  }

  return merged;
}