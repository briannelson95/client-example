"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _promises = _interopRequireDefault(require("fs/promises"));

var _prettyMs = _interopRequireDefault(require("pretty-ms"));

var _fs = require("@sanity/util/fs");

var _export = _interopRequireDefault(require("@sanity/export"));

var _chooseDatasetPrompt = require("../../actions/dataset/chooseDatasetPrompt");

var _validateDatasetName = require("../../actions/dataset/validateDatasetName");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const noop = () => null;

const helpText = "\nOptions\n  --raw                     Extract only documents, without rewriting asset references\n  --no-assets               Export only non-asset documents and remove references to image assets\n  --no-drafts               Export only published versions of documents\n  --no-compress             Skips compressing tarball entries (still generates a gzip file)\n  --types                   Defines which document types to export\n  --overwrite               Overwrite any file with the same name\n  --asset-concurrency <num> Concurrent number of asset downloads\n\nExamples\n  sanity dataset export moviedb localPath.tar.gz\n  sanity dataset export moviedb assetless.tar.gz --no-assets\n  sanity dataset export staging staging.tar.gz --raw\n  sanity dataset export staging staging.tar.gz --types products,shops\n";

function parseFlags(rawFlags) {
  const flags = {};

  if (rawFlags.types) {
    flags.types = "".concat(rawFlags.types).split(',');
  }

  if (rawFlags['asset-concurrency']) {
    flags.assetConcurrency = parseInt(rawFlags['asset-concurrency'], 10);
  }

  if (typeof rawFlags.raw !== 'undefined') {
    flags.raw = Boolean(rawFlags.raw);
  }

  if (typeof rawFlags.assets !== 'undefined') {
    flags.assets = Boolean(rawFlags.assets);
  }

  if (typeof rawFlags.drafts !== 'undefined') {
    flags.drafts = Boolean(rawFlags.drafts);
  }

  if (typeof rawFlags.compress !== 'undefined') {
    flags.compress = Boolean(rawFlags.compress);
  }

  if (typeof rawFlags.overwrite !== 'undefined') {
    flags.overwrite = Boolean(rawFlags.overwrite);
  }

  return flags;
}

const exportDatasetCommand = {
  name: 'export',
  group: 'dataset',
  signature: '[NAME] [DESTINATION]',
  description: 'Export dataset to local filesystem as a gzipped tarball',
  helpText,
  action: async (args, context) => {
    const {
      apiClient,
      output,
      chalk,
      workDir,
      prompt
    } = context;
    const client = apiClient();
    const [targetDataset, targetDestination] = args.argsWithoutOptions;
    const flags = parseFlags(args.extOptions);
    let dataset = targetDataset ? "".concat(targetDataset) : null;

    if (!dataset) {
      dataset = await (0, _chooseDatasetPrompt.chooseDatasetPrompt)(context, {
        message: 'Select dataset to export'
      });
    }

    const dsError = (0, _validateDatasetName.validateDatasetName)(dataset);

    if (dsError) {
      throw dsError;
    } // Verify existence of dataset before trying to export from it


    const datasets = await client.datasets.list();

    if (!datasets.find(set => set.name === dataset)) {
      throw new Error("Dataset with name \"".concat(dataset, "\" not found"));
    }

    let destinationPath = targetDestination;

    if (!destinationPath) {
      destinationPath = await prompt.single({
        type: 'input',
        message: 'Output path:',
        default: _path.default.join(workDir, "".concat(dataset, ".tar.gz")),
        filter: _fs.absolutify
      });
    }

    const outputPath = await getOutputPath(destinationPath, dataset, prompt, flags);

    if (!outputPath) {
      output.print('Cancelled');
      return;
    } // If we are dumping to a file, let the user know where it's at


    if (outputPath !== '-') {
      output.print("Exporting dataset \"".concat(chalk.cyan(dataset), "\" to \"").concat(chalk.cyan(outputPath), "\""));
    }

    let currentStep = 'Exporting documents...';
    let spinner = output.spinner(currentStep).start();

    const onProgress = progress => {
      if (progress.step !== currentStep) {
        spinner.succeed();
        spinner = output.spinner(progress.step).start();
      } else if (progress.step === currentStep && progress.update) {
        spinner.text = "".concat(progress.step, " (").concat(progress.current, "/").concat(progress.total, ")");
      }

      currentStep = progress.step;
    };

    const start = Date.now();

    try {
      await (0, _export.default)({
        client,
        dataset,
        outputPath,
        onProgress,
        ...flags
      });
      spinner.succeed();
    } catch (err) {
      spinner.fail();
      throw err;
    }

    output.print("Export finished (".concat((0, _prettyMs.default)(Date.now() - start), ")"));
  }
}; // eslint-disable-next-line complexity

async function getOutputPath(destination, dataset, prompt, flags) {
  if (destination === '-') {
    return '-';
  }

  const dstPath = _path.default.isAbsolute(destination) ? destination : _path.default.resolve(process.cwd(), destination);
  let dstStats = await _promises.default.stat(dstPath).catch(noop);
  const looksLikeFile = dstStats ? dstStats.isFile() : _path.default.basename(dstPath).indexOf('.') !== -1;

  if (!dstStats) {
    const createPath = looksLikeFile ? _path.default.dirname(dstPath) : dstPath;
    await _promises.default.mkdir(createPath, {
      recursive: true
    });
  }

  const finalPath = looksLikeFile ? dstPath : _path.default.join(dstPath, "".concat(dataset, ".tar.gz"));
  dstStats = await _promises.default.stat(finalPath).catch(noop);

  if (!flags.overwrite && dstStats && dstStats.isFile()) {
    const shouldOverwrite = await prompt.single({
      type: 'confirm',
      message: "File \"".concat(finalPath, "\" already exists, would you like to overwrite it?"),
      default: false
    });

    if (!shouldOverwrite) {
      return false;
    }
  }

  return finalPath;
}

var _default = exportDatasetCommand;
exports.default = _default;