"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _groupBy2 = _interopRequireDefault(require("lodash/groupBy"));

var _util = require("util");

var _printHookAttemptCommand = require("./printHookAttemptCommand");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const listHookLogsCommand = {
  name: 'logs',
  group: 'hook',
  signature: '[NAME]',
  helpText: '',
  description: 'List latest log entries for a given hook',
  action: async (args, context) => {
    const {
      apiClient
    } = context;
    const flags = args.extOptions;
    const [name] = args.argsWithoutOptions;
    const client = apiClient();
    const hookId = await promptForHook(name, context);
    let messages;
    let attempts;

    try {
      messages = await client.request({
        uri: "/hooks/".concat(hookId, "/messages")
      });
      attempts = await client.request({
        uri: "/hooks/".concat(hookId, "/attempts")
      });
    } catch (err) {
      throw new Error("Hook logs retrieval failed:\n".concat(err.message));
    }

    const groupedAttempts = (0, _groupBy2.default)(attempts, 'messageId');
    const populated = messages.map(msg => ({ ...msg,
      attempts: groupedAttempts[msg.id]
    }));
    const totalMessages = messages.length - 1;
    populated.forEach((message, i) => {
      printMessage(message, context, {
        detailed: flags.detailed
      });
      printSeparator(context, totalMessages === i);
    });
  }
};
var _default = listHookLogsCommand;
exports.default = _default;

async function promptForHook(specified, context) {
  const specifiedName = specified && specified.toLowerCase();
  const {
    prompt,
    apiClient
  } = context;
  const client = apiClient();
  const hooks = await client.clone().config({
    apiVersion: '2021-10-04'
  }).request({
    uri: '/hooks',
    json: true
  });

  if (specifiedName) {
    const selected = hooks.filter(hook => hook.name.toLowerCase() === specifiedName)[0];

    if (!selected) {
      throw new Error("Hook with name \"".concat(specified, " not found\""));
    }

    return selected.id;
  }

  if (hooks.length === 0) {
    throw new Error('No hooks currently registered');
  }

  if (hooks.length === 1) {
    return hooks[0].id;
  }

  const choices = hooks.map(hook => ({
    value: hook.id,
    name: hook.name
  }));
  return prompt.single({
    message: 'Select hook to list logs for',
    type: 'list',
    choices
  });
}

function printSeparator(context, skip) {
  if (!skip) {
    context.output.print('---\n');
  }
}

function printMessage(message, context, options) {
  const {
    detailed
  } = options;
  const {
    output,
    chalk
  } = context;
  output.print("Date: ".concat(message.createdAt));
  output.print("Status: ".concat(message.status));
  output.print("Result code: ".concat(message.resultCode));

  if (message.failureCount > 0) {
    output.print("Failures: ".concat(message.failureCount));
  }

  if (detailed) {
    output.print('Payload:');
    output.print((0, _util.inspect)(JSON.parse(message.payload), {
      colors: true
    }));
  }

  if (detailed && message.attempts) {
    output.print('Attempts:');
    message.attempts.forEach(attempt => {
      const date = attempt.createdAt.replace(/\.\d+Z$/, 'Z');
      const prefix = "  [".concat(date, "]");

      if (attempt.inProgress) {
        output.print("".concat(prefix, " ").concat(chalk.yellow('Pending')));
      } else if (attempt.isFailure) {
        const failure = (0, _printHookAttemptCommand.formatFailure)(attempt, {
          includeHelp: true
        });
        output.print("".concat(prefix, " ").concat(chalk.yellow("Failure: ".concat(failure))));
      } else {
        output.print("".concat(prefix, " Success: HTTP ").concat(attempt.resultCode, " (").concat(attempt.duration, "ms)"));
      }
    });
  } // Leave some empty space between messages


  output.print('');
}