"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addCorsOrigin = addCorsOrigin;

var _url = _interopRequireDefault(require("url"));

var _logSymbols = _interopRequireDefault(require("log-symbols"));

var _oneline = _interopRequireDefault(require("oneline"));

var _templateObject, _templateObject2, _templateObject3, _templateObject4;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

const wildcardReplacement = 'a-wild-card-r3pl4c3m3n7-a';
const portReplacement = ':7777777';

async function addCorsOrigin(givenOrigin, flags, context) {
  const {
    apiClient,
    prompt,
    output
  } = context;
  const origin = await (givenOrigin ? filterAndValidateOrigin(givenOrigin) : promptForOrigin(prompt));
  const hasWildcard = origin.includes('*');

  if (hasWildcard && !(await promptForWildcardConfirmation(origin, context))) {
    return false;
  }

  const allowCredentials = typeof flags.credentials === 'undefined' ? await promptForCredentials(hasWildcard, context) : Boolean(flags.credentials);

  if (givenOrigin !== origin) {
    output.print("Normalized origin to ".concat(origin));
  }

  const client = apiClient({
    requireUser: true,
    requireProject: true
  });
  await client.request({
    method: 'POST',
    url: '/cors',
    body: {
      origin,
      allowCredentials
    },
    maxRedirects: 0
  });
  return true;
}

function promptForCredentials(hasWildcard, context) {
  const {
    prompt,
    output,
    chalk
  } = context;
  output.print('');

  if (hasWildcard) {
    output.print((0, _oneline.default)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n      ", "\n      We ", " recommend NOT allowing credentials\n      on origins containing wildcards. If you are logged in to a studio, people will\n      be able to send requests ", " to read and modify\n      data, from any matching origin. Please tread carefully!\n    "])), chalk.yellow("".concat(_logSymbols.default.warning, " Warning:")), chalk.red(chalk.underline('HIGHLY')), chalk.underline('on your behalf')));
  } else {
    output.print((0, _oneline.default)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n      ", "\n      Should this origin be allowed to send requests using authentication tokens or\n      session cookies? Be aware that any script on this origin will be able to send\n      requests ", " to read and modify data if you\n      are logged in to a Sanity studio. If this origin hosts a studio, you will need\n      this, otherwise you should probably answer \"No\" (n).\n    "])), chalk.yellow("".concat(_logSymbols.default.warning, " Warning:")), chalk.underline('on your behalf')));
  }

  output.print('');
  return prompt.single({
    type: 'confirm',
    message: (0, _oneline.default)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n      Allow credentials to be sent from this origin? Please read the warning above.\n    "]))),
    default: false
  });
}

function promptForWildcardConfirmation(origin, context) {
  const {
    prompt,
    output,
    chalk
  } = context;
  output.print('');
  output.print(chalk.yellow("".concat(_logSymbols.default.warning, " Warning: Examples of allowed origins:")));

  if (origin === '*') {
    output.print('- http://www.some-malicious.site');
    output.print('- https://not.what-you-were-expecting.com');
    output.print('- https://high-traffic-site.com');
    output.print('- http://192.168.1.1:8080');
  } else {
    output.print("- ".concat(origin.replace(/:\*/, ':1234').replace(/\*/g, 'foo')));
    output.print("- ".concat(origin.replace(/:\*/, ':3030').replace(/\*/g, 'foo.bar')));
  }

  output.print('');
  return prompt.single({
    type: 'confirm',
    message: (0, _oneline.default)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n      Using wildcards can be ", ".\n      Are you ", " you want to allow this origin?"])), chalk.red('risky'), chalk.underline('absolutely sure')),
    default: false
  });
}

function promptForOrigin(prompt) {
  return prompt.single({
    type: 'input',
    message: 'Origin (including protocol):',
    filter: filterOrigin,
    validate: origin => validateOrigin(origin, origin)
  });
}

function filterOrigin(origin) {
  if (origin === '*' || origin === 'file:///*' || origin === 'null') {
    return origin;
  }

  try {
    const example = origin.replace(/([^:])\*/g, "$1".concat(wildcardReplacement)).replace(/:\*/, portReplacement);

    const parsed = _url.default.parse(example);

    let host = parsed.host || '';

    if (/^https?:$/.test(parsed.protocol || '')) {
      host = host.replace(/:(80|443)$/, '');
    }

    host = host.replace(portReplacement, ':*').replace(new RegExp(wildcardReplacement, 'g'), '*');
    return "".concat(parsed.protocol, "//").concat(host);
  } catch (err) {
    return null;
  }
}

function validateOrigin(origin, givenOrigin) {
  if (origin === '*' || origin === 'file:///*' || origin === 'null') {
    return true;
  }

  try {
    _url.default.parse(origin || 0); // Use 0 to trigger error for unset values


    return true;
  } catch (err) {// Fall-through to error
  }

  if (/^file:\/\//.test(givenOrigin)) {
    return "Only a local file wildcard is currently allowed: file:///*";
  }

  return "Invalid origin \"".concat(givenOrigin, "\", must include protocol (https://some.host)");
}

function filterAndValidateOrigin(givenOrigin) {
  const origin = filterOrigin(givenOrigin);
  const result = validateOrigin(origin, givenOrigin);

  if (result !== true) {
    throw new Error(result);
  }

  if (!origin) {
    throw new Error('Invalid origin');
  }

  return origin;
}