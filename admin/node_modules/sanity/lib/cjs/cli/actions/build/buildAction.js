"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildSanityStudio;

var _path = _interopRequireDefault(require("path"));

var _util = require("util");

var _server = require("@sanity/server");

var _chalk = _interopRequireDefault(require("chalk"));

var _rimraf = _interopRequireDefault(require("rimraf"));

var _checkStudioDependencyVersions = require("../../util/checkStudioDependencyVersions");

var _checkRequiredDependencies = require("../../util/checkRequiredDependencies");

var _timing = require("../../util/timing");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore This may not yet be built.
const rimraf = (0, _util.promisify)(_rimraf.default);

async function buildSanityStudio(args, context, overrides) {
  const timer = (0, _timing.getTimer)();
  const {
    output,
    prompt,
    workDir,
    cliConfig
  } = context;
  const flags = {
    minify: true,
    stats: false,
    'source-maps': false,
    ...args.extOptions
  };
  const unattendedMode = Boolean(flags.yes || flags.y);

  const defaultOutputDir = _path.default.resolve(_path.default.join(workDir, 'dist'));

  const outputDir = _path.default.resolve(args.argsWithoutOptions[0] || defaultOutputDir);

  await (0, _checkStudioDependencyVersions.checkStudioDependencyVersions)(workDir); // If the check resulted in a dependency install, the CLI command will be re-run,
  // thus we want to exit early

  if ((await (0, _checkRequiredDependencies.checkRequiredDependencies)(context)).didInstall) {
    return {
      didCompile: false
    };
  }

  const envVarKeys = getSanityEnvVars();

  if (envVarKeys.length > 0) {
    output.print('\nIncluding the following environment variables as part of the JavaScript bundle:');
    envVarKeys.forEach(key => output.print("- ".concat(key)));
    output.print('');
  }

  let shouldClean = true;

  if (outputDir !== defaultOutputDir && !unattendedMode) {
    shouldClean = await prompt.single({
      type: 'confirm',
      message: "Do you want to delete the existing directory (".concat(outputDir, ") first?"),
      default: true
    });
  }

  let spin;

  if (shouldClean) {
    timer.start('cleanOutputFolder');
    spin = output.spinner('Clean output folder').start();
    await rimraf(outputDir);
    const cleanDuration = timer.end('cleanOutputFolder');
    spin.text = "Clean output folder (".concat(cleanDuration.toFixed(), "ms)");
    spin.succeed();
  }

  spin = output.spinner('Build Sanity Studio').start();

  try {
    var _cliConfig$project;

    timer.start('bundleStudio');
    const bundle = await (0, _server.buildStaticFiles)({
      cwd: workDir,
      outputDir,
      basePath: (overrides === null || overrides === void 0 ? void 0 : overrides.basePath) || (cliConfig === null || cliConfig === void 0 ? void 0 : (_cliConfig$project = cliConfig.project) === null || _cliConfig$project === void 0 ? void 0 : _cliConfig$project.basePath) || '/',
      sourceMap: Boolean(flags['source-maps']),
      minify: Boolean(flags.minify),
      vite: cliConfig && 'vite' in cliConfig ? cliConfig.vite : undefined
    });
    const buildDuration = timer.end('bundleStudio');
    spin.text = "Build Sanity Studio (".concat(buildDuration.toFixed(), "ms)");
    spin.succeed();

    if (flags.stats) {
      output.print('\nLargest module files:');
      output.print(formatModuleSizes(sortModulesBySize(bundle.chunks).slice(0, 15)));
    }
  } catch (err) {
    spin.fail();
    throw err;
  }

  return {
    didCompile: true
  };
} // eslint-disable-next-line no-process-env


function getSanityEnvVars() {
  let env = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.env;
  return Object.keys(env).filter(key => key.toUpperCase().startsWith('SANITY_STUDIO_'));
}

function sortModulesBySize(chunks) {
  return chunks.flatMap(chunk => chunk.modules).sort((modA, modB) => modB.renderedLength - modA.renderedLength);
}

function formatModuleSizes(modules) {
  const lines = [];

  for (const mod of modules) {
    lines.push(" - ".concat(formatModuleName(mod.name), " (").concat(formatSize(mod.renderedLength), ")"));
  }

  return lines.join('\n');
}

function formatModuleName(modName) {
  const delimiter = '/node_modules/';
  const nodeIndex = modName.lastIndexOf(delimiter);
  return nodeIndex === -1 ? modName : modName.slice(nodeIndex + delimiter.length);
}

function formatSize(bytes) {
  return _chalk.default.cyan("".concat((bytes / 1024).toFixed(), " kB"));
}