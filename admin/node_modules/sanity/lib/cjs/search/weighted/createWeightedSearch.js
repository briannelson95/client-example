"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWeightedSearch = createWeightedSearch;

var _union2 = _interopRequireDefault(require("lodash/union"));

var _sortBy2 = _interopRequireDefault(require("lodash/sortBy"));

var _flow2 = _interopRequireDefault(require("lodash/flow"));

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _toLower2 = _interopRequireDefault(require("lodash/toLower"));

var _compact2 = _interopRequireDefault(require("lodash/compact"));

var _operators = require("rxjs/operators");

var _searchUtils = require("../../util/searchUtils");

var _tokenize = require("../common/tokenize");

var _draftUtils = require("../../util/draftUtils");

var _applyWeights = require("./applyWeights");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const combinePaths = (0, _flow2.default)([_flatten2.default, _union2.default, _compact2.default]);

const toGroqParams = terms => {
  const params = {};
  return terms.reduce((acc, term, i) => {
    acc["t".concat(i)] = "".concat(term, "*"); // "t" is short for term

    return acc;
  }, params);
};

const pathWithMapper = _ref => {
  let {
    mapWith,
    path
  } = _ref;
  return mapWith ? "".concat(mapWith, "(").concat(path, ")") : path;
};

function createWeightedSearch( // eslint-disable-next-line camelcase
types, client) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!types) {
    throw new Error('missing types');
  }

  const {
    filter,
    params,
    tag
  } = options;
  const searchSpec = types.map(type => {
    var _type$__experimental_;

    return {
      typeName: type.name,
      paths: (_type$__experimental_ = type.__experimental_search) === null || _type$__experimental_ === void 0 ? void 0 : _type$__experimental_.map(config => ({
        weight: config.weight,
        path: (0, _searchUtils.joinPath)(config.path),
        mapWith: config.mapWith
      }))
    };
  });
  const combinedSearchPaths = combinePaths(searchSpec.map(configForType => {
    var _configForType$paths;

    return (_configForType$paths = configForType.paths) === null || _configForType$paths === void 0 ? void 0 : _configForType$paths.map(opt => pathWithMapper(opt));
  }));
  const selections = searchSpec.map(spec => {
    var _spec$paths;

    const constraint = "_type == \"".concat(spec.typeName, "\" => ");
    const selection = "{ ".concat((_spec$paths = spec.paths) === null || _spec$paths === void 0 ? void 0 : _spec$paths.map((cfg, i) => "\"w".concat(i, "\": ").concat(pathWithMapper(cfg))), " }");
    return "".concat(constraint).concat(selection);
  }); // this is the actual search function that takes the search string and returns the hits

  return function search(queryString) {
    var _searchOpts$limit;

    let searchOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const terms = (0, _uniq2.default)((0, _compact2.default)((0, _tokenize.tokenize)((0, _toLower2.default)(queryString))));
    const constraints = terms.map((term, i) => combinedSearchPaths.map(joinedPath => "".concat(joinedPath, " match $t").concat(i))).filter(constraint => constraint.length > 0);
    const filters = ['_type in $__types', searchOpts.includeDrafts === false && "!(_id in path('drafts.**'))", ...constraints.map(constraint => "(".concat(constraint.join('||'), ")")), filter ? "(".concat(filter, ")") : ''].filter(Boolean);
    const selection = selections.length > 0 ? "...select(".concat(selections.join(',\n'), ")") : '';
    const query = "*[".concat(filters.join('&&'), "][0...$__limit]{_type, _id, ").concat(selection, "}");
    return client.observable.fetch(query, { ...toGroqParams(terms),
      __types: searchSpec.map(spec => spec.typeName),
      __limit: (_searchOpts$limit = searchOpts.limit) !== null && _searchOpts$limit !== void 0 ? _searchOpts$limit : 1000,
      ...(params || {})
    }, {
      tag
    }).pipe(options.unique ? (0, _operators.map)(_draftUtils.removeDupes) : (0, _operators.tap)(), (0, _operators.map)(hits => (0, _applyWeights.applyWeights)(searchSpec, hits, terms)), (0, _operators.map)(hits => (0, _sortBy2.default)(hits, hit => -hit.score)));
  };
}