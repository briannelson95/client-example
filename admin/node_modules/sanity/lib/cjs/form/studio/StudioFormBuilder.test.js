"use strict";

var _types = require("@sanity/types");

var _react = require("@testing-library/react");

var _react2 = _interopRequireWildcard(require("react"));

var _mockSanityClient = require("../../../test/mocks/mockSanityClient");

var _TestProvider = require("../../../test/testUtils/TestProvider");

var _patch = require("../patch");

var _useFormState = require("../store/useFormState");

var _empty = require("../utils/empty");

var _studio = require("../../studio");

var _StudioFormBuilder = require("./StudioFormBuilder");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable camelcase */
const schemaTypes = [(0, _types.defineType)({
  type: 'document',
  name: 'test',
  title: 'Test',
  fields: [{
    type: 'string',
    name: 'title',
    title: 'Title'
  }]
})];
describe('StudioFormBuilder', () => {
  it('should render a studio form', async () => {
    const client = (0, _mockSanityClient.createMockSanityClient)();
    const TestProvider = await (0, _TestProvider.createTestProvider)({
      client,
      config: {
        name: 'default',
        projectId: 'test',
        dataset: 'test',
        schema: {
          types: schemaTypes
        }
      }
    });
    const focusPath = [];
    const openPath = [];
    const value = {
      _id: 'test',
      _type: 'test'
    };
    const onChange = jest.fn();
    const onFieldGroupSelect = jest.fn();
    const onPathBlur = jest.fn();
    const onPathFocus = jest.fn();
    const onPathOpen = jest.fn();
    const onSelectFieldGroup = jest.fn();
    const onSetFieldSetCollapsed = jest.fn();
    const onSetPathCollapsed = jest.fn();

    function TestForm() {
      const {
        schema
      } = (0, _studio.useWorkspace)();
      const schemaType = schema.get('test');

      if (!schemaType) {
        throw new Error('missing schema type');
      }

      if (schemaType.jsonType !== 'object') {
        throw new Error('schema type is not an object');
      }

      const patchChannel = (0, _react2.useMemo)(() => (0, _patch.createPatchChannel)(), []);
      const formState = (0, _useFormState.useFormState)(schemaType, {
        value,
        comparisonValue: value,
        focusPath,
        collapsedPaths: undefined,
        collapsedFieldSets: undefined,
        fieldGroupState: undefined,
        openPath,
        presence: [],
        validation: []
      });
      const formBuilderProps = (0, _react2.useMemo)(() => ({
        __internal_patchChannel: patchChannel,
        changesOpen: false,
        changed: false,
        collapsedFieldSets: undefined,
        collapsedPaths: undefined,
        focused: formState === null || formState === void 0 ? void 0 : formState.focused,
        focusPath: (formState === null || formState === void 0 ? void 0 : formState.focusPath) || _empty.EMPTY_ARRAY,
        groups: (formState === null || formState === void 0 ? void 0 : formState.groups) || _empty.EMPTY_ARRAY,
        id: (formState === null || formState === void 0 ? void 0 : formState.id) || '',
        level: (formState === null || formState === void 0 ? void 0 : formState.level) || 0,
        members: (formState === null || formState === void 0 ? void 0 : formState.members) || _empty.EMPTY_ARRAY,
        onChange,
        onFieldGroupSelect,
        onPathBlur,
        onPathFocus,
        onPathOpen,
        onSelectFieldGroup,
        onSetFieldSetCollapsed,
        onSetPathCollapsed,
        path: _empty.EMPTY_ARRAY,
        presence: _empty.EMPTY_ARRAY,
        schemaType: (formState === null || formState === void 0 ? void 0 : formState.schemaType) || schemaType,
        validation: _empty.EMPTY_ARRAY,
        value: formState === null || formState === void 0 ? void 0 : formState.value
      }), [formState, patchChannel, schemaType]);
      return /*#__PURE__*/_react2.default.createElement(_StudioFormBuilder.StudioFormBuilder, formBuilderProps);
    }

    const result = (0, _react.render)( /*#__PURE__*/_react2.default.createElement(TestProvider, null, /*#__PURE__*/_react2.default.createElement(TestForm, null)));
    const titleField = await result.findByTestId('field-title');
    expect(removeClasses(titleField.outerHTML)).toMatchSnapshot();
  });
});

function removeClasses(html) {
  return html.replace(/\s+class=".*?"/g, '');
}