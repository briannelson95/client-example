"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGetReferenceInfo = createGetReferenceInfo;

var _keyBy2 = _interopRequireDefault(require("lodash/keyBy"));

var _operators = require("rxjs/operators");

var _rxjs = require("rxjs");

var _preview = require("../../../../../preview");

var _util = require("../../../../../util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const REQUEST_TAG_BASE = 'cross-dataset-refs';
const AVAILABILITY_READABLE = {
  available: true,
  reason: 'READABLE'
};
const AVAILABILITY_PERMISSION_DENIED = {
  available: false,
  reason: 'PERMISSION_DENIED'
};
const AVAILABILITY_NOT_FOUND = {
  available: false,
  reason: 'NOT_FOUND'
};
/**
 * Takes a client instance and returns a function that can be called to retrieve reference information
 */

function createGetReferenceInfo(context) {
  const {
    client,
    documentPreviewStore
  } = context;
  const {
    dataset,
    projectId
  } = client.config();
  const apiConfig = dataset && projectId ? {
    dataset,
    projectId
  } : undefined;
  /**
   * Takes an id and a reference schema type, returns metadata about it
   * Assumption: _id is always published id
   */

  return function getReferenceInfo(doc, // pass {_id, _type} instead and we can skip the `fetchType`
  referenceType) {
    return (doc._type ? (0, _rxjs.of)(doc) : documentPreviewStore.observeDocumentTypeFromId(doc._id, apiConfig).pipe((0, _operators.map)(docType => ({
      _id: doc._id,
      _type: docType
    })))).pipe((0, _operators.switchMap)(resolvedDoc => {
      if (!resolvedDoc._type) {
        // we still can't read the type of the referenced document. This may be due to either 1) lack of access 2) lack of existence
        // we want to display a reason to the end user, so we're fetching metadata about it
        return fetchDocumentAvailability(client, doc._id).pipe((0, _operators.map)(availability => ({
          id: doc._id,
          type: undefined,
          availability,
          preview: {
            published: undefined
          }
        })));
      }

      const refSchemaType = referenceType.to.find(candidate => candidate.type === resolvedDoc._type);
      const previewPaths = [...((0, _preview.getPreviewPaths)(refSchemaType === null || refSchemaType === void 0 ? void 0 : refSchemaType.preview) || []), ['_updatedAt'], ['_createdAt']];
      const publishedPreview$ = documentPreviewStore.observePaths(doc, previewPaths, apiConfig).pipe((0, _operators.map)(result => result ? (0, _preview.prepareForPreview)(result, refSchemaType) : result));
      return (0, _rxjs.combineLatest)([publishedPreview$]).pipe((0, _operators.map)(_ref => {
        let [publishedPreview] = _ref;
        return {
          type: resolvedDoc._type,
          id: doc._id,
          availability: AVAILABILITY_READABLE,
          preview: {
            published: (0, _util.isRecord)(publishedPreview) ? publishedPreview : undefined
          }
        };
      }));
    }));
  };
}

function fetchDocumentAvailability(client, id) {
  const requestOptions = {
    uri: client.getDataUrl('doc', id),
    json: true,
    query: {
      excludeContent: 'true'
    },
    tag: "".concat(REQUEST_TAG_BASE, ".availability")
  };
  return client.observable.request(requestOptions).pipe((0, _operators.map)(response => {
    const omitted = (0, _keyBy2.default)(response.omitted || [], entry => entry.id);
    const omittedEntry = omitted[id];

    if (!omittedEntry) {
      // it's not omitted, so it exists and is readable
      return AVAILABILITY_READABLE;
    } // omitted because it doesn't exist


    if (omittedEntry.reason === 'existence') {
      return AVAILABILITY_NOT_FOUND;
    }

    if (omittedEntry.reason === 'permission') {
      // omitted because it's not readable
      return AVAILABILITY_PERMISSION_DENIED;
    }

    return null;
  }));
}