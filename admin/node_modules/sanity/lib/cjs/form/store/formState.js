"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepareFormState = prepareFormState;

var _isEqual3 = _interopRequireDefault(require("lodash/isEqual"));

var _pick2 = _interopRequireDefault(require("lodash/pick"));

var _castArray2 = _interopRequireDefault(require("lodash/castArray"));

var _types = require("@sanity/types");

var _paths = require("@sanity/util/paths");

var _content = require("@sanity/util/content");

var _util = require("../../util");

var _conditionalProperty = require("./conditional-property");

var _constants = require("./constants");

var _getItemType = require("./utils/getItemType");

var _getCollapsibleOptions = require("./utils/getCollapsibleOptions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable max-statements */

/* eslint-disable camelcase, no-else-return */
const ALL_FIELDS_GROUP = {
  name: 'all-fields',
  title: 'All fields',
  hidden: false
};

function isFieldEnabledByGroupFilter( // the groups config for the "enclosing object" type
groupsConfig, field, currentGroup) {
  if (currentGroup.name === ALL_FIELDS_GROUP.name) {
    return true;
  } // if there's no group config for the object type, all fields are visible


  if (groupsConfig.length === 0) {
    return true;
  }

  return (0, _castArray2.default)(field.group).includes(currentGroup.name);
}

function isAcceptedObjectValue(value) {
  return typeof value === 'undefined' || (0, _util.isRecord)(value);
}

function isValidArrayOfObjectsValue(value) {
  return typeof value === 'undefined' || Array.isArray(value);
}

function isValidArrayOfPrimitivesValue(value) {
  return typeof value === 'undefined' || Array.isArray(value);
}

function everyItemIsObject(value) {
  return value.length === 0 || value.every(item => (0, _util.isRecord)(item));
}

function findDuplicateKeyEntries(array) {
  const seenKeys = new Set();
  return array.reduce((acc, item, index) => {
    if (seenKeys.has(item._key)) {
      acc.push([index, item._key]);
    }

    seenKeys.add(item._key);
    return acc;
  }, []);
}

function hasKey(value) {
  return '_key' in value;
}

function everyItemHasKey(array) {
  return array === null || array === void 0 ? void 0 : array.every(item => (0, _util.isRecord)(item) && hasKey(item));
}

function isChangedValue(value, comparisonValue) {
  if (value && !comparisonValue) {
    return true;
  }

  return !(0, _isEqual3.default)(value, comparisonValue);
}
/*
 * Takes a field in context of a parent object and returns prepared props for it
 */


function prepareFieldMember(props) {
  const {
    parent,
    field,
    index
  } = props;
  const fieldPath = (0, _paths.pathFor)([...parent.path, field.name]);
  const fieldLevel = parent.level + 1;
  const parentValue = parent.value;
  const parentComparisonValue = parent.comparisonValue;

  if (!isAcceptedObjectValue(parentValue)) {
    // Note: we validate each field, before passing it recursively to this function so getting this error means that the
    // ´prepareFormState´ function itself has been called with a non-object value
    throw new Error('Unexpected non-object value');
  }

  if ((0, _types.isObjectSchemaType)(field.type)) {
    var _parent$fieldGroupSta, _parent$fieldGroupSta2, _parent$collapsedPath, _parent$collapsedPath2, _parent$collapsedFiel, _parent$collapsedFiel2;

    const fieldValue = parentValue === null || parentValue === void 0 ? void 0 : parentValue[field.name];
    const fieldComparisonValue = (0, _util.isRecord)(parentComparisonValue) ? parentComparisonValue === null || parentComparisonValue === void 0 ? void 0 : parentComparisonValue[field.name] : undefined;

    if (!isAcceptedObjectValue(fieldValue)) {
      return {
        kind: 'error',
        key: field.name,
        fieldName: field.name,
        error: {
          type: 'INCOMPATIBLE_TYPE',
          expectedSchemaType: field.type,
          resolvedValueType: (0, _content.resolveTypeName)(fieldValue),
          value: fieldValue
        }
      };
    } // todo: consider requiring a _type annotation for object values on fields as well
    // if (resolvedValueType !== field.type.name) {
    //   return {
    //     kind: 'error',
    //     key: field.name,
    //     error: {
    //       type: 'TYPE_ANNOTATION_MISMATCH',
    //       expectedSchemaType: field.type,
    //       resolvedValueType,
    //     },
    //   }
    // }


    const fieldGroupState = (_parent$fieldGroupSta = parent.fieldGroupState) === null || _parent$fieldGroupSta === void 0 ? void 0 : (_parent$fieldGroupSta2 = _parent$fieldGroupSta.children) === null || _parent$fieldGroupSta2 === void 0 ? void 0 : _parent$fieldGroupSta2[field.name];
    const scopedCollapsedPaths = (_parent$collapsedPath = parent.collapsedPaths) === null || _parent$collapsedPath === void 0 ? void 0 : (_parent$collapsedPath2 = _parent$collapsedPath.children) === null || _parent$collapsedPath2 === void 0 ? void 0 : _parent$collapsedPath2[field.name];
    const scopedCollapsedFieldsets = (_parent$collapsedFiel = parent.collapsedFieldSets) === null || _parent$collapsedFiel === void 0 ? void 0 : (_parent$collapsedFiel2 = _parent$collapsedFiel.children) === null || _parent$collapsedFiel2 === void 0 ? void 0 : _parent$collapsedFiel2[field.name];
    const inputState = prepareObjectInputState({
      schemaType: field.type,
      currentUser: parent.currentUser,
      parent: parent.value,
      document: parent.document,
      value: fieldValue,
      changed: isChangedValue(fieldValue, fieldComparisonValue),
      comparisonValue: fieldComparisonValue,
      presence: parent.presence,
      validation: parent.validation,
      fieldGroupState,
      path: fieldPath,
      level: fieldLevel,
      focusPath: parent.focusPath,
      openPath: parent.openPath,
      collapsedPaths: scopedCollapsedPaths,
      collapsedFieldSets: scopedCollapsedFieldsets,
      readOnly: parent.readOnly
    });

    if (inputState === null) {
      return null;
    }

    const defaultCollapsedState = (0, _getCollapsibleOptions.getCollapsedWithDefaults)(field.type.options, fieldLevel);
    const collapsed = scopedCollapsedPaths ? scopedCollapsedPaths.value : defaultCollapsedState.collapsed;
    return {
      kind: 'field',
      key: "field-".concat(field.name),
      name: field.name,
      index: index,
      open: (0, _paths.startsWith)(fieldPath, parent.openPath),
      field: inputState,
      collapsed,
      collapsible: defaultCollapsedState.collapsible
    };
  } else if ((0, _types.isArraySchemaType)(field.type)) {
    const fieldValue = parentValue === null || parentValue === void 0 ? void 0 : parentValue[field.name];
    const fieldComparisonValue = (0, _util.isRecord)(parentComparisonValue) ? parentComparisonValue === null || parentComparisonValue === void 0 ? void 0 : parentComparisonValue[field.name] : undefined;

    if ((0, _types.isArrayOfObjectsSchemaType)(field.type)) {
      var _parent$fieldGroupSta3, _parent$fieldGroupSta4, _parent$collapsedPath3, _parent$collapsedPath4, _parent$collapsedFiel3, _parent$collapsedFiel4;

      const hasValue = typeof fieldValue !== 'undefined';

      if (hasValue && !isValidArrayOfObjectsValue(fieldValue)) {
        const resolvedValueType = (0, _content.resolveTypeName)(fieldValue);
        return {
          kind: 'error',
          key: field.name,
          fieldName: field.name,
          error: {
            type: 'INCOMPATIBLE_TYPE',
            expectedSchemaType: field.type,
            resolvedValueType,
            value: fieldValue
          }
        };
      }

      if (hasValue && !everyItemIsObject(fieldValue)) {
        return {
          kind: 'error',
          key: field.name,
          fieldName: field.name,
          error: {
            type: 'MIXED_ARRAY',
            schemaType: field.type
          }
        };
      }

      if (hasValue && !everyItemHasKey(fieldValue)) {
        return {
          kind: 'error',
          key: field.name,
          fieldName: field.name,
          error: {
            type: 'MISSING_KEYS',
            value: fieldValue,
            schemaType: field.type
          }
        };
      }

      const duplicateKeyEntries = hasValue ? findDuplicateKeyEntries(fieldValue) : [];

      if (duplicateKeyEntries.length > 0) {
        return {
          kind: 'error',
          key: field.name,
          fieldName: field.name,
          error: {
            type: 'DUPLICATE_KEYS',
            duplicates: duplicateKeyEntries,
            schemaType: field.type
          }
        };
      }

      const fieldGroupState = (_parent$fieldGroupSta3 = parent.fieldGroupState) === null || _parent$fieldGroupSta3 === void 0 ? void 0 : (_parent$fieldGroupSta4 = _parent$fieldGroupSta3.children) === null || _parent$fieldGroupSta4 === void 0 ? void 0 : _parent$fieldGroupSta4[field.name];
      const scopedCollapsedPaths = (_parent$collapsedPath3 = parent.collapsedPaths) === null || _parent$collapsedPath3 === void 0 ? void 0 : (_parent$collapsedPath4 = _parent$collapsedPath3.children) === null || _parent$collapsedPath4 === void 0 ? void 0 : _parent$collapsedPath4[field.name];
      const scopedCollapsedFieldSets = (_parent$collapsedFiel3 = parent.collapsedFieldSets) === null || _parent$collapsedFiel3 === void 0 ? void 0 : (_parent$collapsedFiel4 = _parent$collapsedFiel3.children) === null || _parent$collapsedFiel4 === void 0 ? void 0 : _parent$collapsedFiel4[field.name];
      const readOnly = parent.readOnly || (0, _conditionalProperty.resolveConditionalProperty)(field.type.readOnly, {
        value: fieldValue,
        parent: parent.value,
        document: parent.document,
        currentUser: parent.currentUser
      });
      const fieldState = prepareArrayOfObjectsInputState({
        schemaType: field.type,
        parent: parent.value,
        currentUser: parent.currentUser,
        document: parent.document,
        value: fieldValue,
        changed: isChangedValue(fieldValue, fieldComparisonValue),
        comparisonValue: fieldComparisonValue,
        fieldGroupState,
        focusPath: parent.focusPath,
        openPath: parent.openPath,
        presence: parent.presence,
        validation: parent.validation,
        collapsedPaths: scopedCollapsedPaths,
        collapsedFieldSets: scopedCollapsedFieldSets,
        level: fieldLevel,
        path: fieldPath,
        readOnly
      });

      if (fieldState === null) {
        return null;
      }

      return {
        kind: 'field',
        key: "field-".concat(field.name),
        name: field.name,
        index: index,
        open: (0, _paths.startsWith)(fieldPath, parent.openPath),
        collapsible: false,
        collapsed: false,
        // note: this is what we actually end up passing down as to the next input component
        field: fieldState
      };
    } else {
      var _parent$fieldGroupSta5, _parent$fieldGroupSta6, _parent$collapsedPath5, _parent$collapsedPath6, _parent$collapsedFiel5, _parent$collapsedFiel6;

      // array of primitives
      if (!isValidArrayOfPrimitivesValue(fieldValue)) {
        const resolvedValueType = (0, _content.resolveTypeName)(fieldValue);
        return {
          kind: 'error',
          key: field.name,
          fieldName: field.name,
          error: {
            type: 'INCOMPATIBLE_TYPE',
            expectedSchemaType: field.type,
            resolvedValueType,
            value: fieldValue
          }
        };
      }

      const fieldGroupState = (_parent$fieldGroupSta5 = parent.fieldGroupState) === null || _parent$fieldGroupSta5 === void 0 ? void 0 : (_parent$fieldGroupSta6 = _parent$fieldGroupSta5.children) === null || _parent$fieldGroupSta6 === void 0 ? void 0 : _parent$fieldGroupSta6[field.name];
      const scopedCollapsedPaths = (_parent$collapsedPath5 = parent.collapsedPaths) === null || _parent$collapsedPath5 === void 0 ? void 0 : (_parent$collapsedPath6 = _parent$collapsedPath5.children) === null || _parent$collapsedPath6 === void 0 ? void 0 : _parent$collapsedPath6[field.name];
      const scopedCollapsedFieldSets = (_parent$collapsedFiel5 = parent.collapsedFieldSets) === null || _parent$collapsedFiel5 === void 0 ? void 0 : (_parent$collapsedFiel6 = _parent$collapsedFiel5.children) === null || _parent$collapsedFiel6 === void 0 ? void 0 : _parent$collapsedFiel6[field.name];
      const readOnly = parent.readOnly || (0, _conditionalProperty.resolveConditionalProperty)(field.type.readOnly, {
        value: fieldValue,
        parent: parent.value,
        document: parent.document,
        currentUser: parent.currentUser
      });
      const fieldState = prepareArrayOfPrimitivesInputState({
        changed: isChangedValue(fieldValue, fieldComparisonValue),
        comparisonValue: fieldComparisonValue,
        schemaType: field.type,
        parent: parent.value,
        currentUser: parent.currentUser,
        document: parent.document,
        value: fieldValue,
        fieldGroupState,
        focusPath: parent.focusPath,
        openPath: parent.openPath,
        presence: parent.presence,
        validation: parent.validation,
        collapsedPaths: scopedCollapsedPaths,
        collapsedFieldSets: scopedCollapsedFieldSets,
        level: fieldLevel,
        path: fieldPath,
        readOnly
      });

      if (fieldState === null) {
        return null;
      }

      return {
        kind: 'field',
        key: "field-".concat(field.name),
        name: field.name,
        index: index,
        open: (0, _paths.startsWith)(fieldPath, parent.openPath),
        // todo: consider support for collapsible arrays
        collapsible: false,
        collapsed: false,
        // note: this is what we actually end up passing down as to the next input component
        field: fieldState
      };
    }
  } else {
    // primitive fields
    const fieldValue = parentValue === null || parentValue === void 0 ? void 0 : parentValue[field.name];
    const fieldComparisonValue = (0, _util.isRecord)(parentComparisonValue) ? parentComparisonValue === null || parentComparisonValue === void 0 ? void 0 : parentComparisonValue[field.name] : undefined;
    const conditionalPropertyContext = {
      value: fieldValue,
      parent: parent.value,
      document: parent.document,
      currentUser: parent.currentUser
    }; // note: we *only* want to call the conditional props here, as it's handled by the prepare<Object|Array>InputProps otherwise

    const hidden = (0, _conditionalProperty.resolveConditionalProperty)(field.type.hidden, conditionalPropertyContext);

    if (hidden) {
      return null;
    }

    const readOnly = parent.readOnly || (0, _conditionalProperty.resolveConditionalProperty)(field.type.readOnly, conditionalPropertyContext);
    const fieldState = preparePrimitiveInputState({ ...parent,
      comparisonValue: fieldComparisonValue,
      value: fieldValue,
      schemaType: field.type,
      path: fieldPath,
      readOnly
    });
    return {
      kind: 'field',
      key: "field-".concat(field.name),
      name: field.name,
      index: index,
      open: (0, _paths.startsWith)(fieldPath, parent.openPath),
      // todo: consider support for collapsible primitive fields
      collapsible: false,
      collapsed: false,
      field: fieldState
    };
  }
}

function prepareObjectInputState(props) {
  var _ref;

  let enableHiddenCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (props.level === _constants.MAX_FIELD_DEPTH) {
    return null;
  }

  const conditionalPropertyContext = {
    value: props.value,
    parent: props.parent,
    document: props.document,
    currentUser: props.currentUser
  };
  const hidden = enableHiddenCheck && (0, _conditionalProperty.resolveConditionalProperty)(props.schemaType.hidden, conditionalPropertyContext);

  if (hidden) {
    return null;
  }

  const readOnly = props.readOnly || (0, _conditionalProperty.resolveConditionalProperty)(props.schemaType.readOnly, conditionalPropertyContext);
  const schemaTypeGroupConfig = props.schemaType.groups || [];
  const defaultGroupName = (_ref = schemaTypeGroupConfig.find(g => g.default) || ALL_FIELDS_GROUP) === null || _ref === void 0 ? void 0 : _ref.name;
  const groups = [ALL_FIELDS_GROUP, ...schemaTypeGroupConfig].flatMap(group => {
    var _props$fieldGroupStat;

    const groupHidden = (0, _conditionalProperty.resolveConditionalProperty)(group.hidden, conditionalPropertyContext);
    const selected = group.name === (((_props$fieldGroupStat = props.fieldGroupState) === null || _props$fieldGroupStat === void 0 ? void 0 : _props$fieldGroupStat.value) || defaultGroupName);
    return groupHidden ? [] : [{
      icon: group === null || group === void 0 ? void 0 : group.icon,
      name: group.name,
      selected,
      title: group.title
    }];
  });
  const selectedGroup = groups.find(group => group.selected);
  const parentProps = { ...props,
    hidden,
    readOnly
  }; // note: this is needed because not all object types gets a ´fieldsets´ property during schema parsing.
  // ideally members should be normalized as part of the schema parsing and not here

  const normalizedSchemaMembers = props.schemaType.fieldsets ? props.schemaType.fieldsets : props.schemaType.fields.map(field => ({
    single: true,
    field
  })); // create a members array for the object

  const members = normalizedSchemaMembers.flatMap((fieldSet, index) => {
    var _fieldSet$name$value, _fieldSet$name, _props$collapsedField, _fieldSet$options;

    if (fieldSet.single) {
      // "single" means not part of a fieldset
      const fieldMember = prepareFieldMember({
        field: fieldSet.field,
        parent: parentProps,
        index
      });

      if (fieldMember === null || !isFieldEnabledByGroupFilter(groups, fieldSet.field, selectedGroup)) {
        return [];
      }

      return [fieldMember];
    } // it's an actual fieldset


    const fieldsetFieldNames = fieldSet.fields.map(f => f.name);
    const fieldsetHidden = (0, _conditionalProperty.resolveConditionalProperty)(fieldSet.hidden, {
      currentUser: props.currentUser,
      document: props.document,
      parent: props.value,
      value: (0, _pick2.default)(props.value, fieldsetFieldNames)
    });

    if (fieldsetHidden) {
      return [];
    }

    const fieldsetMembers = fieldSet.fields.flatMap(field => {
      const fieldState = prepareFieldMember({
        field,
        parent: parentProps,
        index // the explicit type cast here is ok - we know that a fieldset can not have fieldsets

      });

      if (fieldState === null || !isFieldEnabledByGroupFilter(groups, field, selectedGroup)) {
        return [];
      }

      return [fieldState];
    }); // if all members of the fieldset is hidden, the fieldset should effectively also be hidden

    if (fieldsetMembers.length === 0) {
      return [];
    }

    const defaultCollapsedState = (0, _getCollapsibleOptions.getCollapsedWithDefaults)(fieldSet.options, props.level);
    const collapsed = (_fieldSet$name$value = (_fieldSet$name = (((_props$collapsedField = props.collapsedFieldSets) === null || _props$collapsedField === void 0 ? void 0 : _props$collapsedField.children) || {})[fieldSet.name]) === null || _fieldSet$name === void 0 ? void 0 : _fieldSet$name.value) !== null && _fieldSet$name$value !== void 0 ? _fieldSet$name$value : defaultCollapsedState.collapsed;
    return [{
      kind: 'fieldSet',
      key: "fieldset-".concat(fieldSet.name),
      fieldSet: {
        path: (0, _paths.pathFor)(props.path.concat(fieldSet.name)),
        name: fieldSet.name,
        title: fieldSet.title,
        description: fieldSet.description,
        hidden: false,
        level: props.level + 1,
        members: fieldsetMembers,
        collapsible: defaultCollapsedState === null || defaultCollapsedState === void 0 ? void 0 : defaultCollapsedState.collapsible,
        collapsed,
        columns: fieldSet === null || fieldSet === void 0 ? void 0 : (_fieldSet$options = fieldSet.options) === null || _fieldSet$options === void 0 ? void 0 : _fieldSet$options.columns
      }
    }];
  });
  const hasFieldGroups = schemaTypeGroupConfig.length > 0;
  const presence = props.presence.filter(item => (0, _paths.isEqual)(item.path, props.path));
  const validation = props.validation.filter(item => (0, _paths.isEqual)(item.path, props.path)).map(v => ({
    level: v.level,
    message: v.item.message,
    path: v.path
  }));

  if (members.length === 0) {
    return null;
  }

  return {
    value: props.value,
    changed: isChangedValue(props.value, props.comparisonValue),
    schemaType: props.schemaType,
    readOnly: props.readOnly || readOnly,
    path: props.path,
    id: (0, _paths.toString)(props.path),
    level: props.level,
    focused: (0, _paths.isEqual)(props.path, props.focusPath),
    focusPath: (0, _paths.trimChildPath)(props.path, props.focusPath),
    presence,
    validation,
    members,
    groups: hasFieldGroups ? groups : []
  };
}

function prepareArrayOfPrimitivesInputState(props) {
  if (props.level === _constants.MAX_FIELD_DEPTH) {
    return null;
  }

  const conditionalPropertyContext = {
    comparisonValue: props.comparisonValue,
    value: props.value,
    parent: props.parent,
    document: props.document,
    currentUser: props.currentUser
  };
  const hidden = (0, _conditionalProperty.resolveConditionalProperty)(props.schemaType.hidden, conditionalPropertyContext);

  if (hidden) {
    return null;
  }

  const readOnly = props.readOnly || (0, _conditionalProperty.resolveConditionalProperty)(props.schemaType.readOnly, conditionalPropertyContext); // Todo: improve error handling at the parent level so that the value here is either undefined or an array

  const items = Array.isArray(props.value) ? props.value : [];
  const presence = props.presence.filter(item => (0, _paths.isEqual)(item.path, props.path));
  const validation = props.validation.filter(item => (0, _paths.isEqual)(item.path, props.path)).map(v => ({
    level: v.level,
    message: v.item.message,
    path: v.path
  }));
  const members = items.flatMap((item, index) => prepareArrayOfPrimitivesMember({
    arrayItem: item,
    parent: props,
    index
  }));
  return {
    changed: members.some(m => m.kind === 'item' && m.item.changed),
    // TODO: is this correct? There could be field and fieldsets here?
    value: props.value,
    readOnly,
    schemaType: props.schemaType,
    focused: (0, _paths.isEqual)(props.path, props.focusPath),
    focusPath: (0, _paths.trimChildPath)(props.path, props.focusPath),
    path: props.path,
    id: (0, _paths.toString)(props.path),
    level: props.level,
    validation,
    presence,
    members
  };
}

function prepareArrayOfObjectsInputState(props) {
  if (props.level === _constants.MAX_FIELD_DEPTH) {
    return null;
  }

  const conditionalPropertyContext = {
    value: props.value,
    parent: props.parent,
    document: props.document,
    currentUser: props.currentUser
  };
  const hidden = (0, _conditionalProperty.resolveConditionalProperty)(props.schemaType.hidden, conditionalPropertyContext);

  if (hidden) {
    return null;
  }

  const readOnly = props.readOnly || (0, _conditionalProperty.resolveConditionalProperty)(props.schemaType.readOnly, conditionalPropertyContext); // Todo: improve error handling at the parent level so that the value here is either undefined or an array

  const items = Array.isArray(props.value) ? props.value : [];
  const presence = props.presence.filter(item => (0, _paths.isEqual)(item.path, props.path));
  const validation = props.validation.filter(item => (0, _paths.isEqual)(item.path, props.path)).map(v => ({
    level: v.level,
    message: v.item.message,
    path: v.path
  }));
  const members = items.flatMap((item, index) => prepareArrayOfObjectsMember({
    arrayItem: item,
    parent: props,
    index
  }));
  return {
    changed: members.some(m => m.kind === 'item' && m.item.changed),
    value: props.value,
    readOnly,
    schemaType: props.schemaType,
    focused: (0, _paths.isEqual)(props.path, props.focusPath),
    focusPath: (0, _paths.trimChildPath)(props.path, props.focusPath),
    path: props.path,
    id: (0, _paths.toString)(props.path),
    level: props.level,
    validation,
    presence,
    members
  };
}
/*
 * Takes a field in context of a parent object and returns prepared props for it
 */


function prepareArrayOfObjectsMember(props) {
  var _parent$collapsedPath7, _parent$collapsedPath8, _collapsedItemPaths$v;

  const {
    arrayItem,
    parent,
    index
  } = props;
  const itemType = (0, _getItemType.getItemType)(parent.schemaType, arrayItem);
  const key = arrayItem._key;

  if (!itemType) {
    const itemTypeName = (0, _content.resolveTypeName)(arrayItem);
    return {
      kind: 'error',
      key,
      index,
      error: {
        type: 'INVALID_ITEM_TYPE',
        resolvedValueType: itemTypeName,
        value: arrayItem,
        validTypes: parent.schemaType.of
      }
    };
  }

  const itemPath = (0, _paths.pathFor)([...parent.path, {
    _key: key
  }]);
  const itemLevel = parent.level + 1;
  const conditionalPropertyContext = {
    value: parent.value,
    parent: props.parent,
    document: parent.document,
    currentUser: parent.currentUser
  };
  const readOnly = parent.readOnly || (0, _conditionalProperty.resolveConditionalProperty)(parent.schemaType.readOnly, conditionalPropertyContext);
  const collapsedItemPaths = (_parent$collapsedPath7 = parent.collapsedPaths) === null || _parent$collapsedPath7 === void 0 ? void 0 : (_parent$collapsedPath8 = _parent$collapsedPath7.children) === null || _parent$collapsedPath8 === void 0 ? void 0 : _parent$collapsedPath8[key];
  const comparisonValue = Array.isArray(parent.comparisonValue) && parent.comparisonValue.find(i => i._key === arrayItem._key) || undefined;
  const itemState = prepareObjectInputState({
    schemaType: itemType,
    level: itemLevel,
    document: parent.document,
    value: arrayItem,
    comparisonValue,
    changed: isChangedValue(arrayItem, comparisonValue),
    path: itemPath,
    focusPath: parent.focusPath,
    openPath: parent.openPath,
    currentUser: parent.currentUser,
    collapsedPaths: collapsedItemPaths,
    presence: parent.presence,
    validation: parent.validation,
    readOnly
  }, false);
  const defaultCollapsedState = (0, _getCollapsibleOptions.getCollapsedWithDefaults)(itemType.options, itemLevel);
  const collapsed = (_collapsedItemPaths$v = collapsedItemPaths === null || collapsedItemPaths === void 0 ? void 0 : collapsedItemPaths.value) !== null && _collapsedItemPaths$v !== void 0 ? _collapsedItemPaths$v : defaultCollapsedState.collapsed;
  return {
    kind: 'item',
    key,
    index,
    open: (0, _paths.startsWith)(itemPath, parent.openPath),
    collapsed: collapsed,
    collapsible: true,
    item: itemState
  };
}
/*
 * Takes a field in context of a parent object and returns prepared props for it
 */


function prepareArrayOfPrimitivesMember(props) {
  var _parent$value, _parent$comparisonVal;

  const {
    arrayItem,
    parent,
    index
  } = props;
  const itemType = (0, _getItemType.getPrimitiveItemType)(parent.schemaType, arrayItem);
  const itemPath = (0, _paths.pathFor)([...parent.path, index]);
  const itemValue = (_parent$value = parent.value) === null || _parent$value === void 0 ? void 0 : _parent$value[index];
  const itemComparisonValue = (_parent$comparisonVal = parent.comparisonValue) === null || _parent$comparisonVal === void 0 ? void 0 : _parent$comparisonVal[index];
  const itemLevel = parent.level + 1; // Best effort attempt to make a stable key for each item in the array
  // Since items may be reordered and change at any time, there's no way to reliably address each item uniquely
  // This is a "best effort"-attempt at making sure we don't re-use internal state for item inputs
  // when items are added to or removed from the array

  const key = "".concat((itemType === null || itemType === void 0 ? void 0 : itemType.name) || 'invalid-type', "-").concat(String(index));

  if (!itemType) {
    return {
      kind: 'error',
      key,
      index,
      error: {
        type: 'INVALID_ITEM_TYPE',
        validTypes: parent.schemaType.of,
        resolvedValueType: (0, _content.resolveTypeName)(itemType),
        value: itemValue
      }
    };
  }

  const readOnly = parent.readOnly || (0, _conditionalProperty.resolveConditionalProperty)(itemType.readOnly, {
    value: itemValue,
    parent: parent.value,
    document: parent.document,
    currentUser: parent.currentUser
  });
  const item = preparePrimitiveInputState({ ...parent,
    path: itemPath,
    schemaType: itemType,
    level: itemLevel,
    value: itemValue,
    comparisonValue: itemComparisonValue,
    readOnly
  });
  return {
    kind: 'item',
    key,
    index,
    open: (0, _paths.isEqual)(itemPath, parent.openPath),
    item
  };
}

function preparePrimitiveInputState(props) {
  const presence = props.presence.filter(item => (0, _paths.isEqual)(item.path, props.path));
  const validation = props.validation.filter(item => (0, _paths.isEqual)(item.path, props.path)).map(v => ({
    level: v.level,
    message: v.item.message,
    path: v.path
  }));
  return {
    schemaType: props.schemaType,
    changed: isChangedValue(props.value, props.comparisonValue),
    value: props.value,
    level: props.level,
    id: (0, _paths.toString)(props.path),
    readOnly: props.readOnly,
    focused: (0, _paths.isEqual)(props.path, props.focusPath),
    path: props.path,
    presence,
    validation
  };
}

function prepareFormState(props) {
  return prepareObjectInputState(props);
}