"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromMutationPatches = fromMutationPatches;
exports.toMutationPatches = toMutationPatches;

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _mutator = require("@sanity/mutator");

var _path = require("./path");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// @todo: complete this typing

/**
 * @internal
 */
function toMutationPatches(patches) {
  return patches.map(toMutationPatch);
}
/**
 * @internal
 */


function fromMutationPatches(origin, patches) {
  return (0, _flatten2.default)(patches.map(patch => toFormBuilderPatches(origin, patch)));
}

const notIn = values => value => !values.includes(value);

function toFormBuilderPatches(origin, patch) {
  return (0, _flatten2.default)(Object.keys(patch).filter(notIn(['id', 'ifRevisionID', 'query'])).map(type => {
    if (type === 'unset') {
      return patch.unset.map(path => {
        return {
          type: 'unset',
          path: (0, _path.decodePath)(path),
          origin
        };
      });
    }

    if (type === 'insert') {
      const position = 'before' in patch.insert ? 'before' : 'after';
      return {
        type: 'insert',
        position: position,
        path: (0, _path.decodePath)(patch.insert[position]),
        items: patch.insert.items,
        origin
      };
    }

    return Object.keys(patch[type]).map(gradientPath => {
      if (type === 'set') {
        return {
          type: 'set',
          path: (0, _path.decodePath)(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }

      if (type === 'inc' || type === 'dec') {
        return {
          type: type,
          path: (0, _path.decodePath)(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }

      if (type === 'setIfMissing') {
        return {
          type: 'setIfMissing',
          path: (0, _path.decodePath)(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }

      if (type === 'diffMatchPatch') {
        return {
          type: 'diffMatchPatch',
          path: (0, _path.decodePath)(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      } // eslint-disable-next-line no-console


      console.warn(new Error("Unsupported patch type: ".concat(type)));
      return null;
    }).filter(Boolean);
  }));
}

function toMutationPatch(patch) {
  const matchPath = (0, _mutator.arrayToJSONMatchPath)(patch.path || []);

  if (patch.type === 'insert') {
    const {
      position,
      items
    } = patch;
    return {
      insert: {
        [position]: matchPath,
        items: items
      }
    };
  }

  if (patch.type === 'unset') {
    return {
      unset: [matchPath]
    };
  }

  if (!patch.type) {
    throw new Error("Missing patch type in patch ".concat(JSON.stringify(patch)));
  }

  if (matchPath) {
    return {
      [patch.type]: {
        [matchPath]: patch.value
      }
    };
  }

  return {
    [patch.type]: patch.value
  };
}