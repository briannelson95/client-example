"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MemberItem = MemberItem;

var React = _interopRequireWildcard(require("react"));

var _FormCallbacks = require("../studio/contexts/FormCallbacks");

var _useDidUpdate = require("../hooks/useDidUpdate");

var _patch = require("../patch");

var _createProtoValue = require("../utils/createProtoValue");

var _ensureKey = require("../utils/ensureKey");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @alpha
 */
function MemberItem(props) {
  const focusRef = (0, React.useRef)();
  const {
    member,
    renderItem,
    renderInput,
    renderField,
    renderPreview
  } = props;
  const {
    onPathBlur,
    onPathFocus,
    onChange,
    onPathOpen,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    onFieldGroupSelect
  } = (0, _FormCallbacks.useFormCallbacks)();
  (0, _useDidUpdate.useDidUpdate)(member.item.focused, (hadFocus, hasFocus) => {
    if (!hadFocus && hasFocus) {
      var _focusRef$current;

      (_focusRef$current = focusRef.current) === null || _focusRef$current === void 0 ? void 0 : _focusRef$current.focus();
    }
  });
  const handleBlur = (0, React.useCallback)(() => {
    onPathBlur(member.item.path);
  }, [member.item.path, onPathBlur]);
  const handleFocus = (0, React.useCallback)(() => {
    onPathFocus(member.item.path);
  }, [member.item.path, onPathFocus]);
  const handleFocusChildPath = (0, React.useCallback)(path => {
    onPathFocus(member.item.path.concat(path));
  }, [member.item.path, onPathFocus]);
  const handleChange = (0, React.useCallback)(event => {
    onChange(_patch.PatchEvent.from(event).prepend((0, _patch.setIfMissing)((0, _createProtoValue.createProtoValue)(member.item.schemaType))).prefixAll({
      _key: member.key
    }));
  }, [onChange, member.item.schemaType, member.key]);
  const handleCollapse = (0, React.useCallback)(() => {
    onSetPathCollapsed(member.item.path, true);
  }, [onSetPathCollapsed, member.item.path]);
  const handleExpand = (0, React.useCallback)(() => {
    onSetPathCollapsed(member.item.path, false);
  }, [onSetPathCollapsed, member.item.path]);
  const handleCollapseField = (0, React.useCallback)(fieldName => {
    onSetPathCollapsed(member.item.path.concat(fieldName), true);
  }, [onSetPathCollapsed, member.item.path]);
  const handleExpandField = (0, React.useCallback)(fieldName => {
    onSetPathCollapsed(member.item.path.concat(fieldName), false);
  }, [onSetPathCollapsed, member.item.path]);
  const handleCloseField = (0, React.useCallback)(() => {
    onPathOpen(member.item.path);
  }, [onPathOpen, member.item.path]);
  const handleOpenField = (0, React.useCallback)(fieldName => {
    onPathOpen(member.item.path.concat(fieldName));
  }, [onPathOpen, member.item.path]);
  const handleExpandFieldSet = (0, React.useCallback)(fieldsetName => {
    onSetFieldSetCollapsed(member.item.path.concat(fieldsetName), false);
  }, [onSetFieldSetCollapsed, member.item.path]);
  const handleCollapseFieldSet = (0, React.useCallback)(fieldsetName => {
    onSetFieldSetCollapsed(member.item.path.concat(fieldsetName), true);
  }, [onSetFieldSetCollapsed, member.item.path]);
  const handleOpen = (0, React.useCallback)(() => {
    onPathOpen(member.item.path);
  }, [onPathOpen, member.item.path]);
  const handleClose = (0, React.useCallback)(() => {
    onPathOpen(member.item.path.slice(0, -1));
  }, [onPathOpen, member.item.path]);
  const handleSelectFieldGroup = (0, React.useCallback)(groupName => {
    onFieldGroupSelect(member.item.path, groupName);
  }, [onFieldGroupSelect, member.item.path]);
  const inputProps = (0, React.useMemo)(() => {
    return {
      changed: member.item.changed,
      focusPath: member.item.focusPath,
      focusRef: focusRef,
      focused: member.item.focused,
      groups: member.item.groups,
      id: member.item.id,
      level: member.item.level,
      members: member.item.members,
      onBlur: handleBlur,
      onChange: handleChange,
      onCloseField: handleCloseField,
      onCollapseField: handleCollapseField,
      onCollapseFieldSet: handleCollapseFieldSet,
      onExpandField: handleExpandField,
      onExpandFieldSet: handleExpandFieldSet,
      onFieldGroupSelect: handleSelectFieldGroup,
      onFocus: handleFocus,
      onFocusPath: handleFocusChildPath,
      onOpenField: handleOpenField,
      path: member.item.path,
      presence: member.item.presence,
      readOnly: member.item.readOnly,
      renderField,
      renderInput,
      renderItem,
      renderPreview,
      schemaType: member.item.schemaType,
      validation: member.item.validation,
      value: member.item.value
    };
  }, [handleBlur, handleChange, handleCloseField, handleCollapseField, handleCollapseFieldSet, handleExpandField, handleExpandFieldSet, handleFocus, handleFocusChildPath, handleOpenField, handleSelectFieldGroup, member.item.changed, member.item.focusPath, member.item.focused, member.item.groups, member.item.id, member.item.level, member.item.members, member.item.path, member.item.presence, member.item.readOnly, member.item.schemaType, member.item.validation, member.item.value, renderField, renderInput, renderItem, renderPreview]);
  const renderedInput = (0, React.useMemo)(() => renderInput(inputProps), [inputProps, renderInput]); // const onInsert = useCallback(() => {}, [member.key])

  const onRemove = (0, React.useCallback)(() => {
    onChange(_patch.PatchEvent.from([(0, _patch.unset)([{
      _key: member.key
    }])]));
  }, [member.key, onChange]);
  const onInsert = (0, React.useCallback)(event => {
    onChange(_patch.PatchEvent.from([(0, _patch.insert)(event.items.map(item => (0, _ensureKey.ensureKey)(item)), event.position, [{
      _key: member.key
    }])]));
  }, [member.key, onChange]);
  const itemProps = (0, React.useMemo)(() => {
    return {
      key: member.key,
      index: member.index,
      level: member.item.level,
      value: member.item.value,
      title: member.item.schemaType.title,
      description: member.item.schemaType.description,
      collapsible: member.collapsible,
      collapsed: member.collapsed,
      schemaType: member.item.schemaType,
      onInsert,
      onRemove,
      presence: member.item.presence,
      validation: member.item.validation,
      open: member.open,
      onOpen: handleOpen,
      onClose: handleClose,
      onExpand: handleExpand,
      onCollapse: handleCollapse,
      readOnly: member.item.readOnly,
      focused: member.item.focused,
      onFocus: handleFocus,
      inputId: member.item.id,
      path: member.item.path,
      children: renderedInput,
      changed: member.item.changed
    };
  }, [member.key, member.index, member.item.level, member.item.value, member.item.schemaType, member.item.presence, member.item.validation, member.item.readOnly, member.item.focused, member.item.id, member.item.path, member.item.changed, member.collapsible, member.collapsed, member.open, onInsert, onRemove, handleOpen, handleClose, handleExpand, handleCollapse, handleFocus, renderedInput]);
  return /*#__PURE__*/React.createElement(_FormCallbacks.FormCallbacksProvider, {
    onFieldGroupSelect: onFieldGroupSelect,
    onChange: handleChange,
    onPathOpen: onPathOpen,
    onSetFieldSetCollapsed: onSetFieldSetCollapsed,
    onSetPathCollapsed: onSetPathCollapsed,
    onPathBlur: onPathBlur,
    onPathFocus: onPathFocus
  }, (0, React.useMemo)(() => renderItem(itemProps), [itemProps, renderItem]));
}