"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrayOfObjectsField = ArrayOfObjectsField;

var _react = _interopRequireWildcard(require("react"));

var _FormCallbacks = require("../../studio/contexts/FormCallbacks");

var _useDidUpdate = require("../../hooks/useDidUpdate");

var _patch = require("../../patch");

var _ensureKey = require("../../utils/ensureKey");

var _templates = require("../../../templates");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Responsible for creating inputProps and fieldProps to pass to ´renderInput´ and ´renderField´ for an array input
 * Note: "ArrayField" in this context means an object field of an array type
 * @param props - Component props
 */
function ArrayOfObjectsField(props) {
  const {
    onPathBlur,
    onPathFocus,
    onChange,
    onSetPathCollapsed,
    onSetFieldSetCollapsed,
    onPathOpen,
    onFieldGroupSelect
  } = (0, _FormCallbacks.useFormCallbacks)();
  const {
    member,
    renderField,
    renderInput,
    renderItem,
    renderPreview
  } = props;
  const focusRef = (0, _react.useRef)();
  (0, _useDidUpdate.useDidUpdate)(member.field.focused, (hadFocus, hasFocus) => {
    if (!hadFocus && hasFocus) {
      var _focusRef$current;

      (_focusRef$current = focusRef.current) === null || _focusRef$current === void 0 ? void 0 : _focusRef$current.focus();
    }
  });
  const handleBlur = (0, _react.useCallback)(() => {
    onPathBlur(member.field.path);
  }, [member.field.path, onPathBlur]);
  const handleFocus = (0, _react.useCallback)(() => {
    onPathFocus(member.field.path);
  }, [member.field.path, onPathFocus]);
  const handleChange = (0, _react.useCallback)(event => {
    onChange(_patch.PatchEvent.from(event).prepend((0, _patch.setIfMissing)([])).prefixAll(member.name));
  }, [onChange, member.name]);
  const handleInsert = (0, _react.useCallback)(event => {
    onChange(_patch.PatchEvent.from([(0, _patch.setIfMissing)([]), (0, _patch.insert)(event.items.map(item => (0, _ensureKey.ensureKey)(item)), event.position, [event.referenceItem])]).prefixAll(member.name));
  }, [member.name, onChange]);
  const handleMoveItem = (0, _react.useCallback)(event => {
    const value = member.field.value;
    const item = value === null || value === void 0 ? void 0 : value[event.fromIndex];
    const refItem = value === null || value === void 0 ? void 0 : value[event.toIndex];

    if (event.fromIndex === event.toIndex) {
      return;
    }

    if (!(item !== null && item !== void 0 && item._key) || !(refItem !== null && refItem !== void 0 && refItem._key)) {
      // eslint-disable-next-line no-console
      console.error('Neither the item you are moving nor the item you are moving to have a key. Cannot continue.');
      return;
    }

    onChange(_patch.PatchEvent.from([(0, _patch.unset)([{
      _key: item._key
    }]), (0, _patch.insert)([item], event.fromIndex > event.toIndex ? 'before' : 'after', [{
      _key: refItem._key
    }])]).prefixAll(member.name));
  }, [member.field.value, member.name, onChange]);
  const handlePrependItem = (0, _react.useCallback)(item => {
    onChange(_patch.PatchEvent.from([(0, _patch.setIfMissing)([]), (0, _patch.insert)([(0, _ensureKey.ensureKey)(item)], 'before', [0])]).prefixAll(member.name));
  }, [member.name, onChange]);
  const handleAppendItem = (0, _react.useCallback)(item => {
    onChange(_patch.PatchEvent.from([(0, _patch.setIfMissing)([]), (0, _patch.insert)([(0, _ensureKey.ensureKey)(item)], 'after', [-1])]).prefixAll(member.name));
  }, [member.name, onChange]);
  const handleCollapse = (0, _react.useCallback)(() => {
    onSetPathCollapsed(member.field.path, true);
  }, [onSetPathCollapsed, member.field.path]);
  const handleExpand = (0, _react.useCallback)(() => {
    onSetPathCollapsed(member.field.path, false);
  }, [onSetPathCollapsed, member.field.path]);
  const handleCollapseItem = (0, _react.useCallback)(itemKey => {
    onSetPathCollapsed(member.field.path.concat({
      _key: itemKey
    }), true);
  }, [onSetPathCollapsed, member.field.path]);
  const handleExpandItem = (0, _react.useCallback)(itemKey => {
    onSetPathCollapsed(member.field.path.concat({
      _key: itemKey
    }), false);
  }, [onSetPathCollapsed, member.field.path]);
  const handleOpenItem = (0, _react.useCallback)(path => {
    onPathOpen(path);
    onSetPathCollapsed(path, false);
  }, [onPathOpen, onSetPathCollapsed]);
  const handleCloseItem = (0, _react.useCallback)(() => {
    onPathOpen(member.field.path);
    onSetPathCollapsed(member.field.path, true);
  }, [onPathOpen, member.field.path, onSetPathCollapsed]);
  const handleRemoveItem = (0, _react.useCallback)(itemKey => {
    onChange(_patch.PatchEvent.from([(0, _patch.unset)(member.field.path.concat({
      _key: itemKey
    }))]));
  }, [onChange, member.field.path]);
  const handleFocusChildPath = (0, _react.useCallback)(path => {
    onPathFocus(member.field.path.concat(path));
  }, [member.field.path, onPathFocus]);
  const inputProps = (0, _react.useMemo)(() => {
    return {
      level: member.field.level,
      onBlur: handleBlur,
      members: member.field.members,
      value: member.field.value,
      readOnly: member.field.readOnly,
      schemaType: member.field.schemaType,
      changed: member.field.changed,
      focusRef: focusRef,
      id: member.field.id,
      onExpand: handleExpand,
      onCollapse: handleCollapse,
      onExpandItem: handleExpandItem,
      onCollapseItem: handleCollapseItem,
      onCloseItem: handleCloseItem,
      onOpenItem: handleOpenItem,
      onFocus: handleFocus,
      focusPath: member.field.focusPath,
      focused: member.field.focused,
      path: member.field.path,
      onChange: handleChange,
      onInsert: handleInsert,
      onMoveItem: handleMoveItem,
      onRemoveItem: handleRemoveItem,
      onAppendItem: handleAppendItem,
      onPrependItem: handlePrependItem,
      onFocusPath: handleFocusChildPath,
      resolveInitialValue: _templates.resolveInitialValueForType,
      validation: member.field.validation,
      presence: member.field.presence,
      renderInput,
      renderField,
      renderItem,
      renderPreview
    };
  }, [member.field.level, member.field.members, member.field.value, member.field.readOnly, member.field.schemaType, member.field.changed, member.field.id, member.field.focusPath, member.field.focused, member.field.path, member.field.validation, member.field.presence, handleBlur, handleExpand, handleCollapse, handleExpandItem, handleCollapseItem, handleCloseItem, handleOpenItem, handleFocus, handleChange, handleInsert, handleMoveItem, handleRemoveItem, handleAppendItem, handlePrependItem, handleFocusChildPath, renderInput, renderField, renderItem, renderPreview]);
  const renderedInput = (0, _react.useMemo)(() => renderInput(inputProps), [inputProps, renderInput]);
  const fieldProps = (0, _react.useMemo)(() => {
    return {
      name: member.name,
      index: member.index,
      level: member.field.level,
      value: member.field.value,
      title: member.field.schemaType.title,
      description: member.field.schemaType.description,
      collapsible: member.collapsible,
      collapsed: member.collapsed,
      changed: member.field.changed,
      onCollapse: handleCollapse,
      onExpand: handleExpand,
      schemaType: member.field.schemaType,
      inputId: member.field.id,
      path: member.field.path,
      presence: member.field.presence,
      validation: member.field.validation,
      children: renderedInput,
      inputProps
    };
  }, [member.name, member.index, member.field.level, member.field.value, member.field.schemaType, member.field.id, member.field.path, member.field.presence, member.field.changed, member.field.validation, member.collapsible, member.collapsed, handleCollapse, handleExpand, renderedInput, inputProps]);
  return /*#__PURE__*/_react.default.createElement(_FormCallbacks.FormCallbacksProvider, {
    onFieldGroupSelect: onFieldGroupSelect,
    onChange: handleChange,
    onSetFieldSetCollapsed: onSetFieldSetCollapsed,
    onSetPathCollapsed: onSetPathCollapsed,
    onPathOpen: onPathOpen,
    onPathBlur: onPathBlur,
    onPathFocus: onPathFocus
  }, (0, _react.useMemo)(() => renderField(fieldProps), [fieldProps, renderField]));
}