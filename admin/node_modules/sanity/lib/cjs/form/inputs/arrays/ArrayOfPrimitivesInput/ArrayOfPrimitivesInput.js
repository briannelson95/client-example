"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrayOfPrimitivesInput = void 0;

var _get2 = _interopRequireDefault(require("lodash/get"));

var _react = _interopRequireDefault(require("react"));

var _ui = require("@sanity/ui");

var _list = require("../common/list");

var _members = require("../../../members");

var _getEmptyValue = require("./getEmptyValue");

var _nearestIndex = require("./utils/nearestIndex");

var _PrimitiveMemberItem = require("./PrimitiveMemberItem");

var _ItemRow = require("./ItemRow");

var _ArrayOfPrimitivesFunctions = require("./ArrayOfPrimitivesFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class ArrayOfPrimitivesInput extends _react.default.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_element", null);

    _defineProperty(this, "_lastAddedIndex", -1);

    _defineProperty(this, "handleAppend", itemValue => {
      const {
        value = [],
        onFocusIndex,
        onAppendItem
      } = this.props;
      onAppendItem(itemValue);
      onFocusIndex(value.length);
    });

    _defineProperty(this, "handlePrepend", itemValue => {
      const {
        onFocusIndex,
        value = [],
        onPrependItem
      } = this.props;
      onPrependItem(itemValue);
      onFocusIndex(value.length);
    });

    _defineProperty(this, "handleItemEnterKey", index => {
      const {
        schemaType,
        onInsert
      } = this.props;
      const firstType = schemaType === null || schemaType === void 0 ? void 0 : schemaType.of[0];

      if (firstType) {
        onInsert({
          referenceIndex: index,
          position: 'after',
          items: [(0, _getEmptyValue.getEmptyValue)(firstType)]
        });
        this._lastAddedIndex = index + 1;
      }
    });

    _defineProperty(this, "handleItemEscapeKey", index => {
      const {
        value,
        onRemoveItem
      } = this.props;

      if (index === this._lastAddedIndex && (value === null || value === void 0 ? void 0 : value[index]) === '') {
        onRemoveItem(index);
      }
    });

    _defineProperty(this, "handleSortEnd", event => {
      const {
        onFocusIndex,
        onMoveItem,
        value
      } = this.props;
      if (value) onMoveItem({
        fromIndex: event.oldIndex,
        toIndex: event.newIndex
      });
      onFocusIndex(event.newIndex);
    });

    _defineProperty(this, "setElement", el => {
      this._element = el;
    });

    _defineProperty(this, "handleFocusRoot", event => {
      const {
        onFocus
      } = this.props; // We want to handle focus when the array input *itself* element receives
      // focus, not when a child element receives focus, but React has decided
      // to let focus bubble, so this workaround is needed
      // Background: https://github.com/facebook/react/issues/6410#issuecomment-671915381

      if (event.currentTarget === event.target && event.currentTarget === this._element) {
        onFocus(event);
      }
    });

    _defineProperty(this, "renderItem", props => {
      const {
        schemaType,
        readOnly
      } = this.props;
      const isSortable = !readOnly && (0, _get2.default)(schemaType, 'options.sortable') !== false;
      return /*#__PURE__*/_react.default.createElement(_ItemRow.ItemRow, _extends({}, props, {
        isSortable: isSortable,
        insertableTypes: schemaType.of,
        onEnterKey: this.handleItemEnterKey,
        onEscapeKey: this.handleItemEscapeKey
      }));
    });
  }

  focus() {
    if (this._element) {
      this._element.focus();
    }
  }

  getSnapshotBeforeUpdate(prevProps) {
    const {
      focusPath: prevFocusPath = [],
      value: prevValue = []
    } = prevProps;
    const {
      focusPath = [],
      value = []
    } = this.props;

    if (prevFocusPath[0] === focusPath[0] && prevValue.length !== value.length) {
      var _selection$focusNode;

      // the length of the array has changed, but the focus path has not, which may happen if someone inserts or removes a new item above the one currently in focus
      const focusIndex = focusPath[0];
      const selection = window.getSelection();

      if (!((selection === null || selection === void 0 ? void 0 : selection.focusNode) instanceof HTMLElement)) {
        return null;
      }

      const input = (_selection$focusNode = selection.focusNode) === null || _selection$focusNode === void 0 ? void 0 : _selection$focusNode.querySelector('input,textarea');
      return input instanceof HTMLInputElement ? {
        prevFocusedIndex: focusIndex,
        restoreSelection: {
          text: selection.toString(),
          start: input.selectionStart,
          end: input.selectionEnd,
          value: input.value
        }
      } : {};
    }

    return null;
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    const {
      onFocusIndex
    } = this.props;

    if (snapshot !== null && snapshot !== void 0 && snapshot.restoreSelection && prevProps.value) {
      var _this$_element;

      const prevFocusedValue = prevProps.value[snapshot.prevFocusedIndex];
      const nearestIndex = (0, _nearestIndex.nearestIndexOf)(this.props.value || [], snapshot.prevFocusedIndex, prevFocusedValue);

      if (nearestIndex === -1) {
        return;
      }

      const newInput = (_this$_element = this._element) === null || _this$_element === void 0 ? void 0 : _this$_element.querySelector("[data-item-index='".concat(nearestIndex, "'] input,textarea"));

      if (newInput instanceof HTMLInputElement) {
        newInput.focus();

        try {
          newInput.setSelectionRange(snapshot.restoreSelection.start, snapshot.restoreSelection.end);
        } catch (_unused) {// not all inputs supports selection (e.g. <input type="number" />)
        }
      }

      onFocusIndex(nearestIndex);
    }
  }

  render() {
    const {
      schemaType,
      members,
      readOnly,
      value,
      onChange,
      renderInput
    } = this.props;
    const isSortable = !readOnly && (0, _get2.default)(schemaType, 'options.sortable') !== false;
    return /*#__PURE__*/_react.default.createElement(_ui.Stack, {
      space: 3
    }, /*#__PURE__*/_react.default.createElement(_ui.Stack, {
      space: 1
    }, members.length > 0 && /*#__PURE__*/_react.default.createElement(_ui.Card, {
      padding: 1,
      border: true
    }, /*#__PURE__*/_react.default.createElement(_list.List, {
      onSortEnd: this.handleSortEnd,
      isSortable: isSortable
    }, members.map((member, index) => {
      if (member.kind === 'item') {
        return /*#__PURE__*/_react.default.createElement(_list.Item, {
          key: member.key,
          index: index,
          "data-item-index": index,
          isSortable: isSortable
        }, /*#__PURE__*/_react.default.createElement(_PrimitiveMemberItem.PrimitiveMemberItem, {
          member: member,
          renderInput: renderInput,
          renderItem: this.renderItem
        }));
      }

      if (member.kind === 'error') {
        return /*#__PURE__*/_react.default.createElement(_members.MemberItemError, {
          key: member.key,
          member: member
        });
      } //@ts-expect-error all possible cases should be covered


      return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, "Unknown member kind: $", member.kind);
    })))), /*#__PURE__*/_react.default.createElement(_ArrayOfPrimitivesFunctions.ArrayOfPrimitivesFunctions, {
      type: schemaType,
      value: value,
      readOnly: readOnly,
      onAppendItem: this.handleAppend,
      onPrependItem: this.handlePrepend,
      onCreateValue: _getEmptyValue.getEmptyValue,
      onChange: onChange
    }));
  }

}

exports.ArrayOfPrimitivesInput = ArrayOfPrimitivesInput;