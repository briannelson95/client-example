"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OptionsArrayInput = void 0;

var _startCase2 = _interopRequireDefault(require("lodash/startCase"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _react = _interopRequireDefault(require("react"));

var _ui = require("@sanity/ui");

var _content = require("@sanity/util/content");

var _patch = require("../../../patch");

var _ItemWithMissingType = require("../ArrayOfObjectsInput/item/ItemWithMissingType");

var _list = require("../common/list");

var _changeIndicators = require("../../../../components/changeIndicators");

var _legacyOptionsSupport = require("./legacyOptionsSupport");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const changeIndicatorOptions = {
  compareDeep: true
};

function isEqual(item, otherItem) {
  if ((0, _legacyOptionsSupport.isLegacyOptionsItem)(item) || (0, _legacyOptionsSupport.isLegacyOptionsItem)(otherItem)) {
    return item.value === otherItem.value;
  }

  if (item === otherItem) {
    return true;
  }

  if (typeof item !== typeof otherItem) {
    return false;
  }

  if (typeof item !== 'object' && !Array.isArray(item)) {
    return item === otherItem;
  }

  if (item._key && item._key === otherItem._key) {
    return true;
  }

  if (Array.isArray(item)) {
    if (!item.length !== otherItem.length) {
      return false;
    }

    return item.every((it, i) => isEqual(item[i], otherItem[i]));
  }

  const keys = Object.keys(item);
  const otherKeys = Object.keys(item);

  if (keys.length !== otherKeys.length) {
    return false;
  }

  return keys.every(keyName => isEqual(item[keyName], otherItem[keyName]));
}

function inArray(array, candidate) {
  return array ? array.some(item => isEqual(item, candidate)) : false;
}

class OptionsArrayInput extends _react.default.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_element", null);

    _defineProperty(this, "handleChange", (isChecked, optionValue) => {
      const {
        schemaType,
        value = []
      } = this.props;
      const list = (0, _get2.default)(schemaType.options, 'list');

      if (!isChecked && optionValue._key) {
        // This is an optimization that only works if list items are _keyed
        this.props.onChange((0, _patch.unset)([{
          _key: optionValue._key
        }]));
      }

      const nextValue = list.filter(item => isEqual(optionValue, item) ? isChecked : inArray(value, (0, _legacyOptionsSupport.resolveValueWithLegacyOptionsSupport)(item))).map(_legacyOptionsSupport.resolveValueWithLegacyOptionsSupport);
      this.props.onChange(nextValue.length > 0 ? (0, _patch.set)(nextValue) : (0, _patch.unset)());
    });

    _defineProperty(this, "setElement", el => {
      this._element = el;
    });

    _defineProperty(this, "handleFocus", index => {
      const {
        onFocusIndex
      } = this.props;
      onFocusIndex(index);
    });
  }

  getMemberTypeOfItem(option) {
    const {
      schemaType
    } = this.props;
    return schemaType.of.find(memberType => memberType.name === (0, _content.resolveTypeName)((0, _legacyOptionsSupport.resolveValueWithLegacyOptionsSupport)(option)));
  }

  focus() {
    if (this._element) {
      this._element.focus();
    }
  }

  render() {
    var _schemaType$options, _schemaType$options2, _schemaType$options3;

    const {
      changed,
      focused,
      onBlur,
      onFocus,
      path,
      renderPreview,
      schemaType,
      value,
      readOnly
    } = this.props;
    const options = ((_schemaType$options = schemaType.options) === null || _schemaType$options === void 0 ? void 0 : _schemaType$options.list) || []; // note: direction was never documented and makes more sense to use "grid" for it too

    const isGrid = ((_schemaType$options2 = schemaType.options) === null || _schemaType$options2 === void 0 ? void 0 : _schemaType$options2.direction) === 'horizontal' || ((_schemaType$options3 = schemaType.options) === null || _schemaType$options3 === void 0 ? void 0 : _schemaType$options3.layout) === 'grid';
    return /*#__PURE__*/_react.default.createElement(_changeIndicators.ChangeIndicator, {
      path: path,
      isChanged: changed,
      hasFocus: !!focused
    }, /*#__PURE__*/_react.default.createElement(_list.List, {
      isGrid: isGrid
    }, options.map((option, index) => {
      const optionType = this.getMemberTypeOfItem(option);
      const checked = inArray(value || [], (0, _legacyOptionsSupport.resolveValueWithLegacyOptionsSupport)(option));
      const disabled = !optionType;
      const title = (option === null || option === void 0 ? void 0 : option.title) || (0, _startCase2.default)(option === null || option === void 0 ? void 0 : option.value) || option;
      return /*#__PURE__*/_react.default.createElement(_list.Item, {
        index: index,
        isGrid: isGrid,
        key: index
      }, /*#__PURE__*/_react.default.createElement(_ui.Flex, {
        align: "center",
        as: "label",
        muted: disabled
      }, /*#__PURE__*/_react.default.createElement(WrappedCheckbox, {
        disabled: disabled,
        checked: checked,
        onChange: e => this.handleChange(e.currentTarget.checked, option),
        onFocus: () => this.handleFocus(index),
        onBlur: onBlur,
        readOnly: readOnly
      }), optionType && (title ? /*#__PURE__*/_react.default.createElement(_ui.Box, {
        padding: 2
      }, /*#__PURE__*/_react.default.createElement(_ui.Text, null, title)) : /*#__PURE__*/_react.default.createElement(_ui.Box, {
        marginLeft: 2
      }, renderPreview({
        layout: 'media',
        schemaType: optionType,
        value: (0, _legacyOptionsSupport.resolveValueWithLegacyOptionsSupport)(option)
      }))), !optionType && /*#__PURE__*/_react.default.createElement(_ItemWithMissingType.ItemWithMissingType, {
        value: option,
        onFocus: event => onFocus(event)
      })));
    })));
  }

}

exports.OptionsArrayInput = OptionsArrayInput;

const WrappedCheckbox = props => {
  const {
    disabled,
    checked,
    onChange,
    onFocus,
    readOnly,
    onBlur
  } = props;
  return /*#__PURE__*/_react.default.createElement(_ui.Checkbox, {
    disabled: disabled,
    checked: checked,
    readOnly: readOnly,
    onChange: onChange,
    onFocus: onFocus,
    onBlur: onBlur
  });
};