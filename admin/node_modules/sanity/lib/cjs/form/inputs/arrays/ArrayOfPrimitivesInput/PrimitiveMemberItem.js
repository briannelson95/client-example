"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PrimitiveMemberItem = PrimitiveMemberItem;

var React = _interopRequireWildcard(require("react"));

var _useDidUpdate = require("../../../hooks/useDidUpdate");

var _FormCallbacks = require("../../../studio/contexts/FormCallbacks");

var _patch = require("../../../patch");

var _getEmptyValue = require("./getEmptyValue");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @alpha
 */
function PrimitiveMemberItem(props) {
  const focusRef = (0, React.useRef)();
  const {
    member,
    renderItem,
    renderInput
  } = props;
  const {
    onPathBlur,
    onPathFocus,
    onChange
  } = (0, _FormCallbacks.useFormCallbacks)();
  (0, _useDidUpdate.useDidUpdate)(member.item.focused, (hadFocus, hasFocus) => {
    if (!hadFocus && hasFocus) {
      var _focusRef$current;

      (_focusRef$current = focusRef.current) === null || _focusRef$current === void 0 ? void 0 : _focusRef$current.focus();
    }
  });
  const handleBlur = (0, React.useCallback)(event => {
    onPathBlur(member.item.path);
  }, [member.item.path, onPathBlur]);
  const handleFocus = (0, React.useCallback)(event => {
    onPathFocus(member.item.path);
  }, [member.item.path, onPathFocus]);
  const handleChange = (0, React.useCallback)(event => {
    const patches = _patch.PatchEvent.from(event).patches.map(patch => // Map direct unset patches to empty value instead in order to not *remove* elements as the user clears out the value
    // note: this creates the rather "weird" case where the input renders ´0´ when you try to clear it
    patch.path.length === 0 && patch.type === 'unset' ? (0, _patch.set)((0, _getEmptyValue.getEmptyValue)(member.item.schemaType)) : patch);

    onChange(_patch.PatchEvent.from(patches).prefixAll(member.index));
  }, [onChange, member.item.schemaType, member.index]);
  const inputProps = (0, React.useMemo)(() => {
    return {
      changed: member.item.changed,
      level: member.item.level,
      value: member.item.value,
      readOnly: member.item.readOnly,
      schemaType: member.item.schemaType,
      focusRef: focusRef,
      id: member.item.id,
      onBlur: handleBlur,
      onFocus: handleFocus,
      path: member.item.path,
      focused: member.item.focused,
      onChange: handleChange,
      validation: member.item.validation,
      presence: member.item.presence
    };
  }, [member.item.level, member.item.value, member.item.readOnly, member.item.schemaType, member.item.id, member.item.path, member.item.focused, member.item.validation, member.item.presence, member.item.changed, handleBlur, handleFocus, handleChange]);
  const renderedInput = (0, React.useMemo)(() => renderInput(inputProps), [inputProps, renderInput]);
  const onRemove = (0, React.useCallback)(() => {
    onChange(_patch.PatchEvent.from([(0, _patch.unset)([member.index])]));
  }, [member.index, onChange]);
  const onInsert = (0, React.useCallback)(event => {
    onChange(_patch.PatchEvent.from([(0, _patch.insert)(event.items, event.position, [member.index])]));
  }, [member.index, onChange]);
  const itemProps = (0, React.useMemo)(() => {
    return {
      key: member.key,
      index: member.index,
      level: member.item.level,
      value: member.item.value,
      title: member.item.schemaType.title,
      description: member.item.schemaType.description,
      schemaType: member.item.schemaType,
      onInsert,
      onRemove,
      presence: member.item.presence,
      validation: member.item.validation,
      readOnly: member.item.readOnly,
      focused: member.item.focused,
      onFocus: handleFocus,
      inputId: member.item.id,
      path: member.item.path,
      children: renderedInput
    };
  }, [member.key, member.index, member.item.level, member.item.value, member.item.schemaType, member.item.presence, member.item.validation, member.item.readOnly, member.item.focused, member.item.id, member.item.path, onInsert, onRemove, handleFocus, renderedInput]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, (0, React.useMemo)(() => renderItem(itemProps), [itemProps, renderItem]));
}