"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uploadTarget = uploadTarget;

var _sortBy2 = _interopRequireDefault(require("lodash/sortBy"));

var _ui = require("@sanity/ui");

var _react = _interopRequireDefault(require("react"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _fileTarget = require("../../../common/fileTarget");

var _DropMessage = require("../../../files/common/DropMessage");

var _styles = require("./styles");

var _templateObject;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

const Root = _styledComponents.default.div(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  position: relative;\n"])));

function getUploadCandidates(types, resolveUploader, file) {
  return types.map(memberType => ({
    type: memberType,
    uploader: resolveUploader(memberType, file)
  })).filter(member => member.uploader);
}

function uploadTarget(Component) {
  const FileTarget = (0, _fileTarget.fileTarget)(Component);
  return /*#__PURE__*/_react.default.forwardRef(function UploadTarget(props, forwardedRef) {
    const {
      children,
      resolveUploader,
      onUpload,
      types,
      ...rest
    } = props;
    const {
      push: pushToast
    } = (0, _ui.useToast)();

    const uploadFile = _react.default.useCallback((file, resolvedUploader) => {
      const {
        type,
        uploader
      } = resolvedUploader;
      onUpload === null || onUpload === void 0 ? void 0 : onUpload({
        file,
        type,
        uploader
      });
    }, [onUpload]);

    const handleFiles = _react.default.useCallback(files => {
      if (!resolveUploader) {
        return;
      }

      const tasks = files.map(file => ({
        file,
        uploaderCandidates: getUploadCandidates(types, resolveUploader, file)
      }));
      const ready = tasks.filter(task => task.uploaderCandidates.length > 0);
      const rejected = tasks.filter(task => task.uploaderCandidates.length === 0);

      if (rejected.length > 0) {
        const plural = rejected.length > 1;
        pushToast({
          closable: true,
          status: 'warning',
          title: "The following item".concat(plural ? 's' : '', " can't be uploaded because there's no known conversion from content type").concat(plural ? 's' : '', " to array item:"),
          description: rejected.map((task, i) => /*#__PURE__*/_react.default.createElement(_ui.Flex, {
            key: i,
            padding: 2
          }, /*#__PURE__*/_react.default.createElement(_ui.Box, {
            marginLeft: 1
          }, /*#__PURE__*/_react.default.createElement(_ui.Text, {
            weight: "semibold"
          }, task.file.name)), /*#__PURE__*/_react.default.createElement(_ui.Box, {
            paddingLeft: 2
          }, /*#__PURE__*/_react.default.createElement(_ui.Text, {
            size: 1
          }, "(", task.file.type, ")"))))
        });
      } // todo: consider if we should to ask the user here
      // the list of candidates is sorted by their priority and the first one is selected
      // const ambiguous = tasks
      //   .filter(task => task.uploaderCandidates.length > 1)


      ready.forEach(task => {
        uploadFile(task.file, // eslint-disable-next-line max-nested-callbacks
        (0, _sortBy2.default)(task.uploaderCandidates, candidate => candidate.uploader.priority)[0]);
      });
    }, [pushToast, resolveUploader, types, uploadFile]);

    const [hoveringFiles, setHoveringFiles] = _react.default.useState([]);

    const handleFilesOut = _react.default.useCallback(() => setHoveringFiles([]), []);

    return /*#__PURE__*/_react.default.createElement(Root, null, /*#__PURE__*/_react.default.createElement(FileTarget, _extends({}, rest, {
      ref: forwardedRef,
      onFiles: handleFiles,
      onFilesOver: setHoveringFiles,
      onFilesOut: handleFilesOut
    }), resolveUploader && hoveringFiles.length > 0 && /*#__PURE__*/_react.default.createElement(_styles.Overlay, {
      zOffset: 10
    }, /*#__PURE__*/_react.default.createElement(_DropMessage.DropMessage, {
      hoveringFiles: hoveringFiles,
      types: types,
      resolveUploader: resolveUploader
    })), children));
  });
}