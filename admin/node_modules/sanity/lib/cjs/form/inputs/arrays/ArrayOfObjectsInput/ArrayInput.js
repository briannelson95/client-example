"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrayInput = void 0;
exports.createProtoValue = createProtoValue;

var _isPlainObject2 = _interopRequireDefault(require("lodash/isPlainObject"));

var _types = require("@sanity/types");

var _ui = require("@sanity/ui");

var _react = _interopRequireDefault(require("react"));

var _operators = require("rxjs/operators");

var _content = require("@sanity/util/content");

var _helpers = require("../../../../schema/helpers");

var _environment = require("../../../../environment");

var _Alert = require("../../../components/Alert");

var _Details = require("../../../components/Details");

var _list = require("../common/list");

var _applyPatch = require("../../../patch/applyPatch");

var _patch = require("../../../patch");

var _ArrayFunctions = require("../common/ArrayFunctions");

var _asserters = require("../../../types/asserters");

var _withFocusRing = require("../../../components/withFocusRing");

var _members = require("../../../members");

var _uploadTarget = require("./uploadTarget/uploadTarget");

var _helpers2 = require("./item/helpers");

var _ArrayItem = require("./item/ArrayItem");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function createProtoValue(type) {
  if (!(0, _types.isObjectSchemaType)(type)) {
    throw new Error("Invalid item type: \"".concat(type.type, "\". Default array input can only contain objects (for now)"));
  }

  const _key = (0, _content.randomKey)(12);

  return type.name === 'object' ? {
    _key
  } : {
    _type: type.name,
    _key
  };
}
/**
 * @internal
 */


const UploadTarget = (0, _uploadTarget.uploadTarget)((0, _withFocusRing.withFocusRing)(_ui.Card));

class ArrayInput extends _react.default.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_focusArea", null);

    _defineProperty(this, "toast", null);

    _defineProperty(this, "uploadSubscriptions", {});

    _defineProperty(this, "state", {
      isResolvingInitialValue: false
    });

    _defineProperty(this, "insert", (item, position, referenceItem) => {
      const {
        onInsert
      } = this.props;
      onInsert({
        items: [item],
        position,
        referenceItem
      });
    });

    _defineProperty(this, "handlePrepend", value => {
      this.handleInsert({
        item: value,
        position: 'before',
        referenceItem: 0
      });
    });

    _defineProperty(this, "handleAppend", value => {
      this.handleInsert({
        item: value,
        position: 'after',
        referenceItem: -1
      });
    });

    _defineProperty(this, "handleInsert", event => {
      const {
        onFocusPath,
        onOpenItem,
        resolveInitialValue
      } = this.props;
      this.setState({
        isResolvingInitialValue: true
      });
      const memberType = this.getMemberTypeOfItem(event.item);

      if (!memberType) {
        throw new Error("Type \"".concat(event.item._type, "\" not valid for this array"));
      }

      const resolvedInitialValue = (0, _helpers2.isEmpty)(event.item) && resolveInitialValue ? resolveInitialValue(memberType, event.item) : Promise.resolve({});
      resolvedInitialValue.then(initial => ({ ...event.item,
        ...initial
      })).then(value => {
        this.insert(value, event.position, event.referenceItem);
      }, error => {
        var _this$toast;

        (_this$toast = this.toast) === null || _this$toast === void 0 ? void 0 : _this$toast.push({
          title: "Could not resolve initial value",
          description: "Unable to resolve initial value for type: ".concat(memberType.name, ": ").concat(error.message, "."),
          status: 'error'
        });
        this.insert(event.item, event.position, event.referenceItem);
      }).finally(() => {
        this.setState({
          isResolvingInitialValue: false
        });

        if (event.edit !== false) {
          onOpenItem(this.props.path.concat([{
            _key: event.item._key
          }]));
        }

        onFocusPath([{
          _key: event.item._key
        }]);
      });
    });

    _defineProperty(this, "handleRemoveItem", item => {
      this.removeItem(item);
    });

    _defineProperty(this, "handleFocus", event => {
      const {
        onFocus
      } = this.props; // We want to handle focus when the array input *itself* element receives
      // focus, not when a child element receives focus, but React has decided
      // to let focus bubble, so this workaround is needed
      // Background: https://github.com/facebook/react/issues/6410#issuecomment-671915381

      if (event.currentTarget === event.target && event.currentTarget === this._focusArea) {
        onFocus(event);
      }
    });

    _defineProperty(this, "handleBlur", event => {
      const {
        onBlur
      } = this.props; // We want to handle blur when the array input *itself* element receives
      // blur, not when a child element receives blur, but React has decided
      // to let focus events bubble, so this workaround is needed
      // Background: https://github.com/facebook/react/issues/6410#issuecomment-671915381

      if (event.currentTarget === event.target && event.currentTarget === this._focusArea) {
        onBlur(event);
      }
    });

    _defineProperty(this, "handleSortEnd", event => {
      const {
        value,
        onMoveItem
      } = this.props;
      const item = value === null || value === void 0 ? void 0 : value[event.oldIndex];
      const refItem = value === null || value === void 0 ? void 0 : value[event.newIndex];

      if (!(item !== null && item !== void 0 && item._key) || !(refItem !== null && refItem !== void 0 && refItem._key)) {
        // eslint-disable-next-line no-console
        console.error('Neither the item you are moving nor the item you are moving to have a key. Cannot continue.');
        return;
      }

      if (event.oldIndex === event.newIndex || item._key === refItem._key) {
        return;
      }

      onMoveItem({
        fromIndex: event.oldIndex,
        toIndex: event.newIndex
      });
    });

    _defineProperty(this, "setFocusArea", el => {
      this._focusArea = el;
    });

    _defineProperty(this, "setToast", toast => {
      this.toast = toast;
    });

    _defineProperty(this, "handleRemoveNonObjectValues", () => {
      const {
        onChange,
        value
      } = this.props;
      const nonObjects = (value || []).reduce((acc, val, i) => (0, _isPlainObject2.default)(val) ? acc : acc.concat(i), []).reverse();
      const patches = nonObjects.map(index => (0, _patch.unset)([index]));
      onChange(patches);
    });

    _defineProperty(this, "handleUpload", _ref => {
      let {
        file,
        type,
        uploader
      } = _ref;
      const {
        onChange,
        client
      } = this.props;
      const item = createProtoValue(type);
      const key = item._key;
      this.insert(item, 'after', -1);
      const events$ = uploader.upload(client, file, type).pipe((0, _operators.map)(uploadEvent => _patch.PatchEvent.from(uploadEvent.patches || []).prefixAll({
        _key: key
      })));
      this.uploadSubscriptions = { ...this.uploadSubscriptions,
        [key]: events$.subscribe(event => onChange(event.patches))
      };
    });

    _defineProperty(this, "renderItem", itemProps => {
      var _schemaType$options;

      if (!(0, _asserters.isObjectItemProps)(itemProps)) {
        throw new Error('Expected item to be of object type');
      }

      const {
        id,
        renderPreview,
        schemaType
      } = this.props;

      if ((0, _types.isReferenceSchemaType)(itemProps.schemaType)) {
        return itemProps.children;
      }

      const typeTitle = (0, _helpers.getSchemaTypeTitle)(itemProps.schemaType);
      return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_ArrayItem.ArrayItem, {
        changed: itemProps.changed,
        validation: itemProps.validation,
        readOnly: itemProps.readOnly,
        onInsert: itemProps.onInsert,
        onRemove: itemProps.onRemove,
        onFocus: itemProps.onFocus,
        index: itemProps.index,
        schemaType: itemProps.schemaType,
        layout: (_schemaType$options = schemaType.options) === null || _schemaType$options === void 0 ? void 0 : _schemaType$options.layout,
        insertableTypes: schemaType.of,
        value: itemProps.value,
        focused: itemProps.focused,
        open: itemProps.open,
        path: itemProps.path,
        onClick: itemProps.onOpen,
        presence: itemProps.presence,
        renderPreview: renderPreview
      }, itemProps.open ? /*#__PURE__*/_react.default.createElement(_ui.Dialog, {
        width: 1,
        header: "Edit ".concat(typeTitle),
        id: "".concat(id, "-item-").concat(itemProps.key, "-dialog"),
        onClose: itemProps.onClose
      }, /*#__PURE__*/_react.default.createElement(_ui.Box, {
        padding: 4
      }, itemProps.children)) : null));
    });
  }

  getMemberTypeOfItem(item) {
    const {
      schemaType
    } = this.props;
    const itemTypeName = (0, _content.resolveTypeName)(item);
    return schemaType.of.find(memberType => memberType.name === itemTypeName);
  }

  removeItem(item) {
    const {
      onChange,
      onFocusPath,
      value
    } = this.props; // create a patch for removing the item

    const patch = (0, _patch.unset)((0, _types.isKeySegment)(item) ? [{
      _key: item._key
    }] : [(value === null || value === void 0 ? void 0 : value.indexOf(item)) || -1]); // apply the patch to the current value

    const result = (0, _applyPatch.applyAll)(value || [], [patch]); // if the result is an empty array

    if (Array.isArray(result) && !result.length) {
      // then unset the value
      onChange((0, _patch.unset)());
    } else {
      // otherwise apply the patch
      onChange(patch);
    }

    if (item._key in this.uploadSubscriptions) {
      this.uploadSubscriptions[item._key].unsubscribe();
    } // move focus to the nearest sibling


    const idx = (value === null || value === void 0 ? void 0 : value.indexOf(item)) || -1;
    const nearestSibling = (value === null || value === void 0 ? void 0 : value[idx + 1]) || (value === null || value === void 0 ? void 0 : value[idx - 1]); // if there's no siblings we want to focus the input itself

    onFocusPath(nearestSibling ? [{
      _key: nearestSibling._key
    }] : []);
  }

  focus() {
    if (this._focusArea) {
      this._focusArea.focus();
    }
  }

  renderMember(member) {
    const {
      renderField,
      renderInput,
      renderPreview
    } = this.props;

    if (member.kind === 'item') {
      return /*#__PURE__*/_react.default.createElement(_members.MemberItem, {
        member: member,
        renderItem: this.renderItem,
        renderField: renderField,
        renderInput: renderInput,
        renderPreview: renderPreview
      });
    }

    if (member.kind === 'error') {
      return /*#__PURE__*/_react.default.createElement(_members.MemberItemError, {
        member: member
      });
    } //@ts-expect-error all possible cases should be covered


    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, "Unknown member kind: $", member.kind);
  }

  render() {
    const {
      schemaType,
      onChange,
      value = [],
      readOnly,
      members,
      resolveUploader
    } = this.props;
    const {
      isResolvingInitialValue
    } = this.state;
    const hasNonObjectValues = (value || []).some(item => !(0, _isPlainObject2.default)(item));

    if (hasNonObjectValues) {
      return /*#__PURE__*/_react.default.createElement(_Alert.Alert, {
        status: "error",
        suffix: /*#__PURE__*/_react.default.createElement(_ui.Stack, {
          padding: 2
        }, /*#__PURE__*/_react.default.createElement(_ui.Button, {
          onClick: this.handleRemoveNonObjectValues,
          text: "Remove non-object values",
          tone: "critical"
        })),
        title: /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, "Invalid list values")
      }, /*#__PURE__*/_react.default.createElement(_ui.Text, {
        as: "p",
        muted: true,
        size: 1
      }, "Some items in this list are not objects. This must be fixed in order to edit the list."), /*#__PURE__*/_react.default.createElement(_Details.Details, {
        marginTop: 4,
        open: _environment.isDev,
        title: /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, "Developer info")
      }, /*#__PURE__*/_react.default.createElement(_ui.Stack, {
        space: 3
      }, /*#__PURE__*/_react.default.createElement(_ui.Text, {
        as: "p",
        muted: true,
        size: 1
      }, "This usually happens when items are created using an API client, or when a custom input component has added invalid data to the list."))));
    }

    const options = schemaType.options || {};
    const isSortable = options.sortable !== false;
    const isGrid = options.layout === 'grid';
    return /*#__PURE__*/_react.default.createElement(_ui.Stack, {
      space: 3
    }, /*#__PURE__*/_react.default.createElement(UploadTarget, {
      types: schemaType.of,
      resolveUploader: resolveUploader,
      onUpload: this.handleUpload,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur,
      ref: this.setFocusArea,
      tabIndex: 0
    }, /*#__PURE__*/_react.default.createElement(_ui.Stack, {
      "data-ui": "ArrayInput__content",
      space: 3
    }, (members === null || members === void 0 ? void 0 : members.length) === 0 && /*#__PURE__*/_react.default.createElement(_ui.Card, {
      padding: 3,
      border: true,
      style: {
        borderStyle: 'dashed'
      },
      radius: 2
    }, /*#__PURE__*/_react.default.createElement(_ui.Text, {
      align: "center",
      muted: true,
      size: 1
    }, schemaType.placeholder || /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, "No items"))), ((members === null || members === void 0 ? void 0 : members.length) > 0 || isResolvingInitialValue) && /*#__PURE__*/_react.default.createElement(_ui.Card, {
      border: true,
      radius: 1,
      paddingY: isGrid ? 2 : 1,
      paddingX: isGrid ? 2 : undefined
    }, /*#__PURE__*/_react.default.createElement(_list.List, {
      onSortEnd: this.handleSortEnd,
      isSortable: isSortable,
      isGrid: isGrid
    }, members.map((member, index) => {
      return /*#__PURE__*/_react.default.createElement(_list.Item, {
        key: member.key,
        isSortable: isSortable,
        isGrid: isGrid,
        index: index
      }, this.renderMember(member));
    }), isResolvingInitialValue && /*#__PURE__*/_react.default.createElement(_list.Item, {
      isGrid: isGrid,
      index: -1
    }, /*#__PURE__*/_react.default.createElement(_ui.Card, {
      radius: 1,
      padding: 1
    }, /*#__PURE__*/_react.default.createElement(_ui.Flex, {
      align: "center",
      justify: "center",
      padding: 3
    }, /*#__PURE__*/_react.default.createElement(_ui.Box, {
      marginX: 3
    }, /*#__PURE__*/_react.default.createElement(_ui.Spinner, {
      muted: true
    })), /*#__PURE__*/_react.default.createElement(_ui.Text, null, "Resolving initial value\u2026")))))))), /*#__PURE__*/_react.default.createElement(_ArrayFunctions.DefaultArrayInputFunctions, {
      type: schemaType,
      value: value,
      readOnly: readOnly,
      onAppendItem: this.handleAppend,
      onPrependItem: this.handlePrepend,
      onCreateValue: createProtoValue,
      onChange: onChange
    }));
  }

}

exports.ArrayInput = ArrayInput;