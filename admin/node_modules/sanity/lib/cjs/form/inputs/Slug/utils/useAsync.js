"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAsync = useAsync;

var _react = _interopRequireDefault(require("react"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Takes an async function and returns a [AsyncState<value>, callback] pair.
 * Whenever the callback is invoked, a new AsyncState is returned.
 * If the returned callback is called again before the previous callback has settled, the resolution of the previous one will be ignored, thus preventing race conditions.
 * @param fn an async function that returns a value
 * @param dependencies list of dependencies that will return a new [value, callback] pair
 */
function useAsync(fn, dependencies) {
  const [state, setState] = _react.default.useState(null);

  const lastId = _react.default.useRef(0);

  const wrappedCallback = _react.default.useCallback(arg => {
    const asyncId = ++lastId.current;
    setState({
      status: 'pending'
    });
    Promise.resolve().then(() => fn(arg)).then(res => {
      if (asyncId === lastId.current) {
        setState({
          status: 'complete',
          result: res
        });
      }
    }, err => {
      if (asyncId === lastId.current) {
        setState({
          status: 'error',
          error: err
        });
      }
    });
  }, [fn, ...dependencies]);

  return [state, wrappedCallback];
}