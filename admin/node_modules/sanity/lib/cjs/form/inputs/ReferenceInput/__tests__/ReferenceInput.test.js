"use strict";

var _noop2 = _interopRequireDefault(require("lodash/noop"));

var _react = require("@testing-library/react");

var _react2 = _interopRequireWildcard(require("react"));

var _schema = _interopRequireDefault(require("@sanity/schema"));

var _ui = require("@sanity/ui");

var _rxjs = require("rxjs");

var _router = require("../../../../router");

var _ReferenceInput = require("../ReferenceInput");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const EMPTY_SEARCH = () => (0, _rxjs.of)([]);

const AVAILABLE = {
  available: true,
  reason: 'READABLE'
};
const UNAVAILABLE_NOT_FOUND = {
  available: false,
  reason: 'NOT_FOUND'
};
const UNAVAILABLE_PERMISSION_DENIED = {
  available: false,
  reason: 'PERMISSION_DENIED'
};
const infinityNoop = new Proxy(() => infinityNoop, {
  get: () => infinityNoop
}); // eslint-disable-next-line @typescript-eslint/no-explicit-any

const StubComponent = /*#__PURE__*/(0, _react2.forwardRef)((_ref, ref) => {
  let {
    documentId,
    documentType
  } = _ref;
  (0, _react2.useImperativeHandle)(ref, () => infinityNoop, []);
  return null;
});
StubComponent.displayName = 'StubComponent';

function ReferenceInputTester(props) {
  const onFocus = jest.fn();
  const onChange = jest.fn();
  return /*#__PURE__*/_react2.default.createElement(_router.RouterProvider, {
    router: _router.route.intents('/intents'),
    state: {},
    onNavigate: _noop2.default
  }, /*#__PURE__*/_react2.default.createElement(_ui.ThemeProvider, {
    scheme: "light",
    theme: _ui.studioTheme
  }, /*#__PURE__*/_react2.default.createElement(_ui.ToastProvider, null, /*#__PURE__*/_react2.default.createElement(_ui.LayerProvider, null, /*#__PURE__*/_react2.default.createElement(_ReferenceInput.ReferenceInput, _extends({
    onFocus: onFocus,
    onChange: onChange,
    validation: [],
    level: 0,
    liveEdit: false,
    focusPath: [],
    presence: [],
    onSearch: EMPTY_SEARCH,
    createOptions: [],
    editReferenceLinkComponent: StubComponent,
    onEditReference: _noop2.default
  }, props))))));
}

function ReferenceInfoTester(props) {
  const schema = _schema.default.compile({
    types: [{
      name: 'actor',
      type: 'document',
      fields: [{
        name: 'name',
        type: 'string'
      }]
    }, {
      name: 'actorReference',
      type: 'reference',
      weak: props.typeIsWeakRef,
      to: [{
        type: 'actor'
      }]
    }]
  });

  return /*#__PURE__*/_react2.default.createElement(ReferenceInputTester, {
    getReferenceInfo: id => (0, _rxjs.of)(props.referenceInfo),
    onSearch: EMPTY_SEARCH,
    focusPath: props.isEditing ? ['_ref'] : [],
    schemaType: schema.get('actorReference'),
    value: props.value
  });
}

const PUBLISHED_PREVIEW = {
  title: 'Actor (published)',
  description: ''
};
const DRAFT_PREVIEW = {
  title: 'Actor (draft)',
  description: ''
};
describe('if schema type is a strong reference', () => {
  test('the UI does *NOT* show a warning if the draft exist and the reference value is weak and has a _strengthenOnPublish flag', () => {
    const {
      getByTestId,
      queryByTestId
    } = (0, _react.render)( /*#__PURE__*/_react2.default.createElement(ReferenceInfoTester, {
      value: {
        _type: 'reference',
        _ref: 'someActor',
        _weak: true,
        _strengthenOnPublish: {
          type: 'actor'
        }
      },
      referenceInfo: {
        id: 'someActor',
        type: 'actorReference',
        availability: AVAILABLE,
        preview: {
          published: undefined,
          draft: DRAFT_PREVIEW
        }
      }
    }));
    expect(queryByTestId('alert-nonexistent-document')).toBe(null);
  });
  test('the UI shows a warning if the document is published and the value is is weak', () => {
    const {
      getByTestId,
      queryByTestId
    } = (0, _react.render)( /*#__PURE__*/_react2.default.createElement(ReferenceInfoTester, {
      value: {
        _type: 'reference',
        _weak: true,
        _ref: 'someActor'
      },
      referenceInfo: {
        id: 'someActor',
        type: 'actorReference',
        availability: AVAILABLE,
        preview: {
          published: undefined,
          draft: DRAFT_PREVIEW
        }
      }
    }));
    expect(queryByTestId('alert-reference-strength-mismatch')).toBeInTheDocument();
  });
});
describe('if schema type is a weak reference', () => {
  test('the UI indicates that the referenced document does not exist', () => {
    const {
      getByTestId
    } = (0, _react.render)( /*#__PURE__*/_react2.default.createElement(ReferenceInfoTester, {
      typeIsWeakRef: true,
      value: {
        _type: 'reference',
        _weak: true,
        _ref: 'someActor'
      },
      referenceInfo: {
        id: 'someActor',
        type: 'actorReference',
        availability: UNAVAILABLE_NOT_FOUND,
        preview: {
          published: PUBLISHED_PREVIEW,
          draft: DRAFT_PREVIEW
        }
      }
    }));
    expect(getByTestId('alert-nonexistent-document')).toBeInTheDocument();
  });
  test('a warning is visible if the reference value is strong while the schema says it should be weak', () => {
    const {
      getByTestId
    } = (0, _react.render)( /*#__PURE__*/_react2.default.createElement(ReferenceInfoTester, {
      typeIsWeakRef: true,
      value: {
        _type: 'reference',
        _ref: 'someActor'
      },
      referenceInfo: {
        id: 'someActor',
        type: 'actorReference',
        availability: AVAILABLE,
        preview: {
          published: PUBLISHED_PREVIEW,
          draft: DRAFT_PREVIEW
        }
      }
    }));
    expect(getByTestId('alert-reference-strength-mismatch')).toBeInTheDocument();
  });
});