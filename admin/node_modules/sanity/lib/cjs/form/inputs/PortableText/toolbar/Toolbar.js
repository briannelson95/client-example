"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Toolbar = Toolbar;

var _portableTextEditor = require("@sanity/portable-text-editor");

var _react = _interopRequireWildcard(require("react"));

var _ui = require("@sanity/ui");

var _icons = require("@sanity/icons");

var _styledComponents = _interopRequireWildcard(require("styled-components"));

var _rovingFocus = require("../../../../components/rovingFocus");

var _templates = require("../../../../templates");

var _ActionMenu = require("./ActionMenu");

var _BlockStyleSelect = require("./BlockStyleSelect");

var _InsertMenu = require("./InsertMenu");

var _helpers = require("./helpers");

var _hooks = require("./hooks");

var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

const RootFlex = (0, _styledComponents.default)(_ui.Flex)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  width: 100%;\n"])));
const StyleSelectBox = (0, _styledComponents.default)(_ui.Box)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n  width: 8em;\n"])));
const StyleSelectFlex = (0, _styledComponents.default)(_ui.Flex)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n  border-right: 1px solid var(--card-border-color);\n"])));
const ActionMenuBox = (0, _styledComponents.default)(_ui.Box)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n  ", "\n"])), _ref => {
  let {
    $withInsertMenu
  } = _ref;
  return $withInsertMenu && (0, _styledComponents.css)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["\n      max-width: max-content;\n      border-right: 1px solid var(--card-border-color);\n    "])));
});
const FullscreenButtonBox = (0, _styledComponents.default)(_ui.Box)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral(["\n  border-left: 1px solid var(--card-border-color);\n"])));
const SLOW_INITIAL_VALUE_LIMIT = 300;
const IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
const InnerToolbar = /*#__PURE__*/(0, _react.memo)(function InnerToolbar(_ref2) {
  let {
    actionGroups,
    blockStyles,
    disabled,
    insertMenuItems,
    isFullscreen,
    onToggleFullscreen
  } = _ref2;
  const actionsLen = actionGroups.reduce((acc, x) => acc + x.actions.length, 0);
  const showActionMenu = actionsLen > 0;
  const showInsertMenu = insertMenuItems.length > 0;
  const [rootElement, setRootElement] = (0, _react.useState)(null);
  const rootElementRect = (0, _ui.useElementRect)(rootElement);
  const collapsed = rootElementRect ? (rootElementRect === null || rootElementRect === void 0 ? void 0 : rootElementRect.width) < 400 : false;
  (0, _rovingFocus.useRovingFocus)({
    rootElement: rootElement
  });
  return /*#__PURE__*/_react.default.createElement(RootFlex, {
    align: "center",
    ref: setRootElement
  }, /*#__PURE__*/_react.default.createElement(StyleSelectFlex, {
    flex: collapsed ? 1 : undefined
  }, /*#__PURE__*/_react.default.createElement(StyleSelectBox, {
    padding: isFullscreen ? 2 : 1
  }, /*#__PURE__*/_react.default.createElement(_BlockStyleSelect.BlockStyleSelect, {
    disabled: disabled,
    items: blockStyles
  }))), /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    flex: 1
  }, showActionMenu && /*#__PURE__*/_react.default.createElement(ActionMenuBox, {
    flex: collapsed ? undefined : 1,
    padding: isFullscreen ? 2 : 1,
    $withInsertMenu: showInsertMenu
  }, /*#__PURE__*/_react.default.createElement(_ActionMenu.ActionMenu, {
    disabled: disabled,
    collapsed: collapsed,
    groups: actionGroups,
    isFullscreen: isFullscreen
  })), showInsertMenu && /*#__PURE__*/_react.default.createElement(_ui.Box, {
    flex: collapsed ? undefined : 1,
    padding: isFullscreen ? 2 : 1
  }, /*#__PURE__*/_react.default.createElement(_InsertMenu.InsertMenu, {
    disabled: disabled,
    collapsed: collapsed,
    items: insertMenuItems,
    isFullscreen: isFullscreen
  }))), /*#__PURE__*/_react.default.createElement(FullscreenButtonBox, {
    padding: isFullscreen ? 2 : 1
  }, /*#__PURE__*/_react.default.createElement(_ui.Tooltip, {
    content: /*#__PURE__*/_react.default.createElement(_ui.Flex, {
      align: "center",
      padding: 1
    }, /*#__PURE__*/_react.default.createElement(_ui.Box, {
      flex: 1,
      paddingX: 1
    }, /*#__PURE__*/_react.default.createElement(_ui.Text, {
      size: 1
    }, "".concat(isFullscreen ? 'Collapse' : 'Expand', " editor"))), /*#__PURE__*/_react.default.createElement(_ui.Box, {
      marginLeft: 1
    }, /*#__PURE__*/_react.default.createElement(_ui.Hotkeys, {
      keys: ["".concat(IS_MAC ? 'Cmd' : 'Ctrl'), 'Enter']
    }))),
    placement: isFullscreen ? 'bottom' : 'top',
    portal: "default"
  }, /*#__PURE__*/_react.default.createElement(_ui.Button, {
    padding: 2,
    icon: isFullscreen ? _icons.CollapseIcon : _icons.ExpandIcon,
    mode: "bleed",
    onClick: onToggleFullscreen
  }))));
});

function Toolbar(props) {
  const {
    hotkeys,
    isFullscreen,
    readOnly,
    onExpand,
    onToggleFullscreen
  } = props;
  const features = (0, _hooks.useFeatures)();
  const editor = (0, _portableTextEditor.usePortableTextEditor)();
  const selection = (0, _portableTextEditor.usePortableTextEditorSelection)();
  const disabled = readOnly || !selection;
  const {
    push
  } = (0, _ui.useToast)();
  const resolveInitialValue = (0, _react.useCallback)(type => {
    let isSlow = false;
    const slowTimer = setTimeout(() => {
      isSlow = true;
      push({
        id: 'resolving-initial-value',
        status: 'info',
        title: 'Resolving initial value…'
      });
    }, SLOW_INITIAL_VALUE_LIMIT);
    return (0, _templates.resolveInitialValueForType)(type, {}).then(value => {
      if (isSlow) {
        // I found no way to close an existing toast, so this will replace the message in the
        // "Resolving initial value…"-toast and then make sure it gets closed.
        push({
          id: 'resolving-initial-value',
          status: 'info',
          duration: 500,
          title: 'Initial value resolved'
        });
      }

      return value;
    }).catch(error => {
      push({
        title: "Could not resolve initial value",
        id: 'resolving-initial-value',
        description: "Unable to resolve initial value for type: ".concat(type.name, ": ").concat(error.message, "."),
        status: 'error'
      });
      return undefined;
    }).finally(() => clearTimeout(slowTimer));
  }, [push]);
  const handleInsertBlock = (0, _react.useCallback)(async type => {
    const initialValue = await resolveInitialValue(type);

    const path = _portableTextEditor.PortableTextEditor.insertBlock(editor, type, initialValue);

    if (path) {
      _portableTextEditor.PortableTextEditor.blur(editor);

      onExpand(path);
    }
  }, [editor, onExpand, resolveInitialValue]);
  const handleInsertInline = (0, _react.useCallback)(async type => {
    const initialValue = await resolveInitialValue(type);

    const path = _portableTextEditor.PortableTextEditor.insertChild(editor, type, initialValue);

    if (path) {
      _portableTextEditor.PortableTextEditor.blur(editor);

      onExpand(path);
    }
  }, [editor, onExpand, resolveInitialValue]);
  const actionGroups = (0, _hooks.useActionGroups)({
    hotkeys,
    onExpand,
    resolveInitialValue,
    disabled: true
  });
  const blockStyles = (0, _react.useMemo)(() => (0, _helpers.getBlockStyles)(features), [features]);
  const insertMenuItems = (0, _react.useMemo)(() => (0, _helpers.getInsertMenuItems)(features, disabled, handleInsertBlock, handleInsertInline), [disabled, features, handleInsertBlock, handleInsertInline]);
  return /*#__PURE__*/_react.default.createElement(InnerToolbar, {
    actionGroups: actionGroups,
    blockStyles: blockStyles,
    disabled: disabled,
    insertMenuItems: insertMenuItems,
    isFullscreen: isFullscreen,
    onToggleFullscreen: onToggleFullscreen
  });
}