"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useActionGroups = useActionGroups;
exports.useActiveActionKeys = useActiveActionKeys;
exports.useActiveStyleKeys = useActiveStyleKeys;
exports.useFeatures = useFeatures;
exports.useFocusBlock = useFocusBlock;
exports.useFocusChild = useFocusChild;

var _portableTextEditor = require("@sanity/portable-text-editor");

var _react = require("react");

var _util = require("../../../../util");

var _helpers = require("./helpers");

function useFocusBlock() {
  const editor = (0, _portableTextEditor.usePortableTextEditor)();
  const selection = (0, _portableTextEditor.usePortableTextEditorSelection)(); // eslint-disable-next-line react-hooks/exhaustive-deps

  return (0, _react.useMemo)(() => _portableTextEditor.PortableTextEditor.focusBlock(editor), [editor, selection]); // selection must be an additional dep here
}

function useFocusChild() {
  const editor = (0, _portableTextEditor.usePortableTextEditor)();
  const selection = (0, _portableTextEditor.usePortableTextEditorSelection)(); // eslint-disable-next-line react-hooks/exhaustive-deps

  return (0, _react.useMemo)(() => _portableTextEditor.PortableTextEditor.focusChild(editor), [editor, selection]); // selection must be an additional dep here
}

function useFeatures() {
  const editor = (0, _portableTextEditor.usePortableTextEditor)();
  return (0, _react.useMemo)(() => _portableTextEditor.PortableTextEditor.getPortableTextFeatures(editor), [editor]);
}

function useActionGroups(_ref) {
  let {
    hotkeys,
    onExpand,
    resolveInitialValue,
    disabled
  } = _ref;
  const editor = (0, _portableTextEditor.usePortableTextEditor)();
  const handleInsertAnnotation = (0, _react.useCallback)(async type => {
    const initialValue = await resolveInitialValue(type);

    const paths = _portableTextEditor.PortableTextEditor.addAnnotation(editor, type, initialValue);

    if (paths && paths.markDefPath) {
      _portableTextEditor.PortableTextEditor.blur(editor);

      onExpand(paths.markDefPath);
    }
  }, [editor, onExpand, resolveInitialValue]);
  return (0, _react.useMemo)(() => editor ? (0, _helpers.getPTEToolbarActionGroups)(editor, disabled, handleInsertAnnotation, hotkeys) : [], [disabled, editor, handleInsertAnnotation, hotkeys]);
}

function useActiveActionKeys(_ref2) {
  let {
    actions
  } = _ref2;
  const editor = (0, _portableTextEditor.usePortableTextEditor)();
  const selection = (0, _portableTextEditor.usePortableTextEditorSelection)();
  return (0, _util.useUnique)((0, _react.useMemo)(() => {
    const activeAnnotationKeys = _portableTextEditor.PortableTextEditor.activeAnnotations(editor).map(a => a._type);

    return actions.filter(a => {
      if (a.type === 'annotation') {
        return activeAnnotationKeys.includes(a.key);
      }

      if (a.type === 'listStyle') {
        return _portableTextEditor.PortableTextEditor.hasListStyle(editor, a.key);
      }

      return _portableTextEditor.PortableTextEditor.isMarkActive(editor, a.key);
    }).map(a => a.key);
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [editor, // This is needed so that active actions update as `selection` changes
  selection]));
}

function useActiveStyleKeys(_ref3) {
  let {
    items
  } = _ref3;
  const editor = (0, _portableTextEditor.usePortableTextEditor)();
  const focusBlock = useFocusBlock();
  const selection = (0, _portableTextEditor.usePortableTextEditorSelection)();
  return (0, _util.useUnique)((0, _react.useMemo)(() => items.filter(i => _portableTextEditor.PortableTextEditor.hasBlockStyle(editor, i.style)).map(i => i.style), //  eslint-disable-next-line react-hooks/exhaustive-deps
  [focusBlock, // This is needed so that active styles update as `selection` changes
  selection]));
}