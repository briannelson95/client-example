"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectEditModal = ObjectEditModal;

var _portableTextEditor = require("@sanity/portable-text-editor");

var _react = _interopRequireWildcard(require("react"));

var _helpers = require("../helpers");

var _DefaultEditDialog = require("./DefaultEditDialog");

var _PopoverEditDialog = require("./PopoverEditDialog");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ObjectEditModal(props) {
  const {
    memberItem,
    onClose,
    scrollElement,
    kind
  } = props;
  const {
    schemaType
  } = memberItem.node;
  const modalOption = (0, _react.useMemo)(() => (0, _helpers._getModalOption)({
    schemaType
  }), [schemaType]);
  const modalType = (0, _react.useMemo)(() => {
    if (modalOption.type) return modalOption.type; // If the object is inline or an annotation, then default to "popover"

    if (kind === 'inlineObject' || kind === 'annotation') return 'popover';
    return 'dialog';
  }, [kind, modalOption]);
  const [firstField, setFirstField] = (0, _react.useState)(null);
  const editor = (0, _portableTextEditor.usePortableTextEditor)();
  const initialSelection = (0, _react.useRef)(_portableTextEditor.PortableTextEditor.getSelection(editor));
  const handleClose = (0, _react.useCallback)(() => {
    onClose(); // Force a new selection here as the selection is a callback dep. for showing the popup

    _portableTextEditor.PortableTextEditor.select(editor, null);

    _portableTextEditor.PortableTextEditor.focus(editor);

    _portableTextEditor.PortableTextEditor.select(editor, initialSelection.current);
  }, [editor, onClose]);

  const title = /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, "Edit ", memberItem.node.schemaType.title); // Set focus on the first field


  (0, _react.useEffect)(() => {
    if (firstField) {
      return;
    }

    const firstFieldMember = memberItem.node.members.find(m => m.kind === 'field');

    if (firstFieldMember && firstFieldMember.kind === 'field') {
      const firstFieldElm = document.getElementById(firstFieldMember.field.id);

      if (firstFieldElm) {
        setFirstField(firstFieldElm);
        firstFieldElm.focus();
      }
    }
  }, [firstField, memberItem]);

  if (modalType === 'popover') {
    return /*#__PURE__*/_react.default.createElement(_PopoverEditDialog.PopoverEditDialog, {
      elementRef: memberItem.elementRef,
      onClose: handleClose,
      scrollElement: scrollElement,
      title: title
    }, props.children);
  }

  return /*#__PURE__*/_react.default.createElement(_DefaultEditDialog.DefaultEditDialog, {
    title: title,
    onClose: handleClose
  }, props.children);
}