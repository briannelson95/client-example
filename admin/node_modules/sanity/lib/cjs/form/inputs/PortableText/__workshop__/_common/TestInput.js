"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TestInput = TestInput;

var _react = _interopRequireWildcard(require("react"));

var _studio = require("../../../../../studio");

var _simplePatch = require("../../../../patch/simplePatch");

var _PatchChannel = require("../../../../patch/PatchChannel");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function TestInput(props) {
  const {
    markers: markersProp = [],
    validation: validationProp = [],
    readOnly = false,
    renderBlockActions,
    renderCustomMarkers,
    type,
    value: valueProp = [],
    withError = false,
    withWarning = false,
    withCustomMarkers = false
  } = props;
  const {
    form
  } = (0, _studio.useSource)();
  const [value, setValue] = (0, _react.useState)(valueProp);
  const [focusPath, setFocusPath] = (0, _react.useState)([]);
  const blockType = (0, _react.useMemo)(() => {
    var _type$of;

    return (_type$of = type.of) === null || _type$of === void 0 ? void 0 : _type$of.find(t => {
      var _t$type;

      return ((_t$type = t.type) === null || _t$type === void 0 ? void 0 : _t$type.name) === 'block';
    });
  }, [type]);
  const presence = (0, _react.useMemo)(() => [], []);
  const hotkeys = (0, _react.useMemo)(() => ({}), []);
  const [markers, setMarkers] = (0, _react.useState)([]);
  const [validation, setValidation] = (0, _react.useState)([]); // const resolveInputComponent: FormInputComponentResolver = useCallback(
  //   (_type) => inputResolver(_type, form),
  //   [form]
  // )

  const onFocus = (0, _react.useCallback)(pathOrEvent => {
    setFocusPath(Array.isArray(pathOrEvent) ? pathOrEvent : []);
  }, []);
  const onBlur = (0, _react.useCallback)(() => {
    setFocusPath([]);
  }, []);
  const onChange = (0, _react.useCallback)(event => {
    setValue(prevValue => (0, _simplePatch.applyAll)(prevValue, event.patches));
  }, []); // useEffect(() => {
  //   if (value) {
  //     const newValidation = [...validationProp]
  //     const newMarkers = [...markersProp]
  //     value.forEach((blk) => {
  //       if (blk._type === blockType.name) {
  //         const inline = blk.children.find((child) => child._type !== 'span')
  //         const annotation = blk.markDefs[0]
  //         if (inline) {
  //           if (withError) {
  //             newValidation.push({
  //               level: 'error',
  //               path: [{_key: blk._key}, 'children', {_key: inline._key}],
  //               item: {message: 'There is an error with this inline object'},
  //             })
  //           }
  //           if (withWarning) {
  //             newValidation.push({
  //               level: 'warning',
  //               path: [{_key: blk._key}, 'children', {_key: inline._key}],
  //               item: {message: 'This is a warning'},
  //             })
  //           }
  //           if (withCustomMarkers) {
  //             newMarkers.push({
  //               type: 'customMarkerTest',
  //               path: [{_key: blk._key}, 'children', {_key: inline._key}],
  //             })
  //           }
  //         } else if (annotation) {
  //           if (withError) {
  //             newValidation.push({
  //               level: 'error',
  //               path: [{_key: blk._key}, 'markDefs', {_key: annotation._key}],
  //               item: {message: 'There an error with this annotation'},
  //             })
  //           }
  //           if (withWarning) {
  //             newValidation.push({
  //               level: 'warning',
  //               path: [{_key: blk._key}, 'markDefs', {_key: annotation._key}],
  //               item: {message: 'This is a warning'},
  //             })
  //           }
  //           if (withCustomMarkers) {
  //             newMarkers.push({
  //               type: 'customMarkerTest',
  //               path: [{_key: blk._key}, 'markDefs', {_key: annotation._key}],
  //             })
  //           }
  //         } else {
  //           if (withError) {
  //             newValidation.push({
  //               level: 'error',
  //               path: [{_key: blk._key}],
  //               item: {message: 'There is an error with this textblock'},
  //             })
  //           }
  //           if (withWarning) {
  //             newValidation.push({
  //               level: 'warning',
  //               path: [{_key: blk._key}],
  //               item: {message: 'This is a warning'},
  //             })
  //           }
  //           if (withCustomMarkers) {
  //             newMarkers.push({
  //               type: 'customMarkerTest',
  //               path: [{_key: blk._key}],
  //             })
  //           }
  //         }
  //       } else {
  //         if (withError) {
  //           newValidation.push({
  //             level: 'error',
  //             path: [{_key: blk._key}, 'title'],
  //             item: {message: 'There is an error with this object block'},
  //           })
  //         }
  //         if (withWarning) {
  //           newValidation.push({
  //             level: 'warning',
  //             path: [{_key: blk._key}, 'title'],
  //             item: {message: 'This is a warning'},
  //           })
  //         }
  //         if (withCustomMarkers) {
  //           newMarkers.push({
  //             type: 'customMarkerTest',
  //             path: [{_key: blk._key}],
  //           })
  //         }
  //       }
  //     })
  //     setMarkers(newMarkers)
  //     setValidation(newValidation)
  //   }
  //   if (!withError && !withCustomMarkers && !withWarning) {
  //     setMarkers(markersProp)
  //     setValidation(validationProp)
  //   }
  // }, [blockType, markersProp, validationProp, value, withCustomMarkers, withError, withWarning])

  const patchChannel = (0, _react.useMemo)(() => (0, _PatchChannel.createPatchChannel)(), []);
  (0, _react.useEffect)(() => {
    setValue(props.value || []);
  }, [props.value]);
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, "TODO"); // return (
  //   <FormBuilderProvider
  //     __internal_patchChannel={patchChannel}
  //     onChange={onChange}
  //     value={value}
  //     {...formBuilder}
  //   >
  //     <ReviewChangesContextProvider changesOpen={false}>
  //       {/* <Box
  //         style={{
  //          width: '300px',
  //          height: '300px',
  //          position: 'absolute',
  //          bottom: 0,
  //          zIndex: 9999,
  //          padding: 10,
  //          left: 0,
  //         }}
  //         >
  //         <Box marginBottom={3}>
  //          <Heading size={1}>FocusPath</Heading>
  //         </Box>
  //         <Box>
  //          <Code size={5}>{JSON.stringify(focusPath, null, 2)}</Code>
  //         </Box>
  //         </Box> */}
  //       <>TODO</>
  //       {/* <PortableTextInput
  //         focusPath={focusPath}
  //         hotkeys={hotkeys}
  //         level={1}
  //         markers={markers}
  //         validation={validation}
  //         onBlur={onBlur}
  //         onChange={onChange}
  //         onFocus={onFocus}
  //         presence={presence}
  //         readOnly={readOnly}
  //         renderBlockActions={renderBlockActions}
  //         renderCustomMarkers={renderCustomMarkers}
  //         type={props.type as any}
  //         value={value}
  //       /> */}
  //     </ReviewChangesContextProvider>
  //   </FormBuilderProvider>
  // )
}