"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditObjectsStory = EditObjectsStory;

var _ui = require("@sanity/ui");

var _uiWorkshop = require("@sanity/ui-workshop");

var _react = _interopRequireWildcard(require("react"));

var _studio = require("../../../../../studio");

var _PatchChannel = require("../../../../patch/PatchChannel");

var _empty = require("../../../../utils/empty");

var _schemaType = require("./schemaType");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import {resolveInputComponent, resolvePreviewComponent} from './formBuilder'
const TYPE_OPTIONS = {
  Annotation: 'annotation',
  'Object block': 'blockObject',
  'Inline object': 'inlineObject'
};
const TYPE_DATA = {
  annotation: {
    editorPath: [{
      _key: '1'
    }, 'children', {
      _key: '1-2'
    }],
    focusPath: [{
      _key: '1'
    }, 'markDefs', {
      _key: 'm1'
    }]
  },
  blockObject: {
    editorPath: undefined,
    focusPath: [{
      _key: '2'
    }]
  },
  inlineObject: {
    editorPath: undefined,
    focusPath: [{
      _key: '1'
    }, 'children', {
      _key: '1-3'
    }]
  }
};

function EditObjectsStory() {
  const open = (0, _uiWorkshop.useBoolean)('Open', false);
  const kind = (0, _uiWorkshop.useSelect)('Kind', TYPE_OPTIONS, 'annotation') || 'annotation';
  const portal = (0, _ui.usePortal)();
  const {
    form
  } = (0, _studio.useSource)();
  const {
    editorPath,
    focusPath
  } = (0, _react.useMemo)(() => {
    var _TYPE_DATA$kind, _TYPE_DATA$kind2, _TYPE_DATA$kind3;

    if (!open) {
      return {
        editorPath: _empty.EMPTY_ARRAY,
        focusPath: _empty.EMPTY_ARRAY
      };
    }

    return {
      editorPath: ((_TYPE_DATA$kind = TYPE_DATA[kind]) === null || _TYPE_DATA$kind === void 0 ? void 0 : _TYPE_DATA$kind.editorPath) || ((_TYPE_DATA$kind2 = TYPE_DATA[kind]) === null || _TYPE_DATA$kind2 === void 0 ? void 0 : _TYPE_DATA$kind2.focusPath) || _empty.EMPTY_ARRAY,
      focusPath: ((_TYPE_DATA$kind3 = TYPE_DATA[kind]) === null || _TYPE_DATA$kind3 === void 0 ? void 0 : _TYPE_DATA$kind3.focusPath) || _empty.EMPTY_ARRAY
    };
  }, [kind, open]);
  const markers = (0, _react.useMemo)(() => [], []);
  const presence = (0, _react.useMemo)(() => [], []);
  const readOnly = false;
  const value = (0, _react.useMemo)(() => [{
    _type: 'block',
    _key: '1',
    children: [{
      _type: 'span',
      _key: '1-1',
      text: 'test'
    }, {
      _type: 'span',
      _key: '1-2',
      text: 'annotation',
      marks: ['m1']
    }, {
      _type: 'myInlineObject',
      _key: '1-3',
      title: 'The inline object'
    }],
    markDefs: [{
      _type: 'link',
      _key: 'm1',
      url: 'test'
    }]
  }, {
    _type: 'myObjectBlock',
    _key: '2'
  }], []);
  const objectEditData = (0, _react.useMemo)(() => ({
    editorPath,
    formBuilderPath: focusPath,
    kind: kind,
    returnToSelection: null
  }), [editorPath, focusPath, kind]);
  const handleBlur = (0, _uiWorkshop.useAction)('onBlur');
  const handleChange = (0, _uiWorkshop.useAction)('onChange');
  const handleClose = (0, _uiWorkshop.useAction)('onClose');
  const handleFocus = (0, _uiWorkshop.useAction)('onFocus');
  const patchChannel = (0, _react.useMemo)(() => (0, _PatchChannel.createPatchChannel)(), []);

  const type = _schemaType.schema.get('body');

  if (!type) {
    return /*#__PURE__*/_react.default.createElement(_ui.Card, {
      height: "fill",
      overflow: "auto",
      tone: "critical"
    }, /*#__PURE__*/_react.default.createElement(_ui.Stack, {
      padding: 4,
      space: 4
    }, /*#__PURE__*/_react.default.createElement(_ui.Text, {
      weight: "bold"
    }, "\"body\" type not found"), /*#__PURE__*/_react.default.createElement(_ui.Code, {
      language: "json",
      size: 1
    }, JSON.stringify({
      schema: _schemaType.schema._original,
      schemaErrors: _schemaType.schema._validation
    }, null, 2))));
  }

  return /*#__PURE__*/_react.default.createElement(_ui.PortalProvider, {
    __unstable_elements: {
      default: portal.element
    }
  });
}