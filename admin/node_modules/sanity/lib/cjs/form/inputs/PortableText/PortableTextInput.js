"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PortableTextInput = PortableTextInput;

var _debounce2 = _interopRequireDefault(require("lodash/debounce"));

var _portableTextEditor = require("@sanity/portable-text-editor");

var _react = _interopRequireWildcard(require("react"));

var _rxjs = require("rxjs");

var _ui = require("@sanity/ui");

var _scrollIntoViewIfNeeded = _interopRequireDefault(require("scroll-into-view-if-needed"));

var _empty = require("../../utils/empty");

var _asserters = require("../../members/fields/asserters");

var _paths = require("../../../field/paths");

var _Compositor = require("./Compositor");

var _InvalidValue = require("./InvalidValue");

var _usePatches = require("./usePatches");

var _VisibleOnFocusButton = require("./VisibleOnFocusButton");

var _PortableTextMarkers = require("./contexts/PortableTextMarkers");

var _PortableTextMembers = require("./contexts/PortableTextMembers");

var _helpers = require("./_helpers");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/**
 * The root Portable Text Input component
 *
 * @alpha
 */
function PortableTextInput(props) {
  const {
    focused,
    focusPath,
    focusRef,
    hotkeys,
    markers = _empty.EMPTY_ARRAY,
    members,
    onChange,
    onCopy,
    onFocusPath,
    onInsert,
    onPaste,
    path,
    readOnly: readOnlyFromProps,
    renderBlockActions,
    renderCustomMarkers,
    schemaType: type,
    value
  } = props; // Make the PTE focusable from the outside

  (0, _react.useImperativeHandle)(focusRef, () => ({
    focus() {
      if (editorRef.current) {
        _portableTextEditor.PortableTextEditor.focus(editorRef.current);
      }
    }

  }));
  const {
    subscribe
  } = (0, _usePatches.usePatches)({
    path
  });
  const editorRef = (0, _react.useRef)(null);
  const [hasFocus, setHasFocus] = (0, _react.useState)(false);
  const [ignoreValidationError, setIgnoreValidationError] = (0, _react.useState)(false);
  const [invalidValue, setInvalidValue] = (0, _react.useState)(null);
  const [isFullscreen, setIsFullscreen] = (0, _react.useState)(false);
  const [isActive, setIsActive] = (0, _react.useState)(false);
  const readOnly = (0, _react.useMemo)(() => {
    return isActive ? Boolean(readOnlyFromProps) : true;
  }, [isActive, readOnlyFromProps]);
  const toast = (0, _ui.useToast)();
  const portableTextMemberItemsRef = (0, _react.useRef)([]); // Memoized patch stream

  const patchSubject = (0, _react.useMemo)(() => new _rxjs.Subject(), []);
  const remotePatch$ = (0, _react.useMemo)(() => patchSubject.asObservable(), [patchSubject]);
  const innerElementRef = (0, _react.useRef)(null);
  const handleToggleFullscreen = (0, _react.useCallback)(() => {
    if (editorRef.current) {
      const prevSel = _portableTextEditor.PortableTextEditor.getSelection(editorRef.current);

      setIsFullscreen(v => !v);
      setTimeout(() => {
        if (editorRef.current) {
          _portableTextEditor.PortableTextEditor.focus(editorRef.current);

          if (prevSel) {
            _portableTextEditor.PortableTextEditor.select(editorRef.current, { ...prevSel
            });
          }
        }
      });
    }
  }, []); // Reset invalidValue if new value is coming in from props

  (0, _react.useEffect)(() => {
    if (invalidValue && value !== invalidValue.value) {
      setInvalidValue(null);
    }
  }, [invalidValue, value]); // Subscribe to patches

  (0, _react.useEffect)(() => {
    return subscribe(_ref => {
      let {
        patches,
        snapshot
      } = _ref;
      patchSubject.next({
        patches,
        snapshot
      });
    });
  }, [patchSubject, subscribe]); // Populate the portableTextMembers Map

  const portableTextMemberItems = (0, _react.useMemo)(() => {
    const result = [];

    for (const member of members) {
      if (member.kind === 'item') {
        if (!(0, _helpers._isBlockType)(member.item.schemaType)) {
          result.push({
            kind: 'objectBlock',
            member,
            node: member.item
          });
        } else if (member.item.validation.length > 0 || member.item.changed) {
          // Only text blocks that have validation or changes
          result.push({
            kind: 'textBlock',
            member,
            node: member.item
          });
        }

        if ((0, _helpers._isBlockType)(member.item.schemaType)) {
          // Inline objects
          const childrenField = member.item.members.find(f => f.kind === 'field' && f.name === 'children');

          if (childrenField && childrenField.kind === 'field' && (0, _asserters.isMemberArrayOfObjects)(childrenField)) {
            // eslint-disable-next-line max-depth
            for (const child of childrenField.field.members) {
              // eslint-disable-next-line max-depth
              if (child.kind === 'item' && child.item.schemaType.name !== 'span') {
                result.push({
                  kind: 'inlineObject',
                  member: child,
                  node: child.item
                });
              }
            }
          } // Markdefs


          const markDefArrayMember = member.item.members.filter(_helpers._isArrayOfObjectsFieldMember).find(f => f.name === 'markDefs');

          if (markDefArrayMember) {
            // eslint-disable-next-line max-depth
            for (const child of markDefArrayMember.field.members) {
              // eslint-disable-next-line max-depth
              if (child.kind === 'item' && child.item.schemaType.jsonType === 'object') {
                result.push({
                  kind: 'annotation',
                  member: child,
                  node: child.item
                });
              }
            }
          }
        }
      }
    }

    const items = result.map(r => {
      const key = (0, _paths.pathToString)(r.node.path.slice(path.length));
      const existingItem = portableTextMemberItemsRef.current.find(ref => ref.key === key);

      if (existingItem) {
        existingItem.member = r.member;
        existingItem.node = r.node;
        return existingItem;
      }

      return {
        kind: r.kind,
        key,
        member: r.member,
        node: r.node,
        elementRef: /*#__PURE__*/(0, _react.createRef)()
      };
    });
    portableTextMemberItemsRef.current = items;
    return items;
  }, [members, path]);
  const hasOpenItem = (0, _react.useMemo)(() => {
    return portableTextMemberItems.some(item => item.member.open);
  }, [portableTextMemberItems]); // Sets the focusPath from editor selection (when typing, moving the cursor, clicking around)
  // This doesn't need to be immediate, so debounce it as it impacts performance.

  const setFocusPathDebounced = (0, _react.useMemo)(() => (0, _debounce2.default)(sel => {
    if (sel && hasFocus) onFocusPath(sel.focus.path);
  }, 500, {
    trailing: true,
    leading: false
  }), [hasFocus, onFocusPath]); // Handle editor changes

  const handleEditorChange = (0, _react.useCallback)(change => {
    switch (change.type) {
      case 'mutation':
        onChange(change.patches);
        break;

      case 'selection':
        setFocusPathDebounced(change.selection);
        break;

      case 'focus':
        setHasFocus(true);
        break;

      case 'blur':
        setHasFocus(false);
        break;

      case 'undo':
      case 'redo':
        onChange(change.patches);
        break;

      case 'invalidValue':
        setInvalidValue(change);
        break;

      case 'error':
        toast.push({
          status: change.level,
          description: change.description
        });
        break;

      default:
    }
  }, [onChange, toast, setFocusPathDebounced]);
  const handleFocusSkipperClick = (0, _react.useCallback)(() => {
    if (editorRef.current) {
      _portableTextEditor.PortableTextEditor.focus(editorRef.current);
    }
  }, [editorRef]);
  const handleIgnoreInvalidValue = (0, _react.useCallback)(() => {
    setIgnoreValidationError(true);
  }, []);
  const respondToInvalidContent = (0, _react.useMemo)(() => {
    if (invalidValue && invalidValue.resolution) {
      return /*#__PURE__*/_react.default.createElement(_ui.Box, {
        marginBottom: 2
      }, /*#__PURE__*/_react.default.createElement(_InvalidValue.InvalidValue, {
        onChange: handleEditorChange,
        onIgnore: handleIgnoreInvalidValue,
        resolution: invalidValue.resolution
      }));
    }

    return null;
  }, [handleEditorChange, handleIgnoreInvalidValue, invalidValue]);
  const handleActivate = (0, _react.useCallback)(() => {
    if (!isActive) {
      setIsActive(true); // Focus the editor in the next tick if needed
      // Next tick because we are in a re-rendering phase of the editor at this point (activating it).

      if (!hasFocus) {
        setTimeout(() => {
          if (editorRef.current) {
            _portableTextEditor.PortableTextEditor.focus(editorRef.current);
          }
        });
      }
    }
  }, [hasFocus, isActive]); // If the editor that has an opened item and isn't focused - scroll to the input if needed.

  (0, _react.useEffect)(() => {
    if (!hasFocus && hasOpenItem && innerElementRef.current) {
      (0, _scrollIntoViewIfNeeded.default)(innerElementRef.current, {
        scrollMode: 'if-needed'
      });
    }
  }, [focused, hasFocus, hasOpenItem]);
  return /*#__PURE__*/_react.default.createElement(_ui.Box, {
    ref: innerElementRef
  }, !readOnly && /*#__PURE__*/_react.default.createElement(_VisibleOnFocusButton.VisibleOnFocusButton, {
    onClick: handleFocusSkipperClick
  }, /*#__PURE__*/_react.default.createElement(_ui.Text, null, "Go to content")), !ignoreValidationError && respondToInvalidContent, (!invalidValue || ignoreValidationError) && /*#__PURE__*/_react.default.createElement(_PortableTextMarkers.PortableTextMarkersProvider, {
    markers: markers
  }, /*#__PURE__*/_react.default.createElement(_PortableTextMembers.PortableTextMemberItemsProvider, {
    memberItems: portableTextMemberItems
  }, /*#__PURE__*/_react.default.createElement(_portableTextEditor.PortableTextEditor, {
    ref: editorRef,
    incomingPatches$: remotePatch$,
    onChange: handleEditorChange,
    maxBlocks: undefined // TODO: from schema?
    ,
    readOnly: readOnly,
    type: type,
    value: value
  }, /*#__PURE__*/_react.default.createElement(_Compositor.Compositor, _extends({}, props, {
    focused: focused,
    focusPath: focusPath,
    hasFocus: hasFocus,
    hotkeys: hotkeys,
    isActive: isActive,
    isFullscreen: isFullscreen,
    onActivate: handleActivate,
    onChange: onChange,
    onCopy: onCopy,
    onInsert: onInsert,
    onPaste: onPaste,
    onToggleFullscreen: handleToggleFullscreen,
    readOnly: readOnly,
    renderBlockActions: renderBlockActions,
    renderCustomMarkers: renderCustomMarkers,
    value: value
  }))))));
}