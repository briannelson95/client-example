"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Compositor = Compositor;

var _react = _interopRequireWildcard(require("react"));

var _portableTextEditor = require("@sanity/portable-text-editor");

var _ui = require("@sanity/ui");

var _changeIndicators = require("../../../components/changeIndicators");

var _ActivateOnFocus = require("../../components/ActivateOnFocus/ActivateOnFocus");

var _empty = require("../../utils/empty");

var _FormInput = require("../../FormInput");

var _BlockObject = require("./object/BlockObject");

var _InlineObject = require("./object/InlineObject");

var _text = require("./text");

var _Editor = require("./Editor");

var _Compositor = require("./Compositor.styles");

var _useHotKeys = require("./hooks/useHotKeys");

var _ObjectEditModal = require("./object/renderers/ObjectEditModal");

var _useScrollToOpenedMember = require("./hooks/useScrollToOpenedMember");

var _usePortableTextMembers = require("./hooks/usePortableTextMembers");

var _helpers = require("./_helpers");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function isTouchDevice() {
  return typeof window !== 'undefined' && 'ontouchstart' in window || typeof navigator !== 'undefined' && navigator.maxTouchPoints > 0;
}

const activateVerb = isTouchDevice() ? 'Tap' : 'Click';

const ACTIVATE_ON_FOCUS_MESSAGE = /*#__PURE__*/_react.default.createElement(_ui.Text, {
  weight: "semibold"
}, activateVerb, " to activate");

function Compositor(props) {
  const {
    changed,
    focusPath = _empty.EMPTY_ARRAY,
    focused,
    hasFocus,
    hotkeys,
    isActive,
    isFullscreen,
    onChange,
    onCopy,
    onActivate,
    onOpenItem,
    onCloseItem,
    onPaste,
    onToggleFullscreen,
    path,
    renderBlockActions,
    renderCustomMarkers,
    value,
    readOnly,
    renderPreview
  } = props;
  const editor = (0, _portableTextEditor.usePortableTextEditor)();
  const [wrapperElement, setWrapperElement] = (0, _react.useState)(null);
  const [scrollElement, setScrollElement] = (0, _react.useState)(null);
  const portableTextMemberItems = (0, _usePortableTextMembers.usePortableTextMemberItems)();
  const {
    element: boundaryElement
  } = (0, _ui.useBoundaryElement)(); // Scroll to the DOM element of the "opened" portable text member when relevant.

  (0, _useScrollToOpenedMember.useScrollToOpenedMember)({
    hasFocus,
    editorRootPath: path,
    scrollElement,
    onCloseItem
  });
  const handleToggleFullscreen = (0, _react.useCallback)(() => {
    onToggleFullscreen();
  }, [onToggleFullscreen]);
  const hotkeysWithFullscreenToggle = (0, _react.useMemo)(() => ({ ...hotkeys,
    custom: {
      'mod+enter': onToggleFullscreen,
      ...((hotkeys === null || hotkeys === void 0 ? void 0 : hotkeys.custom) || {})
    }
  }), [hotkeys, onToggleFullscreen]);
  const editorHotkeys = (0, _useHotKeys.useHotkeys)(hotkeysWithFullscreenToggle);
  const ptFeatures = (0, _react.useMemo)(() => _portableTextEditor.PortableTextEditor.getPortableTextFeatures(editor), [editor]);
  const hasContent = !!value;
  const initialSelection = (0, _react.useMemo)(() => focusPath.length > 0 ? {
    anchor: {
      path: focusPath,
      offset: 0
    },
    focus: {
      path: focusPath,
      offset: 0
    }
  } : null, // eslint-disable-next-line react-hooks/exhaustive-deps
  [] // Only initial
  );
  const renderBlock = (0, _react.useCallback)((block, blockType, attributes, defaultRender) => {
    const isTextBlock = block._type === ptFeatures.types.block.name;

    if (isTextBlock) {
      return /*#__PURE__*/_react.default.createElement(_text.TextBlock, {
        attributes: attributes,
        block: block,
        isFullscreen: isFullscreen,
        onChange: onChange,
        readOnly: readOnly,
        renderBlockActions: hasContent ? renderBlockActions : undefined,
        renderCustomMarkers: hasContent ? renderCustomMarkers : undefined
      }, defaultRender(block));
    }

    return /*#__PURE__*/_react.default.createElement(_BlockObject.BlockObject, {
      attributes: attributes,
      block: block,
      isFullscreen: isFullscreen,
      onChange: onChange,
      onOpenItem: onOpenItem,
      readOnly: readOnly,
      renderBlockActions: hasContent ? renderBlockActions : undefined,
      renderCustomMarkers: hasContent ? renderCustomMarkers : undefined,
      renderPreview: renderPreview,
      type: blockType
    });
  }, [hasContent, isFullscreen, onChange, onOpenItem, ptFeatures.types.block.name, readOnly, renderBlockActions, renderCustomMarkers, renderPreview]);
  const renderChild = (0, _react.useCallback)((child, childType, attributes, defaultRender) => {
    const isSpan = child._type === ptFeatures.types.span.name;

    if (isSpan) {
      return defaultRender(child);
    }

    return /*#__PURE__*/_react.default.createElement(_InlineObject.InlineObject, {
      attributes: attributes,
      onOpenItem: onOpenItem,
      readOnly: readOnly,
      renderCustomMarkers: renderCustomMarkers,
      scrollElement: scrollElement,
      type: childType,
      value: child,
      renderPreview: renderPreview
    });
  }, [onOpenItem, ptFeatures.types.span.name, readOnly, renderCustomMarkers, renderPreview, scrollElement]);
  const renderAnnotation = (0, _react.useCallback)((annotation, annotationType, attributes, defaultRender) => {
    return /*#__PURE__*/_react.default.createElement(_text.Annotation, {
      attributes: attributes,
      onOpenItem: onOpenItem,
      readOnly: readOnly,
      renderCustomMarkers: renderCustomMarkers,
      scrollElement: scrollElement,
      value: annotation,
      type: annotationType
    }, defaultRender());
  }, [onOpenItem, readOnly, renderCustomMarkers, scrollElement]);
  const [portalElement, setPortalElement] = (0, _react.useState)(null);
  const openMemberItems = (0, _react.useMemo)(() => portableTextMemberItems.filter(m => m.member.open && !(0, _helpers._isBlockType)(m.node.schemaType)), [portableTextMemberItems]);
  const editorNode = (0, _react.useMemo)(() => /*#__PURE__*/_react.default.createElement(_Editor.Editor, {
    hotkeys: editorHotkeys,
    initialSelection: initialSelection,
    isFullscreen: isFullscreen,
    onOpenItem: onOpenItem,
    onCopy: onCopy,
    onPaste: onPaste,
    onToggleFullscreen: handleToggleFullscreen,
    path: path,
    readOnly: readOnly,
    renderAnnotation: renderAnnotation,
    renderBlock: renderBlock,
    renderChild: renderChild,
    setPortalElement: setPortalElement,
    scrollElement: scrollElement,
    setScrollElement: setScrollElement
  }), // Keep only stable ones here!
  [editorHotkeys, handleToggleFullscreen, initialSelection, isFullscreen, onCopy, onOpenItem, onPaste, path, readOnly, renderAnnotation, renderBlock, renderChild, scrollElement]);
  const boundaryElm = isFullscreen ? scrollElement : boundaryElement;
  const children = (0, _react.useMemo)(() => boundaryElm && /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, editorNode, /*#__PURE__*/_react.default.createElement(_ui.BoundaryElementProvider, {
    element: boundaryElm
  }, openMemberItems.map(dMemberItem => {
    return /*#__PURE__*/_react.default.createElement(_ObjectEditModal.ObjectEditModal, {
      kind: dMemberItem.kind,
      key: dMemberItem.member.key,
      memberItem: dMemberItem,
      onClose: onCloseItem,
      scrollElement: boundaryElm
    }, /*#__PURE__*/_react.default.createElement(_FormInput.FormInput, _extends({
      absolutePath: dMemberItem.node.path
    }, props)));
  }))), [boundaryElm, editorNode, openMemberItems, onCloseItem, props]);
  const portal = (0, _ui.usePortal)();
  const portalElements = (0, _react.useMemo)(() => ({
    collapsed: wrapperElement,
    default: portal.element,
    editor: portalElement,
    expanded: portal.element
  }), [portal.element, portalElement, wrapperElement]);
  const editorLayer = (0, _react.useMemo)(() => /*#__PURE__*/_react.default.createElement(_ui.Portal, {
    __unstable_name: isFullscreen ? 'expanded' : 'collapsed'
  }, /*#__PURE__*/_react.default.createElement(_Compositor.ExpandedLayer, {
    "data-fullscreen": isFullscreen ? '' : undefined
  }, children)), [children, isFullscreen]);
  return /*#__PURE__*/_react.default.createElement(_ui.PortalProvider, {
    __unstable_elements: portalElements
  }, /*#__PURE__*/_react.default.createElement(_ActivateOnFocus.ActivateOnFocus, {
    message: ACTIVATE_ON_FOCUS_MESSAGE,
    onActivate: onActivate,
    isOverlayActive: !isActive
  }, /*#__PURE__*/_react.default.createElement(_changeIndicators.ChangeIndicator, {
    disabled: isFullscreen,
    hasFocus: Boolean(focused),
    isChanged: changed,
    path: path
  }, /*#__PURE__*/_react.default.createElement(_Compositor.Root, {
    "data-focused": hasFocus ? '' : undefined,
    "data-read-only": readOnly ? '' : undefined
  }, /*#__PURE__*/_react.default.createElement("div", {
    "data-wrapper": "",
    ref: setWrapperElement
  }, editorLayer), /*#__PURE__*/_react.default.createElement("div", {
    "data-border": ""
  })))));
}