"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Calendar = void 0;

var _range2 = _interopRequireDefault(require("lodash/range"));

var _ui = require("@sanity/ui");

var _icons = require("@sanity/icons");

var _dateFns = require("date-fns");

var _react = _interopRequireWildcard(require("react"));

var _CalendarMonth = require("./CalendarMonth");

var _constants = require("./constants");

var _features = require("./features");

var _utils = require("./utils");

var _YearInput = require("./YearInput");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// This is used to maintain focus on a child element of the calendar-grid between re-renders
// When using arrow keys to move focus from a day in one month to another we are setting focus at the button for the day
// after it has changed but *only* if we *already* had focus inside the calendar grid (e.g not if focus was on the "next
// year" button, or any of the other controls)
// When moving from the last day of a month that displays 6 weeks in the grid to a month that displays 5 weeks, current
// focus gets lost on render, so this provides us with a stable element to help us preserve focus on a child element of
// the calendar grid between re-renders
const PRESERVE_FOCUS_ELEMENT = /*#__PURE__*/_react.default.createElement("span", {
  "data-preserve-focus": true,
  style: {
    overflow: 'hidden',
    position: 'absolute',
    outline: 'none'
  },
  tabIndex: -1
});

const Calendar = /*#__PURE__*/(0, _react.forwardRef)(function Calendar(props, forwardedRef) {
  const {
    selectTime,
    onFocusedDateChange,
    selectedDate = new Date(),
    focusedDate = selectedDate,
    timeStep = 1,
    onSelect,
    ...restProps
  } = props;
  const setFocusedDate = (0, _react.useCallback)(date => onFocusedDateChange(date), [onFocusedDateChange]);
  const setFocusedDateMonth = (0, _react.useCallback)(month => setFocusedDate((0, _dateFns.setDate)((0, _dateFns.setMonth)(focusedDate, month), 1)), [focusedDate, setFocusedDate]);
  const handleFocusedMonthChange = (0, _react.useCallback)(e => setFocusedDateMonth(Number(e.currentTarget.value)), [setFocusedDateMonth]);
  const moveFocusedDate = (0, _react.useCallback)(by => setFocusedDate((0, _dateFns.addMonths)(focusedDate, by)), [focusedDate, setFocusedDate]);
  const setFocusedDateYear = (0, _react.useCallback)(year => setFocusedDate((0, _dateFns.setYear)(focusedDate, year)), [focusedDate, setFocusedDate]);
  const handleDateChange = (0, _react.useCallback)(date => {
    onSelect((0, _dateFns.setMinutes)((0, _dateFns.setHours)(date, selectedDate.getHours()), selectedDate.getMinutes()));
  }, [onSelect, selectedDate]);
  const handleMinutesChange = (0, _react.useCallback)(event => {
    const m = Number(event.currentTarget.value);
    onSelect((0, _dateFns.setMinutes)(selectedDate, m));
  }, [onSelect, selectedDate]);
  const handleHoursChange = (0, _react.useCallback)(event => {
    const m = Number(event.currentTarget.value);
    onSelect((0, _dateFns.setHours)(selectedDate, m));
  }, [onSelect, selectedDate]);
  const handleTimeChange = (0, _react.useCallback)((hours, mins) => {
    onSelect((0, _dateFns.setHours)((0, _dateFns.setMinutes)(selectedDate, mins), hours));
  }, [onSelect, selectedDate]);
  const ref = (0, _ui.useForwardedRef)(forwardedRef);
  const focusCurrentWeekDay = (0, _react.useCallback)(() => {
    var _ref$current, _ref$current$querySel;

    (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : (_ref$current$querySel = _ref$current.querySelector("[data-focused=\"true\"]")) === null || _ref$current$querySel === void 0 ? void 0 : _ref$current$querySel.focus();
  }, [ref]);
  const handleKeyDown = (0, _react.useCallback)(event => {
    var _ref$current2, _ref$current2$querySe;

    if (!_constants.ARROW_KEYS.includes(event.key)) {
      return;
    }

    event.preventDefault();

    if (event.target.hasAttribute('data-calendar-grid')) {
      focusCurrentWeekDay();
      return;
    }

    if (event.key === 'ArrowUp') {
      onFocusedDateChange((0, _dateFns.addDays)(focusedDate, -7));
    }

    if (event.key === 'ArrowDown') {
      onFocusedDateChange((0, _dateFns.addDays)(focusedDate, 7));
    }

    if (event.key === 'ArrowLeft') {
      onFocusedDateChange((0, _dateFns.addDays)(focusedDate, -1));
    }

    if (event.key === 'ArrowRight') {
      onFocusedDateChange((0, _dateFns.addDays)(focusedDate, 1));
    } // set focus temporarily on this element to make sure focus is still inside the calendar-grid after re-render


    (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : (_ref$current2$querySe = _ref$current2.querySelector('[data-preserve-focus]')) === null || _ref$current2$querySe === void 0 ? void 0 : _ref$current2$querySe.focus();
  }, [ref, focusCurrentWeekDay, onFocusedDateChange, focusedDate]);
  (0, _react.useEffect)(() => {
    focusCurrentWeekDay();
  }, [focusCurrentWeekDay]);
  (0, _react.useEffect)(() => {
    var _document$activeEleme;

    const currentFocusInCalendarGrid = (_document$activeEleme = document.activeElement) === null || _document$activeEleme === void 0 ? void 0 : _document$activeEleme.matches('[data-calendar-grid], [data-calendar-grid] [data-preserve-focus]');

    if ( // Only move focus if it's currently in the calendar grid
    currentFocusInCalendarGrid) {
      focusCurrentWeekDay();
    }
  }, [ref, focusCurrentWeekDay, focusedDate]);
  const handleYesterdayClick = (0, _react.useCallback)(() => handleDateChange((0, _dateFns.addDays)(new Date(), -1)), [handleDateChange]);
  const handleTodayClick = (0, _react.useCallback)(() => handleDateChange(new Date()), [handleDateChange]);
  const handleTomorrowClick = (0, _react.useCallback)(() => handleDateChange((0, _dateFns.addDays)(new Date(), 1)), [handleDateChange]);
  const handleNowClick = (0, _react.useCallback)(() => onSelect(new Date()), [onSelect]);
  return /*#__PURE__*/_react.default.createElement(_ui.Box, _extends({
    "data-ui": "Calendar"
  }, restProps, {
    ref: ref
  }), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    padding: 2
  }, _features.features.dayPresets && /*#__PURE__*/_react.default.createElement(_ui.Grid, {
    columns: 3,
    "data-ui": "CalendaryDayPresets",
    gap: 1
  }, /*#__PURE__*/_react.default.createElement(_ui.Button, {
    text: "Yesterday",
    mode: "bleed",
    fontSize: 1,
    onClick: handleYesterdayClick
  }), /*#__PURE__*/_react.default.createElement(_ui.Button, {
    text: "Today",
    mode: "bleed",
    fontSize: 1,
    onClick: handleTodayClick
  }), /*#__PURE__*/_react.default.createElement(_ui.Button, {
    text: "Tomorrow",
    mode: "bleed",
    fontSize: 1,
    onClick: handleTomorrowClick
  })), /*#__PURE__*/_react.default.createElement(_ui.Flex, null, /*#__PURE__*/_react.default.createElement(_ui.Box, {
    flex: 1
  }, /*#__PURE__*/_react.default.createElement(CalendarMonthSelect, {
    moveFocusedDate: moveFocusedDate,
    onChange: handleFocusedMonthChange,
    value: focusedDate === null || focusedDate === void 0 ? void 0 : focusedDate.getMonth()
  })), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginLeft: 2
  }, /*#__PURE__*/_react.default.createElement(CalendarYearSelect, {
    moveFocusedDate: moveFocusedDate,
    onChange: setFocusedDateYear,
    value: focusedDate.getFullYear()
  }))), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    "data-calendar-grid": true,
    onKeyDown: handleKeyDown,
    marginTop: 2,
    overflow: "hidden",
    tabIndex: 0
  }, /*#__PURE__*/_react.default.createElement(_CalendarMonth.CalendarMonth, {
    date: focusedDate,
    focused: focusedDate,
    onSelect: handleDateChange,
    selected: selectedDate
  }), PRESERVE_FOCUS_ELEMENT)), selectTime && /*#__PURE__*/_react.default.createElement(_ui.Box, {
    padding: 2,
    style: {
      borderTop: '1px solid var(--card-border-color)'
    }
  }, /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    align: "center"
  }, /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    align: "center",
    flex: 1
  }, /*#__PURE__*/_react.default.createElement(_ui.Box, null, /*#__PURE__*/_react.default.createElement(_ui.Select, {
    "aria-label": "Select hour",
    value: selectedDate === null || selectedDate === void 0 ? void 0 : selectedDate.getHours(),
    onChange: handleHoursChange
  }, _constants.HOURS_24.map(h => /*#__PURE__*/_react.default.createElement("option", {
    key: h,
    value: h
  }, "".concat(h).padStart(2, '0'))))), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    paddingX: 1
  }, /*#__PURE__*/_react.default.createElement(_ui.Text, null, ":")), /*#__PURE__*/_react.default.createElement(_ui.Box, null, /*#__PURE__*/_react.default.createElement(_ui.Select, {
    "aria-label": "Select minutes",
    value: selectedDate === null || selectedDate === void 0 ? void 0 : selectedDate.getMinutes(),
    onChange: handleMinutesChange
  }, (0, _range2.default)(0, 60, timeStep).map(m => /*#__PURE__*/_react.default.createElement("option", {
    key: m,
    value: m
  }, "".concat(m).padStart(2, '0')))))), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginLeft: 2
  }, /*#__PURE__*/_react.default.createElement(_ui.Button, {
    text: "Set to current time",
    mode: "bleed",
    onClick: handleNowClick
  }))), _features.features.timePresets && /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    direction: "row",
    justify: "center",
    align: "center",
    style: {
      marginTop: 5
    }
  }, _constants.DEFAULT_TIME_PRESETS.map(_ref => {
    let [hours, minutes] = _ref;
    return /*#__PURE__*/_react.default.createElement(CalendarTimePresetButton, {
      key: "".concat(hours, "-").concat(minutes),
      hours: hours,
      minutes: minutes,
      onTimeChange: handleTimeChange,
      selectedDate: selectedDate
    });
  }))));
});
exports.Calendar = Calendar;

function CalendarTimePresetButton(props) {
  const {
    hours,
    minutes,
    onTimeChange,
    selectedDate
  } = props;
  const formatted = (0, _utils.formatTime)(hours, minutes);
  const handleClick = (0, _react.useCallback)(() => {
    onTimeChange(hours, minutes);
  }, [hours, minutes, onTimeChange]);
  return /*#__PURE__*/_react.default.createElement(_ui.Button, {
    text: formatted,
    "aria-label": "".concat(formatted, " on ").concat(selectedDate.toDateString()),
    mode: "bleed",
    fontSize: 1,
    onClick: handleClick
  });
}

function CalendarMonthSelect(props) {
  const {
    moveFocusedDate,
    onChange,
    value
  } = props;
  const handlePrevMonthClick = (0, _react.useCallback)(() => moveFocusedDate(-1), [moveFocusedDate]);
  const handleNextMonthClick = (0, _react.useCallback)(() => moveFocusedDate(1), [moveFocusedDate]);
  return /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    flex: 1
  }, /*#__PURE__*/_react.default.createElement(_ui.Button, {
    "aria-label": "Go to previous month",
    onClick: handlePrevMonthClick,
    mode: "bleed",
    icon: _icons.ChevronLeftIcon,
    paddingX: 2,
    radius: 0
  }), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    flex: 1
  }, /*#__PURE__*/_react.default.createElement(_ui.Select, {
    radius: 0,
    value: value,
    onChange: onChange
  }, _constants.MONTH_NAMES.map((m, i) =>
  /*#__PURE__*/
  // eslint-disable-next-line react/no-array-index-key
  _react.default.createElement("option", {
    key: i,
    value: i
  }, m)))), /*#__PURE__*/_react.default.createElement(_ui.Button, {
    "aria-label": "Go to next month",
    mode: "bleed",
    icon: _icons.ChevronRightIcon,
    onClick: handleNextMonthClick,
    paddingX: 2,
    radius: 0
  }));
}

function CalendarYearSelect(props) {
  const {
    moveFocusedDate,
    onChange,
    value
  } = props;
  const handlePrevYearClick = (0, _react.useCallback)(() => moveFocusedDate(-12), [moveFocusedDate]);
  const handleNextYearClick = (0, _react.useCallback)(() => moveFocusedDate(12), [moveFocusedDate]);
  return /*#__PURE__*/_react.default.createElement(_ui.Flex, null, /*#__PURE__*/_react.default.createElement(_ui.Button, {
    "aria-label": "Previous year",
    onClick: handlePrevYearClick,
    mode: "bleed",
    icon: _icons.ChevronLeftIcon,
    paddingX: 2,
    radius: 0
  }), /*#__PURE__*/_react.default.createElement(_YearInput.YearInput, {
    value: value,
    onChange: onChange,
    radius: 0,
    style: {
      width: 65
    }
  }), /*#__PURE__*/_react.default.createElement(_ui.Button, {
    "aria-label": "Next year",
    onClick: handleNextYearClick,
    mode: "bleed",
    icon: _icons.ChevronRightIcon,
    paddingX: 2,
    radius: 0
  }));
}