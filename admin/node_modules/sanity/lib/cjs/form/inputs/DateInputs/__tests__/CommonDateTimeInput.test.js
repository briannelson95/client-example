"use strict";

var _react = require("@testing-library/react");

var _userEvent = _interopRequireDefault(require("@testing-library/user-event"));

var _dateFns = require("date-fns");

var _react2 = _interopRequireDefault(require("react"));

var _types = require("@sanity/types");

var _CommonDateTimeInput = require("../CommonDateTimeInput");

var _utils = require("../utils");

var _form = require("../../../../../test/form");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parseInputValue(input) {
  const candidate = (0, _dateFns.parse)(input, 'yyyy-MM-dd HH:mm', 0);
  if ((0, _utils.isValidDate)(candidate)) return {
    isValid: true,
    date: candidate
  };
  return {
    isValid: false,
    error: "Invalid date string: ".concat(input)
  };
}

function formatInputValue(date) {
  return (0, _dateFns.format)(date, 'yyyy-MM-dd HH:mm');
}

function deserialize(value) {
  const deserialized = new Date(value);
  if ((0, _utils.isValidDate)(deserialized)) return {
    isValid: true,
    date: deserialized
  };
  return {
    isValid: false,
    error: "Invalid date string: ".concat(value)
  };
}

function serialize(date) {
  return date.toISOString();
}

async function renderInput() {
  const onChange = jest.fn();
  const ret = await (0, _form.renderStringInput)({
    fieldDefinition: (0, _types.defineType)({
      type: 'datetime',
      name: 'test'
    }),
    render: props => {
      const {
        id,
        readOnly = false,
        value
      } = props;
      return /*#__PURE__*/_react2.default.createElement(_CommonDateTimeInput.CommonDateTimeInput, {
        deserialize: deserialize,
        id: id,
        formatInputValue: formatInputValue,
        onChange: onChange,
        parseInputValue: parseInputValue,
        readOnly: readOnly,
        serialize: serialize,
        value: value
      });
    }
  });
  return { ...ret,
    onChange
  };
} // NOTE: for the tests to be deterministic we need this to ensure tests are run in a predefined timezone
// see globalSetup in jest config for details about how this is set up


test('timezone for the test environment should be set to America/Los_Angeles', () => {
  expect(Intl.DateTimeFormat().resolvedOptions().timeZone).toBe('America/Los_Angeles');
});
test('does not emit onChange after invalid value has been typed', async () => {
  const {
    result,
    onChange
  } = await renderInput();
  const input = result.container.querySelector('input');

  _userEvent.default.type(input, 'this is invalid');

  expect(input.value).toBe('this is invalid');
  expect(onChange.mock.calls.length).toBe(0);

  _react.fireEvent.blur(input);

  expect(onChange.mock.calls.length).toBe(0);
});
test('emits onChange on correct format if a valid value has been typed', async () => {
  const {
    result,
    onChange
  } = await renderInput();
  const input = result.container.querySelector('input'); // NOTE: the date is entered and displayed in local timezone (which is hardcoded to America/Los_Angeles)

  _userEvent.default.type(input, '2021-03-28 10:23');

  expect(input === null || input === void 0 ? void 0 : input.value).toBe('2021-03-28 10:23');

  _react.fireEvent.blur(input); // NOTE: the date is entered and displayed in local timezone but stored in utc


  expect(onChange.mock.calls).toEqual([['2021-03-28T17:23:00.000Z']]);
});