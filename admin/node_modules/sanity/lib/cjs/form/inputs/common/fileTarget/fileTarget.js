"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fileTarget = fileTarget;

var _react = _interopRequireWildcard(require("react"));

var _ui = require("@sanity/ui");

var _extractFiles = require("./utils/extractFiles");

var _imageUrlToBlob = require("./utils/imageUrlToBlob");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const PASTE_INPUT_STYLE = {
  opacity: 0,
  position: 'absolute'
};
/**
 * Higher order component that creates a file target from a given component.
 * Returns a component that acts both as a drop target and a paste target, emitting a list of Files upon drop or paste
 */

function fileTarget(Component) {
  return /*#__PURE__*/_react.default.forwardRef(function FileTarget(props, ref) {
    const {
      onFiles,
      onFilesOver,
      onFilesOut,
      disabled,
      ...rest
    } = props;

    const [showPasteInput, setShowPasteInput] = _react.default.useState(false);

    const pasteInput = _react.default.useRef(null);

    const forwardedRef = (0, _ui.useForwardedRef)(ref);

    const enteredElements = _react.default.useRef([]);

    const emitFiles = (0, _react.useCallback)(files => {
      onFiles === null || onFiles === void 0 ? void 0 : onFiles(files);
    }, [onFiles]);
    const handleKeyDown = (0, _react.useCallback)(event => {
      if (event.target === forwardedRef.current && (event.ctrlKey || event.metaKey) && event.key === 'v') {
        setShowPasteInput(true);
      }
    }, [forwardedRef]);
    const handlePaste = (0, _react.useCallback)(event => {
      (0, _extractFiles.extractPastedFiles)(event.clipboardData).then(files => {
        if (!pasteInput.current) {
          return [];
        }

        return files.length > 0 ? files : // Invoke Safari hack if we didn't get any files
        convertImagesToFilesAndClearContentEditable(pasteInput.current, 'image/jpeg');
      }).then(files => {
        var _forwardedRef$current;

        emitFiles(files);
        setShowPasteInput(false);
        (_forwardedRef$current = forwardedRef.current) === null || _forwardedRef$current === void 0 ? void 0 : _forwardedRef$current.focus();
      });
    }, [emitFiles, forwardedRef]);
    const handleDrop = (0, _react.useCallback)(event => {
      enteredElements.current = [];
      event.preventDefault();
      event.stopPropagation();
      const dataTransfer = event.nativeEvent.dataTransfer;

      if (onFiles && dataTransfer) {
        (0, _extractFiles.extractDroppedFiles)(dataTransfer).then(files => {
          if (files) {
            emitFiles(files);
          }
        });
      }

      onFilesOut === null || onFilesOut === void 0 ? void 0 : onFilesOut();
    }, [emitFiles, onFiles, onFilesOut]);
    const handleDragOver = (0, _react.useCallback)(event => {
      if (onFiles) {
        event.preventDefault();
        event.stopPropagation();
      }
    }, [onFiles]);
    const handleDragEnter = (0, _react.useCallback)(event => {
      event.stopPropagation();

      if (onFilesOver && forwardedRef.current === event.currentTarget) {
        /* this is a (hackish) work around to have the drag and drop work when the file is hovered back and forth over it
        as part of the refactor and adding more components to the "hover" state, it didn't recognise that it just kept adding the same
        element over and over, so when it tried to remove them on the handleDragLeave, it only removed the last instance.
        */
        enteredElements.current = [...new Set(enteredElements.current), event.currentTarget];
        const fileTypes = Array.from(event.dataTransfer.items).map(item => ({
          type: item.type,
          kind: item.kind
        }));
        onFilesOver(fileTypes);
      }
    }, [onFilesOver, forwardedRef]);
    const handleDragLeave = (0, _react.useCallback)(event => {
      event.stopPropagation();
      const idx = enteredElements.current.indexOf(event.currentTarget);

      if (idx > -1) {
        enteredElements.current.splice(idx, 1);
      }

      if (enteredElements.current.length === 0) {
        onFilesOut === null || onFilesOut === void 0 ? void 0 : onFilesOut();
      }
    }, [onFilesOut]);

    const prevShowPasteInput = _react.default.useRef(false);

    _react.default.useEffect(() => {
      if (!prevShowPasteInput.current && showPasteInput && pasteInput.current) {
        pasteInput.current.focus();
        select(pasteInput.current); // Needed by Edge
      } else if (prevShowPasteInput.current && !showPasteInput) {
        var _pasteInput$current;

        (_pasteInput$current = pasteInput.current) === null || _pasteInput$current === void 0 ? void 0 : _pasteInput$current.focus();
      }

      prevShowPasteInput.current = showPasteInput;
    }, [showPasteInput]);

    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(Component, _extends({}, rest, {
      ref: forwardedRef,
      onKeyDown: disabled ? undefined : handleKeyDown,
      onDragOver: disabled ? undefined : handleDragOver,
      onDragEnter: disabled ? undefined : handleDragEnter,
      onDragLeave: disabled ? undefined : handleDragLeave,
      onDrop: disabled ? undefined : handleDrop
    })), !disabled && showPasteInput && /*#__PURE__*/_react.default.createElement("div", {
      contentEditable: true,
      onPaste: handlePaste,
      ref: pasteInput,
      style: PASTE_INPUT_STYLE
    }));
  });
} // this is a hack for Safari that reads pasted image(s) from an ContentEditable div instead of the onpaste event


function convertImagesToFilesAndClearContentEditable(element) {
  let targetFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'image/jpeg';

  if (!element.isContentEditable) {
    return Promise.reject(new Error("Expected element to be contentEditable=\"true\". Instead found a non contenteditable ".concat(element.tagName)));
  }

  return new Promise(resolve => setTimeout(resolve, 10)) // add a delay so the paste event can finish
  .then(() => Array.from(element.querySelectorAll('img'))).then(imageElements => {
    element.innerHTML = ''; // clear

    return imageElements;
  }).then(images => Promise.all(images.map(img => (0, _imageUrlToBlob.imageUrlToBlob)(img.src)))).then(imageBlobs => imageBlobs.map(blob => new File([blob], 'pasted-image.jpg', {
    type: targetFormat
  })));
} // needed by Edge


function select(el) {
  const range = document.createRange();
  range.selectNodeContents(el);
  const sel = window.getSelection();
  sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
  sel === null || sel === void 0 ? void 0 : sel.addRange(range);
}