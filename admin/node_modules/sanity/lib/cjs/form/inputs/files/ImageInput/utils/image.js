"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.base64ToFile = base64ToFile;
exports.urlToFile = urlToFile;

var _uuid = require("@sanity/uuid");

function urlToFile(url, filename) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();

    xhr.onload = () => {
      const reader = new FileReader();

      reader.onloadend = () => {
        var _reader$result;

        const string = (_reader$result = reader.result) === null || _reader$result === void 0 ? void 0 : _reader$result.toString();
        const ext = string === null || string === void 0 ? void 0 : string.substring('data:image/'.length, string.indexOf(';base64'));

        if (!ext && !filename) {
          reject(new Error('Could not find mime type for image'));
          return;
        }

        resolve(dataURLtoFile(reader.result, filename || "".concat((0, _uuid.uuid)(), ".").concat(ext)));
      };

      reader.readAsDataURL(xhr.response);
    };

    xhr.onerror = error => {
      reject(error);
    };

    xhr.open('GET', url);
    xhr.responseType = 'blob';
    xhr.send();
  });
}

function base64ToFile(base64Data, filename) {
  return new Promise((resolve, reject) => {
    const string = base64Data.toString();
    const ext = string.substring('data:image/'.length, string.indexOf(';base64'));

    if (!ext && !filename) {
      reject(new Error('Could not find mime type for image'));
      return;
    }

    resolve(dataURLtoFile(base64Data, filename || "".concat((0, _uuid.uuid)(), ".").concat(ext)));
  });
}

function dataURLtoFile(dataurl, filename) {
  var _arr$0$match;

  const arr = dataurl.split(',');
  const mime = (_arr$0$match = arr[0].match(/:(.*?);/)) === null || _arr$0$match === void 0 ? void 0 : _arr$0$match[1];
  const bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);

  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }

  return new File([u8arr], filename, {
    type: mime
  });
}