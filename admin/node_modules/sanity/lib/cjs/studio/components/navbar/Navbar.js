"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Navbar = Navbar;

var _startCase2 = _interopRequireDefault(require("lodash/startCase"));

var _icons = require("@sanity/icons");

var _ui = require("@sanity/ui");

var _react = _interopRequireWildcard(require("react"));

var _reactIs = require("react-is");

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _workspace = require("../../workspace");

var _colorScheme = require("../../colorScheme");

var _router = require("../../../router");

var _workspaces = require("../../workspaces");

var _environment = require("../../../environment");

var _userMenu = require("./userMenu");

var _NewDocumentButton = require("./NewDocumentButton");

var _presence = require("./presence");

var _NavDrawer = require("./NavDrawer");

var _search = require("./search");

var _ToolMenu = require("./tools/ToolMenu");

var _changelog = require("./changelog");

var _workspace2 = require("./workspace");

var _ConfigIssuesButton = require("./configIssues/ConfigIssuesButton");

var _templateObject, _templateObject2, _templateObject3;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

const RootLayer = (0, _styledComponents.default)(_ui.Layer)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  min-height: auto;\n  position: relative;\n\n  &[data-search-open='true'] {\n    top: 0;\n    position: sticky;\n  }\n"])));
const SearchCard = (0, _styledComponents.default)(_ui.Card)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n  z-index: 1;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n\n  &[data-fullscreen='true'] {\n    position: absolute;\n  }\n\n  &[data-fullscreen='false'] {\n    min-width: 253px;\n    max-width: 350px;\n  }\n"])));
const LeftFlex = (0, _styledComponents.default)(_ui.Flex)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n  width: max-content;\n"])));

function Navbar(props) {
  var _navbar$components;

  const {
    fullscreenSearchPortalEl,
    onSearchOpenChange
  } = props;
  const {
    name,
    logo,
    navbar,
    tools,
    ...workspace
  } = (0, _workspace.useWorkspace)();
  const workspaces = (0, _workspaces.useWorkspaces)();
  const routerState = (0, _router.useRouterState)();
  const ToolMenu = (navbar === null || navbar === void 0 ? void 0 : (_navbar$components = navbar.components) === null || _navbar$components === void 0 ? void 0 : _navbar$components.ToolMenu) || _ToolMenu.ToolMenu;
  const {
    scheme
  } = (0, _colorScheme.useColorScheme)();
  const rootLink = (0, _router.useStateLink)({
    state: {}
  });
  const mediaIndex = (0, _ui.useMediaIndex)();
  const activeToolName = typeof routerState.tool === 'string' ? routerState.tool : undefined;
  const [searchOpen, setSearchOpen] = (0, _react.useState)(false);
  const [drawerOpen, setDrawerOpen] = (0, _react.useState)(false);
  const routerStateRef = (0, _react.useRef)(routerState);
  const workspaceNameRef = (0, _react.useRef)(name); // Close the NavDrawer when changing tool or workspace

  (0, _react.useEffect)(() => {
    if (routerStateRef.current.tool !== routerState.tool || name !== workspaceNameRef.current) {
      setDrawerOpen(false);
    }

    routerStateRef.current = routerState;
    workspaceNameRef.current = name;
  }, [name, routerState]);
  const [drawerButtonEl, setDrawerButtonEl] = (0, _react.useState)(null);
  const [searchInputElement, setSearchInputElement] = (0, _react.useState)(null);
  const [searchOpenButtonEl, setSearchOpenButtonEl] = (0, _react.useState)(null);
  const [searchCloseButtonEl, setSearchCloseButtonEl] = (0, _react.useState)(null);
  const shouldRender = (0, _react.useMemo)(() => ({
    brandingCenter: mediaIndex <= 1,
    changelog: mediaIndex > 1,
    collapsedPresenceMenu: mediaIndex <= 1,
    loginStatus: mediaIndex > 1,
    searchFullscreen: mediaIndex <= 1,
    configIssues: mediaIndex > 1 && _environment.isDev,
    workspaces: mediaIndex >= 3 && workspaces.length > 1,
    tools: mediaIndex >= 3
  }), [mediaIndex, workspaces.length]);
  const formattedName = typeof name === 'string' && name !== 'root' ? (0, _startCase2.default)(name) : null;
  const title = workspace.title || formattedName || 'Studio';
  (0, _react.useEffect)(() => {
    onSearchOpenChange(searchOpen);
    if (searchOpen) searchInputElement === null || searchInputElement === void 0 ? void 0 : searchInputElement.focus();
  }, [searchOpen, searchInputElement, onSearchOpenChange]);
  (0, _ui.useGlobalKeyDown)(e => {
    if (e.key === 'Escape' && searchOpen) {
      handleCloseSearch();
    }
  });
  const handleOpenSearch = (0, _react.useCallback)(() => {
    setSearchOpen(true);
  }, []);
  const handleCloseSearch = (0, _react.useCallback)(() => {
    setSearchOpen(false);
    searchOpenButtonEl === null || searchOpenButtonEl === void 0 ? void 0 : searchOpenButtonEl.focus();
  }, [searchOpenButtonEl]);
  const handleCloseDrawer = (0, _react.useCallback)(() => {
    setDrawerOpen(false);
    drawerButtonEl === null || drawerButtonEl === void 0 ? void 0 : drawerButtonEl.focus();
  }, [drawerButtonEl]);
  const handleOpenDrawer = (0, _react.useCallback)(() => {
    setDrawerOpen(true);
  }, []);

  const rootLinkContent = (() => {
    if ((0, _reactIs.isValidElementType)(logo)) return /*#__PURE__*/(0, _react.createElement)(logo);
    if ( /*#__PURE__*/(0, _react.isValidElement)(logo)) return logo;
    return /*#__PURE__*/_react.default.createElement(_ui.Text, {
      weight: "bold"
    }, title);
  })();

  const brandingComponent = (0, _react.useMemo)(() => /*#__PURE__*/_react.default.createElement(_ui.Button, {
    "aria-label": title,
    as: "a",
    href: rootLink.href,
    mode: "bleed",
    onClick: rootLink.handleClick,
    padding: 3
  }, rootLinkContent), [rootLink.handleClick, rootLink.href, rootLinkContent, title]); // The HTML elements that are part of the search view (i.e. the "close" button that is visible
  // when in fullscreen mode on narrow devices) needs to be passed to `<Autocomplete />` so it knows
  // how to make the search experience work properly for non-sighted users.
  // Specifically – without passing `relatedElements`, the listbox with results will close when you
  // TAB to focus the "close" button, and that‘s not a good experience for anyone.

  const searchRelatedElements = (0, _react.useMemo)(() => [searchCloseButtonEl].filter(Boolean), [searchCloseButtonEl]);
  return /*#__PURE__*/_react.default.createElement(RootLayer, {
    zOffset: 100,
    "data-search-open": searchOpen
  }, /*#__PURE__*/_react.default.createElement(_ui.Card, {
    scheme: "dark",
    shadow: scheme === 'dark' ? 1 : undefined,
    style: {
      lineHeight: 0
    },
    padding: 2,
    sizing: "border",
    "data-ui": "Navbar"
  }, /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    align: "center",
    justify: "space-between"
  }, /*#__PURE__*/_react.default.createElement(LeftFlex, {
    align: "center",
    flex: shouldRender.brandingCenter ? undefined : 1
  }, !shouldRender.tools && /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginRight: 1
  }, /*#__PURE__*/_react.default.createElement(_ui.Button, {
    mode: "bleed",
    icon: _icons.MenuIcon,
    onClick: handleOpenDrawer,
    ref: setDrawerButtonEl
  })), !shouldRender.brandingCenter && /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginRight: 1
  }, brandingComponent), shouldRender.workspaces && /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginRight: 2
  }, /*#__PURE__*/_react.default.createElement(_ui.Tooltip, {
    content: /*#__PURE__*/_react.default.createElement(_ui.Box, {
      padding: 2
    }, /*#__PURE__*/_react.default.createElement(_ui.Text, {
      size: 1
    }, "Select workspace")),
    placement: "bottom",
    portal: true,
    scheme: scheme
  }, /*#__PURE__*/_react.default.createElement(_ui.Box, null, /*#__PURE__*/_react.default.createElement(_workspace2.WorkspaceMenuButton, null)))), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginRight: shouldRender.brandingCenter ? undefined : 2
  }, /*#__PURE__*/_react.default.createElement(_NewDocumentButton.NewDocumentButton, null)), (searchOpen || !shouldRender.searchFullscreen) && /*#__PURE__*/_react.default.createElement(SearchCard, {
    "data-fullscreen": shouldRender.searchFullscreen,
    "data-ui": "SearchRoot",
    flex: 1,
    padding: shouldRender.searchFullscreen ? 2 : undefined,
    scheme: shouldRender.searchFullscreen ? 'light' : undefined,
    shadow: shouldRender.searchFullscreen ? 1 : undefined
  }, /*#__PURE__*/_react.default.createElement(_ui.Flex, null, /*#__PURE__*/_react.default.createElement(_ui.Box, {
    flex: 1,
    marginRight: shouldRender.tools ? undefined : [1, 1, 2]
  }, /*#__PURE__*/_react.default.createElement(_search.SearchField, {
    fullScreen: shouldRender.searchFullscreen,
    onSearchItemClick: handleCloseSearch,
    portalElement: fullscreenSearchPortalEl,
    setSearchInputElement: setSearchInputElement,
    relatedElements: searchRelatedElements
  })), shouldRender.searchFullscreen && /*#__PURE__*/_react.default.createElement(_ui.Button, {
    "aria-label": "Close search",
    icon: _icons.CloseIcon,
    mode: "bleed",
    onClick: handleCloseSearch,
    ref: setSearchCloseButtonEl
  }))), shouldRender.tools && /*#__PURE__*/_react.default.createElement(_ui.Card, {
    borderRight: true,
    flex: 1,
    marginX: 2,
    overflow: "visible",
    paddingRight: 1
  }, /*#__PURE__*/_react.default.createElement(ToolMenu, {
    activeToolName: activeToolName,
    context: "topbar",
    isDrawerOpen: false,
    tools: tools,
    closeDrawer: handleCloseDrawer
  }))), shouldRender.brandingCenter && /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginX: 1
  }, brandingComponent), /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    align: "center"
  }, shouldRender.changelog && /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginRight: 1
  }, /*#__PURE__*/_react.default.createElement(_changelog.ChangelogButton, null)), shouldRender.configIssues && /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginRight: 2
  }, /*#__PURE__*/_react.default.createElement(_ConfigIssuesButton.ConfigIssuesButton, null)), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginRight: 1
  }, /*#__PURE__*/_react.default.createElement(_presence.PresenceMenu, {
    collapse: shouldRender.collapsedPresenceMenu
  })), shouldRender.tools && /*#__PURE__*/_react.default.createElement(_ui.Box, null, /*#__PURE__*/_react.default.createElement(_userMenu.UserMenu, null)), shouldRender.searchFullscreen && /*#__PURE__*/_react.default.createElement(_ui.Button, {
    "aria-label": "Open search",
    icon: _icons.SearchIcon,
    mode: "bleed",
    onClick: handleOpenSearch,
    ref: setSearchOpenButtonEl
  })))), !shouldRender.tools && /*#__PURE__*/_react.default.createElement(_NavDrawer.NavDrawer, {
    activeToolName: activeToolName,
    isOpen: drawerOpen,
    onClose: handleCloseDrawer,
    tools: tools
  }));
}