"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRouterEventStream = createRouterEventStream;

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _escapeRegExp2 = _interopRequireDefault(require("lodash/escapeRegExp"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _helpers = require("./helpers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @internal
 */
function createRouterEventStream(_ref) {
  let {
    unstable_history: history,
    router,
    tools
  } = _ref;

  function maybeHandleIntent(prevEvent, currentEvent) {
    var _currentEvent$state;

    if ((currentEvent === null || currentEvent === void 0 ? void 0 : currentEvent.type) === 'state' && (_currentEvent$state = currentEvent.state) !== null && _currentEvent$state !== void 0 && _currentEvent$state.intent) {
      const redirectState = (0, _helpers.resolveIntentState)(tools, (prevEvent === null || prevEvent === void 0 ? void 0 : prevEvent.type) === 'state' ? prevEvent.state : {}, currentEvent.state);

      if ((redirectState === null || redirectState === void 0 ? void 0 : redirectState.type) === 'state') {
        history.replace(router.encode(redirectState.state)); // This will not push anything downstream and preserve the prevEvent for the next received value
        // Since we are calling history.replace here, a new event will be received immediately

        return _rxjs.EMPTY;
      }
    }

    return (0, _rxjs.of)(currentEvent);
  }

  function maybeRedirectDefaultState(event) {
    if (event.type === 'state') {
      const defaultState = (0, _helpers.resolveDefaultState)(tools, event.state);

      if (defaultState && defaultState !== event.state) {
        history.replace(router.encode(defaultState));
        return null;
      }
    }

    return event;
  }

  const routerBasePath = router.getBasePath();
  const state$ = new _rxjs.Observable(observer => {
    const unlisten = history.listen(location => observer.next(location)); // emit on mount

    observer.next(history.location);
    return unlisten;
  }).pipe( // this is necessary to prevent emissions intended for other workspaces.
  //
  // this regex ends with a `(\\/|$)` (forward slash or end) to prevent false
  // matches where the pathname is a false subset of the current pathname.
  (0, _operators.filter)(_ref2 => {
    let {
      pathname
    } = _ref2;
    return routerBasePath === '/' ? true : new RegExp("^".concat((0, _escapeRegExp2.default)(routerBasePath), "(\\/|$)"), 'i').test(pathname);
  }), (0, _operators.map)(_ref3 => {
    let {
      pathname
    } = _ref3;
    return (0, _helpers.decodeUrlState)(router, pathname);
  }), (0, _operators.mergeScan)(maybeHandleIntent, null), (0, _operators.filter)(_helpers.isNonNullable), (0, _operators.map)(maybeRedirectDefaultState), (0, _operators.filter)(_helpers.isNonNullable), (0, _operators.distinctUntilChanged)(_isEqual2.default), (0, _operators.shareReplay)(1));
  return state$;
}