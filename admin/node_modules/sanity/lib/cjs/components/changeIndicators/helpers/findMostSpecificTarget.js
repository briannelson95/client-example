"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findMostSpecificTarget = findMostSpecificTarget;

var _types = require("@sanity/types");

var PathUtils = _interopRequireWildcard(require("@sanity/util/paths"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function findMostSpecificTarget(targetType, id, values) {
  const pathString = id.slice(id.indexOf('-') + 1) || '[]';
  const path = PathUtils.fromString(pathString);
  const exactId = "".concat(targetType, "-").concat(PathUtils.toString(path));

  if (values.has(exactId)) {
    return values.get(exactId);
  }

  let mostSpecific;

  for (const [targetId, target] of values) {
    if (!('path' in target) || !targetId.startsWith(targetType)) {
      continue;
    }

    const numEqual = PathUtils.numEqualSegments(path, target.path);
    const lastPathSegment = target.path[target.path.length - 1];
    const pathOnlyDiffersByKey = numEqual === target.path.length - 1 && (0, _types.isKeyedObject)(lastPathSegment);

    if (numEqual === 0) {
      continue;
    } else if (numEqual !== target.path.length && !pathOnlyDiffersByKey) {
      /*
       * We only allow matching to shorter paths if the last element in the path is a keyed object.
       * `foo.bar.portableTextField[_key=abc123]` should resolve to `foo.bar.portableTextField`.
       *
       * Otherwise we'll only get a connector line when you add new elements to a portable text
       * field and not when you alter an existing part.
       */
      continue;
    }

    mostSpecific = target;

    if (numEqual === path.length) {
      // On exact match, return early
      break;
    }
  } // if (!mostSpecific) {
  //   throw new Error(`target not found: "${id}"`)
  // }


  return mostSpecific;
}