"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConnectorsOverlay = ConnectorsOverlay;

var _sortBy2 = _interopRequireDefault(require("lodash/sortBy"));

var _react = _interopRequireWildcard(require("react"));

var _scroll = require("../../scroll");

var _isNonNullable = require("../../../util/isNonNullable");

var _findMostSpecificTarget = require("../helpers/findMostSpecificTarget");

var _isChangeBar = require("../helpers/isChangeBar");

var _scrollIntoView = require("../helpers/scrollIntoView");

var _constants = require("../constants");

var _getOffsetsTo = require("../helpers/getOffsetsTo");

var _tracker = require("../tracker");

var _Connector = require("./Connector");

var _DebugLayers = require("./DebugLayers");

var _useResizeObserver = require("./useResizeObserver");

var _ConnectorsOverlay = require("./ConnectorsOverlay.styled");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getState(allReportedValues, hovered, byId, rootElement) {
  const changeBarsWithHover = [];
  const changeBarsWithFocus = [];

  for (const value of allReportedValues) {
    if (!(0, _isChangeBar.isChangeBar)(value) || !value[1].isChanged) {
      continue;
    }

    const [id, reportedChangeBar] = value;

    if (id === hovered) {
      changeBarsWithHover.push(value);
      continue;
    }

    if (reportedChangeBar.hasHover) {
      changeBarsWithHover.push(value);
      continue;
    }

    if (reportedChangeBar.hasFocus) {
      changeBarsWithFocus.push(value);
      continue;
    }
  }

  const isHoverConnector = changeBarsWithHover.length > 0;
  const changeBars = isHoverConnector ? changeBarsWithHover : changeBarsWithFocus;
  const connectors = changeBars.map(_ref => {
    let [id] = _ref;
    const field = (0, _findMostSpecificTarget.findMostSpecificTarget)('field', id, byId);
    const change = (0, _findMostSpecificTarget.findMostSpecificTarget)('change', id, byId);
    if (!field || !change) return null;
    return {
      field: {
        id,
        ...field
      },
      change: {
        id,
        ...change
      }
    };
  }).filter(_isNonNullable.isNonNullable) // .filter(({field, change}) => field && change && field.element && change.element)
  .map(_ref2 => {
    let {
      field,
      change
    } = _ref2;
    return {
      hasHover: field.hasHover || change.hasHover,
      hasFocus: field.hasFocus,
      hasRevertHover: change.hasRevertHover,
      field: { ...field,
        ...(0, _getOffsetsTo.getOffsetsTo)(field.element, rootElement)
      },
      change: { ...change,
        ...(0, _getOffsetsTo.getOffsetsTo)(change.element, rootElement)
      }
    };
  });
  return {
    connectors,
    isHoverConnector
  };
}

function ConnectorsOverlay(props) {
  const {
    rootElement,
    onSetFocus
  } = props;

  const [hovered, setHovered] = _react.default.useState(null);

  const allReportedValues = (0, _tracker.useReportedValues)();
  const byId = (0, _react.useMemo)(() => new Map(allReportedValues), [allReportedValues]);
  const [{
    connectors
  }, setState] = (0, _react.useState)(() => getState(allReportedValues, hovered, byId, rootElement));
  const visibleConnectors = (0, _react.useMemo)(() => (0, _sortBy2.default)(connectors, c => 0 - c.field.path.length).slice(0, 1), [connectors]);
  const handleScrollOrResize = (0, _react.useCallback)(() => {
    setState(getState(allReportedValues, hovered, byId, rootElement));
  }, [byId, allReportedValues, hovered, rootElement]);
  (0, _useResizeObserver.useResizeObserver)(rootElement, handleScrollOrResize);
  return /*#__PURE__*/_react.default.createElement(_scroll.ScrollMonitor, {
    onScroll: handleScrollOrResize
  }, /*#__PURE__*/_react.default.createElement(_ConnectorsOverlay.SvgWrapper, {
    style: {
      zIndex: visibleConnectors[0] && visibleConnectors[0].field.zIndex
    }
  }, visibleConnectors.map(_ref3 => {
    let {
      field,
      change
    } = _ref3;

    if (!change) {
      return null;
    }

    return /*#__PURE__*/_react.default.createElement(ConnectorGroup, {
      field: field,
      change: change,
      key: field.id,
      onSetFocus: onSetFocus,
      setHovered: setHovered
    });
  })));
}

function ConnectorGroup(props) {
  const {
    change,
    field,
    onSetFocus,
    setHovered
  } = props;
  const onConnectorClick = (0, _react.useCallback)(() => {
    (0, _scrollIntoView.scrollIntoView)(field);
    (0, _scrollIntoView.scrollIntoView)(change);
    onSetFocus(field.path);
  }, [field, change, onSetFocus]);
  const handleMouseEnter = (0, _react.useCallback)(() => setHovered(field.id), [field, setHovered]);
  const handleMouseLeave = (0, _react.useCallback)(() => setHovered(null), [setHovered]);
  const from = (0, _react.useMemo)(() => ({
    rect: {
      left: field.rect.left + 2,
      top: field.rect.top,
      height: field.rect.height,
      width: field.rect.width
    },
    bounds: field.bounds
  }), [field.bounds, field.rect]);
  const to = (0, _react.useMemo)(() => ({
    rect: change.rect,
    bounds: change.bounds
  }), [change.bounds, change.rect]);
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement("g", {
    onClick: onConnectorClick,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave
  }, /*#__PURE__*/_react.default.createElement(_Connector.Connector, {
    from: from,
    to: to
  })), _constants.DEBUG_LAYER_BOUNDS && /*#__PURE__*/_react.default.createElement(_DebugLayers.DebugLayers, {
    field: field,
    change: change
  }));
}