"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepareConfig = prepareConfig;

var _startCase2 = _interopRequireDefault(require("lodash/startCase"));

var _operators = require("rxjs/operators");

var _ui = require("@sanity/ui");

var _bifurClient = require("@sanity/bifur-client");

var _react = require("react");

var _reactIs = require("react-is");

var _schema = require("../schema");

var _datastores = require("../datastores");

var _util = require("../util");

var _defaults = require("../form/defaults");

var _validateWorkspaces = require("../studio/workspaces/validateWorkspaces");

var _configPropertyReducers = require("./configPropertyReducers");

var _resolveConfigProperty = require("./resolveConfigProperty");

var _ConfigResolutionError = require("./ConfigResolutionError");

var _SchemaError = require("./SchemaError");

var _createDefaultIcon = require("./createDefaultIcon");

var _renderField = require("./form/_renderField");

var _renderInput = require("./form/_renderInput");

var _renderItem = require("./form/_renderItem");

var _renderPreview = require("./form/_renderPreview");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function normalizeLogo(logo, title) {
  let subtitle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  if ((0, _reactIs.isValidElementType)(logo)) return /*#__PURE__*/(0, _react.createElement)(logo);
  if ( /*#__PURE__*/(0, _react.isValidElement)(logo)) return logo;
  return (0, _createDefaultIcon.createDefaultIcon)(title, subtitle);
}
/**
 * Takes in a config (created from the `createConfig` function) and returns
 * an array of `WorkspaceSummary`. Note: this only partially resolves a config.
 *
 * For usage usage inside of the Studio, it's preferred to pull the pre-resolved
 * workspaces and sources via `useWorkspace` or `useSource`. For usage outside
 * of the Studio or for testing, use `resolveConfig`.
 */


function prepareConfig(config) {
  const workspaceOptions = Array.isArray(config) ? config : [config];

  try {
    (0, _validateWorkspaces.validateWorkspaces)({
      workspaces: workspaceOptions
    });
  } catch (e) {
    throw new _ConfigResolutionError.ConfigResolutionError({
      name: '',
      type: 'workspace',
      causes: [e.message]
    });
  }

  const workspaces = workspaceOptions.map(_ref => {
    let {
      unstable_sources: nestedSources = [],
      ...rootSource
    } = _ref;
    const sources = [rootSource, ...nestedSources];
    const resolvedSources = sources.map(source => {
      const projectId = source.projectId;
      const dataset = source.dataset;
      const auth = source.auth || (0, _datastores.createAuthStore)({
        dataset,
        projectId
      });
      let schemaTypes;

      try {
        schemaTypes = (0, _resolveConfigProperty.resolveConfigProperty)({
          propertyName: 'schema.types',
          config: source,
          context: {
            projectId,
            dataset
          },
          initialValue: [],
          reducer: _configPropertyReducers.schemaTypesReducer
        });
      } catch (e) {
        throw new _ConfigResolutionError.ConfigResolutionError({
          name: source.name,
          type: 'source',
          causes: [e]
        });
      }

      const schema = (0, _schema.createSchema)({
        name: source.name,
        types: schemaTypes
      });
      const schemaValidationProblemGroups = schema._validation;
      const schemaErrors = schemaValidationProblemGroups === null || schemaValidationProblemGroups === void 0 ? void 0 : schemaValidationProblemGroups.filter(msg => msg.problems.some(p => p.severity === 'error'));

      if (schemaValidationProblemGroups && schemaErrors !== null && schemaErrors !== void 0 && schemaErrors.length) {
        // TODO: consider using the `ConfigResolutionError`
        throw new _SchemaError.SchemaError(schema);
      }

      const source$ = auth.state.pipe((0, _operators.map)(_ref2 => {
        let {
          client,
          authenticated,
          currentUser
        } = _ref2;
        return resolveSource({
          config: source,
          client,
          currentUser,
          schema,
          authenticated,
          auth
        });
      }), (0, _operators.shareReplay)(1));
      return Object.assign(source$, {
        name: source.name,
        projectId: source.projectId,
        dataset: source.dataset,
        title: source.title || (0, _startCase2.default)(source.name),
        auth,
        schema
      });
    });
    const title = rootSource.title || (0, _startCase2.default)(rootSource.name);
    const workspaceSummary = {
      type: 'workspace-summary',
      auth: resolvedSources[0].auth,
      basePath: rootSource.basePath || '/',
      dataset: rootSource.dataset,
      schema: resolvedSources[0].schema,
      icon: normalizeLogo(rootSource.icon, title, "".concat(rootSource.projectId, " ").concat(rootSource.dataset)),
      name: rootSource.name || 'default',
      projectId: rootSource.projectId,
      theme: rootSource.theme || _ui.studioTheme,
      title,
      subtitle: rootSource.subtitle,
      __internal: {
        sources: resolvedSources
      }
    };
    return workspaceSummary;
  });
  return {
    type: 'prepared-config',
    workspaces
  };
}

function getBifurClient(client, auth) {
  const bifurVersionedClient = client.withConfig({
    apiVersion: '2022-06-30'
  });
  const dataset = bifurVersionedClient.config().dataset;
  const url = bifurVersionedClient.getUrl("/socket/".concat(dataset)).replace(/^http/, 'ws');
  return (0, _bifurClient.fromUrl)(url, auth.token ? {
    token$: auth.token
  } : {});
}

function resolveSource(_ref3) {
  var _config$form, _config$form$file, _config$form2, _config$form2$file;

  let {
    config,
    client,
    currentUser,
    schema,
    authenticated,
    auth
  } = _ref3;
  const {
    dataset,
    projectId
  } = config;
  const bifur = getBifurClient(client, auth);
  const errors = [];
  const context = {
    client,
    currentUser,
    dataset,
    projectId,
    schema
  };
  let templates;

  try {
    templates = (0, _resolveConfigProperty.resolveConfigProperty)({
      config,
      context,
      propertyName: 'schema.templates',
      reducer: _configPropertyReducers.schemaTemplatesReducer,
      initialValue: schema.getTypeNames().filter(typeName => !/^sanity\./.test(typeName)).map(typeName => schema.get(typeName)).filter(_util.isNonNullable).filter(schemaType => {
        var _schemaType$type;

        return ((_schemaType$type = schemaType.type) === null || _schemaType$type === void 0 ? void 0 : _schemaType$type.name) === 'document';
      }).map(schemaType => {
        const template = {
          id: schemaType.name,
          schemaType: schemaType.name,
          title: schemaType.title || schemaType.name,
          icon: schemaType.icon,
          value: schemaType.initialValue || {
            _type: schemaType.name
          }
        };
        return template;
      })
    }); // TODO: validate templates
    // TODO: validate that each one has a unique template ID
  } catch (e) {
    errors.push(e);
  }

  let tools;

  try {
    tools = (0, _resolveConfigProperty.resolveConfigProperty)({
      config,
      context,
      initialValue: [],
      propertyName: 'tools',
      reducer: _configPropertyReducers.toolsReducer
    });
  } catch (e) {
    errors.push(e);
  }

  const initialTemplatesResponses = templates // filter out the ones with parameters to fill
  .filter(template => {
    var _template$parameters;

    return !((_template$parameters = template.parameters) !== null && _template$parameters !== void 0 && _template$parameters.length);
  }).map(template => ({
    templateId: template.id,
    description: template.description,
    icon: template.icon,
    title: template.title
  }));
  const templateMap = templates.reduce((acc, template) => {
    acc.set(template.id, template);
    return acc;
  }, new Map()); // TODO: extract this function

  const resolveNewDocumentOptions = creationContext => {
    const {
      schemaType: schemaTypeName
    } = creationContext;
    const templateResponses = (0, _resolveConfigProperty.resolveConfigProperty)({
      config,
      context: { ...context,
        creationContext
      },
      initialValue: initialTemplatesResponses,
      propertyName: 'document.resolveNewDocumentOptions',
      reducer: _configPropertyReducers.newDocumentOptionsResolver
    });
    const templateErrors = []; // TODO: validate template responses
    // ensure there is a matching template per each one

    if (templateErrors.length) {
      throw new _ConfigResolutionError.ConfigResolutionError({
        name: config.name,
        // TODO: figure out this name
        type: 'source',
        causes: templateErrors
      });
    }

    return templateResponses // take the template responses and transform them into the formal
    // `InitialValueTemplateItem`
    .map((response, index) => {
      const template = templateMap.get(response.templateId);

      if (!template) {
        throw new Error("Could not find template with ID `".concat(response.templateId, "`"));
      }

      const schemaType = schema.get(template.schemaType);

      if (!schemaType) {
        throw new Error("Could not find matching schema type `".concat(template.schemaType, "` for template `").concat(template.id, "`"));
      }

      const title = response.title || template.title; // Don't show the type name as subtitle if it's the same as the template name

      const defaultSubtitle = (schemaType === null || schemaType === void 0 ? void 0 : schemaType.title) === title ? undefined : schemaType === null || schemaType === void 0 ? void 0 : schemaType.title;
      return {
        id: "".concat(response.templateId, "-").concat(index),
        templateId: response.templateId,
        type: 'initialValueTemplateItem',
        title,
        subtitle: response.subtitle || defaultSubtitle,
        description: response.description || template.description,
        icon: response.icon || template.icon || (schemaType === null || schemaType === void 0 ? void 0 : schemaType.icon),
        initialDocumentId: response.initialDocumentId,
        parameters: response.parameters,
        schemaType: template.schemaType
      };
    }).filter(item => {
      var _templateMap$get;

      // if we are in a creationContext where there is no schema type,
      // then keep everything
      if (!schemaTypeName) return true; // else only keep the `schemaType`s that match the creationContext

      return schemaTypeName === ((_templateMap$get = templateMap.get(item.templateId)) === null || _templateMap$get === void 0 ? void 0 : _templateMap$get.schemaType);
    });
  };

  let staticInitialValueTemplateItems;

  try {
    staticInitialValueTemplateItems = resolveNewDocumentOptions({
      type: 'global'
    });
  } catch (e) {
    errors.push(e);
  }

  if (errors.length) {
    throw new _ConfigResolutionError.ConfigResolutionError({
      name: config.name,
      type: 'source',
      causes: errors
    });
  }

  const source = {
    type: 'source',
    name: config.name,
    title: config.title || (0, _startCase2.default)(config.name),
    schema,
    client,
    dataset,
    projectId,
    tools,
    currentUser,
    authenticated,
    templates,
    auth,
    document: {
      actions: partialContext => (0, _resolveConfigProperty.resolveConfigProperty)({
        config,
        context: { ...context,
          ...partialContext
        },
        initialValue: _configPropertyReducers.initialDocumentActions,
        propertyName: 'document.actions',
        reducer: _configPropertyReducers.documentActionsReducer
      }),
      badges: partialContext => (0, _resolveConfigProperty.resolveConfigProperty)({
        config,
        context: { ...context,
          ...partialContext
        },
        initialValue: _configPropertyReducers.initialDocumentBadges,
        propertyName: 'document.badges',
        reducer: _configPropertyReducers.documentBadgesReducer
      }),
      resolveProductionUrl: partialContext => (0, _resolveConfigProperty.resolveConfigProperty)({
        config,
        context: { ...context,
          ...partialContext
        },
        initialValue: undefined,
        propertyName: 'resolveProductionUrl',
        asyncReducer: _configPropertyReducers.resolveProductionUrlReducer
      }),
      resolveNewDocumentOptions,
      unstable_languageFilter: partialContext => (0, _resolveConfigProperty.resolveConfigProperty)({
        config,
        context: { ...context,
          ...partialContext
        },
        initialValue: _configPropertyReducers.initialLanguageFilter,
        propertyName: 'document.unstable_languageFilter',
        reducer: _configPropertyReducers._documentLanguageFilterReducer
      })
    },
    form: {
      renderField: (0, _renderField._createRenderField)(config),
      renderInput: (0, _renderInput._createRenderInput)(config),
      renderItem: (0, _renderItem._createRenderItem)(config),
      renderPreview: (0, _renderPreview._createRenderPreview)(config),
      file: {
        assetSources: (0, _resolveConfigProperty.resolveConfigProperty)({
          config,
          context,
          initialValue: _defaults.defaultFileAssetSources,
          propertyName: 'formBuilder.file.assetSources',
          reducer: _configPropertyReducers.fileAssetSourceResolver
        }),
        directUploads: // TODO: consider refactoring this to `noDirectUploads` or similar
        // default value for this is `true`
        ((_config$form = config.form) === null || _config$form === void 0 ? void 0 : (_config$form$file = _config$form.file) === null || _config$form$file === void 0 ? void 0 : _config$form$file.directUploads) === undefined ? true : config.form.file.directUploads
      },
      image: {
        assetSources: (0, _resolveConfigProperty.resolveConfigProperty)({
          config,
          context,
          initialValue: _defaults.defaultImageAssetSources,
          propertyName: 'formBuilder.image.assetSources',
          reducer: _configPropertyReducers.imageAssetSourceResolver
        }),
        directUploads: // TODO: consider refactoring this to `noDirectUploads` or similar
        // default value for this is `true`
        ((_config$form2 = config.form) === null || _config$form2 === void 0 ? void 0 : (_config$form2$file = _config$form2.file) === null || _config$form2$file === void 0 ? void 0 : _config$form2$file.directUploads) === undefined ? true : config.form.file.directUploads
      }
    },
    __internal: {
      bifur,
      staticInitialValueTemplateItems
    }
  };
  return source;
}