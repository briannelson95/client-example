"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useReferringDocuments = useReferringDocuments;

var _react = require("react");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _datastores = require("../../../datastores");

var _hooks = require("../../../hooks");

var _util = require("../../../util");

// this is used in place of `instanceof` so the matching can be more robust and
// won't have any issues with dual packages etc
// https://nodejs.org/api/packages.html#dual-package-hazard
function isClientError(e) {
  if (typeof e !== 'object') return false;
  if (!e) return false;
  return 'statusCode' in e && 'response' in e;
}

const POLL_INTERVAL = 5000; // only fetches when the document is visible

let visiblePoll$;

const getVisiblePoll$ = () => {
  if (!visiblePoll$) {
    visiblePoll$ = (0, _rxjs.fromEvent)(document, 'visibilitychange').pipe( // add empty emission to have this fire on creation
    (0, _operators.startWith)(null), (0, _operators.map)(() => document.visibilityState === 'visible'), (0, _operators.distinctUntilChanged)(), (0, _operators.switchMap)(visible => visible ? // using timer instead of interval since timer will emit on creation
    (0, _rxjs.timer)(0, POLL_INTERVAL) : _rxjs.EMPTY), (0, _operators.shareReplay)({
      refCount: true,
      bufferSize: 1
    }));
  }

  return visiblePoll$;
};

function getDocumentExistence(documentId, _ref) {
  let {
    versionedClient
  } = _ref;
  const draftId = (0, _util.getDraftId)(documentId);
  const publishedId = (0, _util.getPublishedId)(documentId);
  const requestOptions = {
    uri: versionedClient.getDataUrl('doc', "".concat(draftId, ",").concat(publishedId)),
    json: true,
    query: {
      excludeContent: 'true'
    },
    tag: 'use-referring-documents.document-existence'
  };
  return versionedClient.observable.request(requestOptions).pipe((0, _operators.map)(_ref2 => {
    let {
      omitted
    } = _ref2;
    const nonExistant = omitted.filter(doc => doc.reason === 'existence');

    if (nonExistant.length === 2) {
      // None of the documents exist
      return undefined;
    }

    if (nonExistant.length === 0) {
      // Both exist, so use the published one
      return publishedId;
    } // If the draft does not exist, use the published ID, and vice versa


    return nonExistant.some(doc => doc.id === draftId) ? publishedId : draftId;
  }));
}
/**
 * fetches the cross-dataset references using the client observable.request
 * method (for that requests can be automatically cancelled)
 */


function fetchCrossDatasetReferences(documentId, context) {
  const {
    crossProjectTokenStore,
    versionedClient
  } = context;
  return getVisiblePoll$().pipe((0, _operators.switchMap)(() => (0, _rxjs.forkJoin)({
    checkDocumentId: getDocumentExistence(documentId, context),
    crossProjectTokens: crossProjectTokenStore.fetchAllCrossProjectTokens()
  })), (0, _operators.switchMap)(_ref3 => {
    let {
      checkDocumentId,
      crossProjectTokens
    } = _ref3;

    if (!checkDocumentId) {
      return (0, _rxjs.of)({
        totalCount: 0,
        references: []
      });
    }

    const currentDataset = versionedClient.config().dataset;
    const headers = crossProjectTokens.length > 0 ? {
      'sanity-project-tokens': crossProjectTokens.map(t => "".concat(t.projectId, "=").concat(t.token)).join(',')
    } : {};
    return versionedClient.observable.request({
      url: "/data/references/".concat(currentDataset, "/documents/").concat(checkDocumentId, "/to?excludeInternalReferences=true&excludePaths=true"),
      headers,
      tag: 'use-referring-documents.external'
    }).pipe((0, _operators.catchError)(e => {
      // it's possible that referencing document doesn't exist yet so the
      // API will return a 404. In those cases, we want to catch and return
      // a response with no references
      if (isClientError(e) && e.statusCode === 404) {
        return (0, _rxjs.of)({
          totalCount: 0,
          references: []
        });
      }

      throw e;
    }));
  }));
}

const useInternalReferences = (0, _util.createHookFromObservableFactory)((documentId, context) => {
  const {
    documentStore
  } = context;
  const referencesClause = '*[references($documentId)][0...100]{_id,_type}';
  const totalClause = 'count(*[references($documentId)])';
  const fetchQuery = "{\"references\":".concat(referencesClause, ",\"totalCount\":").concat(totalClause, "}");
  const listenQuery = '*[references($documentId)]';
  return documentStore.listenQuery({
    fetch: fetchQuery,
    listen: listenQuery
  }, {
    documentId
  }, {
    tag: 'use-referring-documents',
    transitions: ['appear', 'disappear'],
    throttleTime: 5000
  });
});
const useCrossDatasetReferences = (0, _util.createHookFromObservableFactory)((documentId, context, versionedClient) => {
  const {
    crossProjectTokenStore
  } = context;
  return getVisiblePoll$().pipe((0, _operators.switchMap)(() => fetchCrossDatasetReferences(documentId, {
    versionedClient,
    crossProjectTokenStore
  })));
});

function useReferringDocuments(documentId) {
  const client = (0, _hooks.useClient)();
  const versionedClient = (0, _react.useMemo)(() => client.withConfig({
    apiVersion: '2022-03-07'
  }), [client]);
  const documentStore = (0, _datastores.useDocumentStore)();
  const crossProjectTokenStore = (0, _datastores.useCrossProjectTokenStore)();
  const publishedId = (0, _util.getPublishedId)(documentId);
  const [internalReferences, isInternalReferencesLoading] = useInternalReferences(publishedId, {
    documentStore
  });
  const [crossDatasetReferences, isCrossDatasetReferencesLoading] = useCrossDatasetReferences(publishedId, {
    crossProjectTokenStore
  }, versionedClient);
  const projectIds = (0, _react.useMemo)(() => {
    return Array.from(new Set(crossDatasetReferences === null || crossDatasetReferences === void 0 ? void 0 : crossDatasetReferences.references.map(crossDatasetReference => crossDatasetReference.projectId).filter(Boolean))).sort();
  }, [crossDatasetReferences === null || crossDatasetReferences === void 0 ? void 0 : crossDatasetReferences.references]);
  return {
    totalCount: ((internalReferences === null || internalReferences === void 0 ? void 0 : internalReferences.totalCount) || 0) + ((crossDatasetReferences === null || crossDatasetReferences === void 0 ? void 0 : crossDatasetReferences.totalCount) || 0),
    projectIds,
    internalReferences,
    crossDatasetReferences,
    isLoading: isInternalReferencesLoading || isCrossDatasetReferencesLoading
  };
}