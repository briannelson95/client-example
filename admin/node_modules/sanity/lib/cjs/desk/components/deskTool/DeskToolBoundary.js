"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DeskToolBoundary = DeskToolBoundary;

var _react = _interopRequireWildcard(require("react"));

var _ui = require("@sanity/ui");

var _studio = require("../../../studio");

var _util = require("../../../util");

var _router = require("../../../router");

var _DeskToolProvider = require("../../DeskToolProvider");

var _getIntentState = require("../../getIntentState");

var _intentResolver = require("./intentResolver");

var _StructureError = require("./StructureError");

var _DeskTool = require("./DeskTool");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const EMPTY_RECORD = {};

function DeskToolBoundary(_ref) {
  let {
    tool: {
      options
    }
  } = _ref;
  const {
    unstable_sources: sources
  } = (0, _studio.useWorkspace)();
  const [firstSource] = sources;
  const {
    source,
    defaultDocumentNode,
    structure
  } = options || {};
  const {
    state: routerState
  } = (0, _router.useRouter)();
  const intent = (0, _react.useMemo)(() => {
    const intentName = typeof routerState.intent === 'string' ? routerState.intent : undefined;
    const params = (0, _util.isRecord)(routerState.params) ? routerState.params : EMPTY_RECORD;
    const payload = routerState.payload;
    return intentName ? {
      intent: intentName,
      params,
      payload
    } : undefined;
  }, [routerState]); // Set active panes to blank on mount and unmount

  (0, _react.useEffect)(() => {
    (0, _getIntentState.setActivePanes)([]);
    return () => (0, _getIntentState.setActivePanes)([]);
  }, []);
  const [{
    error
  }, setError] = (0, _react.useState)({
    error: null
  }); // this re-throws if the error it catches is not a PaneResolutionError

  if (error) return /*#__PURE__*/_react.default.createElement(_StructureError.StructureError, {
    error: error
  });
  return /*#__PURE__*/_react.default.createElement(_ui.ErrorBoundary, {
    onCatch: setError
  }, /*#__PURE__*/_react.default.createElement(_studio.SourceProvider, {
    name: source || firstSource.name
  }, /*#__PURE__*/_react.default.createElement(_DeskToolProvider.DeskToolProvider, {
    defaultDocumentNode: defaultDocumentNode,
    structure: structure
  }, intent ? /*#__PURE__*/_react.default.createElement(_intentResolver.IntentResolver, intent) : /*#__PURE__*/_react.default.createElement(_DeskTool.DeskTool, {
    onPaneChange: _getIntentState.setActivePanes
  }))));
}