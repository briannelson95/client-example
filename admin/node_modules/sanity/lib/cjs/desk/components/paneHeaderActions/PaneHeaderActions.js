"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PaneHeaderActions = void 0;

var _uniqBy2 = _interopRequireDefault(require("lodash/uniqBy"));

var _partition2 = _interopRequireDefault(require("lodash/partition"));

var _icons = require("@sanity/icons");

var _ui = require("@sanity/ui");

var _react = _interopRequireWildcard(require("react"));

var _hooks = require("../../../hooks");

var _IntentButton = require("../IntentButton");

var _PaneContextMenuButton = require("../pane/PaneContextMenuButton");

var _PaneHeaderCreateButton = require("./PaneHeaderCreateButton");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// to preserve memory references
const emptyArray = [];
const emptyObject = {};

function isNonNullable(value) {
  return value !== null && value !== undefined;
}
/**
 * hashes an object to a string where the order of the keys don't matter
 */


const hashObject = value => {
  const sortObject = v => {
    if (typeof v !== 'object' || !v) return v;
    if (Array.isArray(v)) return v.map(sortObject);
    return Object.entries(v).sort((_ref, _ref2) => {
      let [keyA] = _ref;
      let [keyB] = _ref2;
      return keyA.localeCompare(keyB, 'en');
    });
  };

  const normalize = v => JSON.parse(JSON.stringify(v));

  return JSON.stringify(sortObject(normalize(value)));
};

const PaneHeaderActions = /*#__PURE__*/(0, _react.memo)(_ref3 => {
  let {
    initialValueTemplateItems: initialValueTemplateItemsFromStructure = emptyArray,
    menuItems = emptyArray,
    menuItemGroups = emptyArray,
    actionHandlers = emptyObject
  } = _ref3;
  const templates = (0, _hooks.useTemplates)();
  const handleAction = (0, _react.useCallback)(item => {
    if (typeof item.action === 'string' && !(item.action in actionHandlers)) {
      console.warn('No handler for action:', item.action);
      return false;
    }

    const handler = // eslint-disable-next-line no-nested-ternary
    typeof item.action === 'function' ? item.action : typeof item.action === 'string' ? actionHandlers[item.action] : null;

    if (handler) {
      handler(item.params);
      return true;
    }

    return false;
  }, [actionHandlers]);
  const [actionMenuItems, contextMenuItems] = (0, _react.useMemo)(() => {
    const nonCreateMenuItem = menuItems // remove items with `create` intents because those will get combined
    // into one action button later
    .filter(item => {
      var _item$intent;

      return ((_item$intent = item.intent) === null || _item$intent === void 0 ? void 0 : _item$intent.type) !== 'create';
    });
    return (0, _partition2.default)(nonCreateMenuItem, item => item.showAsAction);
  }, [menuItems]);
  const initialValueTemplateItemFromMenuItems = (0, _react.useMemo)(() => {
    return menuItems.map((item, menuItemIndex) => {
      var _item$intent2;

      if (((_item$intent2 = item.intent) === null || _item$intent2 === void 0 ? void 0 : _item$intent2.type) !== 'create') return null;
      const {
        params
      } = item.intent;
      if (!params) return null;
      const intentParams = Array.isArray(params) ? params[0] : params;
      const templateParams = Array.isArray(params) ? params[1] : undefined; // fallback to the schema type name as the template ID.
      // by default, the initial template values are populated from every
      // document type in the schema

      const templateId = intentParams.template || intentParams.type;
      if (!templateId) return null; // eslint-disable-next-line max-nested-callbacks

      const template = templates.find(t => t.id === templateId); // the template doesn't exist then the action might be disabled

      if (!template) return null;
      const initialDocumentId = intentParams.id;
      return {
        item,
        template,
        templateParams,
        menuItemIndex,
        initialDocumentId
      };
    }).filter(isNonNullable).map(_ref4 => {
      let {
        initialDocumentId,
        item,
        template,
        menuItemIndex,
        templateParams
      } = _ref4;
      const initialValueTemplateItem = {
        id: "menuItem".concat(menuItemIndex),
        initialDocumentId,
        templateId: template.id,
        type: 'initialValueTemplateItem',
        title: item.title || template.title,
        icon: item.icon,
        description: template.description,
        parameters: templateParams,
        schemaType: template.schemaType
      };
      return initialValueTemplateItem;
    });
  }, [menuItems, templates]);
  const combinedInitialValueTemplates = (0, _react.useMemo)(() => {
    // this de-dupes create actions
    return (0, _uniqBy2.default)([...initialValueTemplateItemFromMenuItems, ...initialValueTemplateItemsFromStructure], item => hashObject([item.initialDocumentId, item.templateId, item.parameters]));
  }, [initialValueTemplateItemFromMenuItems, initialValueTemplateItemsFromStructure]);
  return /*#__PURE__*/_react.default.createElement(_ui.Inline, {
    space: 1
  }, [Boolean(combinedInitialValueTemplates.length) && /*#__PURE__*/_react.default.createElement(_PaneHeaderCreateButton.PaneHeaderCreateButton, {
    key: "$CreateMenuButton",
    templateItems: combinedInitialValueTemplates
  }), //
  ...actionMenuItems.map((actionItem, actionIndex) => {
    return /*#__PURE__*/_react.default.createElement(_ui.Tooltip, {
      content: /*#__PURE__*/_react.default.createElement(_ui.Box, {
        padding: 2
      }, /*#__PURE__*/_react.default.createElement(_ui.Text, {
        size: 1
      }, actionItem.title)) // eslint-disable-next-line react/no-array-index-key
      ,
      key: "".concat(actionIndex, "-").concat(actionItem.title),
      placement: "bottom"
    }, actionItem.intent ? /*#__PURE__*/_react.default.createElement(_IntentButton.IntentButton, {
      intent: actionItem.intent,
      "aria-label": actionItem.title,
      icon: actionItem.icon || _icons.UnknownIcon,
      mode: "bleed"
    }) : /*#__PURE__*/_react.default.createElement(_ui.Button, {
      "aria-label": actionItem.title,
      icon: actionItem.icon || _icons.UnknownIcon,
      mode: "bleed" // eslint-disable-next-line react/jsx-no-bind
      ,
      onClick: () => handleAction(actionItem)
    }));
  }), //
  Boolean(contextMenuItems.length) && /*#__PURE__*/_react.default.createElement(_PaneContextMenuButton.PaneContextMenuButton, {
    items: contextMenuItems,
    itemGroups: menuItemGroups,
    key: "$ContextMenu",
    onAction: handleAction
  })]);
});
exports.PaneHeaderActions = PaneHeaderActions;
PaneHeaderActions.displayName = 'PaneHeaderActions';