"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DeleteAction = void 0;

var _icons = require("@sanity/icons");

var _react = _interopRequireWildcard(require("react"));

var _InsufficientPermissionsMessage = require("../../../components/InsufficientPermissionsMessage");

var _datastores = require("../../../datastores");

var _hooks = require("../../../hooks");

var _components = require("../../components");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const DISABLED_REASON_TITLE = {
  NOTHING_TO_DELETE: 'This document doesn’t yet exist or is already deleted'
};

const DeleteAction = _ref => {
  let {
    id,
    type,
    draft,
    onComplete
  } = _ref;
  const {
    delete: deleteOp
  } = (0, _hooks.useDocumentOperation)(id, type);
  const [isDeleting, setIsDeleting] = (0, _react.useState)(false);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = (0, _react.useState)(false);
  const handleCancel = (0, _react.useCallback)(() => {
    setConfirmDialogOpen(false);
    onComplete();
  }, [onComplete]);
  const handleConfirm = (0, _react.useCallback)(() => {
    setIsDeleting(true);
    setConfirmDialogOpen(false);
    deleteOp.execute();
    onComplete();
  }, [deleteOp, onComplete]);
  const handle = (0, _react.useCallback)(() => {
    setConfirmDialogOpen(true);
  }, []);
  const [permissions, isPermissionsLoading] = (0, _datastores.useDocumentPairPermissions)({
    id,
    type,
    permission: 'delete'
  });
  const currentUser = (0, _datastores.useCurrentUser)();

  if (!isPermissionsLoading && !(permissions !== null && permissions !== void 0 && permissions.granted)) {
    return {
      tone: 'critical',
      icon: _icons.TrashIcon,
      disabled: true,
      label: 'Delete',
      title: /*#__PURE__*/_react.default.createElement(_InsufficientPermissionsMessage.InsufficientPermissionsMessage, {
        operationLabel: "delete this document",
        currentUser: currentUser
      })
    };
  }

  return {
    tone: 'critical',
    icon: _icons.TrashIcon,
    disabled: isDeleting || Boolean(deleteOp.disabled) || isPermissionsLoading,
    title: deleteOp.disabled && DISABLED_REASON_TITLE[deleteOp.disabled] || '',
    label: isDeleting ? 'Deleting…' : 'Delete',
    shortcut: 'Ctrl+Alt+D',
    onHandle: handle,
    modal: isConfirmDialogOpen && {
      type: 'dialog',
      onClose: onComplete,
      content: /*#__PURE__*/_react.default.createElement(_components.ConfirmDeleteDialog, {
        action: "delete",
        id: (draft === null || draft === void 0 ? void 0 : draft._id) || id,
        type: type,
        onCancel: handleCancel,
        onConfirm: handleConfirm
      })
    }
  };
};

exports.DeleteAction = DeleteAction;
DeleteAction.action = 'delete';