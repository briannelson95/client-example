"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormView = FormView;

var _internal = require("@sanity/schema/_internal");

var _ui = require("@sanity/ui");

var _react = _interopRequireWildcard(require("react"));

var _operators = require("rxjs/operators");

var _useDocumentPane = require("../../useDocumentPane");

var _Delay = require("../../../../components/Delay");

var _datastores = require("../../../../../datastores");

var _form = require("../../../../../form");

var _presence = require("../../../../../presence");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable no-nested-ternary */
// interface FormViewState {
//   filterField: FormBuilderFilterFieldFn
// }
// const INITIAL_STATE: FormViewState = {
//   filterField: () => true,
// }
const preventDefault = ev => ev.preventDefault();

function FormView(props) {
  const {
    hidden,
    margins,
    granted
  } = props;
  const {
    collapsedFieldSets,
    collapsedPaths,
    displayed: value,
    documentId,
    documentType,
    onChange: _handleChange,
    historyController,
    validation,
    ready,
    // changesOpen,
    formState,
    onFocus,
    onBlur,
    onSetCollapsedPath,
    onPathOpen,
    onSetCollapsedFieldSet,
    onSetActiveFieldGroup,
    schemaType
  } = (0, _useDocumentPane.useDocumentPane)();
  const documentStore = (0, _datastores.useDocumentStore)();
  const {
    revTime: rev
  } = historyController; // const [{filterField}, setState] = useState<FormViewState>(INITIAL_STATE)

  const hasTypeMismatch = value !== null && value._type !== schemaType.name;
  const isNonExistent = !value || !value._id;
  const presence = (0, _datastores.useDocumentPresence)(documentId); // The `patchChannel` is an INTERNAL publish/subscribe channel that we use to notify form-builder
  // nodes about both remote and local patches.
  // - Used by the Portable Text input to modify selections.
  // - Used by `withDocument` to reset value.

  const patchChannel = (0, _react.useMemo)(() => (0, _form.createPatchChannel)(), []);
  const isReadOnly = (0, _react.useMemo)(() => {
    return formState === null || formState.readOnly || !ready || rev !== null || !granted || !(0, _internal.isActionEnabled)(schemaType, 'update') || isNonExistent && !(0, _internal.isActionEnabled)(schemaType, 'create');
  }, [formState, ready, rev, granted, isNonExistent, schemaType]);
  const handleChange = (0, _react.useCallback)(patchEvent => {
    if (!isReadOnly) _handleChange(patchEvent);
  }, [_handleChange, isReadOnly]); // useEffect(() => {
  //   if (!filterFieldFn$) return undefined
  //   const sub = filterFieldFn$.subscribe((nextFilterField) =>
  //     setState({filterField: nextFilterField})
  //   )
  //   return () => sub.unsubscribe()
  // }, [])

  (0, _react.useEffect)(() => {
    const sub = documentStore.pair.documentEvents(documentId, documentType).pipe((0, _operators.tap)(event => {
      if (event.type === 'mutation') {
        patchChannel.publish(prepareMutationEvent(event));
      }

      if (event.type === 'rebase') {
        patchChannel.publish(prepareRebaseEvent(event));
      }
    })).subscribe();
    return () => {
      sub.unsubscribe();
    };
  }, [documentId, documentStore, documentType, patchChannel]);
  const hasRev = Boolean(value === null || value === void 0 ? void 0 : value._rev);
  (0, _react.useEffect)(() => {
    if (hasRev) {
      // this is a workaround for an issue that caused the document pushed to withDocument to get
      // stuck at the first initial value.
      // This effect is triggered only when the document goes from not having a revision, to getting one
      // so it will kick in as soon as the document is received from the backend
      patchChannel.publish({
        type: 'mutation',
        patches: [],
        snapshot: value
      });
    } // React to changes in hasRev only
    // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [hasRev]); // const after = useMemo(
  //   () =>
  //     Array.isArray(afterEditorComponents) &&
  //     afterEditorComponents.map(
  //       (AfterEditorComponent: React.ComponentType<{documentId: string}>, idx: number) => (
  //         <AfterEditorComponent key={String(idx)} documentId={documentId} />
  //       )
  //     ),
  //   [documentId]
  // )

  return /*#__PURE__*/_react.default.createElement(_ui.Container, {
    hidden: hidden,
    paddingX: 4,
    paddingTop: 5,
    paddingBottom: 9,
    sizing: "border",
    width: 1
  }, /*#__PURE__*/_react.default.createElement(_presence.PresenceOverlay, {
    margins: margins
  }, /*#__PURE__*/_react.default.createElement(_ui.Box, {
    as: "form",
    onSubmit: preventDefault
  }, ready ? formState === null ? /*#__PURE__*/_react.default.createElement(_ui.Box, {
    padding: 2
  }, /*#__PURE__*/_react.default.createElement(_ui.Text, null, "This form is hidden")) : /*#__PURE__*/_react.default.createElement(_form.StudioFormBuilder, {
    __internal_patchChannel: patchChannel,
    collapsedFieldSets: collapsedFieldSets,
    collapsedPaths: collapsedPaths,
    focusPath: formState.focusPath,
    changed: formState.changed,
    focused: formState.focused,
    groups: formState.groups,
    id: "root",
    members: formState.members,
    onChange: handleChange,
    onFieldGroupSelect: onSetActiveFieldGroup,
    onPathBlur: onBlur,
    onPathFocus: onFocus,
    onPathOpen: onPathOpen,
    onSetFieldSetCollapsed: onSetCollapsedFieldSet,
    onSetPathCollapsed: onSetCollapsedPath,
    presence: presence,
    readOnly: isReadOnly,
    schemaType: formState.schemaType,
    validation: validation,
    value: formState.value
  }) : /*#__PURE__*/_react.default.createElement(_Delay.Delay, {
    ms: 300
  }, /*#__PURE__*/_react.default.createElement(_ui.Flex, {
    align: "center",
    direction: "column",
    height: "fill",
    justify: "center"
  }, /*#__PURE__*/_react.default.createElement(_ui.Spinner, {
    muted: true
  }), /*#__PURE__*/_react.default.createElement(_ui.Box, {
    marginTop: 3
  }, /*#__PURE__*/_react.default.createElement(_ui.Text, {
    align: "center",
    muted: true,
    size: 1
  }, "Loading document")))))));
}

function prepareMutationEvent(event) {
  const patches = event.mutations.map(mut => mut.patch).filter(Boolean);
  return {
    type: 'mutation',
    snapshot: event.document,
    patches: (0, _form.fromMutationPatches)(event.origin, patches)
  };
}

function prepareRebaseEvent(event) {
  const remotePatches = event.remoteMutations.map(mut => mut.patch).filter(Boolean);
  const localPatches = event.localMutations.map(mut => mut.patch).filter(Boolean);
  return {
    type: 'rebase',
    snapshot: event.document,
    patches: (0, _form.fromMutationPatches)('remote', remotePatches).concat((0, _form.fromMutationPatches)('local', localPatches))
  };
}