"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DocumentPaneProvider = void 0;

var _omit2 = _interopRequireDefault(require("lodash/omit"));

var _react = _interopRequireWildcard(require("react"));

var _ui = require("@sanity/ui");

var _paths = require("@sanity/util/paths");

var _isHotkey = _interopRequireDefault(require("is-hotkey"));

var _reactRx = require("react-rx");

var _datastores = require("../../../datastores");

var _hooks = require("../../../hooks");

var _environment = require("../../../environment");

var _studio = require("../../../studio");

var _util = require("../../../util");

var _components = require("../../components");

var _form = require("../../../form");

var _useFormState = require("../../../form/store/useFormState");

var _stateTreeHelper = require("../../../form/store/stateTreeHelper");

var _getExpandOperations = require("../../../form/store/utils/getExpandOperations");

var _useDeskTool = require("../../useDeskTool");

var _DocumentPaneContext = require("./DocumentPaneContext");

var _menuItems = require("./menuItems");

var _usePreviewUrl = require("./usePreviewUrl");

var _getInitialValueTemplateOpts = require("./getInitialValueTemplateOpts");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const emptyObject = {};
/**
 * @internal
 */
// eslint-disable-next-line complexity, max-statements

const DocumentPaneProvider = /*#__PURE__*/(0, _react.memo)(props => {
  const {
    children,
    index,
    pane,
    paneKey
  } = props;
  const client = (0, _hooks.useClient)();
  const schema = (0, _hooks.useSchema)();
  const templates = (0, _hooks.useTemplates)();
  const {
    actions: documentActions,
    badges: documentBadges,
    unstable_languageFilter: languageFilterResolver
  } = (0, _studio.useSource)().document;
  const historyStore = (0, _datastores.useHistoryStore)();
  const presenceStore = (0, _datastores.usePresenceStore)();
  const paneRouter = (0, _components.usePaneRouter)();
  const {
    features
  } = (0, _useDeskTool.useDeskTool)();
  const {
    push: pushToast
  } = (0, _ui.useToast)();
  const {
    options,
    menuItemGroups,
    title = null,
    views: viewsProp = []
  } = pane;
  const paneOptions = (0, _util.useUnique)(options);
  const documentIdRaw = paneOptions.id;
  const documentId = (0, _util.getPublishedId)(documentIdRaw);
  const documentType = options.type;
  const paneParams = (0, _util.useUnique)(paneRouter.params);
  const panePayload = (0, _util.useUnique)(paneRouter.payload);
  const {
    templateName,
    templateParams
  } = (0, _react.useMemo)(() => (0, _getInitialValueTemplateOpts.getInitialValueTemplateOpts)(templates, {
    documentType,
    templateName: paneOptions.template,
    templateParams: paneOptions.templateParameters,
    panePayload,
    urlTemplate: paneParams === null || paneParams === void 0 ? void 0 : paneParams.template
  }), [documentType, paneOptions, paneParams, panePayload, templates]);
  const initialValueRaw = (0, _datastores.useInitialValue)({
    documentId,
    documentType,
    templateName,
    templateParams
  });
  const initialValue = (0, _util.useUnique)(initialValueRaw);
  const {
    patch
  } = (0, _hooks.useDocumentOperation)(documentId, documentType);
  const editState = (0, _hooks.useEditState)(documentId, documentType);
  const {
    validation: validationRaw
  } = (0, _hooks.useValidationStatus)(documentId, documentType);
  const connectionState = (0, _hooks.useConnectionState)(documentId, documentType);
  const schemaType = schema.get(documentType);
  const value = (editState === null || editState === void 0 ? void 0 : editState.draft) || (editState === null || editState === void 0 ? void 0 : editState.published) || initialValue.value; // Resolve document actions

  const actions = (0, _react.useMemo)(() => documentActions({
    schemaType: documentType,
    documentId
  }), [documentActions, documentId, documentType]); // Resolve document badges

  const badges = (0, _react.useMemo)(() => documentBadges({
    schemaType: documentType,
    documentId
  }), [documentBadges, documentId, documentType]); // Resolve document language filter

  const languageFilter = (0, _react.useMemo)(() => languageFilterResolver({
    schemaType: documentType,
    documentId
  }), [documentId, documentType, languageFilterResolver]);
  const validation = (0, _util.useUnique)(validationRaw);
  const views = (0, _util.useUnique)(viewsProp);
  const params = paneRouter.params || emptyObject;
  const [focusPath, setFocusPath] = (0, _react.useState)(() => params.path ? (0, _paths.fromString)(params.path) : []);
  const activeViewId = params.view || views[0] && views[0].id || null;
  const timeline = (0, _react.useMemo)(() => historyStore.getTimeline({
    publishedId: documentId,
    enableTrace: _environment.isDev
  }), [documentId, historyStore]);
  const [timelineMode, setTimelineMode] = (0, _react.useState)('closed'); // NOTE: this emits sync so can never be null
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

  const {
    historyController
  } = (0, _reactRx.useMemoObservable)(() => historyStore.getTimelineController({
    client,
    documentId,
    documentType,
    timeline
  }), [client, documentId, documentType, timeline]); // @todo: this will now happen on each render, but should be refactored so it happens only when
  // the `rev`, `since` or `historyController` values change.

  historyController.setRange(params.since || null, params.rev || null);
  const changesOpen = historyController.changesPanelActive(); // TODO: this may cause a lot of churn. May be a good idea to prevent these
  // requests unless the menu is open somehow

  const previewUrl = (0, _usePreviewUrl.usePreviewUrl)(value);
  const [presence, setPresence] = (0, _react.useState)([]);
  (0, _react.useEffect)(() => {
    const subscription = presenceStore.documentPresence(documentId).subscribe(nextPresence => {
      setPresence(nextPresence);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [documentId, presenceStore]);
  const hasValue = Boolean(value);
  const menuItems = (0, _react.useMemo)(() => (0, _menuItems.getMenuItems)({
    features,
    hasValue,
    changesOpen,
    previewUrl
  }), [features, hasValue, changesOpen, previewUrl]);
  const inspectOpen = params.inspect === 'on';
  const compareValue = changesOpen ? historyController.sinceAttributes() : (editState === null || editState === void 0 ? void 0 : editState.published) || null;
  const ready = connectionState === 'connected' && editState.ready;
  const viewOlderVersion = historyController.onOlderRevision();
  const displayed = (0, _react.useMemo)(() => viewOlderVersion ? historyController.displayed() : value, // eslint-disable-next-line react-hooks/exhaustive-deps
  [historyController, params.rev, params.since, value, viewOlderVersion]);
  const setTimelineRange = (0, _react.useCallback)((newSince, newRev) => {
    paneRouter.setParams({ ...paneRouter.params,
      since: newSince,
      rev: newRev || undefined
    });
  }, [paneRouter]);
  const handleFocus = (0, _react.useCallback)(nextFocusPath => {
    setFocusPath(nextFocusPath);
    presenceStore.setLocation([{
      type: 'document',
      documentId,
      path: nextFocusPath,
      lastActiveAt: new Date().toISOString()
    }]);
  }, [documentId, presenceStore, setFocusPath]);
  const handleBlur = (0, _react.useCallback)(blurredPath => {
    setFocusPath([]); // note: we're deliberately not syncing presence here since it would make the user avatar disappear when a
    // user clicks outside a field without focusing another one
  }, [setFocusPath]);
  const patchRef = (0, _react.useRef)(() => {
    throw new Error('Nope');
  });

  patchRef.current = event => {
    patch.execute((0, _form.toMutationPatches)(event.patches), initialValue.value);
  };

  const handleChange = (0, _react.useCallback)(event => patchRef.current(event), []);
  const handleHistoryClose = (0, _react.useCallback)(() => {
    paneRouter.setParams({ ...params,
      since: undefined
    });
  }, [paneRouter, params]);
  const handleHistoryOpen = (0, _react.useCallback)(() => {
    paneRouter.setParams({ ...params,
      since: '@lastPublished'
    });
  }, [paneRouter, params]);
  const handlePaneClose = (0, _react.useCallback)(() => paneRouter.closeCurrent(), [paneRouter]);
  const handlePaneSplit = (0, _react.useCallback)(() => paneRouter.duplicateCurrent(), [paneRouter]);
  const toggleInspect = (0, _react.useCallback)(function () {
    let toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !inspectOpen;

    if (toggle) {
      paneRouter.setParams({ ...params,
        inspect: 'on'
      });
    } else {
      paneRouter.setParams((0, _omit2.default)(params, 'inspect'));
    }
  }, [inspectOpen, paneRouter, params]);
  const handleMenuAction = (0, _react.useCallback)(item => {
    if (item.action === 'production-preview' && previewUrl) {
      window.open(previewUrl);
      return true;
    }

    if (item.action === 'inspect') {
      toggleInspect(true);
      return true;
    }

    if (item.action === 'reviewChanges') {
      handleHistoryOpen();
      return true;
    }

    return false;
  }, [handleHistoryOpen, previewUrl, toggleInspect]);
  const handleKeyUp = (0, _react.useCallback)(event => {
    for (const item of menuItems) {
      if (item.shortcut) {
        if ((0, _isHotkey.default)(item.shortcut, event)) {
          event.preventDefault();
          event.stopPropagation();
          handleMenuAction(item);
          return;
        }
      }
    }
  }, [handleMenuAction, menuItems]);
  const handleInspectClose = (0, _react.useCallback)(() => toggleInspect(false), [toggleInspect]);
  const [openPath, onSetOpenPath] = (0, _react.useState)([]);
  const [fieldGroupState, onSetFieldGroupState] = (0, _react.useState)();
  const [collapsedPaths, onSetCollapsedPath] = (0, _react.useState)();
  const [collapsedFieldSets, onSetCollapsedFieldSets] = (0, _react.useState)();
  const handleOnSetCollapsedPath = (0, _react.useCallback)((path, collapsed) => {
    onSetCollapsedPath(prevState => (0, _stateTreeHelper.setAtPath)(prevState, path, collapsed));
  }, []);
  const handleOnSetCollapsedFieldSet = (0, _react.useCallback)((path, collapsed) => {
    onSetCollapsedFieldSets(prevState => (0, _stateTreeHelper.setAtPath)(prevState, path, collapsed));
  }, []);
  const handleSetActiveFieldGroup = (0, _react.useCallback)((path, groupName) => onSetFieldGroupState(prevState => (0, _stateTreeHelper.setAtPath)(prevState, path, groupName)), []);
  const formState = (0, _useFormState.useFormState)(schemaType, {
    value,
    comparisonValue: compareValue,
    focusPath,
    openPath,
    collapsedPaths,
    presence,
    validation,
    collapsedFieldSets: collapsedFieldSets,
    fieldGroupState
  });
  const formStateRef = (0, _react.useRef)(formState);
  formStateRef.current = formState;
  const handleOpenPath = (0, _react.useCallback)(path => {
    const ops = (0, _getExpandOperations.getExpandOperations)(formStateRef.current, path);
    ops.forEach(op => {
      if (op.type === 'expandPath') {
        onSetCollapsedPath(prevState => (0, _stateTreeHelper.setAtPath)(prevState, op.path, false));
      }

      if (op.type === 'expandFieldSet') {
        onSetCollapsedFieldSets(prevState => (0, _stateTreeHelper.setAtPath)(prevState, op.path, false));
      }

      if (op.type === 'setSelectedGroup') {
        onSetFieldGroupState(prevState => (0, _stateTreeHelper.setAtPath)(prevState, op.path, op.groupName));
      }
    });
    onSetOpenPath(path);
  }, [formStateRef]);
  const documentPane = {
    actions,
    activeViewId,
    badges,
    changesOpen,
    collapsedFieldSets,
    collapsedPaths,
    compareValue,
    connectionState,
    displayed,
    documentId,
    documentIdRaw,
    documentType,
    editState,
    focusPath,
    menuItems,
    onBlur: handleBlur,
    onChange: handleChange,
    onFocus: handleFocus,
    onPathOpen: handleOpenPath,
    onHistoryClose: handleHistoryClose,
    onHistoryOpen: handleHistoryOpen,
    onInspectClose: handleInspectClose,
    onKeyUp: handleKeyUp,
    onMenuAction: handleMenuAction,
    onPaneClose: handlePaneClose,
    onPaneSplit: handlePaneSplit,
    onSetActiveFieldGroup: handleSetActiveFieldGroup,
    onSetCollapsedPath: handleOnSetCollapsedPath,
    onSetCollapsedFieldSet: handleOnSetCollapsedFieldSet,
    historyController,
    index,
    inspectOpen,
    validation,
    menuItemGroups: menuItemGroups || [],
    paneKey,
    previewUrl,
    ready,
    schemaType: schemaType,
    setTimelineMode,
    setTimelineRange,
    timeline,
    timelineMode,
    title,
    value,
    views,
    formState,
    unstable_languageFilter: languageFilter
  };
  (0, _react.useEffect)(() => {
    if (connectionState === 'reconnecting') {
      pushToast({
        id: 'sanity/desk/reconnecting',
        status: 'warning',
        title: /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, "Connection lost. Reconnecting\u2026")
      });
    }
  }, [connectionState, pushToast]); // Reset `focusPath` when `documentId` or `params.path` changes

  (0, _react.useEffect)(() => {
    // Reset focus path
    setFocusPath(params.path ? (0, _paths.fromString)(params.path) : []);
  }, [documentId, params.path]);
  return /*#__PURE__*/_react.default.createElement(_DocumentPaneContext.DocumentPaneContext.Provider, {
    value: documentPane
  }, children);
});
exports.DocumentPaneProvider = DocumentPaneProvider;
DocumentPaneProvider.displayName = 'DocumentPaneProvider';