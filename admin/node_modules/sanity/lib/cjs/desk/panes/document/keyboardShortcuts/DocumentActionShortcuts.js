"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DocumentActionShortcuts = void 0;

var _isHotkey = _interopRequireDefault(require("is-hotkey"));

var _react = _interopRequireWildcard(require("react"));

var _statusBar = require("../statusBar");

var _components = require("../../../components");

var _useDocumentPane = require("../useDocumentPane");

var _actions = require("../../../actions");

var _transitional = require("../../../../components/transitional");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function KeyboardShortcutResponder(props) {
  const {
    actionsBoxElement,
    activeIndex,
    children,
    id,
    onActionStart,
    onKeyDown,
    rootRef,
    states,
    ...rest
  } = props;
  const activeAction = states[activeIndex];
  const handleKeyDown = (0, _react.useCallback)(event => {
    const matchingStates = states.filter(state => state.shortcut && (0, _isHotkey.default)(state.shortcut, event));
    const matchingState = matchingStates[0];

    if (matchingStates.length > 1) {
      // eslint-disable-next-line no-console
      console.warn("Keyboard shortcut conflict: More than one document action matches the shortcut \"".concat(matchingState.shortcut, "\""));
    }

    if (matchingState && !matchingState.disabled && matchingState.onHandle) {
      event.preventDefault();
      matchingState.onHandle();
      onActionStart(states.indexOf(matchingState));
      return;
    }

    if (onKeyDown) {
      onKeyDown(event);
    }
  }, [onActionStart, onKeyDown, states]);
  return /*#__PURE__*/_react.default.createElement(_components.Pane, _extends({
    id: id,
    onKeyDown: handleKeyDown,
    tabIndex: -1
  }, rest, {
    ref: rootRef
  }), children, activeAction && activeAction.modal && /*#__PURE__*/_react.default.createElement(_transitional.LegacyLayerProvider, {
    zOffset: "paneFooter"
  }, /*#__PURE__*/_react.default.createElement(_statusBar.ActionStateDialog, {
    modal: activeAction.modal,
    referenceElement: actionsBoxElement
  })));
}

const DocumentActionShortcuts = /*#__PURE__*/_react.default.memo(props => {
  const {
    actionsBoxElement,
    children,
    ...rest
  } = props;
  const {
    actions,
    editState
  } = (0, _useDocumentPane.useDocumentPane)();
  const [activeIndex, setActiveIndex] = (0, _react.useState)(-1);
  const onActionStart = (0, _react.useCallback)(idx => {
    setActiveIndex(idx);
  }, []);
  const actionProps = (0, _react.useMemo)(() => editState && { ...editState,
    // @todo: what to call here?
    onComplete: () => undefined,
    // @todo: get revision string
    revision: undefined
  }, [editState]);
  if (!actionProps || !actions) return null;
  return /*#__PURE__*/_react.default.createElement(_actions.RenderActionCollectionState, {
    actionProps: actionProps,
    actions: actions
  }, _ref => {
    let {
      states
    } = _ref;
    return /*#__PURE__*/_react.default.createElement(KeyboardShortcutResponder, _extends({}, rest, {
      activeIndex: activeIndex,
      actionsBoxElement: actionsBoxElement,
      onActionStart: onActionStart,
      states: states
    }), children);
  });
});

exports.DocumentActionShortcuts = DocumentActionShortcuts;
DocumentActionShortcuts.displayName = 'DocumentActionShortcuts';