"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDocumentList = useDocumentList;

var _react = require("react");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _hooks = require("../../../hooks");

var _helpers = require("./helpers");

var _constants = require("./constants");

var _getQueryResults = require("./getQueryResults");

/**
 * @internal
 */
function useDocumentList(opts) {
  var _result$result;

  const {
    apiVersion,
    defaultOrdering,
    filter,
    params,
    sortOrder
  } = opts;
  const client = (0, _hooks.useClient)();
  const [fullList, setFullList] = (0, _react.useState)(false);
  const fullListRef = (0, _react.useRef)(fullList);
  const [result, setResult] = (0, _react.useState)(null);
  const error = (result === null || result === void 0 ? void 0 : result.error) || null;
  const isLoading = (result === null || result === void 0 ? void 0 : result.loading) || result === null;
  const onRetry = result === null || result === void 0 ? void 0 : result.onRetry;
  const documents = result === null || result === void 0 ? void 0 : (_result$result = result.result) === null || _result$result === void 0 ? void 0 : _result$result.documents;
  const items = (0, _react.useMemo)(() => documents ? (0, _helpers.removePublishedWithDrafts)(documents) : null, [documents]);
  const query = (0, _react.useMemo)(() => {
    const extendedProjection = sortOrder === null || sortOrder === void 0 ? void 0 : sortOrder.extendedProjection;
    const projectionFields = ['_id', '_type'];
    const finalProjection = projectionFields.join(',');
    const sortBy = defaultOrdering || (sortOrder === null || sortOrder === void 0 ? void 0 : sortOrder.by) || [];
    const limit = fullList ? _constants.FULL_LIST_LIMIT : _constants.PARTIAL_PAGE_LIMIT;
    const sort = sortBy.length > 0 ? sortBy : _constants.DEFAULT_ORDERING.by;
    const order = (0, _helpers.toOrderClause)(sort);

    if (extendedProjection) {
      const firstProjection = projectionFields.concat(extendedProjection).join(',');
      return ["*[".concat(filter, "] {").concat(firstProjection, "}"), "order(".concat(order, ") [0...").concat(limit, "]"), "{".concat(finalProjection, "}")].join('|');
    }

    return "*[".concat(filter, "]|order(").concat(order, ")[0...").concat(limit, "]{").concat(finalProjection, "}");
  }, [defaultOrdering, filter, fullList, sortOrder]);
  const handleListChange = (0, _react.useCallback)(_ref => {
    let {
      toIndex
    } = _ref;

    if (isLoading || fullListRef.current) {
      return;
    }

    if (toIndex >= _constants.PARTIAL_PAGE_LIMIT / 2) {
      setFullList(true); // Prevent change handler from firing again before setState kicks in

      fullListRef.current = true;
    }
  }, [isLoading]); // Set up the document list listener

  (0, _react.useEffect)(() => {
    // @todo: explain what this does
    const filterFn = fullList ? queryResult => Boolean(queryResult.result) : () => true; // Set loading state

    setResult(r => r ? { ...r,
      loading: true
    } : null);
    const queryResults$ = (0, _getQueryResults.getQueryResults)((0, _rxjs.of)({
      client,
      query,
      params
    }), {
      apiVersion,
      tag: 'desk.document-list'
    }).pipe((0, _operators.filter)(filterFn));
    const sub = queryResults$.subscribe(setResult);
    return () => sub.unsubscribe();
  }, [apiVersion, client, fullList, query, params]); // If `filter` or `params` changed, set up a new query from scratch.
  // If `sortOrder` changed, set up a new query from scratch as well.

  (0, _react.useEffect)(() => {
    setResult(null);
    setFullList(false);
    fullListRef.current = false;
  }, [filter, params, sortOrder, apiVersion]);
  return {
    error,
    fullList,
    handleListChange,
    isLoading,
    items,
    onRetry
  };
}