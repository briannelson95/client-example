"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyOrderingFunctions = applyOrderingFunctions;
exports.fieldExtendsType = fieldExtendsType;
exports.getDocumentKey = getDocumentKey;
exports.getTypeNameFromSingleTypeFilter = getTypeNameFromSingleTypeFilter;
exports.isSimpleTypeFilter = isSimpleTypeFilter;
exports.removePublishedWithDrafts = removePublishedWithDrafts;
exports.toOrderClause = toOrderClause;

var PathUtils = _interopRequireWildcard(require("@sanity/util/paths"));

var _types = require("@sanity/types");

var _util = require("../../../util");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function getDocumentKey(value, index) {
  return value._id ? (0, _util.getPublishedId)(value._id) : "item-".concat(index);
}

function removePublishedWithDrafts(documents) {
  return (0, _util.collate)(documents).map(entry => {
    const doc = entry.draft || entry.published;
    return { ...doc,
      hasPublished: !!entry.published,
      hasDraft: !!entry.draft
    };
  });
}

const RE_TYPE_NAME_IN_FILTER = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type\b/;

function getTypeNameFromSingleTypeFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const matches = filter.match(RE_TYPE_NAME_IN_FILTER);

  if (!matches) {
    return null;
  }

  const match = (matches[1] || matches[2]).trim().replace(/^["']|["']$/g, '');

  if (match[0] === '$') {
    const k = match.slice(1);
    const v = params[k];
    return typeof v === 'string' ? v : null;
  }

  return match;
}

function isSimpleTypeFilter(filter) {
  return /^_type\s*==\s*['"$]\w+['"]?\s*$/.test(filter.trim());
}

function toOrderClause(orderBy) {
  return orderBy.map(ordering => [wrapFieldWithFn(ordering), (ordering.direction || '').toLowerCase()].map(str => str.trim()).filter(Boolean).join(' ')).join(',');
}

function wrapFieldWithFn(ordering) {
  return ordering.mapWith ? "".concat(ordering.mapWith, "(").concat(ordering.field, ")") : ordering.field;
}

function applyOrderingFunctions(order, schemaType) {
  const orderBy = order.by.map(by => {
    // Skip those that already have a mapper
    if (by.mapWith) {
      return by;
    }

    const fieldType = tryResolveSchemaTypeForPath(schemaType, by.field);

    if (!fieldType) {
      return by;
    } // Note: order matters here, since the jsonType of a date field is `string`,
    // but we want to apply `datetime()`, not `lower()`


    if (fieldExtendsType(fieldType, 'datetime')) {
      return { ...by,
        mapWith: 'dateTime'
      };
    }

    if (fieldType.jsonType === 'string') {
      return { ...by,
        mapWith: 'lower'
      };
    }

    return by;
  });
  return orderBy.every((item, index) => item === order.by[index]) ? order : { ...order,
    by: orderBy
  };
}

function tryResolveSchemaTypeForPath(baseType, path) {
  const pathSegments = PathUtils.fromString(path);
  let current = baseType;

  for (const segment of pathSegments) {
    if (!current) {
      return undefined;
    }

    if (typeof segment === 'string') {
      current = getFieldTypeByName(current, segment);
      continue;
    }

    const isArrayAccessor = (0, _types.isKeySegment)(segment) || (0, _types.isIndexSegment)(segment);

    if (!isArrayAccessor || current.jsonType !== 'array') {
      return undefined;
    }

    const [memberType, otherType] = current.of || [];

    if (otherType || !memberType) {
      // Can't figure out the type without knowing the value
      return undefined;
    }

    if (!(0, _types.isReferenceSchemaType)(memberType)) {
      current = memberType;
      continue;
    }

    const [refType, otherRefType] = memberType.to || [];

    if (otherRefType || !refType) {
      // Can't figure out the type without knowing the value
      return undefined;
    }

    current = refType;
  }

  return current;
}

function getFieldTypeByName(type, fieldName) {
  if (!('fields' in type)) {
    return undefined;
  }

  const fieldType = type.fields.find(field => field.name === fieldName);
  return fieldType ? fieldType.type : undefined;
}

function fieldExtendsType(field, ofType) {
  let current = field.type;

  while (current) {
    if (current.name === ofType) {
      return true;
    }

    if (!current.type && current.jsonType === ofType) {
      return true;
    }

    current = current.type;
  }

  return false;
}