"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodePanesSegment = encodePanesSegment;
exports.legacyEditParamsToPath = legacyEditParamsToPath;
exports.legacyEditParamsToState = legacyEditParamsToState;
exports.parsePanesSegment = parsePanesSegment;
exports.router = void 0;
exports.toPath = toPath;
exports.toState = toState;

var _omit2 = _interopRequireDefault(require("lodash/omit"));

var _router = require("../router");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const EMPTY_PARAMS = {};
/**
 * @internal
 */

function legacyEditParamsToState(params) {
  try {
    return JSON.parse(decodeURIComponent(params));
  } catch (err) {
    // eslint-disable-next-line no-console
    console.warn('Failed to parse JSON parameters');
    return {};
  }
}

function encodePanesSegment(panes) {
  return (panes || []).map(group => group.map(encodeChunks).join('|')).map(encodeURIComponent).join(';');
}
/**
 * @internal
 */


function legacyEditParamsToPath(params) {
  return JSON.stringify(params);
} // http://localhost:3333/intent/create/template=book-by-author;type=book/eyJhdXRob3JJZCI6Imdycm0ifQ==

/**
 * @internal
 */


function toState(pathSegment) {
  return parsePanesSegment(decodeURIComponent(pathSegment));
}
/**
 * @internal
 */


function toPath(panes) {
  return encodePanesSegment(panes);
}

const router = _router.route.create('/', [// "Asynchronous intent resolving" route
_router.route.intents('/intent'), // Legacy fallback route, will be redirected to new format
_router.route.create('/edit/:type/:editDocumentId', [_router.route.create({
  path: '/:params',
  transform: {
    params: {
      toState: legacyEditParamsToState,
      toPath: legacyEditParamsToPath
    }
  }
})]), // The regular path - when the intent can be resolved to a specific pane
_router.route.create({
  path: '/:panes',
  // Legacy URLs, used to handle redirects
  children: [_router.route.create('/:action', _router.route.create('/:legacyEditDocumentId'))],
  transform: {
    panes: {
      toState,
      toPath
    }
  }
})]); // old: authors;knut,{"template":"diaryEntry"}
// new: authors;knut,view=diff,eyJyZXYxIjoiYWJjMTIzIiwicmV2MiI6ImRlZjQ1NiJ9|latest-posts


exports.router = router;
const panePattern = /^([.a-z0-9_-]+),?({.*?})?(?:(;|$))/i;

const isParam = str => /^[a-z0-9]+=[^=]+/i.test(str);

const isPayload = str => /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);

const exclusiveParams = ['view', 'since', 'rev'];
const isTruthy = Boolean;

function parseChunks(chunks, initial) {
  return chunks.reduce((pane, chunk) => {
    if (isParam(chunk)) {
      const key = chunk.slice(0, chunk.indexOf('='));
      const value = chunk.slice(key.length + 1);
      pane.params = { ...pane.params,
        [decodeURIComponent(key)]: decodeURIComponent(value)
      };
    } else if (isPayload(chunk)) {
      pane.payload = tryParseBase64Payload(chunk);
    } else {
      // eslint-disable-next-line no-console
      console.warn('Unknown pane segment: %s - skipping', chunk);
    }

    return pane;
  }, { ...initial,
    params: EMPTY_PARAMS,
    payload: undefined
  });
}

function encodeChunks(pane, index, group) {
  const {
    payload,
    params = {},
    id
  } = pane;
  const [firstSibling] = group;
  const paneIsFirstSibling = pane === firstSibling;
  const sameAsFirst = index !== 0 && id === firstSibling.id;
  const encodedPayload = typeof payload === 'undefined' ? undefined : btoa(JSON.stringify(payload));
  const encodedParams = Object.entries(params).filter(entry => {
    var _firstSibling$params;

    const [key, value] = entry;
    if (!value) return false;
    if (paneIsFirstSibling) return true; // omit the value if it's the same as the value from the first sibling

    const valueFromFirstSibling = (_firstSibling$params = firstSibling.params) === null || _firstSibling$params === void 0 ? void 0 : _firstSibling$params[key];
    if (value === valueFromFirstSibling && !exclusiveParams.includes(key)) return false;
    return true;
  }).map(_ref => {
    let [key, value] = _ref;
    return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
  });
  return [sameAsFirst ? '' : id].concat([encodedParams.length > 0 && encodedParams, encodedPayload].filter(isTruthy).flat()).join(',') || ',';
}

function parsePanesSegment(str) {
  if (str.indexOf(',{') !== -1) {
    return parseOldPanesSegment(str);
  }

  return str.split(';').map(group => {
    const [firstSibling, ...restOfSiblings] = group.split('|').map(segment => {
      const [id, ...chunks] = segment.split(',');
      return parseChunks(chunks, {
        id
      });
    });
    return [firstSibling, ...restOfSiblings.map(sibling => ({ ...firstSibling,
      ...sibling,
      id: sibling.id || firstSibling.id,
      params: { ...(0, _omit2.default)(firstSibling.params, exclusiveParams),
        ...sibling.params
      },
      payload: sibling.payload || firstSibling.payload
    }))];
  }).filter(group => group.length > 0);
}

function parseOldPanesSegment(str) {
  const chunks = [];
  let buffer = str;

  while (buffer.length) {
    const [match, id, payloadChunk] = buffer.match(panePattern) || [];

    if (!match) {
      buffer = buffer.slice(1);
      continue;
    }

    const payload = payloadChunk && tryParsePayload(payloadChunk);
    chunks.push({
      id,
      payload
    });
    buffer = buffer.slice(match.length);
  }

  return [chunks];
}

function tryParsePayload(json) {
  try {
    return JSON.parse(json);
  } catch (err) {
    // eslint-disable-next-line no-console
    console.warn("Failed to parse parameters: ".concat(err.message));
    return undefined;
  }
}

function tryParseBase64Payload(data) {
  return data ? tryParsePayload(atob(data)) : undefined;
}