"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveIntent = resolveIntent;

var _omit2 = _interopRequireDefault(require("lodash/omit"));

var _operators = require("rxjs/operators");

var _assignId = require("./assignId");

var _memoBind = require("./memoBind");

var _createPaneResolver = require("./createPaneResolver");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Resolves an intent request using breadth first search. If a match is not
 * found, the intent will resolve to the fallback editor.
 *
 * A match is found if:
 * 1. the `PaneNode` is of type `document` and the its ID matches the intent ID
 * 2. the `PaneNode` is of type `documentList` and the `schemaTypeName` matches
 * 3. the `PaneNode`'s `canHandleIntent` method returns true
 *
 * If a `PaneNode` of type `list` is found, it will be searched for a match.
 *
 * @see PaneNode
 */
async function resolveIntent(options) {
  const resolvedPaneCache = new Map(); // this is a simple version of the memoizer in `createResolvedPaneNodeStream`

  const memoize = nextFn => (unresolvedPane, context, flatIndex) => {
    const key = unresolvedPane && "".concat((0, _assignId.assignId)(unresolvedPane), "-").concat(context.path.join('__'));
    const cachedResolvedPane = key && resolvedPaneCache.get(key);
    if (cachedResolvedPane) return cachedResolvedPane;
    const result = nextFn(unresolvedPane, context, flatIndex);
    if (key) resolvedPaneCache.set(key, result);
    return result;
  };

  const resolvePane = (0, _createPaneResolver.createPaneResolver)(memoize);
  const fallbackEditorPanes = [[{
    id: "__edit__".concat(options.params.id),
    params: { ...(0, _omit2.default)(options.params, ['id']),
      type: options.params.type
    },
    payload: options.payload
  }]];

  async function traverse(_ref) {
    var _resolvedPane$canHand;

    let {
      currentId,
      flatIndex,
      intent,
      params,
      parent,
      path,
      payload,
      unresolvedPane,
      levelIndex,
      structureContext
    } = _ref;
    if (!unresolvedPane) return [];
    const {
      id: targetId,
      type: schemaTypeName,
      ...otherParams
    } = params;
    const context = {
      id: currentId,
      splitIndex: 0,
      parent,
      path,
      index: flatIndex,
      params: {},
      payload: undefined,
      structureContext
    };
    const resolvedPane = await resolvePane(unresolvedPane, context, flatIndex).pipe((0, _operators.first)()).toPromise(); // if the resolved pane is a document pane and the pane's ID matches then
    // resolve the intent to the current path

    if (resolvedPane.type === 'document' && resolvedPane.id === targetId) {
      return [{
        panes: [...path.slice(0, path.length - 1).map(i => [{
          id: i
        }]), [{
          id: targetId,
          params: otherParams,
          payload
        }]],
        depthIndex: path.length,
        levelIndex
      }];
    } // NOTE: if you update this logic, please also update the similar handler in
    // `getIntentState.ts`


    if ( // if the resolve pane's `canHandleIntent` returns true, then resolve
    (_resolvedPane$canHand = resolvedPane.canHandleIntent) !== null && _resolvedPane$canHand !== void 0 && _resolvedPane$canHand.call(resolvedPane, intent, params, {
      pane: resolvedPane,
      index: flatIndex
    }) || // if the pane's `canHandleIntent` did not return true, then match against
    // this default case. we will resolve the intent if:
    resolvedPane.type === 'documentList' && // 1. the schema type matches (this required for the document to render)
    resolvedPane.schemaTypeName === schemaTypeName && // 2. the filter is the default filter.
    //
    // NOTE: this case is to prevent false positive matches where the user
    // has configured a more specific filter for a particular type. In that
    // case, the user can implement their own `canHandleIntent` function
    resolvedPane.options.filter === '_type == $type') {
      return [{
        panes: [// map the current path to router panes
        ...path.map(id => [{
          id
        }]), // then augment with the intents IDs and params
        [{
          id: params.id,
          params: otherParams,
          payload
        }]],
        depthIndex: path.length,
        levelIndex
      }];
    }

    if (resolvedPane.type === 'list' && resolvedPane.child && resolvedPane.items) {
      return (await Promise.all(resolvedPane.items.map((item, nextLevelIndex) => {
        if (item.type === 'divider') return Promise.resolve([]);
        return traverse({
          currentId: item._id || item.id,
          flatIndex: flatIndex + 1,
          intent,
          params,
          parent: resolvedPane,
          path: [...path, item.id],
          payload,
          unresolvedPane: typeof resolvedPane.child === 'function' ? (0, _memoBind.memoBind)(resolvedPane, 'child') : resolvedPane.child,
          levelIndex: nextLevelIndex,
          structureContext
        });
      }))).flat();
    }

    return [];
  }

  const matchingPanes = await traverse({
    currentId: 'root',
    flatIndex: 0,
    levelIndex: 0,
    intent: options.intent,
    params: options.params,
    parent: null,
    path: [],
    payload: options.payload,
    unresolvedPane: options.rootPaneNode,
    structureContext: options.structureContext
  });
  const closestPaneToRoot = matchingPanes.sort((a, b) => {
    // break ties with the level index
    if (a.depthIndex === b.depthIndex) return a.levelIndex - b.levelIndex;
    return a.depthIndex - b.depthIndex;
  })[0];

  if (closestPaneToRoot) {
    return closestPaneToRoot.panes;
  }

  return fallbackEditorPanes;
}