"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useResolvedPanes = useResolvedPanes;

var _react = require("react");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _router = require("../../router");

var _constants = require("../constants");

var _useDeskTool = require("../useDeskTool");

var _createResolvedPaneNodeStream = require("./createResolvedPaneNodeStream");

function useRouterPanesStream() {
  const routerStateSubject = (0, _react.useMemo)(() => new _rxjs.ReplaySubject(1), []);
  const routerPanes$ = (0, _react.useMemo)(() => routerStateSubject.asObservable().pipe((0, _operators.map)(_routerState => (_routerState === null || _routerState === void 0 ? void 0 : _routerState.panes) || [])), [routerStateSubject]);
  const {
    state: routerState
  } = (0, _router.useRouter)();
  (0, _react.useEffect)(() => {
    routerStateSubject.next(routerState);
  }, [routerState, routerStateSubject]);
  return routerPanes$;
}

function useResolvedPanes() {
  // used to propagate errors from async effect. throwing inside of the render
  // will bubble the error to react where it can be picked up by standard error
  // boundaries
  const [error, setError] = (0, _react.useState)();
  if (error) throw error;
  const {
    structureContext,
    rootPaneNode
  } = (0, _useDeskTool.useDeskTool)();
  const [data, setData] = (0, _react.useState)({
    paneDataItems: [],
    resolvedPanes: [],
    routerPanes: []
  });
  const routerPanesStream = useRouterPanesStream();
  (0, _react.useEffect)(() => {
    const resolvedPanes$ = (0, _createResolvedPaneNodeStream.createResolvedPaneNodeStream)({
      rootPaneNode,
      routerPanesStream,
      structureContext
    }).pipe((0, _operators.map)(resolvedPanes => {
      const routerPanes = resolvedPanes.reduce((acc, next) => {
        const currentGroup = acc[next.groupIndex] || [];
        currentGroup[next.siblingIndex] = next.routerPaneSibling;
        acc[next.groupIndex] = currentGroup;
        return acc;
      }, []);
      const groupsLen = routerPanes.length;
      const paneDataItems = resolvedPanes.map(pane => {
        var _nextGroup$0$id;

        const {
          groupIndex,
          flatIndex,
          siblingIndex,
          routerPaneSibling,
          path
        } = pane;
        const itemId = routerPaneSibling.id;
        const nextGroup = routerPanes[groupIndex + 1];
        const paneDataItem = {
          active: groupIndex === groupsLen - 2,
          childItemId: (_nextGroup$0$id = nextGroup === null || nextGroup === void 0 ? void 0 : nextGroup[0].id) !== null && _nextGroup$0$id !== void 0 ? _nextGroup$0$id : null,
          index: flatIndex,
          itemId: routerPaneSibling.id,
          groupIndex,
          key: "".concat(pane.type === 'loading' ? 'unknown' : pane.paneNode.id, "-").concat(itemId, "-").concat(siblingIndex),
          pane: pane.type === 'loading' ? _constants.LOADING_PANE : pane.paneNode,
          params: routerPaneSibling.params || {},
          path: path.join(';'),
          payload: routerPaneSibling.payload,
          selected: flatIndex === resolvedPanes.length - 1,
          siblingIndex
        };
        return paneDataItem;
      });
      return {
        paneDataItems,
        routerPanes,
        resolvedPanes: paneDataItems.map(pane => pane.pane)
      };
    }));
    const subscription = resolvedPanes$.subscribe({
      next: result => setData(result),
      error: e => setError(e)
    });
    return () => subscription.unsubscribe();
  }, [rootPaneNode, routerPanesStream, structureContext]);
  return data;
}