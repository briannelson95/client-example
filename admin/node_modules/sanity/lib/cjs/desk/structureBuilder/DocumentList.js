"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DocumentListBuilder = void 0;
exports.getTypeNamesFromFilter = getTypeNamesFromFilter;

var _icons = require("@sanity/icons");

var _SerializeError = require("./SerializeError");

var _GenericList = require("./GenericList");

var _Document = require("./Document");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const resolveTypeForDocument = async (client, id) => {
  const query = '*[_id in [$documentId, $draftId]]._type';
  const documentId = id.replace(/^drafts\./, '');
  const draftId = "drafts.".concat(documentId);
  const types = await client // For structure-internal requests that we have control of the filter on,
  // we'll use this client with a more modern API version
  .withConfig({
    apiVersion: '2021-06-07'
  }).fetch(query, {
    documentId,
    draftId
  }, {
    tag: 'structure.resolve-type'
  });
  return types[0];
};

const validateFilter = (spec, options) => {
  var _spec$options;

  const filter = ((_spec$options = spec.options) === null || _spec$options === void 0 ? void 0 : _spec$options.filter.trim()) || '';

  if (['*', '{'].includes(filter[0])) {
    throw new _SerializeError.SerializeError("`filter` cannot start with `".concat(filter[0], "` - looks like you are providing a query, not a filter"), options.path, spec.id, spec.title).withHelpUrl(_SerializeError.HELP_URL.QUERY_PROVIDED_FOR_FILTER);
  }

  return filter;
};

const createDocumentChildResolverForItem = context => (itemId, options) => {
  var _options$params;

  const parentItem = options.parent;
  const template = (_options$params = options.params) !== null && _options$params !== void 0 && _options$params.template ? context.templates.find(tpl => tpl.id === options.params.template) : undefined;
  const type = template ? template.schemaType : parentItem.schemaTypeName || resolveTypeForDocument(context.client, itemId);
  return Promise.resolve(type).then(schemaType => schemaType ? context.resolveDocumentNode({
    schemaType,
    documentId: itemId
  }) : new _Document.DocumentBuilder(context).id('editor').documentId(itemId).schemaType(''));
};

class DocumentListBuilder extends _GenericList.GenericListBuilder {
  constructor(_context, spec) {
    super();
    this._context = _context;

    _defineProperty(this, "spec", void 0);

    this.spec = spec || {};
    this.initialValueTemplatesSpecified = Boolean(spec === null || spec === void 0 ? void 0 : spec.initialValueTemplates);
  }

  apiVersion(apiVersion) {
    return this.clone({
      options: { ...(this.spec.options || {
          filter: ''
        }),
        apiVersion
      }
    });
  }

  getApiVersion() {
    var _this$spec$options;

    return (_this$spec$options = this.spec.options) === null || _this$spec$options === void 0 ? void 0 : _this$spec$options.apiVersion;
  }

  filter(filter) {
    return this.clone({
      options: { ...(this.spec.options || {}),
        filter
      }
    });
  }

  getFilter() {
    var _this$spec$options2;

    return (_this$spec$options2 = this.spec.options) === null || _this$spec$options2 === void 0 ? void 0 : _this$spec$options2.filter;
  }

  schemaType(type) {
    const schemaTypeName = typeof type === 'string' ? type : type.name;
    return this.clone({
      schemaTypeName
    });
  }

  getSchemaType() {
    return this.spec.schemaTypeName;
  }

  params(params) {
    return this.clone({
      options: { ...(this.spec.options || {
          filter: ''
        }),
        params
      }
    });
  }

  getParams() {
    var _this$spec$options3;

    return (_this$spec$options3 = this.spec.options) === null || _this$spec$options3 === void 0 ? void 0 : _this$spec$options3.params;
  }

  defaultOrdering(ordering) {
    if (!Array.isArray(ordering)) {
      throw new Error('`defaultOrdering` must be an array of order clauses');
    }

    return this.clone({
      options: { ...(this.spec.options || {
          filter: ''
        }),
        defaultOrdering: ordering
      }
    });
  }

  getDefaultOrdering() {
    var _this$spec$options4;

    return (_this$spec$options4 = this.spec.options) === null || _this$spec$options4 === void 0 ? void 0 : _this$spec$options4.defaultOrdering;
  }

  serialize() {
    var _this$spec$options5;

    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      path: []
    };

    if (typeof this.spec.id !== 'string' || !this.spec.id) {
      throw new _SerializeError.SerializeError('`id` is required for document lists', options.path, options.index, this.spec.title).withHelpUrl(_SerializeError.HELP_URL.ID_REQUIRED);
    }

    if (!this.spec.options || !this.spec.options.filter) {
      throw new _SerializeError.SerializeError('`filter` is required for document lists', options.path, this.spec.id, this.spec.title).withHelpUrl(_SerializeError.HELP_URL.FILTER_REQUIRED);
    }

    return { ...super.serialize(options),
      type: 'documentList',
      schemaTypeName: this.spec.schemaTypeName,
      child: this.spec.child || createDocumentChildResolverForItem(this._context),
      options: { ...this.spec.options,
        apiVersion: this.spec.options.apiVersion || ( // If this is a simple type filter, use modern API version - otherwise default to v1
        ((_this$spec$options5 = this.spec.options) === null || _this$spec$options5 === void 0 ? void 0 : _this$spec$options5.filter) === '_type == $type' ? '2021-06-07' : '1'),
        filter: validateFilter(this.spec, options)
      }
    };
  }

  clone(withSpec) {
    const builder = new DocumentListBuilder(this._context);
    builder.spec = { ...this.spec,
      ...(withSpec || {})
    };

    if (!this.initialValueTemplatesSpecified) {
      builder.spec.initialValueTemplates = inferInitialValueTemplates(this._context, builder.spec);
    }

    if (!builder.spec.schemaTypeName) {
      builder.spec.schemaTypeName = inferTypeName(builder.spec);
    }

    return builder;
  }

  getSpec() {
    return this.spec;
  }

}

exports.DocumentListBuilder = DocumentListBuilder;

function inferInitialValueTemplates(context, spec) {
  const {
    document
  } = context;
  const {
    schemaTypeName,
    options
  } = spec;
  const {
    filter,
    params
  } = options || {
    filter: '',
    params: {}
  };
  const typeNames = schemaTypeName ? [schemaTypeName] : Array.from(new Set(getTypeNamesFromFilter(filter, params)));

  if (typeNames.length === 0) {
    return undefined;
  }

  return typeNames.flatMap(schemaType => document.resolveNewDocumentOptions({
    type: 'structure',
    schemaType
  })).map(option => ({ ...option,
    icon: _icons.ComposeIcon
  }));
}

function inferTypeName(spec) {
  const {
    options
  } = spec;
  const {
    filter,
    params
  } = options || {
    filter: '',
    params: {}
  };
  const typeNames = getTypeNamesFromFilter(filter, params);
  return typeNames.length === 1 ? typeNames[0] : undefined;
}

function getTypeNamesFromFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let typeNames = getTypeNamesFromEqualityFilter(filter, params);

  if (typeNames.length === 0) {
    typeNames = getTypeNamesFromInTypesFilter(filter, params);
  }

  return typeNames;
} // From _type == "movie" || _type == $otherType


function getTypeNamesFromEqualityFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const pattern = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type/g;
  const matches = [];
  let match;

  while ((match = pattern.exec(filter)) !== null) {
    matches.push(match[1] || match[2]);
  }

  return matches.map(candidate => {
    const typeName = candidate[0] === '$' ? params[candidate.slice(1)] : candidate;
    const normalized = (typeName || '').trim().replace(/^["']|["']$/g, '');
    return normalized;
  }).filter(Boolean);
} // From _type in ["dog", "cat", $otherSpecies]


function getTypeNamesFromInTypesFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const pattern = /\b_type\s+in\s+\[(.*?)\]/;
  const matches = filter.match(pattern);

  if (!matches) {
    return [];
  }

  return matches[1].split(/,\s*/).map(match => match.trim().replace(/^["']+|["']+$/g, '')).map(item => item[0] === '$' ? params[item.slice(1)] : item).filter(Boolean);
}