"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDocumentTypeList = getDocumentTypeList;
exports.getDocumentTypeListItem = getDocumentTypeListItem;
exports.getDocumentTypeListItems = getDocumentTypeListItems;
exports.getDocumentTypes = getDocumentTypes;

var _startCase2 = _interopRequireDefault(require("lodash/startCase"));

var _icons = require("@sanity/icons");

var _MenuItem = require("./MenuItem");

var _Sort = require("./Sort");

var _ListItem = require("./ListItem");

var _DocumentTypeList = require("./DocumentTypeList");

var _Intent = require("./Intent");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function shouldShowIcon(schemaType) {
  const preview = schemaType.preview;
  return Boolean(preview && (preview.prepare || preview.select && preview.select.media));
}

const BUNDLED_DOC_TYPES = ['sanity.imageAsset', 'sanity.fileAsset'];

function isBundledDocType(typeName) {
  return BUNDLED_DOC_TYPES.includes(typeName);
}

function isDocumentType(schemaType) {
  var _schemaType$type;

  return ((_schemaType$type = schemaType.type) === null || _schemaType$type === void 0 ? void 0 : _schemaType$type.name) === 'document';
}

function isList(collection) {
  return collection.type === 'list';
}

function getDocumentTypes(_ref) {
  let {
    schema
  } = _ref;
  return schema.getTypeNames().filter(n => {
    const schemaType = schema.get(n);
    return schemaType && isDocumentType(schemaType);
  }).filter(n => !isBundledDocType(n));
}

function getDocumentTypeListItems(context) {
  const types = getDocumentTypes(context);
  return types.map(typeName => getDocumentTypeListItem(context, typeName));
}

function getDocumentTypeListItem(context, typeName) {
  const {
    schema
  } = context;
  const type = schema.get(typeName);

  if (!type) {
    throw new Error("Schema type with name \"".concat(typeName, "\" not found"));
  }

  const title = type.title || (0, _startCase2.default)(typeName);
  return new _ListItem.ListItemBuilder(context).id(typeName).title(title).schemaType(typeName).child((id, childContext) => {
    const parent = childContext.parent;
    const parentItem = isList(parent) ? parent.items.find(item => item.id === id) : null;
    let list = getDocumentTypeList(context, typeName);

    if (parentItem && parentItem.title) {
      list = list.title(parentItem.title);
    }

    return list;
  });
}

function getDocumentTypeList(context, typeNameOrSpec) {
  const {
    schema,
    resolveDocumentNode
  } = context;
  const schemaType = typeof typeNameOrSpec === 'string' ? typeNameOrSpec : typeNameOrSpec.schemaType;
  const typeName = typeof schemaType === 'string' ? schemaType : schemaType.name;
  const spec = typeof typeNameOrSpec === 'string' ? {
    schemaType
  } : typeNameOrSpec;
  const type = schema.get(typeName);

  if (!type) {
    throw new Error("Schema type with name \"".concat(typeName, "\" not found"));
  }

  const title = type.title || (0, _startCase2.default)(typeName);
  const showIcons = shouldShowIcon(type);
  return new _DocumentTypeList.DocumentTypeListBuilder(context).id(spec.id || typeName).title(spec.title || title).filter('_type == $type').params({
    type: typeName
  }).schemaType(typeName).showIcons(showIcons).defaultOrdering(_Sort.DEFAULT_SELECTED_ORDERING_OPTION.by).menuItemGroups(spec.menuItemGroups || [{
    id: 'sorting',
    title: 'Sort'
  }, {
    id: 'layout',
    title: 'Layout'
  }, {
    id: 'actions',
    title: 'Actions'
  }]).child(spec.child || (documentId => resolveDocumentNode({
    schemaType: typeName,
    documentId
  }))).canHandleIntent(spec.canHandleIntent || _Intent.defaultIntentChecker).menuItems(spec.menuItems || [// Create new (from action button) will be added in serialization step of GenericList
  // Sort by <Y>
  ...(0, _MenuItem.getOrderingMenuItemsForSchemaType)(context, type), // Display as <Z>
  new _MenuItem.MenuItemBuilder(context).group('layout').title('Compact view').icon(_icons.StackCompactIcon).action('setLayout').params({
    layout: 'default'
  }), new _MenuItem.MenuItemBuilder(context).group('layout').title('Detailed view').icon(_icons.SplitHorizontalIcon).action('setLayout').params({
    layout: 'detail'
  }) // Create new (from menu) will be added in serialization step of GenericList
  ]);
}