"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolvePathFromState = resolvePathFromState;

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _findMatchingRoutes = require("./findMatchingRoutes");

var _debug = require("./utils/debug");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @public
 */
function resolvePathFromState(node, state) {
  (0, _debug.debug)('Resolving path from state %o', state);
  const match = (0, _findMatchingRoutes.findMatchingRoutes)(node, state);

  if (match.remaining.length > 0) {
    const remaining = match.remaining;
    throw new Error("Unable to find matching route for state. Could not map the following state key".concat(remaining.length == 1 ? '' : 's', " to a valid url: ").concat(remaining.join(', ')));
  }

  if (match.nodes.length === 0) {
    throw new Error("Unable to resolve path from given state: ".concat(JSON.stringify(state)));
  }

  let scopedState = state;
  const relative = (0, _flatten2.default)(match.nodes.map(matchNode => {
    if (matchNode.scope && matchNode.scope in scopedState) {
      scopedState = scopedState[matchNode.scope];
    }

    return matchNode.route.segments.map(segment => {
      if (segment.type === 'dir') {
        return segment.name;
      }

      const transform = matchNode.transform && matchNode.transform[segment.name];
      return transform ? transform.toPath(scopedState[segment.name]) : scopedState[segment.name];
    });
  })).join('/');
  (0, _debug.debug)('Resolved to /%s', relative);
  return "/".concat(relative);
}