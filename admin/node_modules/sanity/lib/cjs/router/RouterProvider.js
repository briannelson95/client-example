"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RouterProvider = RouterProvider;

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _react = _interopRequireWildcard(require("react"));

var _RouterContext = require("./RouterContext");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @example
 * ```tsx
 * import {
 *   NavigateOptions,
 *   route,
 *   RouterProvider,
 *   RouterState
 * } from 'sanity'
 * import {useCallback, useMemo} from 'react'
 *
 * function Root() {
 *   const router = useMemo(() => route.create('/'), [])
 *
 *   const [state, setState] = useState<RouterState>({})
 *
 *   const handleNavigate = useCallback((
 *     path: string,
 *     options?: NavigateOptions
 *   ) => {
 *     console.log('navigate', path, options)
 *
 *     setState(router.decode(path))
 *   }, [router])
 *
 *   return (
 *     <RouterProvider
 *       onNavigate={handleNavigate}
 *       router={router}
 *       state={state}
 *     >
 *       <div>This is a routed application</div>
 *     </RouterProvider>
 *   )
 * }
 * ```
 *
 * @public
 */
function RouterProvider(props) {
  // TODO: can we do nested routes?
  const {
    onNavigate,
    router: routerProp,
    state: stateProp
  } = props;
  const [state, setState] = (0, _react.useState)(stateProp);
  const stateRef = (0, _react.useRef)(state);
  const navigateUrl = (0, _react.useCallback)(opts => {
    onNavigate(opts);
  }, [onNavigate]);
  const resolveIntentLink = (0, _react.useCallback)((intentName, parameters) => {
    const [params, payload] = Array.isArray(parameters) ? parameters : [parameters];
    return routerProp.encode({
      intent: intentName,
      params,
      payload
    });
  }, [routerProp]);
  const resolvePathFromState = (0, _react.useCallback)(nextState => {
    return routerProp.encode(nextState);
  }, [routerProp]);
  const navigate = (0, _react.useCallback)(function (nextState) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    navigateUrl({
      path: resolvePathFromState(nextState),
      replace: options.replace
    });
  }, [navigateUrl, resolvePathFromState]);
  const navigateIntent = (0, _react.useCallback)(function (intentName, params) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    navigateUrl({
      path: resolveIntentLink(intentName, params),
      replace: options.replace
    });
  }, [navigateUrl, resolveIntentLink]);
  const router = (0, _react.useMemo)(() => ({
    navigate,
    navigateIntent,
    navigateUrl,
    resolveIntentLink,
    resolvePathFromState,
    state
  }), [navigate, navigateIntent, navigateUrl, resolveIntentLink, resolvePathFromState, state]); // Update state as new `state` prop comes in

  (0, _react.useEffect)(() => {
    const prevState = stateRef.current;
    const nextState = stateProp;

    if (!(0, _isEqual2.default)(nextState, prevState)) {
      setState(nextState);
    }
  }, [stateProp]);
  return /*#__PURE__*/_react.default.createElement(_RouterContext.RouterContext.Provider, {
    value: router
  }, props.children);
}