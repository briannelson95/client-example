"use strict";

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _reactHooks = require("@testing-library/react-hooks");

var Rx = _interopRequireWildcard(require("rxjs"));

var _createHookFromObservableFactory = require("../createHookFromObservableFactory");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const tick = () => new Promise(resolve => setTimeout(resolve, 0));

describe('createHookFromObservableFactory', () => {
  it('takes in an observable factory and returns a loading-tuple hook', async () => {
    const observableFactory = value => Rx.concat(Rx.from(tick().then(() => "hello, ".concat(value))), Rx.from(tick().then(() => "hi, ".concat(value))));

    const useHook = (0, _createHookFromObservableFactory.createHookFromObservableFactory)(observableFactory);
    const {
      result,
      waitForNextUpdate
    } = (0, _reactHooks.renderHook)(() => useHook('world'));
    await waitForNextUpdate();
    expect(result.all).toEqual([[undefined, true], // note: the loading state staying at false is expected here because the
    // next update came from the observable which doesn't tell us when it has
    // an incoming update from it's source (it just pushes and we consume)
    ['hello, world', false], ['hi, world', false]]);
  });
  it('flips the loading state if the hook argument changes', async () => {
    const observableFactory = jest.fn(value => Rx.from(tick().then(() => ({
      value: "hello, ".concat(value)
    }))));
    const useHook = (0, _createHookFromObservableFactory.createHookFromObservableFactory)(observableFactory);
    const {
      result,
      rerender,
      waitForNextUpdate
    } = (0, _reactHooks.renderHook)(useHook, {
      initialProps: 'world'
    });
    await waitForNextUpdate();
    rerender('hooks');
    await waitForNextUpdate(); // using `uniq` because the hooks testing library will
    // log it twice but it is the same instance

    expect((0, _uniq2.default)(result.all)).toEqual([[undefined, true], [{
      value: 'hello, world'
    }, false], [{
      value: 'hello, world'
    }, true], [{
      value: 'hello, hooks'
    }, false]]);
    expect(observableFactory).toHaveBeenCalledTimes(2);
  });
  it('accepts an initial value and will return that immediately', async () => {
    const observableFactory = jest.fn(value => Rx.from(tick().then(() => "hello, ".concat(value))));
    const useHook = (0, _createHookFromObservableFactory.createHookFromObservableFactory)(observableFactory, {
      initialValue: 'factory initial'
    });
    const {
      result,
      waitForNextUpdate
    } = (0, _reactHooks.renderHook)(useHook, {
      initialProps: 'world'
    });
    await waitForNextUpdate();
    expect(result.all).toEqual([['factory initial', true], ['hello, world', false]]);
    expect(observableFactory).toHaveBeenCalledTimes(1);
  });
  it('bubbles errors throws in the observable factory', async () => {
    var _result$error;

    // Error is hoisted. To prevent it from being printed as uncaught in terminal,
    // we explicitly catch it and suppress it, recording that it has been called.
    const preventer = jest.fn(evt => evt.preventDefault());

    if (typeof window !== 'undefined') {
      window.addEventListener('error', preventer, false);
    }

    const observableFactory = () => Rx.from(tick().then(() => {
      throw new Error('test error');
    }));

    const useHook = (0, _createHookFromObservableFactory.createHookFromObservableFactory)(observableFactory, {
      initialValue: 'factory initial'
    });
    const {
      result,
      waitForNextUpdate
    } = (0, _reactHooks.renderHook)(useHook, {
      initialProps: 'world'
    });
    await waitForNextUpdate();
    expect((_result$error = result.error) === null || _result$error === void 0 ? void 0 : _result$error.message).toBe('test error');

    if (typeof window !== 'undefined') {
      window.removeEventListener('error', preventer, false);
      expect(preventer).toHaveBeenCalled();
    }
  });
});