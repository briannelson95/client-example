"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPathObserver = createPathObserver;

var _uniq2 = _interopRequireDefault(require("lodash/uniq"));

var _isString2 = _interopRequireDefault(require("lodash/isString"));

var _types = require("@sanity/types");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _util = require("../util");

var _props = require("./utils/props");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createEmpty(fields) {
  return fields.reduce((result, field) => {
    result[field] = undefined;
    return result;
  }, {});
}

function resolveMissingHeads(value, paths) {
  return paths.filter(path => !(path[0] in value));
}

function observePaths(value, paths, observeFields, apiConfig) {
  if (!value || typeof value !== 'object') {
    // Reached a leaf. Return as is
    return (0, _rxjs.of)(value); // @todo
  }

  const id = (0, _types.isReference)(value) ? value._ref : value._id;
  const currentValue = { ...value,
    _id: id
  };

  if (currentValue._type === 'reference') {
    delete currentValue._type;
    delete currentValue._ref;
    delete currentValue._weak;
    delete currentValue._dataset;
    delete currentValue._projectId;
    delete currentValue._strengthenOnPublish;
  }

  const pathsWithMissingHeads = resolveMissingHeads(currentValue, paths);

  if (id && pathsWithMissingHeads.length > 0) {
    // Reached a node that is either a document (with _id), or a reference (with _ref) that
    // needs to be "materialized"
    const nextHeads = (0, _uniq2.default)(pathsWithMissingHeads.map(path => path[0]));
    const dataset = (0, _util.isRecord)(value) && (0, _isString2.default)(value._dataset) ? value._dataset : undefined;
    const projectId = (0, _util.isRecord)(value) && (0, _isString2.default)(value._projectId) ? value._projectId : undefined;
    const refApiConfig = // if it's a cross dataset reference we want to use it's `_projectId` + `_dataset`
    // attributes as api config
    dataset && projectId ? {
      projectId: projectId,
      dataset: dataset
    } : apiConfig;
    return observeFields(id, nextHeads, refApiConfig).pipe((0, _operators.switchMap)(snapshot => {
      if (snapshot === null) {
        return (0, _rxjs.of)(null);
      }

      return observePaths({ ...createEmpty(nextHeads),
        ...((0, _types.isReference)(value) ? { ...value,
          ...refApiConfig
        } : value),
        ...snapshot
      }, paths, observeFields, refApiConfig);
    }));
  } // We have all the fields needed already present on value


  const leads = {};
  paths.forEach(path => {
    const [head, ...tail] = path;

    if (!leads[head]) {
      leads[head] = [];
    }

    leads[head].push(tail);
  });
  const next = Object.keys(leads).reduce((res, head) => {
    const tails = leads[head].filter(tail => tail.length > 0);

    if (tails.length === 0) {
      res[head] = (0, _util.isRecord)(value) ? value[head] : undefined;
    } else {
      res[head] = observePaths(value[head], tails, observeFields, apiConfig);
    }

    return res;
  }, currentValue);
  return (0, _rxjs.of)(next).pipe((0, _props.props)({
    wait: true
  }));
} // Normalizes path arguments so it supports both dot-paths and array paths, e.g.
// - ['propA.propB', 'propA.propC']
// - [['propA', 'propB'], ['propA', 'propC']]


function normalizePaths(path) {
  return path.map(segment => typeof segment === 'string' ? segment.split('.') : segment);
}

function createPathObserver(context) {
  const {
    observeFields
  } = context;
  return {
    observePaths(value, paths, apiConfig) {
      return observePaths(value, normalizePaths(paths), observeFields, apiConfig);
    }

  };
}