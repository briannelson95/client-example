"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.intersectionObservableFor = void 0;

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _resize = require("./resize");

var _scroll = require("./scroll");

var _orientationChange = require("./orientationChange");

const ROOT_MARGIN_PX = 150;
/*
  Adapted from the polyfill at https://github.com/WICG/IntersectionObserver
*/

function isIntersectionObserverSupported() {
  if (typeof window !== 'undefined' && 'IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in IntersectionObserverEntry.prototype) {
    // Minimal polyfill for Edge 15's lack of `isIntersecting`
    // See: https://github.com/WICG/IntersectionObserver/issues/211
    if (!('isIntersecting' in IntersectionObserverEntry.prototype)) {
      Object.defineProperty(IntersectionObserverEntry.prototype, 'isIntersecting', {
        get() {
          return this.intersectionRatio > 0;
        }

      });
    }

    return true;
  }

  return false;
}

const intersectionObservableFor = isIntersectionObserverSupported() ? createIntersectionObserverBased() : createLegacyBased();
exports.intersectionObservableFor = intersectionObservableFor;

function createIntersectionObserverBased() {
  const intersectionObserverEntriesSubject = new _rxjs.Subject();
  const intersectionObserver = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      intersectionObserverEntriesSubject.next(entry);
    });
  }, {
    threshold: 0,
    rootMargin: "".concat(ROOT_MARGIN_PX, "px")
  }); // eslint-disable-next-line @typescript-eslint/no-shadow

  return function intersectionObservableFor(element) {
    return new _rxjs.Observable(observer => {
      intersectionObserver.observe(element);
      observer.next();
      return () => intersectionObserver.unobserve(element);
    }).pipe((0, _operators.mergeMap)(() => intersectionObserverEntriesSubject.asObservable()), (0, _operators.filter)(entry => entry.target === element), (0, _operators.map)(ev => ({
      isIntersecting: ev.isIntersecting
    })));
  };
} // This can be removed when intersection observer are supported by the browsers we support


function createLegacyBased() {
  function getViewport() {
    return {
      left: 0,
      right: window.innerWidth,
      top: 0,
      bottom: window.innerHeight
    };
  }

  function intersects(rect, viewport, margin) {
    return rect.left <= viewport.right + margin && rect.right >= viewport.left - margin && rect.top <= viewport.bottom + margin && rect.bottom >= viewport.top - margin;
  }

  function inViewport(element) {
    return () => intersects(element.getBoundingClientRect(), getViewport(), ROOT_MARGIN_PX);
  } // eslint-disable-next-line @typescript-eslint/no-shadow


  return function intersectionObservableFor(element) {
    const isElementInViewport = inViewport(element);
    return (0, _rxjs.merge)((0, _rxjs.of)(isElementInViewport()), _resize.resize$, _scroll.scroll$, _orientationChange.orientationChange$).pipe( // @todo: consider "faking" more of the IntersectionObserverEntry api if possible
    (0, _operators.map)(isElementInViewport), (0, _operators.map)(isIntersecting => ({
      isIntersecting
    })));
  };
}