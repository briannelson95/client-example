import { isBlock } from '@sanity/types';
import { isEqual } from 'lodash';
import { DEFAULT_BLOCK } from '../constants';
import { resolveJsType } from '../util/resolveJsType';
import blockContentTypeFeatures from '../util/blockContentTypeFeatures';
import preprocessors from './preprocessors';
/**
 * A utility function to create the options needed for the various rule sets,
 * based on the structure of the blockContentType
 *
 * @param blockContentType - Schema type for array containing _at least_ a block child type
 * @returns
 */
export function createRuleOptions(blockContentType) {
    const features = blockContentTypeFeatures(blockContentType);
    const enabledBlockStyles = features.styles.map((item) => item.value || item.title);
    const enabledSpanDecorators = features.decorators.map((item) => item.value || item.title);
    const enabledBlockAnnotations = features.annotations.map((item) => item.value || item.title || '');
    return {
        enabledBlockStyles,
        enabledSpanDecorators,
        enabledBlockAnnotations,
    };
}
/**
 * Utility function that always return a lowerCase version of the element.tagName
 *
 * @param el - Element to get tag name for
 * @returns Lowercase tagName for that element, or undefined if not an element
 */
export function tagName(el) {
    if (el && 'tagName' in el) {
        return el.tagName.toLowerCase();
    }
    return undefined;
}
// TODO: make this plugin-style
export function preprocess(html, parseHtml) {
    const compactHtml = html
        .trim() // Trim whitespace
        .replace(/\s\s+/g, ' ') // Remove multiple whitespace
        .replace(/[\r\n]/g, ' '); // Remove newlines / carriage returns
    const doc = parseHtml(compactHtml);
    preprocessors.forEach((processor) => {
        processor(html, doc);
    });
    return doc;
}
/**
 * A default `parseHtml` function that returns the html using `DOMParser`.
 *
 * @returns HTML Parser based on `DOMParser`
 */
export function defaultParseHtml() {
    if (resolveJsType(DOMParser) === 'undefined') {
        throw new Error('The native `DOMParser` global which the `Html` deserializer uses by ' +
            'default is not present in this environment. ' +
            'You must supply the `options.parseHtml` function instead.');
    }
    return (html) => {
        return new DOMParser().parseFromString(html, 'text/html');
    };
}
export function flattenNestedBlocks(blocks) {
    let depth = 0;
    const flattened = [];
    const traverse = (nodes) => {
        const toRemove = [];
        nodes.forEach((node) => {
            if (depth === 0) {
                flattened.push(node);
            }
            if (isBlock(node)) {
                if (depth > 0) {
                    toRemove.push(node);
                    flattened.push(node);
                }
                depth++;
                traverse(node.children);
            }
            if (node._type === '__block') {
                toRemove.push(node);
                flattened.push(node.block);
            }
        });
        toRemove.forEach((node) => {
            nodes.splice(nodes.indexOf(node), 1);
        });
        depth--;
    };
    traverse(blocks);
    return flattened;
}
function nextSpan(block, index) {
    const next = block.children[index + 1];
    return next && next._type === 'span' ? next : null;
}
function prevSpan(block, index) {
    const prev = block.children[index - 1];
    return prev && prev._type === 'span' ? prev : null;
}
function isWhiteSpaceChar(text) {
    return ['\xa0', ' '].includes(text);
}
/**
 * NOTE: _mutates_ passed blocks!
 *
 * @param blocks - Array of blocks to trim whitespace for
 * @returns
 */
export function trimWhitespace(blocks) {
    blocks.forEach((block) => {
        if (!isBlock(block)) {
            return;
        }
        // eslint-disable-next-line complexity
        block.children.forEach((child, index) => {
            if (child._type !== 'span') {
                return;
            }
            const nextChild = nextSpan(block, index);
            const prevChild = prevSpan(block, index);
            if (index === 0) {
                child.text = child.text.replace(/^[^\S\n]+/g, '');
            }
            if (index === block.children.length - 1) {
                child.text = child.text.replace(/[^\S\n]+$/g, '');
            }
            if (/\s/.test(child.text.substring(child.text.length - 1)) &&
                nextChild &&
                /\s/.test(nextChild.text.substring(0, 1))) {
                child.text = child.text.replace(/[^\S\n]+$/g, '');
            }
            if (/\s/.test(child.text.substring(0, 1)) &&
                prevChild &&
                /\s/.test(prevChild.text.substring(prevChild.text.length - 1))) {
                child.text = child.text.replace(/^[^\S\n]+/g, '');
            }
            if (!child.text) {
                block.children.splice(index, 1);
            }
            if (prevChild && isEqual(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text)) {
                prevChild.text += ' ';
                block.children.splice(index, 1);
            }
            else if (nextChild &&
                isEqual(nextChild.marks, child.marks) &&
                isWhiteSpaceChar(child.text)) {
                nextChild.text = ` ${nextChild.text}`;
                block.children.splice(index, 1);
            }
        });
    });
    return blocks;
}
export function ensureRootIsBlocks(blocks) {
    return blocks.reduce((memo, node, i, original) => {
        if (node._type === 'block') {
            memo.push(node);
            return memo;
        }
        if (node._type === '__block') {
            memo.push(node.block);
            return memo;
        }
        const lastBlock = memo[memo.length - 1];
        if (i > 0 && !isBlock(original[i - 1]) && isBlock(lastBlock)) {
            lastBlock.children.push(node);
            return memo;
        }
        const block = {
            ...DEFAULT_BLOCK,
            children: [node],
        };
        memo.push(block);
        return memo;
    }, []);
}
export function isNodeList(node) {
    return Object.prototype.toString.call(node) == '[object NodeList]';
}
export function isMinimalSpan(node) {
    return node._type === 'span';
}
export function isMinimalBlock(node) {
    return node._type === 'block';
}
export function isPlaceholderDecorator(node) {
    return node._type === '__decorator';
}
export function isPlaceholderAnnotation(node) {
    return node._type === '__annotation';
}
export function isElement(node) {
    return node.nodeType === 1;
}
//# sourceMappingURL=helpers.js.map