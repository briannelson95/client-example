'use strict';

var types = require('@sanity/types');
var lodash = require('lodash');
var getRandomValues = require('get-random-values-esm');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var getRandomValues__default = /*#__PURE__*/_interopDefaultLegacy(getRandomValues);

function findBlockType(type) {
    if (type.type) {
        return findBlockType(type.type);
    }
    if (type.name === 'block') {
        return true;
    }
    return false;
}

// Helper method for describing a blockContentType's feature set
function blockContentFeatures(blockContentType) {
    if (!blockContentType) {
        throw new Error("Parameter 'blockContentType' required");
    }
    const blockType = blockContentType.of.find(findBlockType);
    if (!types.isBlockSchemaType(blockType)) {
        throw new Error("'block' type is not defined in this schema (required).");
    }
    const ofType = blockType.fields.find(types.isBlockChildrenObjectField)?.type?.of;
    if (!ofType) {
        throw new Error('No `of` declaration found for blocks `children` field');
    }
    const spanType = ofType.find((member) => member.name === 'span');
    if (!spanType) {
        throw new Error('No `span` type found in `block` schema type `children` definition');
    }
    const inlineObjectTypes = ofType.filter((inlineType) => inlineType.name !== 'span' && types.isObjectSchemaType(inlineType));
    const blockObjectTypes = blockContentType.of.filter((memberType) => memberType.name !== blockType.name && types.isObjectSchemaType(memberType));
    return {
        styles: resolveEnabledStyles(blockType),
        decorators: resolveEnabledDecorators(spanType),
        annotations: resolveEnabledAnnotationTypes(spanType),
        lists: resolveEnabledListItems(blockType),
        types: {
            block: blockContentType,
            span: spanType,
            inlineObjects: inlineObjectTypes,
            blockObjects: blockObjectTypes,
        },
    };
}
function resolveEnabledStyles(blockType) {
    const styleField = blockType.fields.find(types.isStyleObjectField);
    if (!styleField) {
        throw new Error("A field with name 'style' is not defined in the block type (required).");
    }
    const textStyles = getTitledListValuesFromEnumListOptions(styleField.type.options);
    if (textStyles.length === 0) {
        throw new Error('The style fields need at least one style ' +
            "defined. I.e: {title: 'Normal', value: 'normal'}.");
    }
    return textStyles;
}
function resolveEnabledAnnotationTypes(spanType) {
    return spanType.annotations.map((annotation) => ({
        blockEditor: annotation.blockEditor,
        title: annotation.title,
        type: annotation,
        value: annotation.name,
        icon: annotation.icon,
    }));
}
function resolveEnabledDecorators(spanType) {
    return spanType.decorators;
}
function resolveEnabledListItems(blockType) {
    const listField = blockType.fields.find(types.isListObjectField);
    if (!listField) {
        throw new Error("A field with name 'list' is not defined in the block type (required).");
    }
    const listItems = getTitledListValuesFromEnumListOptions(listField.type.options);
    if (!listItems) {
        throw new Error('The list field need at least to be an empty array');
    }
    return listItems;
}
function getTitledListValuesFromEnumListOptions(options) {
    const list = options ? options.list : undefined;
    if (!Array.isArray(list)) {
        return [];
    }
    return list.map((item) => (types.isTitledListValue(item) ? item : { title: item, value: item }));
}

const toString = Object.prototype.toString;
// Copied from https://github.com/ForbesLindesay/type-of
// but inlined to have fine grained control
function resolveJsType(val) {
    switch (toString.call(val)) {
        case '[object Function]':
            return 'function';
        case '[object Date]':
            return 'date';
        case '[object RegExp]':
            return 'regexp';
        case '[object Arguments]':
            return 'arguments';
        case '[object Array]':
            return 'array';
        case '[object String]':
            return 'string';
    }
    if (val === null) {
        return 'null';
    }
    if (val === undefined) {
        return 'undefined';
    }
    if (val &&
        typeof val === 'object' &&
        'nodeType' in val &&
        val.nodeType === 1) {
        return 'element';
    }
    if (val === Object(val)) {
        return 'object';
    }
    return typeof val;
}

// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html
function whatwgRNG(length = 16) {
    const rnds8 = new Uint8Array(length);
    getRandomValues__default["default"](rnds8);
    return rnds8;
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 0x100).toString(16).substring(1);
}
/**
 * Generate a random key of the given length
 *
 * @param length - Length of string to generate
 * @returns A string of the given length
 * @public
 */
function randomKey(length) {
    return whatwgRNG(length)
        .reduce((str, n) => str + byteToHex[n], '')
        .slice(0, length);
}

const BLOCK_DEFAULT_STYLE = 'normal';
const DEFAULT_BLOCK = Object.freeze({
    _type: 'block',
    markDefs: [],
    style: BLOCK_DEFAULT_STYLE,
});
const DEFAULT_SPAN = Object.freeze({
    _type: 'span',
    marks: [],
});
const HTML_BLOCK_TAGS = {
    p: DEFAULT_BLOCK,
    blockquote: { ...DEFAULT_BLOCK, style: 'blockquote' },
};
const HTML_SPAN_TAGS = {
    span: { object: 'text' },
};
const HTML_LIST_CONTAINER_TAGS = {
    ol: { object: null },
    ul: { object: null },
};
const HTML_HEADER_TAGS = {
    h1: { ...DEFAULT_BLOCK, style: 'h1' },
    h2: { ...DEFAULT_BLOCK, style: 'h2' },
    h3: { ...DEFAULT_BLOCK, style: 'h3' },
    h4: { ...DEFAULT_BLOCK, style: 'h4' },
    h5: { ...DEFAULT_BLOCK, style: 'h5' },
    h6: { ...DEFAULT_BLOCK, style: 'h6' },
};
const HTML_MISC_TAGS = {
    br: { ...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE },
};
const HTML_DECORATOR_TAGS = {
    b: 'strong',
    strong: 'strong',
    i: 'em',
    em: 'em',
    u: 'underline',
    s: 'strike-through',
    strike: 'strike-through',
    del: 'strike-through',
    code: 'code',
};
const HTML_LIST_ITEM_TAGS = {
    li: {
        ...DEFAULT_BLOCK,
        style: BLOCK_DEFAULT_STYLE,
        level: 1,
        listItem: 'bullet',
    },
};
const ELEMENT_MAP = {
    ...HTML_BLOCK_TAGS,
    ...HTML_SPAN_TAGS,
    ...HTML_LIST_CONTAINER_TAGS,
    ...HTML_LIST_ITEM_TAGS,
    ...HTML_HEADER_TAGS,
    ...HTML_MISC_TAGS,
};
lodash.uniq(Object.values(ELEMENT_MAP)
    .filter((tag) => 'style' in tag)
    .map((tag) => tag.style));
lodash.uniq(Object.values(HTML_DECORATOR_TAGS));

// We need this here if run server side
const _XPathResult = {
    ANY_TYPE: 0,
    NUMBER_TYPE: 1,
    STRING_TYPE: 2,
    BOOLEAN_TYPE: 3,
    UNORDERED_NODE_ITERATOR_TYPE: 4,
    ORDERED_NODE_ITERATOR_TYPE: 5,
    UNORDERED_NODE_SNAPSHOT_TYPE: 6,
    ORDERED_NODE_SNAPSHOT_TYPE: 7,
    ANY_UNORDERED_NODE_TYPE: 8,
    FIRST_ORDERED_NODE_TYPE: 9,
};

// Remove this cruft from the document
const unwantedWordDocumentPaths = [
    '/html/text()',
    '/html/head/text()',
    '/html/body/text()',
    '/html/body/ul/text()',
    '/html/body/ol/text()',
    '//comment()',
    '//style',
    '//xml',
    '//script',
    '//meta',
    '//link',
];
var preprocessHTML = (html, doc) => {
    // Make sure text directly on the body is wrapped in spans.
    // This mimics what the browser does before putting html on the clipboard,
    // when used in a script context with JSDOM
    const bodyTextNodes = doc.evaluate('/html/body/text()', doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {
        const node = bodyTextNodes.snapshotItem(i);
        const text = node.textContent || '';
        if (text.replace(/[^\S\n]+$/g, '')) {
            const newNode = doc.createElement('span');
            newNode.appendChild(doc.createTextNode(text));
            node.parentNode?.replaceChild(newNode, node);
        }
        else {
            node.parentNode?.removeChild(node);
        }
    }
    const unwantedNodes = doc.evaluate(unwantedWordDocumentPaths.join('|'), doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {
        const unwanted = unwantedNodes.snapshotItem(i);
        if (!unwanted) {
            continue;
        }
        unwanted.parentNode?.removeChild(unwanted);
    }
    return doc;
};

const WORD_HTML_REGEX = /(class="?Mso|style=(?:"|')[^"]*?\bmso-|w:WordDocument|<o:\w+>|<\/font>)/;
// xPaths for elements that will be removed from the document
const unwantedPaths = [
    '//o:p',
    "//span[@style='mso-list:Ignore']",
    "//span[@style='mso-list: Ignore']",
];
// xPaths for elements that needs to be remapped into other tags
const mappedPaths = [
    "//p[@class='MsoTocHeading']",
    "//p[@class='MsoTitle']",
    "//p[@class='MsoToaHeading']",
    "//p[@class='MsoSubtitle']",
    "//span[@class='MsoSubtleEmphasis']",
    "//span[@class='MsoIntenseEmphasis']",
];
// Which HTML element(s) to map the elements matching mappedPaths into
const elementMap = {
    MsoTocHeading: ['h3'],
    MsoTitle: ['h1'],
    MsoToaHeading: ['h2'],
    MsoSubtitle: ['h5'],
    MsoSubtleEmphasis: ['span', 'em'],
    MsoIntenseEmphasis: ['span', 'em', 'strong'],
    // Remove cruft
};
function isWordHtml(html) {
    return WORD_HTML_REGEX.test(html);
}
var preprocessWord = (html, doc) => {
    if (!isWordHtml(html)) {
        return doc;
    }
    const unwantedNodes = doc.evaluate(unwantedPaths.join('|'), doc, (prefix) => {
        if (prefix === 'o') {
            return 'urn:schemas-microsoft-com:office:office';
        }
        return null;
    }, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {
        const unwanted = unwantedNodes.snapshotItem(i);
        if (unwanted?.parentNode) {
            unwanted.parentNode.removeChild(unwanted);
        }
    }
    // Transform mapped elements into what they should be mapped to
    const mappedElements = doc.evaluate(mappedPaths.join('|'), doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {
        const mappedElm = mappedElements.snapshotItem(i);
        const tags = elementMap[mappedElm.className];
        const text = new Text(mappedElm.textContent || '');
        if (!tags) {
            continue;
        }
        const parentElement = document.createElement(tags[0]);
        let parent = parentElement;
        let child = parentElement;
        tags.slice(1).forEach((tag) => {
            child = document.createElement(tag);
            parent.appendChild(child);
            parent = child;
        });
        child.appendChild(text);
        mappedElm?.parentNode?.replaceChild(parentElement, mappedElm);
    }
    return doc;
};

function isGoogleDocsDocument(el) {
    if (el.nodeType !== 1) {
        return false;
    }
    const id = el.getAttribute('id');
    return id && id.match(/^docs-internal-guid-/) && el.tagName === 'B';
}
var preprocessGDocs = (html, doc) => {
    if (doc.body.firstElementChild && isGoogleDocsDocument(doc.body.firstElementChild)) {
        // Tag every child with attribute 'is-google-docs' so that the GDocs rule-set can
        // work exclusivly on these children
        const childNodes = doc.evaluate('//*', doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
        for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {
            const elm = childNodes.snapshotItem(i);
            elm?.setAttribute('data-is-google-docs', 'true');
        }
        // Remove that 'b' which Google Docs wraps the HTML content in
        doc.body.firstElementChild.replaceWith(...Array.from(doc.body.firstElementChild.childNodes));
        return doc;
    }
    return doc;
};

var preprocessors = [preprocessWord, preprocessGDocs, preprocessHTML];

/**
 * A utility function to create the options needed for the various rule sets,
 * based on the structure of the blockContentType
 *
 * @param blockContentType - Schema type for array containing _at least_ a block child type
 * @returns
 */
function createRuleOptions(blockContentType) {
    const features = blockContentFeatures(blockContentType);
    const enabledBlockStyles = features.styles.map((item) => item.value || item.title);
    const enabledSpanDecorators = features.decorators.map((item) => item.value || item.title);
    const enabledBlockAnnotations = features.annotations.map((item) => item.value || item.title || '');
    return {
        enabledBlockStyles,
        enabledSpanDecorators,
        enabledBlockAnnotations,
    };
}
/**
 * Utility function that always return a lowerCase version of the element.tagName
 *
 * @param el - Element to get tag name for
 * @returns Lowercase tagName for that element, or undefined if not an element
 */
function tagName(el) {
    if (el && 'tagName' in el) {
        return el.tagName.toLowerCase();
    }
    return undefined;
}
// TODO: make this plugin-style
function preprocess(html, parseHtml) {
    const compactHtml = html
        .trim() // Trim whitespace
        .replace(/\s\s+/g, ' ') // Remove multiple whitespace
        .replace(/[\r\n]/g, ' '); // Remove newlines / carriage returns
    const doc = parseHtml(compactHtml);
    preprocessors.forEach((processor) => {
        processor(html, doc);
    });
    return doc;
}
/**
 * A default `parseHtml` function that returns the html using `DOMParser`.
 *
 * @returns HTML Parser based on `DOMParser`
 */
function defaultParseHtml() {
    if (resolveJsType(DOMParser) === 'undefined') {
        throw new Error('The native `DOMParser` global which the `Html` deserializer uses by ' +
            'default is not present in this environment. ' +
            'You must supply the `options.parseHtml` function instead.');
    }
    return (html) => {
        return new DOMParser().parseFromString(html, 'text/html');
    };
}
function flattenNestedBlocks(blocks) {
    let depth = 0;
    const flattened = [];
    const traverse = (nodes) => {
        const toRemove = [];
        nodes.forEach((node) => {
            if (depth === 0) {
                flattened.push(node);
            }
            if (types.isBlock(node)) {
                if (depth > 0) {
                    toRemove.push(node);
                    flattened.push(node);
                }
                depth++;
                traverse(node.children);
            }
            if (node._type === '__block') {
                toRemove.push(node);
                flattened.push(node.block);
            }
        });
        toRemove.forEach((node) => {
            nodes.splice(nodes.indexOf(node), 1);
        });
        depth--;
    };
    traverse(blocks);
    return flattened;
}
function nextSpan(block, index) {
    const next = block.children[index + 1];
    return next && next._type === 'span' ? next : null;
}
function prevSpan(block, index) {
    const prev = block.children[index - 1];
    return prev && prev._type === 'span' ? prev : null;
}
function isWhiteSpaceChar(text) {
    return ['\xa0', ' '].includes(text);
}
/**
 * NOTE: _mutates_ passed blocks!
 *
 * @param blocks - Array of blocks to trim whitespace for
 * @returns
 */
function trimWhitespace(blocks) {
    blocks.forEach((block) => {
        if (!types.isBlock(block)) {
            return;
        }
        // eslint-disable-next-line complexity
        block.children.forEach((child, index) => {
            if (child._type !== 'span') {
                return;
            }
            const nextChild = nextSpan(block, index);
            const prevChild = prevSpan(block, index);
            if (index === 0) {
                child.text = child.text.replace(/^[^\S\n]+/g, '');
            }
            if (index === block.children.length - 1) {
                child.text = child.text.replace(/[^\S\n]+$/g, '');
            }
            if (/\s/.test(child.text.substring(child.text.length - 1)) &&
                nextChild &&
                /\s/.test(nextChild.text.substring(0, 1))) {
                child.text = child.text.replace(/[^\S\n]+$/g, '');
            }
            if (/\s/.test(child.text.substring(0, 1)) &&
                prevChild &&
                /\s/.test(prevChild.text.substring(prevChild.text.length - 1))) {
                child.text = child.text.replace(/^[^\S\n]+/g, '');
            }
            if (!child.text) {
                block.children.splice(index, 1);
            }
            if (prevChild && lodash.isEqual(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text)) {
                prevChild.text += ' ';
                block.children.splice(index, 1);
            }
            else if (nextChild &&
                lodash.isEqual(nextChild.marks, child.marks) &&
                isWhiteSpaceChar(child.text)) {
                nextChild.text = ` ${nextChild.text}`;
                block.children.splice(index, 1);
            }
        });
    });
    return blocks;
}
function ensureRootIsBlocks(blocks) {
    return blocks.reduce((memo, node, i, original) => {
        if (node._type === 'block') {
            memo.push(node);
            return memo;
        }
        if (node._type === '__block') {
            memo.push(node.block);
            return memo;
        }
        const lastBlock = memo[memo.length - 1];
        if (i > 0 && !types.isBlock(original[i - 1]) && types.isBlock(lastBlock)) {
            lastBlock.children.push(node);
            return memo;
        }
        const block = {
            ...DEFAULT_BLOCK,
            children: [node],
        };
        memo.push(block);
        return memo;
    }, []);
}
function isNodeList(node) {
    return Object.prototype.toString.call(node) == '[object NodeList]';
}
function isMinimalSpan(node) {
    return node._type === 'span';
}
function isMinimalBlock(node) {
    return node._type === 'block';
}
function isPlaceholderDecorator(node) {
    return node._type === '__decorator';
}
function isPlaceholderAnnotation(node) {
    return node._type === '__annotation';
}
function isElement(node) {
    return node.nodeType === 1;
}

function resolveListItem(listNodeTagName) {
    let listStyle;
    switch (listNodeTagName) {
        case 'ul':
            listStyle = 'bullet';
            break;
        case 'ol':
            listStyle = 'number';
            break;
        default:
            listStyle = 'bullet';
    }
    return listStyle;
}
function createHTMLRules(blockContentType, options) {
    return [
        // Text nodes
        {
            deserialize(el) {
                const isValidWhiteSpace = el.nodeType === 3 &&
                    (el.textContent || '').replace(/[\r\n]/g, ' ').replace(/\s\s+/g, ' ') === ' ' &&
                    el.nextSibling &&
                    el.nextSibling.nodeType !== 3 &&
                    el.previousSibling &&
                    el.previousSibling.nodeType !== 3;
                const isValidText = (isValidWhiteSpace || el.textContent !== ' ') && tagName(el.parentNode) !== 'body';
                if (el.nodeName === '#text' && isValidText) {
                    return {
                        ...DEFAULT_SPAN,
                        marks: [],
                        text: (el.textContent || '').replace(/\s\s+/g, ' '),
                    };
                }
                return undefined;
            },
        },
        {
            deserialize(el, next) {
                if (tagName(el) !== 'blockquote') {
                    return undefined;
                }
                const blocks = {
                    ...HTML_BLOCK_TAGS,
                    ...HTML_HEADER_TAGS,
                };
                delete blocks.blockquote;
                const children = [];
                el.childNodes.forEach((node, index) => {
                    if (node.nodeType === 1 &&
                        Object.keys(blocks).includes(node.localName.toLowerCase())) {
                        if (!el.ownerDocument) {
                            return;
                        }
                        const span = el.ownerDocument.createElement('span');
                        span.appendChild(el.ownerDocument.createTextNode('\r'));
                        node.childNodes.forEach((cn) => {
                            span.appendChild(cn.cloneNode(true));
                        });
                        if (index !== el.childNodes.length) {
                            span.appendChild(el.ownerDocument.createTextNode('\r'));
                        }
                        children.push(span);
                    }
                    else {
                        children.push(node);
                    }
                });
                return {
                    _type: 'block',
                    style: 'blockquote',
                    markDefs: [],
                    children: next(children),
                };
            },
        },
        {
            deserialize(el, next) {
                const blocks = {
                    ...HTML_BLOCK_TAGS,
                    ...HTML_HEADER_TAGS,
                };
                const tag = tagName(el);
                let block = tag ? blocks[tag] : undefined;
                if (!block) {
                    return undefined;
                }
                // Don't add blocks into list items
                if (el.parentNode && tagName(el) === 'li') {
                    return next(el.childNodes);
                }
                // If style is not supported, return a defaultBlockType
                if (!options.enabledBlockStyles.includes(block.style)) {
                    block = DEFAULT_BLOCK;
                }
                return {
                    ...block,
                    children: next(el.childNodes),
                };
            },
        },
        {
            deserialize(el, next) {
                const tag = tagName(el);
                if (!tag || !(tag in HTML_SPAN_TAGS)) {
                    return undefined;
                }
                return next(el.childNodes);
            },
        },
        {
            deserialize(el, next) {
                const div = tagName(el) === 'div';
                if (!div) {
                    return undefined;
                }
                return next(el.childNodes);
            },
        },
        {
            deserialize(el, next) {
                const tag = tagName(el);
                if (!tag || !(tag in HTML_LIST_CONTAINER_TAGS)) {
                    return undefined;
                }
                return next(el.childNodes);
            },
        },
        {
            deserialize(el) {
                if (tagName(el) === 'br') {
                    return {
                        ...DEFAULT_SPAN,
                        text: '\n',
                    };
                }
                return undefined;
            },
        },
        {
            deserialize(el, next) {
                const tag = tagName(el);
                const listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : undefined;
                const parentTag = tagName(el.parentNode) || '';
                if (!listItem || !el.parentNode || !HTML_LIST_CONTAINER_TAGS[parentTag]) {
                    return undefined;
                }
                listItem.listItem = resolveListItem(parentTag);
                return {
                    ...listItem,
                    children: next(el.childNodes),
                };
            },
        },
        {
            deserialize(el, next) {
                const decorator = HTML_DECORATOR_TAGS[tagName(el) || ''];
                if (!decorator || !options.enabledSpanDecorators.includes(decorator)) {
                    return undefined;
                }
                return {
                    _type: '__decorator',
                    name: decorator,
                    children: next(el.childNodes),
                };
            },
        },
        // If not supported just write out the link text and href in plain text.
        {
            deserialize(el, next) {
                if (tagName(el) != 'a') {
                    return undefined;
                }
                const linkEnabled = options.enabledBlockAnnotations.includes('link');
                const href = isElement(el) && el.getAttribute('href');
                if (!href) {
                    return next(el.childNodes);
                }
                let markDef;
                if (linkEnabled) {
                    markDef = {
                        _key: randomKey(12),
                        _type: 'link',
                        href: href,
                    };
                    return {
                        _type: '__annotation',
                        markDef: markDef,
                        children: next(el.childNodes),
                    };
                }
                return el.appendChild(el.ownerDocument.createTextNode(` (${href})`)) && next(el.childNodes);
            },
        },
    ];
}

const LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS);
// font-style:italic seems like the most important rule for italic / emphasis in their html
function isEmphasis(el) {
    const style = isElement(el) && el.getAttribute('style');
    return /font-style:italic/.test(style || '');
}
// font-weight:700 seems like the most important rule for bold in their html
function isStrong(el) {
    const style = isElement(el) && el.getAttribute('style');
    return /font-weight:700/.test(style || '');
}
// Check for attribute given by the gdocs preprocessor
function isGoogleDocs(el) {
    return isElement(el) && Boolean(el.getAttribute('data-is-google-docs'));
}
function getListItemStyle$1(el) {
    const parentTag = tagName(el.parentNode);
    if (parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)) {
        return undefined;
    }
    return tagName(el.parentNode) === 'ul' ? 'bullet' : 'number';
}
function getListItemLevel$1(el) {
    let level = 0;
    if (tagName(el) === 'li') {
        let parentNode = el.parentNode;
        while (parentNode) {
            const parentTag = tagName(parentNode);
            if (parentTag && LIST_CONTAINER_TAGS.includes(parentTag)) {
                level++;
            }
            parentNode = parentNode.parentNode;
        }
    }
    else {
        level = 1;
    }
    return level;
}
const blocks = {
    ...HTML_BLOCK_TAGS,
    ...HTML_HEADER_TAGS,
};
function getBlockStyle(el, enabledBlockStyles) {
    const childTag = tagName(el.firstChild);
    const block = childTag && blocks[childTag];
    if (!block) {
        return BLOCK_DEFAULT_STYLE;
    }
    if (!enabledBlockStyles.includes(block.style)) {
        return BLOCK_DEFAULT_STYLE;
    }
    return block.style;
}
function createGDocsRules(_blockContentType, options) {
    return [
        {
            deserialize(el) {
                if (isElement(el) && tagName(el) === 'span' && isGoogleDocs(el)) {
                    const span = {
                        ...DEFAULT_SPAN,
                        marks: [],
                        text: el.innerText,
                    };
                    if (isStrong(el)) {
                        span.marks.push('strong');
                    }
                    if (isEmphasis(el)) {
                        span.marks.push('em');
                    }
                    return span;
                }
                return undefined;
            },
        },
        {
            deserialize(el, next) {
                if (tagName(el) === 'li' && isGoogleDocs(el)) {
                    return {
                        ...DEFAULT_BLOCK,
                        listItem: getListItemStyle$1(el),
                        level: getListItemLevel$1(el),
                        style: getBlockStyle(el, options.enabledBlockStyles),
                        children: next(el.firstChild?.childNodes || []),
                    };
                }
                return undefined;
            },
        },
    ];
}

function getListItemStyle(el) {
    const style = isElement(el) && el.getAttribute('style');
    if (!style) {
        return undefined;
    }
    if (!style.match(/lfo\d+/)) {
        return undefined;
    }
    return style.match('lfo1') ? 'bullet' : 'number';
}
function getListItemLevel(el) {
    const style = isElement(el) && el.getAttribute('style');
    if (!style) {
        return undefined;
    }
    const levelMatch = style.match(/level\d+/);
    if (!levelMatch) {
        return undefined;
    }
    const [level] = levelMatch[0].match(/\d/) || [];
    const levelNum = level ? parseInt(level, 10) : 1;
    return levelNum || 1;
}
function isWordListElement(el) {
    return isElement(el) && el.className
        ? el.className === 'MsoListParagraphCxSpFirst' ||
            el.className === 'MsoListParagraphCxSpMiddle' ||
            el.className === 'MsoListParagraphCxSpLast'
        : false;
}
function createWordRules() {
    return [
        {
            deserialize(el, next) {
                if (tagName(el) === 'p' && isWordListElement(el)) {
                    return {
                        ...DEFAULT_BLOCK,
                        listItem: getListItemStyle(el),
                        level: getListItemLevel(el),
                        style: BLOCK_DEFAULT_STYLE,
                        children: next(el.childNodes),
                    };
                }
                return undefined;
            },
        },
    ];
}

function createRules(blockContentType, options) {
    return [
        ...createWordRules(),
        ...createGDocsRules(blockContentType, options),
        ...createHTMLRules(blockContentType, options),
    ];
}

/**
 * HTML Deserializer
 *
 */
class HtmlDeserializer {
    blockContentType;
    rules;
    parseHtml;
    _markDefs = [];
    /**
     * Create a new serializer respecting a Sanity block content type's schema
     *
     * @param blockContentType - Schema type for array containing _at least_ a block child type
     * @param options - Options for the deserialization process
     */
    constructor(blockContentType, options = {}) {
        const { rules = [] } = options;
        if (!blockContentType) {
            throw new Error("Parameter 'blockContentType' is required");
        }
        const standardRules = createRules(blockContentType, createRuleOptions(blockContentType));
        this.rules = [...rules, ...standardRules];
        const parseHtml = options.parseHtml || defaultParseHtml();
        this.blockContentType = blockContentType;
        this.parseHtml = (html) => {
            const doc = preprocess(html, parseHtml);
            return doc.body;
        };
    }
    /**
     * Deserialize HTML.
     *
     * @param html - The HTML to deserialize, as a string
     * @returns Array of blocks - either portable text blocks or other allowed blocks
     */
    deserialize = (html) => {
        this._markDefs = [];
        const { parseHtml } = this;
        const fragment = parseHtml(html);
        const children = Array.from(fragment.childNodes);
        // Ensure that there are no blocks within blocks, and trim whitespace
        const blocks = trimWhitespace(flattenNestedBlocks(ensureRootIsBlocks(this.deserializeElements(children))));
        if (this._markDefs.length > 0) {
            blocks
                .filter((block) => block._type === 'block')
                .forEach((block) => {
                block.markDefs = block.markDefs || [];
                block.markDefs = block.markDefs.concat(this._markDefs.filter((def) => {
                    return lodash.flatten(block.children.map((child) => child.marks || [])).includes(def._key);
                }));
            });
        }
        // Set back the potentially hoisted block type
        const type = this.blockContentType.of.find(findBlockType);
        if (!type) {
            return blocks;
        }
        return blocks.map((block) => {
            if (block._type === 'block') {
                block._type = type.name;
            }
            return block;
        });
    };
    /**
     * Deserialize an array of DOM elements.
     *
     * @param elements - Array of DOM elements to deserialize
     * @returns
     */
    deserializeElements = (elements = []) => {
        let nodes = [];
        elements.forEach((element) => {
            nodes = nodes.concat(this.deserializeElement(element));
        });
        return nodes;
    };
    /**
     * Deserialize a DOM element
     *
     * @param element - Deserialize a DOM element
     * @returns
     */
    deserializeElement = (element) => {
        const next = (elements) => {
            if (isNodeList(elements)) {
                return this.deserializeElements(Array.from(elements));
            }
            if (Array.isArray(elements)) {
                return this.deserializeElements(elements);
            }
            if (!elements) {
                return undefined;
            }
            return this.deserializeElement(elements);
        };
        const block = (props) => {
            return {
                _type: '__block',
                block: props,
            };
        };
        let node;
        for (let i = 0; i < this.rules.length; i++) {
            const rule = this.rules[i];
            if (!rule.deserialize) {
                continue;
            }
            const ret = rule.deserialize(element, next, block);
            const type = resolveJsType(ret);
            if (type !== 'array' && type !== 'object' && type !== 'null' && type !== 'undefined') {
                throw new Error(`A rule returned an invalid deserialized representation: "${node}".`);
            }
            if (ret === undefined) {
                continue;
            }
            else if (ret === null) {
                throw new Error('Deserializer rule returned `null`');
            }
            else if (Array.isArray(ret)) {
                node = ret;
            }
            else if (isPlaceholderDecorator(ret)) {
                node = this.deserializeDecorator(ret);
            }
            else if (isPlaceholderAnnotation(ret)) {
                node = this.deserializeAnnotation(ret);
            }
            else {
                node = ret;
            }
            // Set list level on list item
            if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && 'listItem' in ret) {
                let parent = element.parentNode?.parentNode;
                while (parent && tagName(parent) === 'li') {
                    parent = parent.parentNode?.parentNode;
                    ret.level = ret.level ? ret.level + 1 : 1;
                }
            }
            // Set newlines on spans orginating from a block element within a blockquote
            if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && ret.style === 'blockquote') {
                ret.children.forEach((child, index) => {
                    if (isMinimalSpan(child) && child.text === '\r') {
                        child.text = '\n\n';
                        if (index === 0 || index === ret.children.length - 1) {
                            ret.children.splice(index, 1);
                        }
                    }
                });
            }
            break;
        }
        return node || next(element.childNodes) || [];
    };
    /**
     * Deserialize a `__decorator` type
     * (an internal made up type to process decorators exclusively)
     *
     * @param decorator -
     * @returns array of ...
     */
    deserializeDecorator = (decorator) => {
        const { name } = decorator;
        const applyDecorator = (node) => {
            if (isPlaceholderDecorator(node)) {
                return this.deserializeDecorator(node);
            }
            else if (isMinimalSpan(node)) {
                node.marks = node.marks || [];
                if (node.text.trim()) {
                    // Only apply marks if this is an actual text
                    node.marks.unshift(name);
                }
            }
            else if ('children' in node && Array.isArray(node.children)) {
                const block = node;
                block.children = block.children.map(applyDecorator);
            }
            return node;
        };
        return decorator.children.reduce((children, node) => {
            const ret = applyDecorator(node);
            if (Array.isArray(ret)) {
                return children.concat(ret);
            }
            children.push(ret);
            return children;
        }, []);
    };
    /**
     * Deserialize a `__annotation` object.
     * (an internal made up type to process annotations exclusively)
     *
     * @param annotation -
     * @returns Array of...
     */
    deserializeAnnotation = (annotation) => {
        const { markDef } = annotation;
        this._markDefs.push(markDef);
        const applyAnnotation = (node) => {
            if (isPlaceholderAnnotation(node)) {
                return this.deserializeAnnotation(node);
            }
            else if (isMinimalSpan(node)) {
                node.marks = node.marks || [];
                if (node.text.trim()) {
                    // Only apply marks if this is an actual text
                    node.marks.unshift(markDef._key);
                }
            }
            else if ('children' in node && Array.isArray(node.children)) {
                const block = node;
                block.children = block.children.map(applyAnnotation);
            }
            return node;
        };
        return annotation.children.reduce((children, node) => {
            const ret = applyAnnotation(node);
            if (Array.isArray(ret)) {
                return children.concat(ret);
            }
            children.push(ret);
            return children;
        }, []);
    };
}

/**
 * Normalizes a block by ensuring it has a `_key` property. If the block is a
 * portable text block, additional normalization is applied:
 *
 * - Ensures it has `children` and `markDefs` properties
 * - Ensures it has at least one child (adds an empty span if empty)
 * - Joins sibling spans that has the same marks
 * - Removes decorators that are not allowed according to the schema
 * - Removes marks that have no annotation definition
 *
 * @param node - The block to normalize
 * @param options - Options for normalization process. See {@link BlockNormalizationOptions}
 * @returns Normalized block
 * @public
 */
function normalizeBlock(node, options = {}) {
    if (node._type !== (options.blockTypeName || 'block')) {
        return '_key' in node ? node : { ...node, _key: randomKey(12) };
    }
    const block = {
        _key: randomKey(12),
        children: [],
        markDefs: [],
        ...node,
    };
    const lastChild = block.children[block.children.length - 1];
    if (!lastChild) {
        // A block must at least have an empty span type child
        block.children = [
            {
                _type: 'span',
                _key: `${block._key}${0}`,
                text: '',
                marks: [],
            },
        ];
        return block;
    }
    const usedMarkDefs = [];
    const allowedDecorators = options.allowedDecorators && Array.isArray(options.allowedDecorators)
        ? options.allowedDecorators
        : false;
    block.children = block.children
        .reduce((acc, child) => {
        const previousChild = acc[acc.length - 1];
        if (previousChild &&
            types.isSpan(child) &&
            types.isSpan(previousChild) &&
            lodash.isEqual(previousChild.marks, child.marks)) {
            if (lastChild && lastChild === child && child.text === '' && block.children.length > 1) {
                return acc;
            }
            previousChild.text += child.text;
            return acc;
        }
        acc.push(child);
        return acc;
    }, [])
        .map((child, index) => {
        if (!child) {
            throw new Error('missing child');
        }
        child._key = `${block._key}${index}`;
        if (types.isSpan(child)) {
            if (!child.marks) {
                child.marks = [];
            }
            else if (allowedDecorators) {
                child.marks = child.marks.filter((mark) => {
                    const isAllowed = allowedDecorators.includes(mark);
                    const isUsed = block.markDefs.some((def) => def._key === mark);
                    return isAllowed || isUsed;
                });
            }
            usedMarkDefs.push(...child.marks);
        }
        return child;
    });
    // Remove leftover (unused) markDefs
    block.markDefs = block.markDefs.filter((markDef) => usedMarkDefs.includes(markDef._key));
    return block;
}

/**
 * Convert HTML to blocks respecting the block content type's schema
 *
 * @param html - The HTML to convert to blocks
 * @param blockContentType - A compiled version of the schema type for the block content
 * @param options - Options for deserializing HTML to blocks
 * @returns Array of blocks
 * @public
 */
function htmlToBlocks(html, blockContentType, options = {}) {
    const deserializer = new HtmlDeserializer(blockContentType, options);
    return deserializer.deserialize(html).map((block) => normalizeBlock(block));
}
/**
 * Normalize and extract features of an schema type containing a block type
 *
 * @param blockContentType - Schema type for the block type
 * @returns Returns the featureset of a compiled block content type.
 * @public
 */
function getBlockContentFeatures(blockContentType) {
    return blockContentFeatures(blockContentType);
}

exports.getBlockContentFeatures = getBlockContentFeatures;
exports.htmlToBlocks = htmlToBlocks;
exports.normalizeBlock = normalizeBlock;
exports.randomKey = randomKey;
//# sourceMappingURL=index.cjs.map
