"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildStaticFiles = buildStaticFiles;

var _path = _interopRequireDefault(require("path"));

var _promises = _interopRequireDefault(require("fs/promises"));

var _fs = require("fs");

var _vite = require("vite");

var _getViteConfig = require("./getViteConfig");

var _webManifest = require("./webManifest");

var _runtime = require("./runtime");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function buildStaticFiles(options) {
  const {
    cwd,
    outputDir,
    sourceMap = false,
    minify = true,
    basePath,
    vite: extendViteConfig
  } = options;
  await (0, _runtime.writeSanityRuntime)({
    cwd,
    watch: false
  });
  let viteConfig = await (0, _getViteConfig.getViteConfig)({
    cwd,
    basePath,
    outputDir,
    minify,
    sourceMap,
    mode: 'production'
  });

  if (extendViteConfig) {
    viteConfig = (0, _getViteConfig.finalizeViteConfig)(extendViteConfig(viteConfig));
  } // Copy files placed in /static to the built /static


  const staticPath = _path.default.join(outputDir, 'static');

  await copyDir(_path.default.join(cwd, 'static'), staticPath); // Write favicons, not overwriting ones that already exist, to static folder

  const faviconBasePath = "".concat(basePath.replace(/\/+$/, ''), "/static");
  await writeFavicons(faviconBasePath, staticPath);
  const bundle = await (0, _vite.build)(viteConfig); // For typescript only - this shouldn't ever be the case given we're not watching

  if (Array.isArray(bundle) || !('output' in bundle)) {
    return {
      chunks: []
    };
  }

  const stats = [];
  bundle.output.forEach(chunk => {
    if (chunk.type !== 'chunk') {
      return;
    }

    stats.push({
      name: chunk.name,
      modules: Object.entries(chunk.modules).map(_ref => {
        let [rawFilePath, chunkModule] = _ref;
        const filePath = rawFilePath.startsWith('\x00') ? rawFilePath.slice('\x00'.length) : rawFilePath;
        return {
          name: _path.default.isAbsolute(filePath) ? _path.default.relative(cwd, filePath) : filePath,
          originalLength: chunkModule.originalLength,
          renderedLength: chunkModule.renderedLength
        };
      })
    });
  });
  return {
    chunks: stats
  };
}

async function copyDir(srcDir, destDir, skipExisting) {
  await _promises.default.mkdir(destDir, {
    recursive: true
  });

  for (const file of await tryReadDir(srcDir)) {
    const srcFile = _path.default.resolve(srcDir, file);

    if (srcFile === destDir) {
      continue;
    }

    const destFile = _path.default.resolve(destDir, file);

    const stat = await _promises.default.stat(srcFile);

    if (stat.isDirectory()) {
      await copyDir(srcFile, destFile, skipExisting);
    } else if (skipExisting) {
      await _promises.default.copyFile(srcFile, destFile, _fs.constants.COPYFILE_EXCL).catch(skipIfExistsError);
    } else {
      await _promises.default.copyFile(srcFile, destFile);
    }
  }
}

async function tryReadDir(dir) {
  try {
    const content = await _promises.default.readdir(dir);
    return content;
  } catch (err) {
    if (err.code === 'ENOENT') {
      return [];
    }

    throw err;
  }
}

function skipIfExistsError(err) {
  if (err.code === 'EEXIST') {
    return;
  }

  throw err;
}

async function writeFavicons(basePath, destDir) {
  await _promises.default.mkdir(destDir, {
    recursive: true
  });
  await copyDir(_path.default.join(__dirname, 'static', 'favicons'), destDir, true);
  await writeWebManifest(basePath, destDir);
}

async function writeWebManifest(basePath, destDir) {
  const content = JSON.stringify((0, _webManifest.generateWebManifest)(basePath), null, 2);
  await _promises.default.writeFile(_path.default.join(destDir, 'manifest.webmanifest'), content, 'utf8').catch(skipIfExistsError);
}