"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getModulePath = getModulePath;
exports.isRecord = isRecord;
exports.normalizeBasePath = normalizeBasePath;

var _path = _interopRequireDefault(require("path"));

var _readPkgUp = _interopRequireDefault(require("read-pkg-up"));

var _resolveFrom = _interopRequireDefault(require("resolve-from"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Given a module name such as "styled-components", will resolve the _module path_,
 * eg if require.resolve(`styled-components`) resolves to:
 *   `/some/node_modules/styled-components/lib/cjs/styled.js`
 * this function will instead return
 *   `/some/node_modules/styled-components`
 *
 * This is done in order for aliases to be pointing to the right module in terms of
 * _file-system location_, without pointing to a specific commonjs/browser/module variant
 *
 * @internal
 */
async function getModulePath(mod, fromDir) {
  const modulePath = (0, _resolveFrom.default)(fromDir, mod);
  const pkg = await (0, _readPkgUp.default)({
    cwd: _path.default.dirname(modulePath)
  });
  return pkg ? _path.default.dirname(pkg.path) : modulePath;
}
/**
 * @internal
 */


function isRecord(value) {
  return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}
/**
 * Ensures that the given path both starts and ends with a single slash
 *
 * @internal
 */


function normalizeBasePath(pathName) {
  return "/".concat(pathName, "/").replace(/^\/+/, '/').replace(/\/+$/, '/');
}