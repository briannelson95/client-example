"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decorateIndexWithAutoGeneratedWarning = decorateIndexWithAutoGeneratedWarning;
exports.getPossibleDocumentComponentLocations = getPossibleDocumentComponentLocations;
exports.renderDocument = renderDocument;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _worker_threads = require("worker_threads");

var _chalk = _interopRequireDefault(require("chalk"));

var _importFresh = _interopRequireDefault(require("import-fresh"));

var _generateHelpUrl = require("@sanity/generate-help-url");

var _react = require("react");

var _server = require("react-dom/server");

var _aliases = require("./aliases");

var _debug = require("./debug");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Looks for and imports (in preferred order):
 *   - src/_document.js
 *   - src/_document.tsx
 *
 * Then renders using ReactDOM to a string, which is sent back to the parent
 * process over the worker `postMessage` channel.
 */
// Don't use threads in the jest world
// eslint-disable-next-line no-process-env
const useThreads = typeof process.env.JEST_WORKER_ID === 'undefined';
const hasWarnedAbout = new Set();
const defaultProps = {
  entryPath: './.sanity/runtime/app.js'
};
const autoGeneratedWarning = "\nThis file is auto-generated on \"sanity start\".\nModifications to this file is automatically discarded.\n\nTo customize the rendering of this file, see\n".concat((0, _generateHelpUrl.generateHelpUrl)('custom-document-component'), "\n").trim();

function renderDocument(options) {
  return new Promise((resolve, reject) => {
    if (!useThreads) {
      resolve(getDocumentHtml(options.studioRootPath, options.props));
      return;
    }

    const worker = new _worker_threads.Worker(__filename, {
      workerData: { ...options,
        shouldWarn: true
      }
    });
    worker.on('message', msg => {
      if (msg.type === 'warning') {
        if (hasWarnedAbout.has(msg.warnKey)) {
          return;
        }

        if (Array.isArray(msg.message)) {
          msg.message.forEach(warning => console.warn("".concat(_chalk.default.yellow('[warn]'), " ").concat(warning)));
        } else {
          console.warn("".concat(_chalk.default.yellow('[warn]'), " ").concat(msg.message));
        }

        hasWarnedAbout.add(msg.warnKey);
        return;
      }

      if (msg.type === 'error') {
        reject(new Error(msg.error || 'Document rendering worker stopped with an unknown error'));
        return;
      }

      if (msg.type === 'result') {
        resolve(msg.html);
      }
    });
    worker.on('error', reject);
    worker.on('exit', code => {
      if (code !== 0) {
        reject(new Error("Document rendering worker stopped with exit code ".concat(code)));
      }
    });
  });
}

function decorateIndexWithAutoGeneratedWarning(template) {
  return template.replace(/<head/, "\n<!--\n".concat(autoGeneratedWarning, "\n-->\n<head"));
}

function getPossibleDocumentComponentLocations(studioRootPath) {
  return [_path.default.join(studioRootPath, '_document.js'), _path.default.join(studioRootPath, '_document.tsx')];
}

if (!_worker_threads.isMainThread) {
  renderDocumentFromWorkerData();
}

function renderDocumentFromWorkerData() {
  if (!_worker_threads.parentPort || !_worker_threads.workerData) {
    throw new Error('Must be used as a Worker with a valid options object in worker data');
  }

  const {
    monorepo,
    studioRootPath,
    props
  } = _worker_threads.workerData || {};

  if (typeof studioRootPath !== 'string') {
    _worker_threads.parentPort.postMessage({
      type: 'error',
      message: 'Missing/invalid `studioRootPath` option'
    });

    return;
  }

  if (props && typeof props !== 'object') {
    _worker_threads.parentPort.postMessage({
      type: 'error',
      message: '`props` must be an object if provided'
    });

    return;
  } // Require hook #1
  // Alias monorepo modules


  require('module-alias').addAliases((0, _aliases.getAliases)({
    monorepo
  })); // Require hook #2
  // Use `esbuild` to allow JSX/TypeScript and modern JS features


  const {
    unregister
  } = require('esbuild-register/dist/node').register({
    target: "node".concat(process.version.slice(1)),
    extensions: ['.jsx', '.ts', '.tsx', '.mjs']
  }); // Require hook #3
  // Same as above, but we don't want to enforce a .jsx extension for anything with JSX


  const {
    unregister: unregisterJs
  } = require('esbuild-register/dist/node').register({
    target: "node".concat(process.version.slice(1)),
    extensions: ['.js'],
    loader: 'jsx'
  });

  const html = getDocumentHtml(studioRootPath, props);

  _worker_threads.parentPort.postMessage({
    type: 'result',
    html
  }); // Be polite and clean up after esbuild-register


  unregister();
  unregisterJs();
}

function getDocumentHtml(studioRootPath, props) {
  var _props$css;

  const Document = getDocumentComponent(studioRootPath); // NOTE: Validate the list of CSS paths so implementers of `_document.tsx` don't have to
  // - If the path is not a full URL, check if it starts with `/`
  //   - If not, then prepend a `/` to the string

  const css = props === null || props === void 0 ? void 0 : (_props$css = props.css) === null || _props$css === void 0 ? void 0 : _props$css.map(url => {
    try {
      // If the URL is absolute, we don't need to prefix it
      return new URL(url).toString();
    } catch (_unused) {
      return url.startsWith('/') ? url : "/".concat(url);
    }
  });
  const result = (0, _server.renderToStaticMarkup)( /*#__PURE__*/(0, _react.createElement)(Document, { ...defaultProps,
    ...props,
    css
  }));
  return "<!DOCTYPE html>".concat(result);
}

function getDocumentComponent(studioRootPath) {
  const {
    DefaultDocument
  } = require('sanity');

  const userDefined = tryLoadDocumentComponent(studioRootPath);

  if (!userDefined) {
    (0, _debug.debug)('Using default document component');
    return DefaultDocument;
  }

  (0, _debug.debug)('Found user defined document component at %s', userDefined.path);
  const DocumentComp = userDefined.component.default;

  if (typeof DocumentComp === 'function') {
    (0, _debug.debug)('User defined document component is a function, assuming valid');
    return DocumentComp;
  }

  (0, _debug.debug)('User defined document component did not have a default export');
  const userExports = Object.keys(userDefined.component).join(', ') || 'None';

  const relativePath = _path.default.relative(process.cwd(), userDefined.path);

  const typeHint = typeof userDefined.component.default === 'undefined' ? '' : " (type was ".concat(typeof userDefined.component.default, ")");
  const warnKey = "".concat(relativePath, "/").concat(userDefined.modified);
  _worker_threads.parentPort === null || _worker_threads.parentPort === void 0 ? void 0 : _worker_threads.parentPort.postMessage({
    type: 'warning',
    message: ["".concat(relativePath, " did not have a default export that is a React component").concat(typeHint), "Found named exports/properties: ".concat(userExports).trim(), "Using default document component from \"sanity\"."],
    warnKey
  });
  return DefaultDocument;
}

function tryLoadDocumentComponent(studioRootPath) {
  const locations = getPossibleDocumentComponentLocations(studioRootPath);

  for (const componentPath of locations) {
    try {
      var _fs$statSync;

      return {
        // eslint-disable-next-line import/no-dynamic-require
        component: (0, _importFresh.default)(componentPath),
        path: componentPath,
        // eslint-disable-next-line no-sync
        modified: Math.floor((_fs$statSync = _fs.default.statSync(componentPath)) === null || _fs$statSync === void 0 ? void 0 : _fs$statSync.mtimeMs)
      };
    } catch (err) {
      // Allow "not found" errors
      if (err.code !== 'MODULE_NOT_FOUND') {
        throw err;
      }
    }
  }

  return null;
}