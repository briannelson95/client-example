"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sanityBuildEntries = sanityBuildEntries;

var _renderDocument = require("../renderDocument");

function sanityBuildEntries(options) {
  const {
    cwd,
    monorepo,
    basePath
  } = options;
  let entryChunkRef;
  return {
    name: '@sanity/server/build-entries',
    apply: 'build',

    buildStart() {
      entryChunkRef = this.emitFile({
        type: 'chunk',
        id: '.sanity/runtime/app.js',
        name: 'sanity'
      });
    },

    async generateBundle(_options, outputBundle) {
      var _entryFile$viteMetada;

      const bundle = outputBundle;
      const entryFileName = this.getFileName(entryChunkRef);
      const entryFile = bundle[entryFileName];

      if (!entryFile) {
        throw new Error("Failed to find entry file in bundle (".concat(entryFileName, ")"));
      }

      const entryPath = [basePath.replace(/\/+$/, ''), entryFileName].join('/');
      let css = [];

      if ((_entryFile$viteMetada = entryFile.viteMetadata) !== null && _entryFile$viteMetada !== void 0 && _entryFile$viteMetada.importedCss) {
        // Check all the top-level imports of the entryPoint to see if they have
        // static CSS assets that need loading
        css = [...entryFile.viteMetadata.importedCss];

        for (const key of entryFile.imports) {
          // Traverse all CSS assets that isn't loaded by the runtime and
          // need <link> tags in the HTML template
          css.push(...bundle[key].viteMetadata.importedCss);
        }
      }

      this.emitFile({
        type: 'asset',
        fileName: 'index.html',
        source: await (0, _renderDocument.renderDocument)({
          monorepo,
          studioRootPath: cwd,
          props: {
            entryPath,
            css
          }
        })
      });
    }

  };
}