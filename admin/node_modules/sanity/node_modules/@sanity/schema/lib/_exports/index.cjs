'use strict';

var lodash = require('lodash');
var arrify = require('arrify');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var arrify__default = /*#__PURE__*/_interopDefaultLegacy(arrify);

const DEFAULT_OVERRIDEABLE_FIELDS = [
    'jsonType',
    'type',
    'name',
    'title',
    'description',
    'options',
    'fieldsets',
    'validation',
    'readOnly',
    'hidden',
    'components',
    'diffComponent',
    'initialValue',
];

const OVERRIDABLE_FIELDS$e = [...DEFAULT_OVERRIDEABLE_FIELDS];
const ANY_CORE = {
    name: 'any',
    type: null,
    jsonType: 'any',
};
const AnyType = {
    get() {
        return ANY_CORE;
    },
    extend(subTypeDef, extendMember) {
        const parsed = Object.assign(lodash.pick(ANY_CORE, OVERRIDABLE_FIELDS$e), subTypeDef, {
            type: ANY_CORE,
            of: subTypeDef.of.map((fieldDef) => {
                return {
                    name: fieldDef.name,
                    type: extendMember(lodash.omit(fieldDef, 'name')),
                };
            }),
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    if (extensionDef.of) {
                        throw new Error('Cannot override `of` property of subtypes of "array"');
                    }
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, OVERRIDABLE_FIELDS$e), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

var primitivePreview = {
    prepare: (val) => ({ title: String(val) }),
};

const OVERRIDABLE_FIELDS$d = [...DEFAULT_OVERRIDEABLE_FIELDS];
const STRING_CORE = {
    name: 'string',
    title: 'String',
    type: null,
    jsonType: 'string',
};
const StringType = {
    get() {
        return STRING_CORE;
    },
    extend(subTypeDef) {
        const parsed = Object.assign(lodash.pick(STRING_CORE, OVERRIDABLE_FIELDS$d), subTypeDef, {
            type: STRING_CORE,
            preview: primitivePreview,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, OVERRIDABLE_FIELDS$d), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

const OVERRIDABLE_FIELDS$c = [...DEFAULT_OVERRIDEABLE_FIELDS, 'rows'];
const TEXT_CORE = {
    name: 'text',
    title: 'Text',
    type: null,
    jsonType: 'string',
};
const TextType = {
    get() {
        return TEXT_CORE;
    },
    extend(subTypeDef) {
        const parsed = Object.assign(lodash.pick(TEXT_CORE, OVERRIDABLE_FIELDS$c), subTypeDef, {
            type: TEXT_CORE,
            preview: primitivePreview,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, OVERRIDABLE_FIELDS$c), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

const OVERRIDABLE_FIELDS$b = [...DEFAULT_OVERRIDEABLE_FIELDS];
const DATETIME_CORE = {
    name: 'datetime',
    title: 'Datetime',
    type: null,
    jsonType: 'string',
};
const DateTimeType = {
    get() {
        return DATETIME_CORE;
    },
    extend(subTypeDef) {
        const parsed = Object.assign(lodash.pick(DATETIME_CORE, OVERRIDABLE_FIELDS$b), subTypeDef, {
            type: DATETIME_CORE,
            preview: primitivePreview,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, OVERRIDABLE_FIELDS$b), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

const OVERRIDABLE_FIELDS$a = [...DEFAULT_OVERRIDEABLE_FIELDS];
const DATE_CORE = {
    name: 'date',
    title: 'Datetime',
    type: null,
    jsonType: 'string',
};
const DateType = {
    get() {
        return DATE_CORE;
    },
    extend(subTypeDef) {
        const parsed = Object.assign(lodash.pick(DATE_CORE, OVERRIDABLE_FIELDS$a), subTypeDef, {
            type: DATE_CORE,
            preview: primitivePreview,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, OVERRIDABLE_FIELDS$a), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

const OVERRIDABLE_FIELDS$9 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const BOOLEAN_CORE = {
    name: 'boolean',
    title: 'Boolean',
    type: null,
    jsonType: 'boolean',
};
const BooleanType = {
    get() {
        return BOOLEAN_CORE;
    },
    extend(subTypeDef) {
        const parsed = Object.assign(lodash.pick(BOOLEAN_CORE, OVERRIDABLE_FIELDS$9), subTypeDef, {
            type: BOOLEAN_CORE,
            preview: primitivePreview,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, OVERRIDABLE_FIELDS$9), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

const OVERRIDABLE_FIELDS$8 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const URL_CORE = {
    name: 'url',
    title: 'Url',
    type: null,
    jsonType: 'string',
};
const UrlType = {
    get() {
        return URL_CORE;
    },
    extend(subTypeDef) {
        const parsed = Object.assign(lodash.pick(URL_CORE, OVERRIDABLE_FIELDS$8), subTypeDef, {
            type: URL_CORE,
            preview: primitivePreview,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, OVERRIDABLE_FIELDS$8), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

const OVERRIDABLE_FIELDS$7 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const EMAIL_CORE = {
    name: 'email',
    title: 'Email',
    type: null,
    jsonType: 'string',
};
const EmailType = {
    get() {
        return EMAIL_CORE;
    },
    extend(subTypeDef) {
        const parsed = Object.assign(lodash.pick(EMAIL_CORE, OVERRIDABLE_FIELDS$7), subTypeDef, {
            type: EMAIL_CORE,
            preview: primitivePreview,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, OVERRIDABLE_FIELDS$7), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

const OVERRIDABLE_FIELDS$6 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const NUMBER_CORE = {
    name: 'number',
    title: 'Number',
    type: null,
    jsonType: 'number',
};
const NumberType = {
    get() {
        return NUMBER_CORE;
    },
    extend(subTypeDef) {
        const parsed = Object.assign(lodash.pick(NUMBER_CORE, OVERRIDABLE_FIELDS$6), subTypeDef, {
            type: NUMBER_CORE,
            preview: primitivePreview,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, OVERRIDABLE_FIELDS$6), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

function lazyGetter(target, key, getter, config = {}) {
    Object.defineProperty(target, key, {
        configurable: true,
        enumerable: config.enumerable !== false,
        get() {
            const val = getter();
            Object.defineProperty(target, key, {
                value: val,
                writable: Boolean(config.writable),
                configurable: false,
            });
            return val;
        },
    });
    return target;
}
//
// const o = lazyGetter({}, 'expensive', function() {
//   console.log('doing expensive calculations')
//   return 'RESULT OF EXPENSIVE'
// })
//
// console.log(o.expensive)
// console.log(o.expensive)
// console.log(o.expensive)

function isEmpty(object) {
    for (const key in object) {
        if (object.hasOwnProperty(key)) {
            return false;
        }
    }
    return true;
}
function _stringify(value, options, depth) {
    if (depth > options.maxDepth) {
        return '...';
    }
    if (Array.isArray(value)) {
        if (value.length === 0) {
            return '[empty]';
        }
        const capLength = Math.max(value.length - options.maxBreadth);
        const asString = value
            .slice(0, options.maxBreadth)
            .map((item, index) => _stringify(item, options, depth + 1))
            .concat(capLength > 0 ? `…+${capLength}` : [])
            .join(', ');
        return depth === 0 ? asString : `[${asString}]`;
    }
    if (typeof value === 'object' && value !== null) {
        const keys = Object.keys(value).filter((key) => !options.ignoreKeys.includes(key) && typeof value[key] !== 'undefined');
        if (isEmpty(lodash.pick(value, keys))) {
            return '{empty}';
        }
        const asString = keys
            .slice(0, options.maxBreadth)
            .map((key) => `${key}: ${_stringify(value[key], options, depth + 1)}`)
            .join(', ');
        return depth === 0 ? asString : `{${asString}}`;
    }
    const asString = String(value);
    return asString === '' ? '""' : asString;
}
function stringify(value, options = {}) {
    const opts = {
        maxDepth: 'maxDepth' in options ? options.maxDepth : 2,
        maxBreadth: 'maxBreadth' in options ? options.maxBreadth : 2,
        ignoreKeys: 'ignoreKeys' in options ? options.ignoreKeys : [],
    };
    return _stringify(value, opts, 0);
}

const OPTIONS = {
    maxEntries: 2,
    maxDepth: 2,
    maxBreadth: 2,
    ignoreKeys: ['_id', '_type', '_key', '_ref'],
};
function createFallbackPrepare(fieldNames) {
    return (value) => ({
        title: stringify(lodash.pick(value, fieldNames), OPTIONS),
    });
}

function isBlockField(field) {
    return field.type === 'array' && field.of && field.of.some((member) => member.type === 'block');
}

const TITLE_CANDIDATES = ['title', 'name', 'label', 'heading', 'header', 'caption'];
const DESCRIPTION_CANDIDATES = ['description', ...TITLE_CANDIDATES];
function fieldHasReferenceTo(fieldDef, refType) {
    return arrify__default["default"](fieldDef.to || []).some((memberTypeDef) => memberTypeDef.type === refType);
}
function isImageAssetField(fieldDef) {
    return fieldHasReferenceTo(fieldDef, 'sanity.imageAsset');
}
function resolveImageAssetPath(typeDef) {
    const fields = typeDef.fields || [];
    const imageAssetField = fields.find(isImageAssetField);
    if (imageAssetField) {
        return imageAssetField.name;
    }
    const fieldWithImageAsset = fields.find((fieldDef) => (fieldDef.fields || []).some(isImageAssetField));
    return fieldWithImageAsset ? `${fieldWithImageAsset.name}.asset` : undefined;
}
function isFileAssetField(fieldDef) {
    return fieldHasReferenceTo(fieldDef, 'sanity.fileAsset');
}
function resolveFileAssetPath(typeDef) {
    const fields = typeDef.fields || [];
    const assetField = fields.find(isFileAssetField);
    if (assetField) {
        return assetField.name;
    }
    const fieldWithFileAsset = fields.find((fieldDef) => (fieldDef.fields || []).some(isFileAssetField));
    return fieldWithFileAsset ? `${fieldWithFileAsset.name}.asset` : undefined;
}
function guessPreviewFields(rawObjectTypeDef) {
    const objectTypeDef = { fields: [], ...rawObjectTypeDef };
    const stringFieldNames = objectTypeDef.fields
        .filter((field) => field.type === 'string')
        .map((field) => field.name);
    const blockFieldNames = objectTypeDef.fields.filter(isBlockField).map((field) => field.name);
    // Check if we have fields with names that is listed in candidate fields
    let titleField = TITLE_CANDIDATES.find((candidate) => stringFieldNames.includes(candidate) || blockFieldNames.includes(candidate));
    let descField = DESCRIPTION_CANDIDATES.find((candidate) => candidate !== titleField &&
        (stringFieldNames.includes(candidate) || blockFieldNames.includes(candidate)));
    if (!titleField) {
        // Pick first defined string field
        titleField = stringFieldNames[0] || blockFieldNames[0];
        // Pick next as desc
        descField = stringFieldNames[1] || blockFieldNames[1];
    }
    const mediaField = objectTypeDef.fields.find((field) => field.type === 'image');
    const imageAssetPath = resolveImageAssetPath(objectTypeDef);
    if (!titleField) {
        const fileAssetPath = resolveFileAssetPath(objectTypeDef);
        if (fileAssetPath) {
            titleField = `${fileAssetPath}.originalFilename`;
        }
        if (imageAssetPath) {
            titleField = `${imageAssetPath}.originalFilename`;
        }
    }
    if (!titleField && !imageAssetPath) {
        // last resort, pick all fields and concat them
        const fieldNames = objectTypeDef.fields.map((field) => field.name);
        const fieldMapping = fieldNames.reduce((acc, fieldName) => {
            acc[fieldName] = fieldName;
            return acc;
        }, {});
        return {
            select: fieldMapping,
            prepare: createFallbackPrepare(fieldNames),
        };
    }
    const select = lodash.omitBy({
        title: titleField,
        description: descField,
        imageUrl: !mediaField && imageAssetPath ? `${imageAssetPath}.url` : undefined,
        media: mediaField ? mediaField.name : undefined,
    }, lodash.isUndefined);
    return {
        select: select,
    };
}

function warnIfPreviewOnOptions(type) {
    if (type.options && type.options.preview) {
        // eslint-disable-next-line no-console
        console.warn(`Heads up! The preview config is no longer defined on "options", but instead on the type/field itself.
Please move {options: {preview: ...}} to {..., preview: ...} on the type/field definition of "${type.name}".
`);
    }
}
function warnIfPreviewHasFields(type) {
    const preview = type.preview || (type.options || {}).preview;
    if (preview && 'fields' in preview) {
        // eslint-disable-next-line no-console
        console.warn(`Heads up! "preview.fields" should be renamed to "preview.select". Please update the preview config for "${type.name}".
`);
    }
}

function parseSelection(selection) {
    return selection.reduce((acc, field) => {
        acc[field] = field;
        return acc;
    }, {});
}
function parsePreview(preview) {
    if (!preview) {
        return preview;
    }
    const select = preview.select || preview.fields || {};
    if (Array.isArray(select)) {
        return {
            ...lodash.pick(preview, ['prepare', 'component']),
            select: parseSelection(select),
        };
    }
    return {
        ...lodash.pick(preview, ['prepare', 'component']),
        select,
    };
}
function createPreviewGetter(objectTypeDef) {
    return function previewGetter() {
        warnIfPreviewOnOptions(objectTypeDef);
        warnIfPreviewHasFields(objectTypeDef);
        const preview = parsePreview(objectTypeDef.preview || (objectTypeDef.options || {}).preview);
        return preview || guessPreviewFields(objectTypeDef);
    };
}

const CANDIDATES = ['title', 'name', 'label', 'heading', 'header', 'caption', 'description'];
const PRIMITIVES = ['string', 'boolean', 'number'];
const isPrimitive = (field) => PRIMITIVES.includes(field.type);
function guessOrderingConfig(objectTypeDef) {
    let candidates = CANDIDATES.filter((candidate) => objectTypeDef.fields.some((field) => isPrimitive(field) && field.name === candidate));
    // None of the candidates were found, fallback to all fields
    if (candidates.length === 0) {
        candidates = objectTypeDef.fields.filter(isPrimitive).map((field) => field.name);
    }
    return candidates.map((name) => ({
        name: name,
        title: lodash.capitalize(lodash.startCase(name)),
        by: [{ field: name, direction: 'asc' }],
    }));
}

function normalizeSearchConfigs(configs) {
    if (!Array.isArray(configs)) {
        throw new Error('The search config of a document type must be an array of search config objects');
    }
    return configs.map((conf) => {
        if (conf === 'defaults') {
            return conf;
        }
        if (!lodash.isPlainObject(conf)) {
            throw new Error('Search config must be an object of {path: string, weight: number}');
        }
        return {
            weight: 'weight' in conf ? conf.weight : 1,
            path: lodash.toPath(conf.path),
            mapWith: typeof conf.mapWith === 'string' ? conf.mapWith : undefined,
        };
    });
}

const stringFieldsSymbol = Symbol('__cachedStringFields');
const isReference = (type) => type.type && type.type.name === 'reference';
const portableTextFields = ['style', 'list'];
const isPortableTextBlock = (type) => type.name === 'block' || (type.type && isPortableTextBlock(type.type));
const isPortableTextArray = (type) => type.jsonType === 'array' && Array.isArray(type.of) && type.of.some(isPortableTextBlock);
function reduceType(type, reducer, acc, path = [], maxDepth) {
    if (maxDepth < 0) {
        return acc;
    }
    const accumulator = reducer(acc, type, path);
    if (type.jsonType === 'array' && Array.isArray(type.of)) {
        return reduceArray(type, reducer, accumulator, path, maxDepth);
    }
    if (type.jsonType === 'object' && Array.isArray(type.fields) && !isReference(type)) {
        return reduceObject(type, reducer, accumulator, path, maxDepth);
    }
    return accumulator;
}
function reduceArray(arrayType, reducer, accumulator, path, maxDepth) {
    return arrayType.of.reduce((acc, ofType) => reduceType(ofType, reducer, acc, path, maxDepth - 1), accumulator);
}
function reduceObject(objectType, reducer, accumulator, path, maxDepth) {
    const isPtBlock = isPortableTextBlock(objectType);
    return objectType.fields.reduce((acc, field) => {
        // Don't include styles and list types as searchable paths for portable text blocks
        if (isPtBlock && portableTextFields.includes(field.name)) {
            return acc;
        }
        const segment = [field.name].concat(field.type.jsonType === 'array' ? [[]] : []);
        return reduceType(field.type, reducer, acc, path.concat(segment), maxDepth - 1);
    }, accumulator);
}
const BASE_WEIGHTS = [
    { weight: 1, path: ['_id'] },
    { weight: 1, path: ['_type'] },
];
const PREVIEW_FIELD_WEIGHT_MAP = {
    title: 10,
    subtitle: 5,
    description: 1.5,
};
function deriveFromPreview(type) {
    const select = type.preview.select;
    return Object.keys(select)
        .filter((fieldName) => fieldName in PREVIEW_FIELD_WEIGHT_MAP)
        .map((fieldName) => ({
        weight: PREVIEW_FIELD_WEIGHT_MAP[fieldName],
        path: select[fieldName].split('.'),
    }));
}
function getCachedStringFieldPaths(type, maxDepth) {
    if (!type[stringFieldsSymbol]) {
        type[stringFieldsSymbol] = lodash.uniqBy([
            ...BASE_WEIGHTS,
            ...deriveFromPreview(type),
            ...getStringFieldPaths(type, maxDepth).map((path) => ({ weight: 1, path })),
            ...getPortableTextFieldPaths(type, maxDepth).map((path) => ({
                weight: 1,
                path,
                mapWith: 'pt::text',
            })),
        ], (spec) => spec.path.join('.'));
    }
    return type[stringFieldsSymbol];
}
function getStringFieldPaths(type, maxDepth) {
    const reducer = (accumulator, childType, path) => childType.jsonType === 'string' ? [...accumulator, path] : accumulator;
    return reduceType(type, reducer, [], [], maxDepth);
}
function getPortableTextFieldPaths(type, maxDepth) {
    const reducer = (accumulator, childType, path) => isPortableTextArray(childType) ? [...accumulator, path] : accumulator;
    return reduceType(type, reducer, [], [], maxDepth);
}
function resolveSearchConfig(type) {
    return getCachedStringFieldPaths(type, 4);
}

const OVERRIDABLE_FIELDS$5 = [
    ...DEFAULT_OVERRIDEABLE_FIELDS,
    'orderings',
    '__experimental_search',
    'blockEditor',
    'icon',
];
const ObjectType = {
    get() {
        return {
            name: 'object',
            title: 'Object',
            type: null,
            jsonType: 'object',
        };
    },
    extend(rawSubTypeDef, createMemberType) {
        const subTypeDef = { fields: [], ...rawSubTypeDef };
        const options = { ...(subTypeDef.options || {}) };
        const parsed = Object.assign(lodash.pick(this.get(), OVERRIDABLE_FIELDS$5), subTypeDef, {
            type: this.get(),
            title: subTypeDef.title || (subTypeDef.name ? lodash.startCase(subTypeDef.name) : ''),
            options: options,
            orderings: subTypeDef.orderings || guessOrderingConfig(subTypeDef),
            fields: subTypeDef.fields.map((fieldDef) => {
                const { name, fieldset, group, ...rest } = fieldDef;
                const compiledField = {
                    name,
                    group,
                    fieldset,
                };
                return lazyGetter(compiledField, 'type', () => {
                    return createMemberType({
                        ...rest,
                        title: fieldDef.title || lodash.startCase(name),
                    });
                });
            }),
        });
        lazyGetter(parsed, 'fieldsets', () => {
            return createFieldsets(subTypeDef, parsed.fields);
        });
        lazyGetter(parsed, 'groups', () => {
            return createFieldsGroups(subTypeDef, parsed.fields);
        });
        lazyGetter(parsed, 'preview', createPreviewGetter(subTypeDef));
        lazyGetter(parsed, '__experimental_search', () => {
            const userProvidedSearchConfig = subTypeDef.__experimental_search
                ? normalizeSearchConfigs(subTypeDef.__experimental_search)
                : null;
            if (userProvidedSearchConfig) {
                return userProvidedSearchConfig.map((entry) => entry === 'defaults' ? normalizeSearchConfigs(subTypeDef) : entry);
            }
            return resolveSearchConfig(parsed);
        }, {
            enumerable: false,
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    if (extensionDef.fields) {
                        throw new Error('Cannot override `fields` of subtypes of "object"');
                    }
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, OVERRIDABLE_FIELDS$5), {
                        title: extensionDef.title ||
                            subTypeDef.title ||
                            (subTypeDef.name ? lodash.startCase(subTypeDef.name) : ''),
                        type: parent,
                    });
                    lazyGetter(current, '__experimental_search', () => parent.__experimental_search);
                    return subtype(current);
                },
            };
        }
    },
};
function createFieldsets(typeDef, fields) {
    const fieldsetsDef = typeDef.fieldsets || [];
    const fieldsets = fieldsetsDef.map((fieldset) => {
        const { name, title, description, options, group, hidden, readOnly } = fieldset;
        return {
            name,
            title,
            description,
            options,
            group,
            fields: [],
            hidden,
            readOnly,
        };
    });
    const fieldsetsByName = lodash.keyBy(fieldsets, 'name');
    return fields
        .map((field) => {
        if (field.fieldset) {
            const fieldset = fieldsetsByName[field.fieldset];
            if (!fieldset) {
                throw new Error(`Fieldset '${field.fieldset}' is not defined in schema for type '${typeDef.name}'`);
            }
            fieldset.fields.push(field);
            // Return the fieldset if its the first time we encounter a field in this fieldset
            return fieldset.fields.length === 1 ? fieldset : null;
        }
        return { single: true, field };
    })
        .filter(Boolean);
}
function createFieldsGroups(typeDef, fields) {
    const groupsDef = typeDef.groups || [];
    const groups = groupsDef.map((group) => {
        const { name, title, description, icon, readOnly, hidden } = group;
        return {
            name,
            title,
            description,
            icon,
            readOnly,
            default: group.default,
            hidden,
            fields: [],
        };
    });
    const defaultGroups = groups.filter((group) => group.default);
    if (defaultGroups.length > 1) {
        // Throw if you have multiple default field groups defined
        throw new Error(`You currently have ${defaultGroups.length} default field groups defined for type '${typeDef.name ? lodash.startCase(typeDef.name) : typeDef.title ?? ``}', but only 1 is supported`);
    }
    const groupsByName = lodash.keyBy(groups, 'name');
    fields.forEach((field) => {
        if (field.group) {
            const fieldGroupNames = lodash.castArray(field.group);
            if (fieldGroupNames.length > 0) {
                fieldGroupNames.forEach((fieldGroupName) => {
                    const currentGroup = groupsByName[fieldGroupName];
                    if (!currentGroup) {
                        throw new Error(`Field group '${fieldGroupName}' is not defined in schema for type '${typeDef.name ?? typeDef.title ?? ``}'`);
                    }
                    currentGroup.fields.push(field);
                });
            }
        }
    });
    return lodash.flatMap(groupsByName).filter((group) => group.fields.length > 0);
}

const REF_FIELD$1 = {
    name: '_ref',
    title: 'Referenced document ID',
    type: 'string',
};
const WEAK_FIELD$1 = {
    name: '_weak',
    title: 'Weak reference',
    type: 'boolean',
};
const REFERENCE_FIELDS$1 = [REF_FIELD$1, WEAK_FIELD$1];
const OVERRIDABLE_FIELDS$4 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const REFERENCE_CORE = {
    name: 'reference',
    title: 'Reference',
    type: null,
    jsonType: 'object',
};
function humanize$1(arr, conjunction) {
    const len = arr.length;
    if (len === 1) {
        return arr[0];
    }
    const first = arr.slice(0, len - 1);
    const last = arr[len - 1];
    return `${first.join(', ')} ${conjunction} ${last}`;
}
function buildTitle$1(type) {
    if (!type.to || type.to.length === 0) {
        return 'Reference';
    }
    return `Reference to ${humanize$1(arrify__default["default"](type.to).map((toType) => toType.title), 'or').toLowerCase()}`;
}
const ReferenceType = {
    get() {
        return REFERENCE_CORE;
    },
    extend(subTypeDef, createMemberType) {
        if (!subTypeDef.to) {
            throw new Error(`Missing "to" field in reference definition. Check the type ${subTypeDef.name}`);
        }
        const parsed = Object.assign(lodash.pick(REFERENCE_CORE, OVERRIDABLE_FIELDS$4), subTypeDef, {
            type: REFERENCE_CORE,
        });
        lazyGetter(parsed, 'fields', () => {
            return REFERENCE_FIELDS$1.map((fieldDef) => {
                const { name, ...type } = fieldDef;
                return {
                    name: name,
                    type: createMemberType(type),
                };
            });
        });
        lazyGetter(parsed, 'fieldsets', () => {
            return createFieldsets(subTypeDef, parsed.fields);
        });
        lazyGetter(parsed, 'to', () => {
            return arrify__default["default"](subTypeDef.to).map((toType) => createMemberType(toType));
        });
        lazyGetter(parsed, 'title', () => subTypeDef.title || buildTitle$1(parsed));
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    if (extensionDef.of) {
                        throw new Error('Cannot override `of` of subtypes of "reference"');
                    }
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, OVERRIDABLE_FIELDS$4), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

const REF_FIELD = {
    name: '_ref',
    title: 'Referenced document ID',
    type: 'string',
};
const WEAK_FIELD = {
    name: '_weak',
    title: 'Weak reference marker',
    type: 'boolean',
};
const REFERENCE_FIELDS = [REF_FIELD, WEAK_FIELD];
const OVERRIDABLE_FIELDS$3 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const CROSS_DATASET_REFERENCE_CORE = {
    name: 'crossDatasetReference',
    type: null,
    jsonType: 'object',
};
function humanize(arr, conjunction) {
    const len = arr.length;
    if (len === 1) {
        return arr[0];
    }
    const first = arr.slice(0, len - 1);
    const last = arr[len - 1];
    return `${first.join(', ')} ${conjunction} ${last}`;
}
function buildTitle(type) {
    if (!type.to || type.to.length === 0) {
        return 'Cross dataset Reference';
    }
    return `Cross dataset reference to ${humanize(arrify__default["default"](type.to).map((toType) => toType.title || lodash.capitalize(toType.type)), 'or').toLowerCase()}`;
}
const CrossDatasetReferenceType = {
    get() {
        return CROSS_DATASET_REFERENCE_CORE;
    },
    extend(subTypeDef, createMemberType) {
        if (!subTypeDef.to) {
            throw new Error(`Missing "to" field in cross dataset reference definition. Check the type ${subTypeDef.name}`);
        }
        const parsed = Object.assign(lodash.pick(CROSS_DATASET_REFERENCE_CORE, OVERRIDABLE_FIELDS$3), subTypeDef, {
            type: CROSS_DATASET_REFERENCE_CORE,
        });
        lazyGetter(parsed, 'fields', () => {
            return REFERENCE_FIELDS.map((fieldDef) => {
                const { name, ...type } = fieldDef;
                return {
                    name: name,
                    type: createMemberType(type),
                };
            });
        });
        lazyGetter(parsed, 'to', () => {
            return arrify__default["default"](subTypeDef.to).map((toType) => {
                return {
                    ...toType,
                    // eslint-disable-next-line camelcase
                    __experimental_search: normalizeSearchConfigs(toType.__experimental_search),
                };
            });
        });
        lazyGetter(parsed, 'title', () => subTypeDef.title || buildTitle(parsed));
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    if (extensionDef.of) {
                        throw new Error('Cannot override `of` of subtypes of "reference"');
                    }
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, OVERRIDABLE_FIELDS$3), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

const ASSET_FIELD$1 = {
    name: 'asset',
    type: 'reference',
    to: [{ type: 'sanity.imageAsset' }],
};
const HOTSPOT_FIELD = {
    name: 'hotspot',
    type: 'sanity.imageHotspot',
};
const CROP_FIELD = {
    name: 'crop',
    type: 'sanity.imageCrop',
};

const OVERRIDABLE_FIELDS$2 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const IMAGE_CORE = {
    name: 'image',
    title: 'Image',
    type: null,
    jsonType: 'object',
};
const DEFAULT_OPTIONS$3 = {};
const ImageType = {
    get() {
        return IMAGE_CORE;
    },
    extend(subTypeDef, extendMember) {
        const options = { ...(subTypeDef.options || DEFAULT_OPTIONS$3) };
        let hotspotFields = [HOTSPOT_FIELD, CROP_FIELD];
        if (!options.hotspot) {
            hotspotFields = hotspotFields.map((field) => ({ ...field, hidden: true }));
        }
        const fields = [ASSET_FIELD$1, ...hotspotFields, ...(subTypeDef.fields || [])];
        const parsed = Object.assign(lodash.pick(IMAGE_CORE, OVERRIDABLE_FIELDS$2), subTypeDef, {
            type: IMAGE_CORE,
            title: subTypeDef.title || lodash.startCase(subTypeDef.name || subTypeDef.type || ''),
            options: options,
            isCustomized: Boolean(subTypeDef.fields),
        });
        lazyGetter(parsed, 'fields', () => {
            return fields.map((fieldDef) => {
                const { name, fieldset, ...type } = fieldDef;
                return {
                    name: name,
                    fieldset,
                    type: extendMember(type),
                };
            });
        });
        lazyGetter(parsed, 'fieldsets', () => {
            return createFieldsets(subTypeDef, parsed.fields);
        });
        lazyGetter(parsed, 'preview', createPreviewGetter(Object.assign({}, subTypeDef, { fields })));
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    if (extensionDef.fields) {
                        throw new Error('Cannot override `fields` of subtypes of "image"');
                    }
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, OVERRIDABLE_FIELDS$2), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

const ASSET_FIELD = {
    name: 'asset',
    type: 'reference',
    to: { type: 'sanity.fileAsset' },
};
const OVERRIDABLE_FIELDS$1 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const FILE_CORE = {
    name: 'file',
    title: 'File',
    type: null,
    jsonType: 'object',
};
const DEFAULT_OPTIONS$2 = {
    accept: '',
};
const FileType = {
    get() {
        return FILE_CORE;
    },
    extend(subTypeDef, extendMember) {
        const options = { ...(subTypeDef.options || DEFAULT_OPTIONS$2) };
        const fields = [ASSET_FIELD, ...(subTypeDef.fields || [])];
        const parsed = Object.assign(lodash.pick(FILE_CORE, OVERRIDABLE_FIELDS$1), subTypeDef, {
            type: FILE_CORE,
            options: options,
            isCustomized: Boolean(subTypeDef.fields),
        });
        lazyGetter(parsed, 'fields', () => {
            return fields.map((fieldDef) => {
                const { name, fieldset, ...type } = fieldDef;
                return {
                    name: name,
                    fieldset,
                    type: extendMember(type),
                };
            });
        });
        lazyGetter(parsed, 'fieldsets', () => {
            return createFieldsets(subTypeDef, parsed.fields);
        });
        lazyGetter(parsed, 'preview', createPreviewGetter(Object.assign({}, subTypeDef, { fields })));
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    if (extensionDef.fields) {
                        throw new Error('Cannot override `fields` of subtypes of "file"');
                    }
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, OVERRIDABLE_FIELDS$1), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

const DOCUMENT_CORE = {
    name: 'document',
    title: 'Document',
    type: null,
    jsonType: 'object',
};
const DocumentType = {
    get() {
        return DOCUMENT_CORE;
    },
    extend: ObjectType.extend,
};

const OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS];
const ARRAY_CORE = {
    name: 'array',
    type: null,
    jsonType: 'array',
    of: [],
};
const ArrayType = {
    get() {
        return ARRAY_CORE;
    },
    extend(subTypeDef, createMemberType) {
        const parsed = Object.assign(lodash.pick(ARRAY_CORE, OVERRIDABLE_FIELDS), subTypeDef, {
            type: ARRAY_CORE,
        });
        lazyGetter(parsed, 'of', () => {
            return subTypeDef.of.map((ofTypeDef) => {
                return createMemberType(ofTypeDef);
            });
        });
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    if (extensionDef.of) {
                        throw new Error('Cannot override `of` property of subtypes of "array"');
                    }
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, OVERRIDABLE_FIELDS), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

const DEFAULT_LINK_ANNOTATION = {
    type: 'object',
    name: 'link',
    options: {
        modal: { type: 'popover' },
    },
    fields: [
        {
            name: 'href',
            type: 'url',
            title: 'Url',
            validation: (Rule) => Rule.uri({
                scheme: ['http', 'https', 'tel', 'mailto'],
                allowRelative: true,
            }),
        },
    ],
};
const DEFAULT_TEXT_FIELD = {
    type: 'text',
    name: 'text',
    title: 'Text',
};
const DEFAULT_MARKS_FIELD = {
    name: 'marks',
    type: 'array',
    of: [{ type: 'string' }],
    title: 'Marks',
};
const LIST_TYPES = {
    bullet: { title: 'Bullet', value: 'bullet' },
    numbered: { title: 'Numbered', value: 'number' },
};
const DEFAULT_LIST_TYPES = [LIST_TYPES.bullet, LIST_TYPES.numbered];
const BLOCK_STYLES = {
    normal: { title: 'Normal', value: 'normal' },
    h1: { title: 'Heading 1', value: 'h1' },
    h2: { title: 'Heading 2', value: 'h2' },
    h3: { title: 'Heading 3', value: 'h3' },
    h4: { title: 'Heading 4', value: 'h4' },
    h5: { title: 'Heading 5', value: 'h5' },
    h6: { title: 'Heading 6', value: 'h6' },
    blockquote: { title: 'Quote', value: 'blockquote' },
};
const DEFAULT_BLOCK_STYLES = [
    BLOCK_STYLES.normal,
    BLOCK_STYLES.h1,
    BLOCK_STYLES.h2,
    BLOCK_STYLES.h3,
    BLOCK_STYLES.h4,
    BLOCK_STYLES.h5,
    BLOCK_STYLES.h6,
    BLOCK_STYLES.blockquote,
];
const DECORATOR_STRONG = { title: 'Strong', value: 'strong' };
const DECORATOR_EMPHASIS = { title: 'Emphasis', value: 'em' };
const DECORATOR_CODE = { title: 'Code', value: 'code' };
const DECORATOR_UNDERLINE = { title: 'Underline', value: 'underline' };
const DECORATOR_STRIKE = { title: 'Strike', value: 'strike-through' };
const DECORATORS = {
    strong: DECORATOR_STRONG,
    em: DECORATOR_EMPHASIS,
    code: DECORATOR_CODE,
    underline: DECORATOR_UNDERLINE,
    strikeThrough: DECORATOR_STRIKE,
};
const DEFAULT_DECORATORS = [
    DECORATORS.strong,
    DECORATORS.em,
    DECORATORS.code,
    DECORATORS.underline,
    DECORATORS.strikeThrough,
];

const INHERITED_FIELDS$1 = [
    'type',
    'name',
    'title',
    'jsonType',
    'description',
    'options',
    'fieldsets',
    'icon',
];
const BLOCK_CORE = {
    name: 'block',
    title: 'Block',
    type: null,
    jsonType: 'object',
};
const DEFAULT_OPTIONS$1 = {};
const BlockType = {
    get() {
        return BLOCK_CORE;
    },
    extend(subTypeDef, extendMember) {
        const options = { ...(subTypeDef.options || DEFAULT_OPTIONS$1) };
        const { marks, styles, lists, of, ...rest } = subTypeDef;
        const childrenField = createChildrenField(marks, of);
        const styleField = createStyleField(styles);
        const listField = createListField(lists);
        const markDefsField = {
            name: 'markDefs',
            title: 'Mark definitions',
            type: 'array',
            of: marks?.annotations || DEFAULT_ANNOTATIONS,
        };
        // NOTE: if you update this (EVEN THE ORDER OF FIELDS) you _NEED TO_ also
        // update `BlockSchemaType`, `isBlockSchemaType` and similar in `@sanity/types`
        const fields = [childrenField, styleField, listField, markDefsField].concat(subTypeDef.fields || []);
        const parsed = Object.assign(lodash.pick(BLOCK_CORE, INHERITED_FIELDS$1), rest, {
            type: BLOCK_CORE,
            options: options,
        });
        lazyGetter(parsed, 'fields', () => {
            return fields.map((fieldDef) => {
                const { name, ...type } = fieldDef;
                return {
                    name: name,
                    type: extendMember(type),
                };
            });
        });
        lazyGetter(parsed, 'preview', createPreviewGetter(subTypeDef));
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    if (extensionDef.fields) {
                        throw new Error('Cannot override `fields` of subtypes of "block"');
                    }
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, INHERITED_FIELDS$1), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};
function ensureNormalStyle(styles) {
    return styles.some((style) => style.value === 'normal')
        ? styles
        : [BLOCK_STYLES.normal, ...styles];
}
function createStyleField(styles) {
    return {
        name: 'style',
        title: 'Style',
        type: 'string',
        options: {
            list: ensureNormalStyle(styles || DEFAULT_BLOCK_STYLES),
        },
    };
}
function createListField(lists) {
    return {
        name: 'list',
        title: 'List type',
        type: 'string',
        options: {
            list: lists || DEFAULT_LIST_TYPES,
        },
    };
}
const DEFAULT_ANNOTATIONS = [DEFAULT_LINK_ANNOTATION];
function createChildrenField(marks, of = []) {
    return {
        name: 'children',
        title: 'Content',
        type: 'array',
        of: [
            {
                type: 'span',
                fields: [DEFAULT_TEXT_FIELD, DEFAULT_MARKS_FIELD],
                annotations: marks && marks.annotations ? marks.annotations : DEFAULT_ANNOTATIONS,
                decorators: marks && marks.decorators ? marks.decorators : DEFAULT_DECORATORS,
            },
            ...of.filter((memberType) => memberType.type !== 'span'),
        ],
    };
}

const INHERITED_FIELDS = [
    'type',
    'name',
    'title',
    'jsonType',
    'description',
    'options',
    'fieldsets',
    'icon',
];
const SPAN_CORE = {
    name: 'span',
    title: 'Span',
    type: null,
    jsonType: 'object',
};
const MARKS_FIELD = {
    name: 'marks',
    title: 'Marks',
    type: 'array',
    of: [{ type: 'string' }],
};
const TEXT_FIELD = {
    name: 'text',
    title: 'Text',
    type: 'string',
};
const DEFAULT_OPTIONS = {};
const SpanType = {
    get() {
        return SPAN_CORE;
    },
    extend(subTypeDef, extendMember) {
        const options = { ...(subTypeDef.options || DEFAULT_OPTIONS) };
        const { annotations = [], marks = [] } = subTypeDef;
        // NOTE: if you update this please also update `SpanSchemaType` in`@sanity/types`
        const fields = [MARKS_FIELD, TEXT_FIELD];
        const parsed = Object.assign(lodash.pick(SPAN_CORE, INHERITED_FIELDS), subTypeDef, {
            type: SPAN_CORE,
            options: options,
        });
        lazyGetter(parsed, 'fields', () => {
            return fields.map((fieldDef) => {
                const { name, ...type } = fieldDef;
                return {
                    name: name,
                    type: extendMember(type),
                };
            });
        });
        lazyGetter(parsed, 'annotations', () => annotations.map(extendMember));
        lazyGetter(parsed, 'marks', () => marks.map(extendMember));
        lazyGetter(parsed, 'preview', createPreviewGetter(subTypeDef));
        return subtype(parsed);
        function subtype(parent) {
            return {
                get() {
                    return parent;
                },
                extend: (extensionDef) => {
                    if (extensionDef.fields) {
                        throw new Error('Cannot override `fields` of subtypes of "span"');
                    }
                    const current = Object.assign({}, parent, lodash.pick(extensionDef, INHERITED_FIELDS), {
                        type: parent,
                    });
                    return subtype(current);
                },
            };
        }
    },
};

var types = {
  __proto__: null,
  any: AnyType,
  string: StringType,
  text: TextType,
  datetime: DateTimeType,
  date: DateType,
  boolean: BooleanType,
  url: UrlType,
  email: EmailType,
  number: NumberType,
  reference: ReferenceType,
  crossDatasetReference: CrossDatasetReferenceType,
  image: ImageType,
  file: FileType,
  object: ObjectType,
  document: DocumentType,
  array: ArrayType,
  block: BlockType,
  span: SpanType
};

function compileRegistry(schemaDef) {
    const registry = Object.assign(Object.create(null), types);
    const defsByName = schemaDef.types.reduce((acc, def) => {
        if (acc[def.name]) {
            throw new Error(`Duplicate type name added to schema: ${def.name}`);
        }
        acc[def.name] = def;
        return acc;
    }, {});
    schemaDef.types.forEach(add);
    return registry;
    function ensure(typeName) {
        if (!registry[typeName]) {
            if (!defsByName[typeName]) {
                throw new Error(`Unknown type: ${typeName}`);
            }
            add(defsByName[typeName]);
        }
    }
    function extendMember(memberDef) {
        ensure(memberDef.type);
        return registry[memberDef.type].extend(memberDef, extendMember).get();
    }
    function add(typeDef) {
        ensure(typeDef.type);
        if (registry[typeDef.name]) {
            return;
        }
        registry[typeDef.name] = registry[typeDef.type].extend(typeDef, extendMember);
    }
}
/**
 * @beta
 */
class Schema {
    _original;
    _registry;
    static compile(schemaDef) {
        return new Schema(schemaDef);
    }
    constructor(schemaDef) {
        this._original = schemaDef;
        this._registry = compileRegistry(schemaDef);
    }
    get name() {
        return this._original.name;
    }
    get(name) {
        return this._registry[name] && this._registry[name].get();
    }
    has(name) {
        return name in this._registry;
    }
    getTypeNames() {
        return Object.keys(this._registry);
    }
}

module.exports = Schema;
//# sourceMappingURL=index.cjs.map
