import { flatten, get, uniq, isPlainObject, omit, difference } from 'lodash';
import inspect from 'object-inspect';
import humanizeList from 'humanize-list';
import leven from 'leven';
import '@sanity/generate-help-url';

// Temporary solution to ensure we have a central registry over used helpIds
const HELP_IDS = {
    TYPE_INVALID: 'schema-type-invalid',
    TYPE_IS_ESM_MODULE: 'schema-type-is-esm-module',
    TYPE_NAME_RESERVED: 'schema-type-name-reserved',
    TYPE_MISSING_NAME: 'schema-type-missing-name-or-type',
    TYPE_MISSING_TYPE: 'schema-type-missing-name-or-type',
    TYPE_TITLE_RECOMMENDED: 'schema-type-title-is-recommended',
    TYPE_TITLE_INVALID: 'schema-type-title-is-recommended',
    OBJECT_FIELDS_INVALID: 'schema-object-fields-invalid',
    OBJECT_FIELD_NOT_UNIQUE: 'schema-object-fields-invalid',
    OBJECT_FIELD_NAME_INVALID: 'schema-object-fields-invalid',
    OBJECT_FIELD_DEFINITION_INVALID_TYPE: 'schema-object-fields-invalid',
    ARRAY_OF_ARRAY: 'schema-array-of-array',
    ARRAY_OF_INVALID: 'schema-array-of-invalid',
    ARRAY_OF_NOT_UNIQUE: 'schema-array-of-invalid',
    ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT: 'schema-array-of-type-global-type-conflict',
    ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT: 'schema-array-of-type-builtin-type-conflict',
    REFERENCE_TO_INVALID: 'schema-reference-to-invalid',
    REFERENCE_TO_NOT_UNIQUE: 'schema-reference-to-invalid',
    REFERENCE_INVALID_OPTIONS: 'schema-reference-invalid-options',
    REFERENCE_INVALID_OPTIONS_LOCATION: 'schema-reference-options-nesting',
    REFERENCE_INVALID_FILTER_PARAMS_COMBINATION: 'schema-reference-filter-params-combination',
    SLUG_SLUGIFY_FN_RENAMED: 'slug-slugifyfn-renamed',
    ASSET_METADATA_FIELD_INVALID: 'asset-metadata-field-invalid',
    CROSS_DATASET_REFERENCE_INVALID: 'cross-dataset-reference-invalid',
};
function createValidationResult(severity, message, helpId) {
    if (helpId && !Object.keys(HELP_IDS).some((id) => HELP_IDS[id] === helpId)) {
        throw new Error(`Used the unknown helpId "${helpId}", please add it to the array in createValidationResult.js`);
    }
    return {
        severity,
        message,
        helpId,
    };
}
const error = (message, helpId) => createValidationResult('error', message, helpId);
const warning = (message, helpId) => createValidationResult('warning', message, helpId);

/**
 * @internal
 */
function groupProblems(types) {
    return flatten(types.map((type) => getTypeProblems(type))).filter((type) => type.problems.length > 0);
}
function createTypeWithMembersProblemsAccessor(memberPropertyName, getMembers = (type) => get(type, memberPropertyName)) {
    return function getProblems(type, parentPath) {
        const currentPath = [
            ...parentPath,
            { kind: 'type', type: type.type, name: type.name },
        ];
        const members = getMembers(type) || [];
        const memberProblems = Array.isArray(members)
            ? members.map((memberType) => {
                const propertySegment = {
                    kind: 'property',
                    name: memberPropertyName,
                };
                const memberPath = [...currentPath, propertySegment];
                return getTypeProblems(memberType, memberPath);
            })
            : [
                [
                    {
                        path: currentPath,
                        problems: [error(`Member declaration (${memberPropertyName}) is not an array`)],
                    },
                ],
            ];
        return [
            {
                path: currentPath,
                problems: type._problems || [],
            },
            ...flatten(memberProblems),
        ];
    };
}
const arrify = (val) => (Array.isArray(val) ? val : (typeof val === 'undefined' && []) || [val]);
const getObjectProblems = createTypeWithMembersProblemsAccessor('fields');
const getImageProblems = createTypeWithMembersProblemsAccessor('fields');
const getFileProblems = createTypeWithMembersProblemsAccessor('fields');
const getArrayProblems = createTypeWithMembersProblemsAccessor('of');
const getReferenceProblems = createTypeWithMembersProblemsAccessor('to', (type) => 'to' in type ? arrify(type.to) : []);
const getBlockAnnotationProblems = createTypeWithMembersProblemsAccessor('marks.annotations');
const getBlockMemberProblems = createTypeWithMembersProblemsAccessor('of');
const getBlockProblems = (type, problems) => [
    ...getBlockAnnotationProblems(type, problems),
    ...getBlockMemberProblems(type, problems),
];
function getDefaultProblems(type, path = []) {
    return [
        {
            path: [...path, { kind: 'type', type: type.type, name: type.name }],
            problems: type._problems || [],
        },
    ];
}
function getTypeProblems(type, path = []) {
    switch (type.type) {
        case 'object': {
            return getObjectProblems(type, path);
        }
        case 'document': {
            return getObjectProblems(type, path);
        }
        case 'array': {
            return getArrayProblems(type, path);
        }
        case 'reference': {
            return getReferenceProblems(type, path);
        }
        case 'block': {
            return getBlockProblems(type, path);
        }
        case 'image': {
            return getImageProblems(type, path);
        }
        case 'file': {
            return getFileProblems(type, path);
        }
        default: {
            return getDefaultProblems(type, path);
        }
    }
}

function getDupes(array, selector = (v) => v) {
    const dupes = array.reduce((acc, item) => {
        const key = selector(item);
        if (!acc[key]) {
            acc[key] = [];
        }
        acc[key].push(item);
        return acc;
    }, {});
    return Object.keys(dupes)
        .map((key) => (dupes[key].length > 1 ? dupes[key] : null))
        .filter(Boolean);
}

const NOOP_VISITOR = (typeDef) => typeDef;
const TYPE_TYPE = { name: 'type', type: null };
const FUTURE_RESERVED = ['any', 'time', 'date'];
function traverseSchema(types = [], coreTypes = [], visitor = NOOP_VISITOR) {
    const coreTypesRegistry = Object.create(null);
    const registry = Object.create(null);
    const coreTypeNames = coreTypes.map((typeDef) => typeDef.name);
    const reservedTypeNames = FUTURE_RESERVED.concat(coreTypeNames);
    const typeNames = types.map((typeDef) => typeDef && typeDef.name).filter(Boolean);
    coreTypes.forEach((coreType) => {
        coreTypesRegistry[coreType.name] = coreType;
    });
    types.forEach((type, i) => {
        // Allocate a placeholder for each type
        registry[(type && type.name) || `__unnamed_${i}`] = {};
    });
    function getType(typeName) {
        return typeName === 'type'
            ? TYPE_TYPE
            : coreTypesRegistry[typeName] || registry[typeName] || null;
    }
    const duplicateNames = uniq(flatten(getDupes(typeNames)));
    function isDuplicate(typeName) {
        return duplicateNames.includes(typeName);
    }
    function getTypeNames() {
        return typeNames.concat(coreTypeNames);
    }
    function isReserved(typeName) {
        return typeName === 'type' || reservedTypeNames.includes(typeName);
    }
    const visitType = (isRoot) => (typeDef, index) => {
        return visitor(typeDef, {
            visit: visitType(false),
            isRoot,
            getType,
            getTypeNames,
            isReserved,
            isDuplicate,
            index,
        });
    };
    coreTypes.forEach((coreTypeDef) => {
        Object.assign(coreTypesRegistry[coreTypeDef.name], visitType(coreTypeDef));
    });
    types.forEach((typeDef, i) => {
        Object.assign(registry[(typeDef && typeDef.name) || `__unnamed_${i}`], visitType(true)(typeDef, i));
    });
    return {
        get(typeName) {
            const res = registry[typeName] || coreTypesRegistry[typeName];
            if (res) {
                return res;
            }
            throw new Error(`No such type: ${typeName}`);
        },
        has(typeName) {
            return typeName in registry || typeName in coreTypesRegistry;
        },
        getTypeNames() {
            return Object.keys(registry);
        },
        getTypes() {
            return this.getTypeNames().map(this.get);
        },
        toJSON() {
            return this.getTypes();
        },
    };
}

const coreTypes = [
    { name: 'array', jsonType: 'array', type: 'type' },
    { name: 'block', jsonType: 'object', type: 'type' },
    { name: 'boolean', jsonType: 'boolean', type: 'type' },
    { name: 'datetime', jsonType: 'string', type: 'type' },
    { name: 'date', jsonType: 'string', type: 'type' },
    { name: 'document', jsonType: 'object', type: 'type' },
    { name: 'email', jsonType: 'string', type: 'type' },
    { name: 'file', jsonType: 'object', type: 'type' },
    { name: 'geopoint', jsonType: 'object', type: 'type' },
    { name: 'image', jsonType: 'object', type: 'type' },
    { name: 'number', jsonType: 'number', type: 'type' },
    { name: 'object', jsonType: 'object', type: 'type' },
    { name: 'reference', jsonType: 'object', type: 'type' },
    { name: 'crossDatasetReference', jsonType: 'object', type: 'type' },
    { name: 'slug', jsonType: 'object', type: 'type' },
    { name: 'string', jsonType: 'string', type: 'type' },
    { name: 'telephone', jsonType: 'string', type: 'type' },
    { name: 'text', jsonType: 'string', type: 'type' },
    { name: 'url', jsonType: 'string', type: 'type' },
];
const coreTypeNames = coreTypes.map((t) => t.name);

function traverseSanitySchema(schemaTypes, visitor) {
    return traverseSchema(schemaTypes, coreTypes, visitor);
}

const REACT_SYM_RE = /^Symbol\(react\..+\)$/;
function isInputComponentLike(value) {
    const type = typeof value;
    // Note: we're not using `isValidElementType` from react-is here since it accepts too much, e.g. any strings.
    return (type === 'function' ||
        (typeof value?.$$typeof === 'symbol' && REACT_SYM_RE.test(String(value?.$$typeof))));
}

function validateInputComponent(typeDef) {
    if ('components' in typeDef && !isInputComponentLike(typeDef.components.input)) {
        return [
            warning(`The \`components.input\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(typeDef.components.input)}). If you have imported a custom input component, please verify that you have imported the correct named/default export.`),
        ];
    }
    return [];
}

const VALID_FIELD_RE = /^[A-Za-z]+[0-9A-Za-z_]*$/;
const CONVENTIONAL_FIELD_RE = /^[A-Za-z_]+[0-9A-Za-z_]*$/;
function validateFieldName(name) {
    if (typeof name !== 'string') {
        return [
            error(`Field names must be strings. Saw "${inspect(name)}"`, HELP_IDS.OBJECT_FIELD_NAME_INVALID),
        ];
    }
    if (name.startsWith('_')) {
        return [
            error(`Invalid field name "${name}". Field names cannot start with underscores "_" as it's reserved for system fields.`, HELP_IDS.OBJECT_FIELD_NAME_INVALID),
        ];
    }
    if (!VALID_FIELD_RE.test(name)) {
        return [
            error(`Invalid field name: "${name}". Fields can only contain characters from A-Z, numbers and underscores and should not start with a number (must pass the regular expression ${String(VALID_FIELD_RE)}).`, HELP_IDS.OBJECT_FIELD_NAME_INVALID),
        ];
    }
    if (!CONVENTIONAL_FIELD_RE.test(name)) {
        return [
            warning('Thats an interesting field name for sure! But it is... how to put it... a bit... unconventional?' +
                ' It may be wise to keep special characters out of field names for easier access later on.'),
            HELP_IDS.OBJECT_FIELD_NAME_INVALID,
        ];
    }
    return [];
}
function validateField(field, _visitorContext) {
    if (!isPlainObject(field)) {
        return [
            error(`Incorrect type for field definition - should be an object, saw ${inspect(field)}`, HELP_IDS.OBJECT_FIELD_DEFINITION_INVALID_TYPE),
        ];
    }
    const problems = [];
    problems.push(...('name' in field
        ? validateFieldName(field.name)
        : [error('Missing field name', HELP_IDS.OBJECT_FIELD_NAME_INVALID)]));
    problems.push(...validateInputComponent(field));
    return problems;
}
function getDuplicateFields(array) {
    const dupes = {};
    array.forEach((field) => {
        if (!dupes[field.name]) {
            dupes[field.name] = [];
        }
        dupes[field.name].push(field);
    });
    return Object.keys(dupes)
        .map((fieldName) => (dupes[fieldName].length > 1 ? dupes[fieldName] : null))
        .filter(Boolean);
}
function validateFields(fields, options = { allowEmpty: false }) {
    const problems = [];
    const fieldsIsArray = Array.isArray(fields);
    if (!fieldsIsArray) {
        return [
            error(`The "fields" property must be an array of fields. Instead saw "${typeof fields}"`, HELP_IDS.OBJECT_FIELDS_INVALID),
        ];
    }
    const fieldsWithNames = fields.filter((field) => typeof field.name === 'string');
    getDuplicateFields(fieldsWithNames).forEach((dupes) => {
        problems.push(error(`Found ${dupes.length} fields with name "${dupes[0].name}" in object`, HELP_IDS.OBJECT_FIELD_NOT_UNIQUE));
    });
    if (fields.length === 0 && !options.allowEmpty) {
        problems.push(error('Object should have at least one field', HELP_IDS.OBJECT_FIELDS_INVALID));
    }
    return problems;
}
function validatePreview(preview) {
    if (!isPlainObject(preview)) {
        return [error(`The "preview" property must be an object, instead saw "${typeof preview}"`)];
    }
    if (typeof preview.prepare !== 'undefined' && typeof preview.prepare !== 'function') {
        return [
            error(`The "preview.prepare" property must be a function, instead saw "${typeof preview.prepare}"`),
        ];
    }
    if (!preview.select) {
        return [];
    }
    if (!isPlainObject(preview.select)) {
        return [
            error(`The "preview.select" property must be an object, instead saw "${typeof preview.prepare}"`),
        ];
    }
    return Object.keys(preview.select).reduce((errs, key) => {
        return typeof preview.select[key] === 'string'
            ? errs
            : errs.concat(error(`The key "${key}" of "preview.select" must be a string, instead saw "${typeof preview
                .select[key]}"`));
    }, []);
}
var object = (typeDef, visitorContext) => {
    let problems = validateFields(typeDef.fields);
    let preview = typeDef.preview;
    if (preview) {
        const previewErrors = validatePreview(typeDef.preview);
        problems = problems.concat(previewErrors);
        preview = previewErrors.some((err) => err.severity === 'error') ? {} : preview;
    }
    if (typeDef.type !== 'document' &&
        typeDef.type !== 'object' &&
        typeof typeDef.initialValue !== 'undefined') {
        problems.push(error(`The "initialValue" property is currently only supported for document & object types.`));
    }
    return {
        ...typeDef,
        preview,
        fields: (Array.isArray(typeDef.fields) ? typeDef.fields : []).map((field, index) => {
            const { name, ...fieldTypeDef } = field;
            const { _problems, ...fieldType } = visitorContext.visit(fieldTypeDef, index);
            return {
                name,
                ...fieldType,
                _problems: validateField(field).concat(_problems || []),
            };
        }),
        _problems: problems,
    };
};

var documentVisitor = (typeDefinition, visitorContext) => {
    const typeDef = object(typeDefinition, visitorContext);
    const { initialValue, initialValues } = typeDef;
    const hasInitialValue = typeof initialValue !== 'undefined';
    if (hasInitialValue && !isPlainObject(initialValue) && typeof initialValue !== 'function') {
        typeDef._problems.push(error(`The "initialValue" property must be either a plain object or a function`));
    }
    if (typeof initialValues !== 'undefined') {
        typeDef._problems.push(error(`Found property "initialValues" - did you mean "initialValue"?`));
    }
    return typeDef;
};

function normalizeToProp$1(typeDef) {
    if (Array.isArray(typeDef.to)) {
        return typeDef.to;
    }
    return typeDef.to ? [typeDef.to] : typeDef.to;
}
var reference = (typeDef, visitorContext) => {
    const isValidTo = Array.isArray(typeDef.to) || isPlainObject(typeDef.to);
    const normalizedTo = normalizeToProp$1(typeDef);
    const problems = flatten([
        isValidTo
            ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map((dupes) => error(`Found ${dupes.length} members with same type, but not unique names "${dupes[0].type}" in reference. This makes it impossible to tell their values apart and you should consider naming them`, HELP_IDS.REFERENCE_TO_INVALID))
            : error('The reference type is missing or having an invalid value for the required "to" property. It should be an array of accepted types.', HELP_IDS.REFERENCE_TO_INVALID),
    ]);
    if (isValidTo && normalizedTo.length === 0) {
        problems.push(error('The reference type should define at least one accepted type. Please check the "to" property.', HELP_IDS.REFERENCE_TO_INVALID));
    }
    problems.push(...getOptionErrors$1(typeDef));
    return {
        ...typeDef,
        to: (isValidTo ? normalizedTo : []).map(visitorContext.visit),
        _problems: problems,
    };
};
function getOptionErrors$1(typeDef) {
    const { options } = typeDef;
    const problems = [];
    problems.push(...['filter', 'filterParams']
        .filter((key) => key in typeDef)
        .map((key) => error(`\`${key}\` is not allowed on a reference type definition - did you mean \`options.${key}\`?`, HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION)));
    if (!options) {
        return problems;
    }
    if (!isPlainObject(options)) {
        return problems.concat(error('The reference type expects `options` to be an object', HELP_IDS.REFERENCE_INVALID_OPTIONS));
    }
    if (typeof options.filter === 'function' && typeof options.filterParams !== 'undefined') {
        return problems.concat(error('`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.', HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION));
    }
    if (typeof options.filter === 'function' || (!options.filter && !options.filterParams)) {
        return problems;
    }
    if (typeof options.filter !== 'string') {
        return problems.concat(error(`If set, \`filter\` must be a string. Got ${typeof options.filter}`));
    }
    if (typeof options.filterParams !== 'undefined' && !isPlainObject(options.filterParams)) {
        return problems.concat(error(`If set, \`filterParams\` must be an object.`));
    }
    if (options.filterParams) {
        return problems.concat(Object.keys(options.filterParams)
            .filter((key) => key.startsWith('__') || key.startsWith('$'))
            .map((key) => error(`Filter parameter cannot be prefixed with "$" or "__". Got ${key}".`)));
    }
    return problems;
}

var array = (typeDef, visitorContext) => {
    // name should already have been marked
    const ofIsArray = Array.isArray(typeDef.of);
    if (ofIsArray) {
        const invalid = typeDef.of.reduce((errs, def, idx) => {
            if (typeof def.name === 'string') {
                // If an array member has been given a "local" type name, we want to trigger an error if the given member type name
                // is one of the builtin types
                //
                // The following examples should be an error (where book is an existing root level type and reference is a built-in type):
                //  - (…) of: [{type: 'book', name: 'image'}]
                //  - (…) of: [{type: 'book', name: 'object'}]
                //  - (…) of: [{type: 'object', name: 'reference'}]
                // The following examples are valid (where "address" is not defined as a global object type)
                //  - (…) of: [{type: 'object', name: 'address'}]
                // The following examples are redundant, but should be allowed (at least for now)
                //  - (…) of: [{type: 'object', name: 'object'}]
                //  - (…) of: [{type: 'image', name: 'image'}]
                if (
                // specifying the same name as the type is redundant, but should not be a hard error at this point
                // Consider showing a warning for this and deprecate this ability eventually
                def.name !== def.type &&
                    coreTypeNames.includes(def.name)) {
                    return errs.concat(error(`Found array member declaration with the same type name as a built-in type ("${def.name}"). Array members can not be given the same name as a built-in type.`, HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT));
                }
            }
            if (def.type === 'object' && def.name && visitorContext.getType(def.name)) {
                return errs.concat(warning(`Found array member declaration with the same name as the global schema type "${def.name}". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`, HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT));
            }
            if (def.type === 'array') {
                return errs.concat(error(`Found array member declaration of type "array" - multidimensional arrays are not currently supported by Sanity`, HELP_IDS.ARRAY_OF_ARRAY));
            }
            if (def) {
                return errs;
            }
            const err = `Found ${def === null ? 'null' : typeof def}, expected member declaration`;
            return errs.concat(error(`Found invalid type member declaration in array at index ${idx}: ${err}`, HELP_IDS.ARRAY_OF_INVALID));
        }, []);
        if (invalid.length > 0) {
            return {
                ...typeDef,
                of: [],
                _problems: invalid,
            };
        }
    }
    const problems = flatten([
        ofIsArray
            ? getDupes(typeDef.of, (t) => `${t.name};${t.type}`).map((dupes) => error(`Found ${dupes.length} members with same type, but not unique names "${dupes[0].type}" in array. This makes it impossible to tell their values apart and you should consider naming them`, HELP_IDS.ARRAY_OF_NOT_UNIQUE))
            : error('The array type is missing or having an invalid value for the required "of" property', HELP_IDS.ARRAY_OF_INVALID),
    ]);
    const of = ofIsArray ? typeDef.of : [];
    // Don't allow object types without a name in block arrays
    const hasObjectTypesWithoutName = of.some((type) => type.type === 'object' && typeof type.name === 'undefined');
    const hasBlockType = of.some((ofType) => ofType.type === 'block');
    if (hasBlockType && hasObjectTypesWithoutName) {
        problems.push(error("The array type's 'of' property can't have an object type without a 'name' property as member, when the 'block' type is also a member of that array.", HELP_IDS.ARRAY_OF_INVALID));
    }
    return {
        ...typeDef,
        of: of.map(visitorContext.visit),
        _problems: problems,
    };
};

var slug = (typeDef, visitorContext) => {
    const problems = [];
    if (typeDef.options && typeDef.options.slugifyFn) {
        problems.push(warning('Heads up! The "slugifyFn" option has been renamed to "slugify".', HELP_IDS.SLUG_SLUGIFY_FN_RENAMED));
        typeDef.options.slugify = typeDef.options.slugifyFn;
    }
    return {
        ...typeDef,
        _problems: problems,
    };
};

var file = (typeDef, visitorContext) => {
    const problems = [];
    const fields = typeDef.fields;
    if (fields) {
        problems.push(...validateFields(fields, { allowEmpty: true }));
    }
    if (typeDef.options &&
        typeof typeDef.options.metadata !== 'undefined' &&
        !Array.isArray(typeDef.options.metadata)) {
        problems.push(error(`Invalid type for file \`metadata\` field - must be an array of strings`, HELP_IDS.ASSET_METADATA_FIELD_INVALID));
    }
    return {
        ...typeDef,
        fields: (Array.isArray(fields) ? fields : []).map((field, index) => {
            const { name, ...fieldTypeDef } = field;
            const { _problems, ...fieldType } = visitorContext.visit(fieldTypeDef, index);
            return {
                name,
                ...fieldType,
                _problems: validateField(field).concat(_problems || []),
            };
        }),
        _problems: problems,
    };
};

const autoMeta = ['dimensions', 'hasAlpha', 'isOpaque'];
var image = (typeDef, visitorContext) => {
    const problems = [];
    const fields = typeDef.fields;
    if (fields) {
        problems.push(...validateFields(fields, { allowEmpty: true }));
    }
    let options = typeDef.options;
    const metadata = options?.metadata;
    const superfluousMeta = Array.isArray(metadata)
        ? metadata.filter((meta) => autoMeta.includes(meta))
        : [];
    if (typeof metadata !== 'undefined' && !Array.isArray(metadata)) {
        problems.push(error(`Invalid type for image \`metadata\` field - must be an array of strings`, HELP_IDS.ASSET_METADATA_FIELD_INVALID));
    }
    else if (superfluousMeta.length > 0) {
        problems.push(warning(`Image \`metadata\` field contains superfluous properties (they are always included): ${superfluousMeta.join(', ')}`));
        options = { ...options, metadata: metadata.filter((meta) => !autoMeta.includes(meta)) };
    }
    return {
        ...typeDef,
        options,
        fields: (Array.isArray(fields) ? fields : []).map((field, index) => {
            const { name, ...fieldTypeDef } = field;
            const { _problems, ...fieldType } = visitorContext.visit(fieldTypeDef, index);
            return {
                name,
                ...fieldType,
                _problems: validateField(field).concat(_problems || []),
            };
        }),
        _problems: problems,
    };
};

function isJSONTypeOf(type, jsonType, visitorContext) {
    if ('jsonType' in type) {
        return type.jsonType === jsonType;
    }
    const parentType = visitorContext.getType(type.type);
    if (!parentType) {
        throw new Error(`Could not resolve jsonType of ${type.name}. No parent type found`);
    }
    return isJSONTypeOf(parentType, jsonType, visitorContext);
}

const getTypeOf = (thing) => (Array.isArray(thing) ? 'array' : typeof thing);
const quote$1 = (str) => `"${str}"`;
const allowedKeys = [
    'lists',
    'marks',
    'name',
    'of',
    'options',
    'styles',
    'title',
    'type',
    'validation',
];
const allowedMarkKeys = ['decorators', 'annotations'];
const allowedStyleKeys = ['title', 'value', 'blockEditor'];
const allowedDecoratorKeys = ['title', 'value', 'blockEditor', 'icon'];
function validateBlockType(typeDef, visitorContext) {
    const problems = [];
    let styles = typeDef.styles;
    let marks = typeDef.marks;
    let members = typeDef.of;
    const disallowedKeys = Object.keys(typeDef).filter((key) => !allowedKeys.includes(key) && !key.startsWith('_'));
    if (disallowedKeys.length > 0) {
        problems.push(error(`Found unknown properties for block declaration: ${humanizeList(disallowedKeys.map(quote$1))}`));
    }
    if (marks) {
        marks = validateMarks(typeDef.marks, visitorContext, problems);
    }
    if (styles) {
        styles = validateStyles(styles, visitorContext, problems);
    }
    if (members) {
        members = validateMembers(members, visitorContext, problems);
    }
    return {
        ...omit(typeDef, disallowedKeys),
        marks,
        styles,
        of: members,
        _problems: problems,
    };
}
function validateMarks(marks, visitorContext, problems) {
    let decorators = marks.decorators;
    let annotations = marks.annotations;
    if (!isPlainObject(marks)) {
        problems.push(error(`"marks" declaration should be an object, got ${getTypeOf(marks)}`));
        return problems;
    }
    const disallowedMarkKeys = Object.keys(marks).filter((key) => !allowedMarkKeys.includes(key) && !key.startsWith('_'));
    if (disallowedMarkKeys.length > 0) {
        problems.push(error(`Found unknown properties for block declaration: ${humanizeList(disallowedMarkKeys.map(quote$1))}`));
    }
    if (decorators && !Array.isArray(decorators)) {
        problems.push(error(`"marks.decorators" declaration should be an array, got ${getTypeOf(decorators)}`));
    }
    else if (decorators) {
        decorators = validateDecorators(decorators, visitorContext, problems);
    }
    if (annotations && !Array.isArray(annotations)) {
        problems.push(error(`"marks.annotations" declaration should be an array, got ${getTypeOf(annotations)}`));
    }
    else if (annotations) {
        annotations = validateAnnotations(annotations, visitorContext);
    }
    return { ...marks, decorators, annotations };
}
function validateStyles(styles, visitorContext, problems) {
    if (!Array.isArray(styles)) {
        problems.push(error(`"styles" declaration should be an array, got ${getTypeOf(styles)}`));
        return problems;
    }
    styles.forEach((style, index) => {
        if (!isPlainObject(style)) {
            problems.push(error(`Style must be an object, got ${getTypeOf(style)}`));
            return;
        }
        const name = style.value || `#${index}`;
        const disallowedKeys = Object.keys(style).filter((key) => !allowedStyleKeys.includes(key) && !key.startsWith('_'));
        if (disallowedKeys.length > 0) {
            problems.push(error(`Found unknown properties for style ${name}: ${humanizeList(disallowedKeys.map(quote$1))}`));
        }
        if (!style.value) {
            problems.push(error(`Style #${index} is missing required "value" property`));
        }
        else if (typeof style.value !== 'string') {
            problems.push(error(`Style #${index} has an invalid "value" property, expected string, got ${getTypeOf(style.value)}`));
        }
        else if (!style.title) {
            problems.push(warning(`Style ${name} is missing recommended "title" property`));
        }
    });
    return styles;
}
function validateDecorators(decorators, visitorContext, problems) {
    decorators.forEach((decorator, index) => {
        if (!isPlainObject(decorator)) {
            problems.push(error(`Annotation must be an object, got ${getTypeOf(decorator)}`));
            return;
        }
        const name = decorator.value || `#${index}`;
        const disallowedKeys = Object.keys(decorator).filter((key) => !allowedDecoratorKeys.includes(key) && !key.startsWith('_'));
        if (disallowedKeys.length > 0) {
            problems.push(error(`Found unknown properties for decorator ${name}: ${humanizeList(disallowedKeys.map(quote$1))}`));
        }
        if (!decorator.value) {
            problems.push(error(`Decorator #${index} is missing required "value" property`));
        }
        else if (typeof decorator.value !== 'string') {
            problems.push(error(`Decorator #${index} has an invalid "value" property, expected string, got ${getTypeOf(decorator.value)}`));
        }
        else if (!decorator.title) {
            problems.push(warning(`Decorator ${name} is missing recommended "title" property`));
        }
    });
    return decorators;
}
function validateAnnotations(annotations, visitorContext, problems) {
    return annotations.map((annotation) => {
        if (!isPlainObject(annotation)) {
            return {
                ...annotation,
                _problems: [error(`Annotation must be an object, got ${getTypeOf(annotation)}`)],
            };
        }
        const { _problems } = visitorContext.visit(annotation, visitorContext);
        const targetType = annotation.type && visitorContext.getType(annotation.type);
        if (targetType && !isJSONTypeOf(targetType, 'object', visitorContext)) {
            _problems.push(error(`Annotation cannot have type "${annotation.type}" - annotation types must inherit from object`));
        }
        return { ...annotation, _problems };
    });
}
function validateMembers(members, visitorContext, problems) {
    if (!Array.isArray(members)) {
        problems.push(error(`"of" declaration should be an array, got ${getTypeOf(members)}`));
        return undefined;
    }
    return members.map((member) => {
        const { _problems } = visitorContext.visit(member, visitorContext);
        return { ...member, _problems };
    });
}

function validateNonObjectFieldsProp(typeDef, visitorContext) {
    if (!('fields' in typeDef)) {
        return [];
    }
    let type = typeDef;
    while (type && !type.jsonType) {
        type = visitorContext.getType(type.type);
    }
    if (type && type.jsonType !== 'object') {
        return [error(`Type has propery "fields", but is not an object/document type.`)];
    }
    return [];
}

const quote = (str) => `"${str}"`;
function validateTypeName(typeName, visitorContext) {
    const possibleTypeNames = visitorContext.getTypeNames();
    if (!typeName) {
        return [
            error(`Type is missing a type. Valid types are: ${humanizeList(possibleTypeNames)}`, HELP_IDS.TYPE_MISSING_TYPE),
        ];
    }
    if (typeof typeName !== 'string') {
        return [
            error(`Type has an invalid "type"-property - should be a string. Valid types are: ${humanizeList(possibleTypeNames)}`, HELP_IDS.TYPE_MISSING_TYPE),
        ];
    }
    const isValid = possibleTypeNames.includes(typeName);
    if (!isValid) {
        const suggestions = possibleTypeNames
            .map((possibleTypeName) => {
            return [leven(typeName, possibleTypeName), possibleTypeName];
        })
            .filter(([distance]) => distance < 3)
            .map(([_, name]) => name);
        const suggestion = suggestions.length > 0
            ? ` Did you mean ${humanizeList(suggestions.map(quote), { conjunction: 'or' })}?`
            : '';
        return [
            error(`Unknown type: ${typeName}.${suggestion}\n\nValid types are: ${humanizeList(possibleTypeNames)}`),
        ];
    }
    return [];
}

var common = (typeDef, visitorContext) => {
    return {
        ...typeDef,
        _problems: [
            ...validateTypeName(typeDef.type, visitorContext),
            ...validateNonObjectFieldsProp(typeDef, visitorContext),
        ].filter(Boolean),
    };
};

var rootType = (typeDef, visitorContext) => {
    const hasName = Boolean(typeDef.name);
    if (!hasName && Object.keys(typeDef).length === 1) {
        // Short-circuit on obviously invalid types (only key is _problems)
        return {
            ...typeDef,
            _problems: [
                error('Invalid/undefined type declaration, check declaration or the import/export of the schema type.', HELP_IDS.TYPE_INVALID),
            ],
        };
    }
    const problems = [];
    if (looksLikeEsmModule(typeDef)) {
        problems.push(error('Type appears to be an ES6 module imported through CommonJS require - use an import statement or access the `.default` property', HELP_IDS.TYPE_IS_ESM_MODULE));
    }
    else if (!hasName) {
        problems.push(error('Missing type name', HELP_IDS.TYPE_MISSING_NAME));
    }
    else if (visitorContext.isReserved(typeDef.name)) {
        problems.push(error(`Invalid type name: "${typeDef.name}" is a reserved name.`, HELP_IDS.TYPE_NAME_RESERVED));
    }
    if (visitorContext.isDuplicate(typeDef.name)) {
        problems.push(error(`Invalid type name: A type with name "${typeDef.name}" is already defined in the schema.`));
    }
    problems.push(...validateInputComponent(typeDef));
    if (!('title' in typeDef)) {
        problems.push(warning("Type is missing title. It's recommended to always set a descriptive title.", HELP_IDS.TYPE_TITLE_RECOMMENDED));
    }
    else if (typeof typeDef.title !== 'string') {
        problems.push(warning('Type title is not a string.', HELP_IDS.TYPE_TITLE_INVALID));
    }
    return {
        ...typeDef,
        _problems: problems,
    };
};
function looksLikeEsmModule(typeDef) {
    return !typeDef.name && typeDef.default && (typeDef.default.name || typeDef.default.title);
}

const validateExperimentalSearch = (configs) => {
    if (!Array.isArray(configs)) {
        return ['The search config of a document type must be an array of search config objects'];
    }
    return configs
        .map((conf) => {
        if (!isPlainObject(conf)) {
            return 'Search config must be an object of {path: string, weight: number}';
        }
        return null;
    })
        .filter(Boolean);
};

function normalizeToProp(typeDef) {
    if (Array.isArray(typeDef.to)) {
        return typeDef.to;
    }
    return typeDef.to ? [typeDef.to] : typeDef.to;
}
const VALID_DATASET = /^[a-z0-9~][-_a-z0-9]+$/;
function isValidDatasetName(name) {
    const isValid = name.length >= 2 && name.toLowerCase() === name && VALID_DATASET.test(name);
    return (isValid ||
        `The provided dataset "${name}" doesn't look like a valid dataset. Dataset names must be more than 2 characters, can only contain lowercase characters, numbers, underscores and dashes and can not start with a dash or an underscore`);
}
const VALID_TOKEN_ID = /^[a-zA-Z0-9_][a-zA-Z0-9_-]+$/;
function isValidTokenId(tokenId) {
    const isValid = tokenId.length >= 2 && VALID_TOKEN_ID.test(tokenId);
    return (isValid ||
        `The provided tokenId "${tokenId}" is invalid. The tokenId must be a string made up of at least 2 characters in the a-zA-Z0-9_- range and cannot start with a - (dash) character`);
}
var crossDatasetReference = (typeDef, visitorContext) => {
    const isValidTo = Array.isArray(typeDef.to) || isPlainObject(typeDef.to);
    const normalizedTo = normalizeToProp(typeDef);
    const problems = flatten([
        isValidTo
            ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map((dupes) => error(`Found ${dupes.length} members with same type, but not unique names "${dupes[0].type}" in reference. This makes it impossible to tell their values apart and you should consider naming them`, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID))
            : error('The cross dataset reference type is missing or having an invalid value for the required "to" property. It should be an array of accepted types.', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID),
    ]);
    if (isValidTo && normalizedTo.length === 0) {
        problems.push(error('The cross dataset reference type should define at least one referenced type. Please check the "to" property.', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    }
    normalizedTo.forEach((crossDatasetTypeDef, index) => {
        if (!crossDatasetTypeDef.type) {
            problems.push(error(`The referenced type at index ${index} must be named. Specify the name of the type you want to create references to.`, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
        }
        if (!isPlainObject(crossDatasetTypeDef.preview)) {
            problems.push(error(`Missing required preview config for the referenced type "${crossDatasetTypeDef.type || '<unknown type>'}"`, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
        }
        validateExperimentalSearch(crossDatasetTypeDef.__experimental_search).forEach((err) => {
            problems.push(error(`Invalid "__experimental_search" config for referenced type "${crossDatasetTypeDef.type || '<unknown type>'}": ${err}`, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
        });
    });
    if (typeof typeDef.tokenId === 'string') {
        const validationResult = isValidTokenId(typeDef.tokenId);
        if (validationResult !== true) {
            problems.push(error(validationResult, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
        }
    }
    if (typeof typeDef.projectId !== 'string') {
        problems.push(error('A cross dataset reference must specify a `projectId`', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    }
    if (typeof typeDef.dataset === 'string') {
        const datasetValidation = isValidDatasetName(typeDef.dataset);
        if (datasetValidation !== true) {
            problems.push(error(datasetValidation, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
        }
    }
    else {
        problems.push(error('A cross dataset reference must specify a `dataset`', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    }
    if (typeDef.studioUrl && typeof typeDef.studioUrl !== 'function') {
        problems.push(error('The "studioUrl" property on a cross dataset reference must be a function taking "{id, type}" as argument and returning a studio url.', HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
    }
    problems.push(...getOptionErrors(typeDef));
    return {
        ...typeDef,
        _problems: problems,
    };
};
function getOptionErrors(typeDef) {
    const { options } = typeDef;
    const problems = [];
    problems.push(...['filter', 'filterParams']
        .filter((key) => key in typeDef)
        .map((key) => error(`\`${key}\` is not allowed on a reference type definition - did you mean \`options.${key}\`?`, HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION)));
    if (!options) {
        return problems;
    }
    if (!isPlainObject(options)) {
        return problems.concat(error('The reference type expects `options` to be an object', HELP_IDS.REFERENCE_INVALID_OPTIONS));
    }
    if (typeof options.filter === 'function' && typeof options.filterParams !== 'undefined') {
        return problems.concat(error('`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.', HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION));
    }
    if (typeof options.filter === 'function' || (!options.filter && !options.filterParams)) {
        return problems;
    }
    if (typeof options.filter !== 'string') {
        return problems.concat(error(`If set, \`filter\` must be a string. Got ${typeof options.filter}`));
    }
    if (typeof options.filterParams !== 'undefined' && !isPlainObject(options.filterParams)) {
        return problems.concat(error(`If set, \`filterParams\` must be an object.`));
    }
    if (options.filterParams) {
        return problems.concat(Object.keys(options.filterParams)
            .filter((key) => key.startsWith('__') || key.startsWith('$'))
            .map((key) => error(`Filter parameter cannot be prefixed with "$" or "__". Got ${key}".`)));
    }
    return problems;
}

const typeVisitors = {
    array,
    object,
    slug,
    file,
    image,
    block: validateBlockType,
    document: documentVisitor,
    reference: reference,
    crossDatasetReference: crossDatasetReference,
};
const getNoopVisitor = (visitorContext) => (schemaDef) => ({
    name: `<unnamed_type_@_index_${visitorContext.index}>`,
    ...schemaDef,
    _problems: [],
});
function combine(...visitors) {
    return (schemaType, visitorContext) => {
        return visitors.reduce((result, visitor) => {
            const res = visitor(result, visitorContext);
            return {
                ...res,
                _problems: result._problems.concat(res._problems),
            };
        }, { _problems: [], ...schemaType });
    };
}
/**
 * @internal
 */
function validateSchema(schemaTypes) {
    return traverseSanitySchema(schemaTypes, (schemaDef, visitorContext) => {
        const typeVisitor = (schemaDef && schemaDef.type && typeVisitors[schemaDef.type]) ||
            getNoopVisitor(visitorContext);
        if (visitorContext.isRoot) {
            return combine(rootType, common, typeVisitor)(schemaDef, visitorContext);
        }
        return combine(common, typeVisitor)(schemaDef, visitorContext);
    });
}

const ACTIONS_FLAG = '__experimental_actions';
const DEFAULT_ACTIONS = ['create', 'update', 'delete', 'publish'];
const VALID_ACTIONS = DEFAULT_ACTIONS;
const readActions = (schemaType) => {
    return ACTIONS_FLAG in schemaType ? schemaType[ACTIONS_FLAG] : DEFAULT_ACTIONS;
};
const validateActions = (typeName, actions) => {
    if (!Array.isArray(actions)) {
        throw new Error(`The value of <type>.${ACTIONS_FLAG} should be an array with any of the actions ${VALID_ACTIONS.join(', ')}`);
    }
    const invalid = difference(actions, VALID_ACTIONS);
    if (invalid.length > 0) {
        throw new Error(`Invalid action${invalid.length > 1 ? 's' : ''} configured for schema type "${typeName}": ${invalid.join(', ')}. Valid actions are: ${VALID_ACTIONS.join(', ')}`);
    }
    return actions;
};
const resolveEnabledActions = (schemaType) => validateActions(schemaType.name, readActions(schemaType));
const isActionEnabled = (schemaType, action) => resolveEnabledActions(schemaType).includes(action);

export { groupProblems, isActionEnabled, validateSchema };
//# sourceMappingURL=_internal.js.map
