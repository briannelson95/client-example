import React, { createContext, useContext, useCallback, useRef, useMemo, useState, useEffect, useLayoutEffect, forwardRef } from 'react';
import { Subject, defer, of, EMPTY } from 'rxjs';
import { tap, concatMap, share, switchMap } from 'rxjs/operators';
import { randomKey } from '@sanity/util/content';
import { Element as Element$1, Text, Editor, Transforms, Node, Path, Operation, Range, createEditor } from 'slate';
import { isObject, uniq, flatten as flatten$1, isEqual, omitBy, isUndefined, get, findIndex, clone, omit, isString, debounce, throttle } from 'lodash';
import { ReactEditor, Slate, useSlateStatic, useSelected, withReact, Editable } from '@sanity/slate-react';
import Schema from '@sanity/schema';
import * as DMP from 'diff-match-patch';
import debug$h from 'debug';
import { isKeySegment } from '@sanity/types';
import styled from 'styled-components';
import isHotkey from 'is-hotkey';
import { htmlToBlocks, normalizeBlock } from '@sanity/block-tools';

function compileType(rawType) {
    return Schema.compile({
        name: 'blockTypeSchema',
        types: [rawType],
    }).get(rawType.name);
}

function getPortableTextFeatures(portabletextType) {
    if (!portabletextType) {
        throw new Error("Parameter 'portabletextType' missing (required)");
    }
    const blockType = portabletextType.of?.find(findBlockType);
    if (!blockType) {
        throw new Error('Block type is not defined in this schema (required)');
    }
    const childrenField = blockType.fields?.find((field) => field.name === 'children');
    if (!childrenField) {
        throw new Error('Children field for block type found in schema (required)');
    }
    const ofType = childrenField.type.of;
    if (!ofType) {
        throw new Error('Valid types for block children not found in schema (required)');
    }
    const spanType = ofType.find((memberType) => memberType.name === 'span');
    if (!spanType) {
        throw new Error('Span type not found in schema (required)');
    }
    const inlineObjectTypes = (ofType.filter((memberType) => memberType.name !== 'span') ||
        []);
    const blockObjectTypes = (portabletextType.of?.filter((field) => field.name !== blockType.name) ||
        []);
    const annotations = resolveEnabledAnnotationTypes(spanType);
    return {
        styles: resolveEnabledStyles(blockType),
        decorators: resolveEnabledDecorators(spanType),
        lists: resolveEnabledListItems(blockType),
        annotations: annotations,
        types: {
            block: blockType,
            span: spanType,
            portableText: portabletextType,
            inlineObjects: inlineObjectTypes,
            blockObjects: blockObjectTypes,
            annotations: annotations.map((an) => an.type),
        },
    };
}
function resolveEnabledStyles(blockType) {
    const styleField = blockType.fields?.find((btField) => btField.name === 'style');
    if (!styleField) {
        throw new Error("A field with name 'style' is not defined in the block type (required).");
    }
    const textStyles = styleField.type.options?.list &&
        styleField.type.options.list?.filter((style) => style.value);
    if (!textStyles || textStyles.length === 0) {
        throw new Error('The style fields need at least one style ' +
            "defined. I.e: {title: 'Normal', value: 'normal'}.");
    }
    return textStyles;
}
function resolveEnabledAnnotationTypes(spanType) {
    return spanType.annotations.map((annotation) => {
        return {
            blockEditor: annotation.blockEditor,
            portableText: annotation.portableText,
            title: annotation.title,
            type: annotation,
            value: annotation.name,
            icon: annotation.icon,
        };
    });
}
function resolveEnabledDecorators(spanType) {
    return spanType.decorators;
}
function resolveEnabledListItems(blockType) {
    const listField = blockType.fields?.find((btField) => btField.name === 'list');
    if (!listField) {
        throw new Error("A field with name 'list' is not defined in the block type (required).");
    }
    const listItems = listField.type.options?.list &&
        listField.type.options.list.filter((list) => list.value);
    if (!listItems) {
        throw new Error('The list field need at least to be an empty array');
    }
    return listItems;
}
function findBlockType(type) {
    if (type.type) {
        return findBlockType(type.type);
    }
    if (type.name === 'block') {
        return type;
    }
    return null;
}

function setIfMissing(value, path = []) {
    return {
        type: 'setIfMissing',
        path,
        value,
    };
}
// eslint-disable-next-line new-cap
const dmp$3 = new DMP.diff_match_patch();
function diffMatchPatch(currentValue, nextValue, path = []) {
    const patch = dmp$3
        .patch_make(currentValue, nextValue)
        .map((_patch) => _patch.toString())
        .join('');
    return { type: 'diffMatchPatch', path, value: patch };
}
function insert$1(items, position, path = []) {
    return {
        type: 'insert',
        path,
        position,
        items,
    };
}
function set(value, path = []) {
    return { type: 'set', path, value };
}
function unset(path = []) {
    return { type: 'unset', path };
}

function validateValue(value, portableTextFeatures, keyGenerator) {
    let resolution = null;
    let valid = true;
    const validChildTypes = [
        ...[portableTextFeatures.types.span.name],
        ...portableTextFeatures.types.inlineObjects.map((t) => t.name),
    ];
    const validBlockTypes = [
        ...[portableTextFeatures.types.block.name],
        ...portableTextFeatures.types.blockObjects.map((t) => t.name),
    ];
    // Undefined is allowed
    if (value === undefined) {
        return { valid: true, resolution: null };
    }
    // Only lengthy arrays are allowed
    if (!Array.isArray(value) || value.length === 0) {
        return {
            valid: false,
            resolution: {
                patches: [unset([])],
                description: 'Value must be an array or undefined',
                action: 'Unset the value',
                item: value,
            },
        };
    }
    if (value.some((blk, index) => {
        if (!isObject(blk)) {
            resolution = {
                patches: [unset([index])],
                description: `Block must be an object, got ${String(blk)}`,
                action: `Unset invalid item`,
                item: blk,
            };
            return true;
        }
        // Test that every block has a _key
        if (!blk._key) {
            resolution = {
                patches: [set({ ...blk, _key: keyGenerator() }, [index])],
                description: `Block at index ${index} is missing required _key.`,
                action: 'Set the block with a random _key value',
                item: blk,
            };
            return true;
        }
        // Test that every block has valid _type
        if (!blk._type || !validBlockTypes.includes(blk._type)) {
            // Special case where block type is set to default 'block', but the block type is named something else according to the schema.
            if (blk._type === 'block') {
                const currentBlockTypeName = portableTextFeatures.types.block.name;
                resolution = {
                    patches: [set({ ...blk, _type: currentBlockTypeName }, [{ _key: blk._key }])],
                    description: `Block with _key '${blk._key}' has invalid type name '${blk._type}'. According to the schema, the block type name is '${currentBlockTypeName}'`,
                    action: `Use type '${currentBlockTypeName}'`,
                    item: blk,
                };
                return true;
            }
            resolution = {
                patches: [unset([{ _key: blk._key }])],
                description: `Block with _key '${blk._key}' has invalid _type '${blk._type}'`,
                action: 'Remove the block',
                item: blk,
            };
            return true;
        }
        // Test that every child in text block is valid
        if (blk._type === portableTextFeatures.types.block.name) {
            // Test that it has children
            if (!blk.children) {
                resolution = {
                    patches: [unset([{ _key: blk._key }])],
                    description: `Text block with _key '${blk._key}' is missing required key 'children'.`,
                    action: 'Remove the block',
                    item: blk,
                };
                return true;
            }
            // Test that markDefs exists
            if (!blk.markDefs) {
                resolution = {
                    patches: [set({ ...blk, markDefs: [] }, [{ _key: blk._key }])],
                    description: `Block is missing required key 'markDefs'.`,
                    action: 'Add empty markDefs array',
                    item: blk,
                };
                return true;
            }
            // // Test that every span has .marks
            // const spansWithUndefinedMarks = blk.children
            //   .filter(cld => cld._type === portableTextFeatures.types.span.name)
            //   .filter(cld => typeof cld.marks === 'undefined')
            // if (spansWithUndefinedMarks.length > 0) {
            //   const first = spansWithUndefinedMarks[0]
            //   resolution = {
            //     patches: [
            //       set({...first, marks: []}, [{_key: blk._key}, 'children', {_key: first._key}])
            //     ],
            //     description: `Span has no .marks array`,
            //     action: 'Add empty marks array',
            //     item: first
            //   }
            //   return true
            // }
            const allUsedMarks = uniq(flatten$1(blk.children
                .filter((cld) => cld._type === portableTextFeatures.types.span.name)
                .map((cld) => cld.marks || [])));
            // // Test that all markDefs are in use
            // if (blk.markDefs && blk.markDefs.length > 0) {
            //   const unusedMarkDefs: string[] = uniq(
            //     blk.markDefs.map(def => def._key).filter(key => !allUsedMarks.includes(key))
            //   )
            //   if (unusedMarkDefs.length > 0) {
            //     resolution = {
            //       patches: unusedMarkDefs.map(key =>
            //         unset([{_key: blk._key}, 'markDefs', {_key: key}])
            //       ),
            //       description: `Block has unused mark definitions: ${unusedMarkDefs.join(', ')}.`,
            //       action: 'Remove unused markDefs',
            //       item: blk
            //     }
            //     return true
            //   }
            // }
            // Test that every annotation mark used has a definition
            const annotationMarks = allUsedMarks.filter((mark) => !portableTextFeatures.decorators.map((dec) => dec.value).includes(mark));
            const orphanedMarks = annotationMarks.filter((mark) => !blk.markDefs.find((def) => def._key === mark));
            if (orphanedMarks.length > 0) {
                const children = blk.children.filter((cld) => Array.isArray(cld.marks) &&
                    cld.marks.some((mark) => orphanedMarks.includes(mark)));
                if (children) {
                    resolution = {
                        patches: children.map((child) => {
                            return set(child.marks.filter((cmrk) => !orphanedMarks.includes(cmrk)), [{ _key: blk._key }, 'children', { _key: child._key }, 'marks']);
                        }),
                        description: `Block with _key '${blk._key}' contains marks (${orphanedMarks.join(', ')}) not supported by the current content model.`,
                        action: 'Remove invalid marks',
                        item: blk,
                    };
                    return true;
                }
            }
            // Test that children is lengthy
            if (blk.children && blk.children.length === 0) {
                const newSpan = {
                    _type: portableTextFeatures.types.span.name,
                    _key: keyGenerator(),
                    text: '',
                };
                resolution = {
                    patches: [insert$1([newSpan], 'after', [{ _key: blk._key }, 'children', 0])],
                    description: `Children for text block with _key '${blk._key}' is empty.`,
                    action: 'Insert an empty text',
                    item: blk,
                };
                return true;
            }
            // Test every child
            if (blk.children.some((child, cIndex) => {
                if (!child._key) {
                    const newchild = { ...child, _key: keyGenerator() };
                    resolution = {
                        patches: [set(newchild, [{ _key: blk._key }, 'children', cIndex])],
                        description: `Child at index ${cIndex} is missing required _key in block with _key ${blk._key}.`,
                        action: 'Set a new random _key on the object',
                        item: blk,
                    };
                    return true;
                }
                // Verify that childs have valid types
                if (!child._type || validChildTypes.includes(child._type) === false) {
                    resolution = {
                        patches: [unset([{ _key: blk._key }, 'children', { _key: child._key }])],
                        description: `Child with _key '${child._key}' in block with key '${blk._key}' has invalid '_type' property (${child._type}).`,
                        action: 'Remove the object',
                        item: blk,
                    };
                    return true;
                }
                // Verify that spans have .text
                if (child._type === portableTextFeatures.types.span.name && child.text === undefined) {
                    resolution = {
                        patches: [
                            set({ ...child, text: '' }, [{ _key: blk._key }, 'children', { _key: child._key }]),
                        ],
                        description: `Child with _key '${child._key}' in block with key '${blk._key}' is missing text property!`,
                        action: `Write an empty .text to the object`,
                        item: blk,
                    };
                    return true;
                }
                return false;
            })) {
                valid = false;
            }
        }
        return false;
    })) {
        valid = false;
    }
    return { valid, resolution };
}

const rootName = 'sanity-pte:';
debug$h(rootName);
function debugWithName(name) {
    const namespace = `${rootName}${name}`;
    if (debug$h && debug$h.enabled(namespace)) {
        return debug$h(namespace);
    }
    return debug$h(rootName);
}

const EMPTY_MARKDEFS = [];
function keepObjectEquality(object, keyMap) {
    const value = keyMap[object._key];
    if (value && isEqual(object, value)) {
        return value;
    }
    keyMap[object._key] = object;
    return object;
}
function toSlateValue(value, { portableTextFeatures }, keyMap = {}) {
    if (value && Array.isArray(value)) {
        return value.map((block) => {
            const { _type, _key, ...rest } = block;
            const voidChildren = [{ _key: `${_key}-void-child`, _type: 'span', text: '', marks: [] }];
            const isPortableText = block && block._type === portableTextFeatures.types.block.name;
            if (isPortableText) {
                const textBlock = block;
                let hasInlines = false;
                const hasMissingStyle = typeof textBlock.style === 'undefined';
                const hasMissingMarkDefs = typeof textBlock.markDefs === 'undefined';
                const children = textBlock.children.map((child) => {
                    const { _type: cType, _key: cKey, ...cRest } = child;
                    if (cType !== 'span') {
                        hasInlines = true;
                        return keepObjectEquality({
                            _type: cType,
                            _key: cKey,
                            children: voidChildren,
                            value: cRest,
                            __inline: true,
                        }, keyMap);
                    }
                    // Original object
                    return child;
                });
                if (!hasMissingStyle && !hasMissingMarkDefs && !hasInlines && Element$1.isElement(block)) {
                    // Original object
                    return block;
                }
                if (hasMissingStyle) {
                    rest.style = portableTextFeatures.styles[0].value;
                }
                if (hasMissingMarkDefs) {
                    rest.markDefs = EMPTY_MARKDEFS;
                }
                return keepObjectEquality({ _type, _key, ...rest, children }, keyMap);
            }
            return keepObjectEquality({
                _type,
                _key,
                children: voidChildren,
                value: rest,
            }, keyMap);
        });
    }
    return [];
}
function fromSlateValue(value, textBlockType, keyMap = {}) {
    return value.map((block) => {
        const { _key, _type } = block;
        if (!_key || !_type) {
            throw new Error('Not a valid block');
        }
        if (_type === textBlockType && 'children' in block && Array.isArray(block.children) && _key) {
            let hasInlines = false;
            const children = block.children.map((child) => {
                const { _type: _cType } = child;
                if ('value' in child && _cType !== 'span') {
                    hasInlines = true;
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    const { value: v, _key: k, _type: t, __inline: _i, children: _c, ...rest } = child;
                    return keepObjectEquality({ ...rest, ...v, _key: k, _type: t }, keyMap);
                }
                return child;
            });
            if (!hasInlines) {
                return block; // Original object
            }
            return keepObjectEquality({ ...block, children, _key, _type }, keyMap);
        }
        const blockValue = 'value' in block && block.value;
        return keepObjectEquality({ _key, _type, ...(typeof blockValue === 'object' ? blockValue : {}) }, keyMap);
    });
}
function isEqualToEmptyEditor(children, portableTextFeatures) {
    return (children === undefined ||
        (children && Array.isArray(children) && children.length === 0) ||
        (children &&
            Array.isArray(children) &&
            children.length === 1 &&
            Element$1.isElement(children[0]) &&
            children[0]._type === portableTextFeatures.types.block.name &&
            'style' in children[0] &&
            children[0].style === portableTextFeatures.styles[0].value &&
            Array.isArray(children[0].children) &&
            children[0].children.length === 1 &&
            Text.isText(children[0].children[0]) &&
            children[0].children[0]._type === 'span' &&
            children[0].children[0].text === ''));
}
function getValueOrInitialValue(value, initialValue) {
    if (value && Array.isArray(value) && value.length > 0) {
        return value;
    }
    return initialValue;
}

/**
 * Dragging
 */
// Is the editor dragging something?
const IS_DRAGGING = new WeakMap();
// Is the editor dragging a element?
const IS_DRAGGING_BLOCK_ELEMENT = new WeakMap();
const IS_DRAGGING_CHILD_ELEMENT = new WeakMap();
// When dragging elements, this will be the target element
const IS_DRAGGING_ELEMENT_TARGET = new WeakMap();
const IS_DRAGGING_ELEMENT_RANGE = new WeakMap();
// Target position for dragging over a block
const IS_DRAGGING_BLOCK_TARGET_POSITION = new WeakMap();
const KEY_TO_SLATE_ELEMENT = new WeakMap();
const KEY_TO_VALUE_ELEMENT = new WeakMap();
// Keep object relation to slate range in the portable-text-range
const SLATE_TO_PORTABLE_TEXT_RANGE = new WeakMap();

/**
 * A React context for sharing the editor object.
 */
const PortableTextEditorContext = createContext(null);
/**
 * Get the current editor object from the React context.
 */
const usePortableTextEditor = () => {
    const editor = useContext(PortableTextEditorContext);
    if (!editor) {
        throw new Error(`The \`usePortableTextEditor\` hook must be used inside the <PortableTextEditor> component's context.`);
    }
    return editor;
};

/**
 * A React context for sharing the editor selection.
 */
const PortableTextEditorSelectionContext = createContext(null);
/**
 * Get the current editor selection from the React context.
 */
const usePortableTextEditorSelection = () => {
    const selection = useContext(PortableTextEditorSelectionContext);
    if (selection === undefined) {
        throw new Error(`The \`usePortableTextEditorSelection\` hook must be used inside the <PortableTextEditor> component's context.`);
    }
    return selection;
};

/**
 * A React context for sharing the editor value.
 */
const PortableTextEditorValueContext = createContext(undefined);

const debug$g = debugWithName('operationToPatches');
function createOperationToPatches(portableTextFeatures) {
    const textBlockName = portableTextFeatures.types.block.name;
    function insertTextPatch(editor, operation, beforeValue) {
        debug$g('Operation', JSON.stringify(operation, null, 2));
        const block = editor.isTextBlock(editor.children[operation.path[0]]) && editor.children[operation.path[0]];
        if (!block) {
            throw new Error('Could not find block');
        }
        const textChild = editor.isTextBlock(block) &&
            Text.isText(block.children[operation.path[1]]) &&
            block.children[operation.path[1]];
        if (!textChild) {
            throw new Error('Could not find child');
        }
        const path = [{ _key: block._key }, 'children', { _key: textChild._key }, 'text'];
        const prevBlock = beforeValue[operation.path[0]];
        const prevChild = editor.isTextBlock(prevBlock) && prevBlock.children[operation.path[1]];
        const prevText = Text.isText(prevChild) ? prevChild.text : '';
        const patch = diffMatchPatch(prevText, textChild.text, path);
        return patch.value.length ? [patch] : [];
    }
    function removeTextPatch(editor, operation, beforeValue) {
        const block = editor && editor.children[operation.path[0]];
        if (!block) {
            throw new Error('Could not find block');
        }
        const textChild = editor.isTextBlock(block) &&
            Text.isText(block.children[operation.path[1]]) &&
            block.children[operation.path[1]];
        if (!textChild) {
            throw new Error('Could not find child');
        }
        const path = [{ _key: block._key }, 'children', { _key: textChild._key }, 'text'];
        const beforeBlock = beforeValue[operation.path[0]];
        const prevTextChild = editor.isTextBlock(beforeBlock) && beforeBlock.children[operation.path[1]];
        const prevText = Text.isText(prevTextChild) && prevTextChild.text;
        const patch = diffMatchPatch(prevText || '', textChild.text, path);
        return patch.value ? [patch] : [];
    }
    function setNodePatch(editor, operation) {
        if (operation.path.length === 1) {
            const block = editor.children[operation.path[0]];
            if (typeof block._key !== 'string') {
                throw new Error('Expected block to have a _key');
            }
            const setNode = omitBy({ ...editor.children[operation.path[0]], ...operation.newProperties }, isUndefined);
            return [set(fromSlateValue([setNode], textBlockName)[0], [{ _key: block._key }])];
        }
        else if (operation.path.length === 2) {
            const block = editor.children[operation.path[0]];
            if (editor.isTextBlock(block)) {
                const child = block.children[operation.path[1]];
                if (child) {
                    const blockKey = block._key;
                    const childKey = child._key;
                    const patches = [];
                    Object.keys(operation.newProperties).forEach((keyName) => {
                        const val = get(operation.newProperties, keyName);
                        patches.push(set(val, [{ _key: blockKey }, 'children', { _key: childKey }, keyName]));
                    });
                    return patches;
                }
                throw new Error('Could not find a valid child');
            }
            throw new Error('Could not find a valid block');
        }
        else {
            throw new Error(`Unexpected path encountered: ${JSON.stringify(operation.path)}`);
        }
    }
    function insertNodePatch(editor, operation, beforeValue) {
        const block = beforeValue[operation.path[0]];
        if (operation.path.length === 1) {
            const position = operation.path[0] === 0 ? 'before' : 'after';
            const beforeBlock = beforeValue[operation.path[0] - 1];
            const targetKey = operation.path[0] === 0 ? block?._key : beforeBlock?._key;
            if (targetKey) {
                return [
                    insert$1([fromSlateValue([operation.node], textBlockName)[0]], position, [
                        { _key: targetKey },
                    ]),
                ];
            }
            return [
                setIfMissing(beforeValue, []),
                insert$1([fromSlateValue([operation.node], textBlockName)[0]], 'before', [operation.path[0]]),
            ];
        }
        else if (operation.path.length === 2 && editor.children[operation.path[0]]) {
            if (!editor.isTextBlock(block)) {
                throw new Error('Invalid block');
            }
            const position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? 'before' : 'after';
            const child = fromSlateValue([
                {
                    _key: 'bogus',
                    _type: textBlockName,
                    children: [operation.node],
                },
            ], textBlockName)[0].children[0];
            return [
                insert$1([child], position, [
                    { _key: block._key },
                    'children',
                    block.children.length <= 1 || !block.children[operation.path[1] - 1]
                        ? 0
                        : { _key: block.children[operation.path[1] - 1]._key },
                ]),
            ];
        }
        throw new Error(`Unexpected path encountered: ${JSON.stringify(operation.path)} - ${JSON.stringify(beforeValue)}`);
    }
    function splitNodePatch(editor, operation, beforeValue) {
        const patches = [];
        const splitBlock = editor.children[operation.path[0]];
        if (!editor.isTextBlock(splitBlock)) {
            throw new Error(`Block with path ${JSON.stringify(operation.path[0])} is not a text block and can't be split`);
        }
        if (operation.path.length === 1) {
            const oldBlock = beforeValue[operation.path[0]];
            if (editor.isTextBlock(oldBlock)) {
                const targetValue = fromSlateValue([editor.children[operation.path[0] + 1]], textBlockName)[0];
                if (targetValue) {
                    patches.push(insert$1([targetValue], 'after', [{ _key: splitBlock._key }]));
                    const spansToUnset = oldBlock.children.slice(operation.position);
                    spansToUnset.forEach((span) => {
                        const path = [{ _key: oldBlock._key }, 'children', { _key: span._key }];
                        patches.push(unset(path));
                    });
                }
            }
            return patches;
        }
        if (operation.path.length === 2) {
            const splitSpan = splitBlock.children[operation.path[1]];
            if (Text.isText(splitSpan)) {
                const targetSpans = fromSlateValue([
                    {
                        ...splitBlock,
                        children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2),
                    },
                ], textBlockName)[0].children;
                patches.push(insert$1(targetSpans, 'after', [
                    { _key: splitBlock._key },
                    'children',
                    { _key: splitSpan._key },
                ]));
                patches.push(set(splitSpan.text, [{ _key: splitBlock._key }, 'children', { _key: splitSpan._key }, 'text']));
            }
            return patches;
        }
        return patches;
    }
    function removeNodePatch(_, operation, beforeValue) {
        const block = beforeValue[operation.path[0]];
        if (operation.path.length === 1) {
            // Remove a single block
            if (block && block._key) {
                return [unset([{ _key: block._key }])];
            }
            throw new Error('Block not found');
        }
        else if (operation.path.length === 2) {
            const spanToRemove = block && block.children && block.children[operation.path[1]];
            if (spanToRemove) {
                return [unset([{ _key: block._key }, 'children', { _key: spanToRemove._key }])];
            }
            // If it was not there before, do nothing
            debug$g('Span not found in editor trying to remove node');
            return [];
        }
        else {
            throw new Error(`Unexpected path encountered: ${JSON.stringify(operation.path)}`);
        }
    }
    function mergeNodePatch(editor, operation, beforeValue) {
        const patches = [];
        if (operation.path.length === 1) {
            const block = beforeValue[operation.path[0]];
            const targetKey = block && block._key;
            if (targetKey) {
                const newBlock = fromSlateValue([editor.children[operation.path[0] - 1]], textBlockName)[0];
                patches.push(set(newBlock, [{ _key: newBlock._key }]));
                patches.push(unset([{ _key: targetKey }]));
            }
            else {
                throw new Error('Target key not found!');
            }
        }
        else if (operation.path.length === 2) {
            const block = beforeValue[operation.path[0]];
            const mergedSpan = block.children[operation.path[1]];
            const targetBlock = editor.children[operation.path[0]];
            if (!editor.isTextBlock(targetBlock)) {
                throw new Error('Invalid block');
            }
            const targetSpan = targetBlock.children[operation.path[1] - 1];
            if (Text.isText(targetSpan)) {
                // Set the merged span with it's new value
                patches.push(set(targetSpan.text, [{ _key: block._key }, 'children', { _key: targetSpan._key }, 'text']));
                patches.push(unset([{ _key: block._key }, 'children', { _key: mergedSpan._key }]));
            }
        }
        else {
            throw new Error(`Unexpected path encountered: ${JSON.stringify(operation.path)}`);
        }
        return patches;
    }
    function moveNodePatch(_, operation, beforeValue) {
        const patches = [];
        const block = beforeValue[operation.path[0]];
        const targetBlock = beforeValue[operation.newPath[0]];
        if (operation.path.length === 1) {
            const position = operation.path[0] > operation.newPath[0] ? 'before' : 'after';
            patches.push(unset([{ _key: block._key }]));
            patches.push(insert$1([fromSlateValue([block], textBlockName)[0]], position, [{ _key: targetBlock._key }]));
        }
        else if (operation.path.length === 2) {
            const child = block.children[operation.path[1]];
            const targetChild = targetBlock.children[operation.newPath[1]];
            const position = operation.newPath[1] === targetBlock.children.length ? 'after' : 'before';
            const childToInsert = fromSlateValue([block], textBlockName)[0].children[operation.path[1]];
            patches.push(unset([{ _key: block._key }, 'children', { _key: child._key }]));
            patches.push(insert$1([childToInsert], position, [
                { _key: targetBlock._key },
                'children',
                { _key: targetChild._key },
            ]));
        }
        return patches;
    }
    return {
        insertNodePatch,
        insertTextPatch,
        mergeNodePatch,
        moveNodePatch,
        removeNodePatch,
        removeTextPatch,
        setNodePatch,
        splitNodePatch,
    };
}

/**
 * This plugin makes sure that the PTE maxBlocks prop is respected
 *
 */
function createWithMaxBlocks() {
    return function withMaxBlocks(editor) {
        const { apply } = editor;
        editor.apply = (operation) => {
            const rows = editor.maxBlocks || -1;
            if (rows > 0 && editor.children.length >= rows) {
                if ((operation.type === 'insert_node' || operation.type === 'split_node') &&
                    operation.path.length === 1) {
                    return;
                }
            }
            apply(operation);
        };
        return editor;
    };
}

const PRESERVE_KEYS = new WeakMap();
function withPreserveKeys(editor, fn) {
    const prev = isPreservingKeys(editor);
    PRESERVE_KEYS.set(editor, true);
    fn();
    PRESERVE_KEYS.set(editor, !prev);
}
function isPreservingKeys(editor) {
    return PRESERVE_KEYS.get(editor);
}

/**
 * This plugin makes sure that every new node in the editor get a new _key prop when created
 *
 */
function createWithObjectKeys(portableTextFeatures, keyGenerator) {
    return function withKeys(editor) {
        PRESERVE_KEYS.set(editor, false);
        const { apply, normalizeNode } = editor;
        editor.apply = (operation) => {
            if (operation.type === 'split_node') {
                operation.properties = {
                    ...operation.properties,
                    _key: keyGenerator(),
                };
            }
            if (operation.type === 'insert_node') {
                // Must be given a new key or adding/removing marks while typing gets in trouble (duped keys)!
                const withNewKey = !isPreservingKeys(editor) || !('_key' in operation.node);
                if (!Editor.isEditor(operation.node)) {
                    operation.node = {
                        ...operation.node,
                        ...(withNewKey ? { _key: keyGenerator() } : {}),
                    };
                }
            }
            apply(operation);
        };
        editor.normalizeNode = (entry) => {
            const [node, path] = entry;
            if (Element$1.isElement(node) && node._type === portableTextFeatures.types.block.name) {
                // Set key on block itself
                if (!node._key) {
                    Transforms.setNodes(editor, { _key: keyGenerator() }, { at: path });
                }
                // Set keys on it's children
                for (const [child, childPath] of Node.children(editor, path)) {
                    if (!child._key) {
                        Transforms.setNodes(editor, { _key: keyGenerator() }, { at: childPath });
                        return;
                    }
                }
            }
            // Do the original `normalizeNode` to enforce other constraints.
            normalizeNode(entry);
        };
        return editor;
    };
}

const PATCHING = new WeakMap();
function withoutPatching(editor, fn) {
    const prev = isPatching(editor);
    PATCHING.set(editor, false);
    fn();
    PATCHING.set(editor, prev);
}
function isPatching(editor) {
    return PATCHING.get(editor);
}

const BEFORE = 'before';
const AFTER = 'after';
function insert(array, position, index, ...args) {
    if (position !== BEFORE && position !== AFTER) {
        throw new Error(`Invalid position "${position}", must be either ${BEFORE} or ${AFTER}`);
    }
    const items = flatten(...args);
    if (array.length === 0) {
        return items;
    }
    const len = array.length;
    const idx = Math.abs((len + index) % len) % len;
    const normalizedIdx = position === 'after' ? idx + 1 : idx;
    const copy = array.slice();
    copy.splice(normalizedIdx, 0, ...flatten(items));
    return copy;
}
function flatten(...values) {
    return values.reduce((prev, item) => prev.concat(item), []);
}

const hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
function move(arr, from, to) {
    const nextValue = arr.slice();
    const val = nextValue[from];
    nextValue.splice(from, 1);
    nextValue.splice(to, 0, val);
    return nextValue;
}
function findTargetIndex(array, pathSegment) {
    if (typeof pathSegment === 'number') {
        return pathSegment;
    }
    const index = findIndex(array, pathSegment);
    return index === -1 ? false : index;
}
function apply$3(value, patch) {
    const nextValue = value.slice(); // make a copy for internal mutation
    if (patch.path.length === 0) {
        // its directed to me
        if (patch.type === 'setIfMissing') {
            if (!Array.isArray(patch.value)) {
                // eslint-disable-line max-depth
                throw new Error('Cannot set value of an array to a non-array');
            }
            return value === undefined ? patch.value : value;
        }
        else if (patch.type === 'set') {
            if (!Array.isArray(patch.value)) {
                // eslint-disable-line max-depth
                throw new Error('Cannot set value of an array to a non-array');
            }
            return patch.value;
        }
        else if (patch.type === 'unset') {
            return undefined;
        }
        else if (patch.type === 'move') {
            if (!patch.value || !hasOwn(patch.value, 'from') || !hasOwn(patch.value, 'to')) {
                // eslint-disable-line max-depth
                throw new Error(`Invalid value of 'move' patch. Expected a value with "from" and "to" indexes, instead got: ${JSON.stringify(patch.value)}`);
            }
            return move(nextValue, patch.value.from, patch.value.to);
        }
        throw new Error(`Invalid array operation: ${patch.type}`);
    }
    const [head, ...tail] = patch.path;
    const index = findTargetIndex(value, head);
    // If the given selector could not be found, return as-is
    if (index === false) {
        return nextValue;
    }
    if (tail.length === 0) {
        if (patch.type === 'insert') {
            const { position, items } = patch;
            return insert(value, position, index, items);
        }
        else if (patch.type === 'unset') {
            if (typeof index !== 'number') {
                throw new Error(`Expected array index to be a number, instead got "${index}"`);
            }
            nextValue.splice(index, 1);
            return nextValue;
        }
    }
    // The patch is not directed to me
    nextValue[index] = _apply(nextValue[index], {
        ...patch,
        path: tail,
    });
    return nextValue;
}

function apply$2(value, patch) {
    const nextValue = clone(value);
    if (patch.path.length === 0) {
        // its directed to me
        if (patch.type === 'set') {
            if (!isObject(patch.value)) {
                // eslint-disable-line max-depth
                throw new Error('Cannot set value of an object to a non-object');
            }
            return patch.value;
        }
        else if (patch.type === 'unset') {
            return undefined;
        }
        else if (patch.type === 'setIfMissing') {
            // console.log('IS IT missing?', value)
            return value === undefined ? patch.value : value;
        }
        throw new Error(`Invalid object operation: ${patch.type}`);
    }
    // The patch is not directed to me
    const [head, ...tail] = patch.path;
    if (typeof head !== 'string') {
        throw new Error(`Expected field name to be a string, instad got: ${head}`);
    }
    if (tail.length === 0 && patch.type === 'unset') {
        return omit(nextValue, head);
    }
    nextValue[head] = _apply(nextValue[head], {
        ...patch,
        path: tail,
    });
    return nextValue;
}

const OPERATIONS$1 = {
    replace(_currentValue, nextValue) {
        return nextValue;
    },
    set(_currentValue, nextValue) {
        return nextValue;
    },
    setIfMissing(currentValue, nextValue) {
        return currentValue === undefined ? nextValue : currentValue;
    },
    unset(_currentValue, _nextValue) {
        return undefined;
    },
    inc(currentValue, nextValue) {
        return currentValue + nextValue;
    },
    dec(currentValue, nextValue) {
        return currentValue - nextValue;
    },
};
const SUPPORTED_PATCH_TYPES$1 = Object.keys(OPERATIONS$1);
function apply$1(value, patch) {
    if (!SUPPORTED_PATCH_TYPES$1.includes(patch.type)) {
        throw new Error(`Received patch of unsupported type: "${JSON.stringify(patch.type)}" for primitives. This is most likely a bug.`);
    }
    if (patch.path.length > 0) {
        throw new Error(`Cannot apply deep operations on primitive values. Received patch with type "${patch.type}" and path "${patch.path
            .map((path) => JSON.stringify(path))
            .join('.')} that targeted the value "${JSON.stringify(value)}"`);
    }
    return OPERATIONS$1[patch.type](value, patch.value);
}

// eslint-disable-next-line new-cap
const dmp$2 = new DMP.diff_match_patch();
const OPERATIONS = {
    replace(currentValue, nextValue) {
        return nextValue;
    },
    set(currentValue, nextValue) {
        return nextValue;
    },
    setIfMissing(currentValue, nextValue) {
        return currentValue === undefined ? nextValue : currentValue;
    },
    unset(currentValue, nextValue) {
        return undefined;
    },
    diffMatchPatch(currentValue, nextValue) {
        return dmp$2.patch_apply(dmp$2.patch_fromText(nextValue), currentValue)[0];
    },
};
const SUPPORTED_PATCH_TYPES = Object.keys(OPERATIONS);
function apply(value, patch) {
    if (!SUPPORTED_PATCH_TYPES.includes(patch.type)) {
        throw new Error(`Received patch of unsupported type: "${JSON.stringify(patch.type)}" for string. This is most likely a bug.`);
    }
    if (patch.path.length > 0) {
        throw new Error(`Cannot apply deep operations on string values. Received patch with type "${patch.type}" and path "${patch.path.join('.')} that targeted the value "${JSON.stringify(value)}"`);
    }
    const func = OPERATIONS[patch.type];
    if (func) {
        return func(value, patch.value);
    }
    throw new Error('Unknown patch type');
}

function applyAll(value, patches) {
    return patches.reduce(_apply, value);
}
function applyPatch(value, patch) {
    if (Array.isArray(value)) {
        return apply$3(value, patch);
    }
    if (isString(value)) {
        return apply(value, patch);
    }
    if (isObject(value)) {
        return apply$2(value, patch);
    }
    return apply$1(value, patch);
}
function _apply(value, patch) {
    const res = applyPatch(value, patch);
    // console.log('applyPatch(%o, %o) : %o (noop? %o)', value, patch, res, value === res)
    return res;
}

/* eslint-disable max-statements */
const debug$f = debugWithName('operationToPatches');
// eslint-disable-next-line new-cap
const dmp$1 = new DMP.diff_match_patch();
function createPatchToOperations(portableTextFeatures, keyGenerator) {
    function diffMatchPatch(editor, patch) {
        const blockKey = findLastKey([patch.path[0]]);
        const blockIndex = editor.children.findIndex((node, indx) => {
            return blockKey ? node._key === blockKey : indx === patch.path[0];
        });
        const block = editor.children[blockIndex];
        const childKey = findLastKey([patch.path[2]]);
        const childIndex = block.children.findIndex((node, indx) => {
            return childKey ? node._key === childKey : indx === patch.path[0];
        });
        const parsed = dmp$1.patch_fromText(patch.value)[0];
        if (parsed) {
            const slatePath = [blockIndex, childIndex];
            const distance = parsed.length2 - parsed.length1;
            const point = {
                path: slatePath,
                offset: distance >= 0
                    ? (parsed.start1 || 0) + parsed.diffs[0][1].length
                    : (parsed.start2 || 0) + parsed.length2 - distance,
            };
            debug$f(`DiffMatchPatch (${distance < 0 ? 'remove' : 'insert'}) at ${JSON.stringify(slatePath)}}: `, JSON.stringify(point, null, 2), JSON.stringify(parsed, null, 2));
            debugState(editor, 'before');
            let text;
            if (parsed.diffs[1]) {
                text = parsed.diffs[1][1];
            }
            else {
                text = parsed.diffs[0][1];
            }
            debug$f(`Text: '${text}'`);
            if (distance >= 0) {
                editor.apply({
                    type: 'insert_text',
                    path: point.path,
                    offset: point.offset,
                    text,
                });
            }
            else {
                editor.apply({
                    type: 'remove_text',
                    path: point.path,
                    offset: point.offset - text.length,
                    text,
                });
            }
            debugState(editor, 'after');
        }
        return true;
    }
    function insertPatch(editor, patch) {
        // Insert blocks
        if (patch.path.length === 1) {
            const { items, position } = patch;
            const blocksToInsert = toSlateValue(items, { portableTextFeatures }, KEY_TO_SLATE_ELEMENT.get(editor));
            const posKey = findLastKey(patch.path);
            const index = editor.children.findIndex((node, indx) => {
                return posKey ? node._key === posKey : indx === patch.path[0];
            });
            const normalizedIdx = position === 'after' ? index + 1 : index;
            debug$f(`Inserting blocks at path [${normalizedIdx}]`);
            debugState(editor, 'before');
            const isEmpty = isEqualToEmptyEditor(editor.children, portableTextFeatures);
            debug$f('isEmpty', isEmpty);
            if (isEmpty) {
                debug$f('Removing placeholder block');
                Transforms.removeNodes(editor, { at: [0] });
            }
            Transforms.insertNodes(editor, blocksToInsert, { at: [normalizedIdx] });
            if (isEmpty) {
                Transforms.select(editor, {
                    focus: { path: [0, 0], offset: 0 },
                    anchor: { path: [0, 0], offset: 0 },
                });
            }
            debugState(editor, 'after');
            return true;
        }
        const { items, position } = patch;
        const posKey = findLastKey(patch.path);
        const blockIndex = editor.children.findIndex((node, indx) => {
            return posKey ? node._key === posKey : indx === patch.path[0];
        });
        // Insert children
        const block = editor.children && blockIndex > -1 ? editor.children[blockIndex] : undefined;
        const childIndex = block &&
            block.children.findIndex((node, indx) => {
                return isKeyedSegment(patch.path[2])
                    ? node._key === patch.path[2]._key
                    : indx === patch.path[2];
            });
        const childrenToInsert = block &&
            toSlateValue([{ ...block, children: items }], { portableTextFeatures }, KEY_TO_SLATE_ELEMENT.get(editor));
        const normalizedIdx = position === 'after' ? childIndex + 1 : childIndex;
        const targetPath = [blockIndex, normalizedIdx];
        debug$f(`Inserting children at path ${targetPath}`);
        debugState(editor, 'before');
        if (childrenToInsert && Element$1.isElement(childrenToInsert[0])) {
            Transforms.insertNodes(editor, childrenToInsert[0].children, { at: targetPath });
        }
        debugState(editor, 'after');
        return true;
    }
    function setPatch(editor, patch) {
        const blockIndex = editor.children.findIndex((node, indx) => {
            return isKeyedSegment(patch.path[0])
                ? node._key === patch.path[0]._key
                : indx === patch.path[0];
        });
        debug$f('blockIndex', blockIndex);
        const block = blockIndex > -1 ? editor.children[blockIndex] : undefined;
        const childIndex = block &&
            block.children.findIndex((node, indx) => {
                return isKeyedSegment(patch.path[2])
                    ? node._key === patch.path[2]._key
                    : indx === patch.path[2];
            });
        let value = patch.value;
        const targetPath = childIndex > -1 ? [blockIndex, childIndex] : [blockIndex];
        if (typeof patch.path[3] === 'string') {
            value = {};
            value[patch.path[3]] = patch.value;
        }
        const isTextBlock = portableTextFeatures.types.block.name === block?._type;
        if (isTextBlock) {
            debug$f(`Setting nodes at ${JSON.stringify(patch.path)} - ${JSON.stringify(targetPath)}`);
            debug$f('Value to set', JSON.stringify(value, null, 2));
            debugState(editor, 'before');
            if (targetPath.length === 1) {
                debug$f('Setting block property');
                const { children, ...nextRest } = value;
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { children: prevChildren, ...prevRest } = block || { children: undefined };
                editor.apply({
                    type: 'set_node',
                    path: targetPath,
                    properties: { ...prevRest },
                    newProperties: nextRest,
                });
                if (block && Element$1.isElement(block)) {
                    block.children.forEach((c, cIndex) => {
                        editor.apply({
                            type: 'remove_node',
                            path: targetPath.concat(cIndex),
                            node: c,
                        });
                    });
                }
                if (Array.isArray(children)) {
                    children.forEach((c, cIndex) => {
                        editor.apply({
                            type: 'insert_node',
                            path: targetPath.concat(cIndex),
                            node: c,
                        });
                    });
                }
            }
            else if (typeof value.text === 'string') {
                debug$f('Setting text property');
                const prevSel = editor.selection && { ...editor.selection };
                editor.apply({
                    type: 'remove_text',
                    path: targetPath,
                    offset: 0,
                    text: block?.children[childIndex].text,
                });
                editor.apply({
                    type: 'insert_text',
                    path: targetPath,
                    offset: 0,
                    text: value.text,
                });
                const onSamePath = prevSel && isEqual(prevSel.focus.path, targetPath);
                // const onSameText =
                //   editor.selection &&
                //   editor.selection.focus.path[0] === blockIndex &&
                //   patch.path[3] === 'text'
                if (onSamePath) {
                    debug$f('On same path, restoring previous selection');
                    Transforms.select(editor, prevSel);
                }
                //  else if (onSameText) {
                //   debug('Adjusting for inserted text')
                //   const newOffset = typeof patch.value === 'string' ? patch.value.length : 0
                //   const point = {path: targetPath, offset: newOffset}
                //   Transforms.select(editor, {focus: point, anchor: point})
                // }
            }
            else {
                debug$f('Setting non-text property');
                editor.apply({
                    type: 'set_node',
                    path: targetPath,
                    properties: {},
                    newProperties: value,
                });
            }
            debugState(editor, 'after');
            return true;
        }
        // If this is a object block, just set the whole block
        else if (!isTextBlock && block) {
            const newVal = applyAll([block.value], [patch])[0];
            Transforms.setNodes(editor, { ...block, value: newVal }, { at: [blockIndex] });
            return true;
        }
        return false;
    }
    function unsetPatch(editor, patch, previousPatch) {
        // Value
        if (patch.path.length === 0) {
            debug$f(`Removing everything`);
            debugState(editor, 'before');
            editor.children.forEach((c, i) => {
                Transforms.removeNodes(editor, { at: [i] });
            });
            Transforms.insertNodes(editor, editor.createPlaceholderBlock(), { at: [0] });
            Transforms.select(editor, {
                focus: { path: [0, 0], offset: 0 },
                anchor: { path: [0, 0], offset: 0 },
            });
            debugState(editor, 'after');
            return true;
        }
        // Single blocks
        if (patch.path.length === 1) {
            const lastKey = findLastKey(patch.path);
            const index = editor.children.findIndex((node, indx) => lastKey ? node._key === lastKey : indx === patch.path[0]);
            if (index > -1) {
                debug$f(`Removing block at path [${index}]`);
                debugState(editor, 'before');
                if (editor.selection && editor.selection.focus.path[0] === index) {
                    const point = { path: [editor.selection.focus.path[0] - 1 || 0], offset: 0 };
                    Transforms.select(editor, { focus: point, anchor: point });
                    Transforms.move(editor, { unit: 'line' });
                }
                Transforms.removeNodes(editor, { at: [index] });
                debugState(editor, 'after');
                return true;
            }
        }
        const blockIndex = editor.children.findIndex((node, indx) => {
            return isKeyedSegment(patch.path[0])
                ? node._key === patch.path[0]._key
                : indx === patch.path[0];
        });
        const block = blockIndex > -1 ? editor.children[blockIndex] : undefined;
        const isTextBlock = portableTextFeatures.types.block.name === block?._type;
        // Unset on text block children
        if (isTextBlock && patch.path[1] === 'children' && patch.path.length === 3) {
            const childIndex = block &&
                block.children.findIndex((node, indx) => {
                    return isKeyedSegment(patch.path[2])
                        ? node._key === patch.path[2]._key
                        : indx === patch.path[2];
                });
            const targetPath = [blockIndex, childIndex];
            const prevSel = editor.selection && { ...editor.selection };
            const onSamePath = isEqual(editor.selection?.focus.path, targetPath);
            debug$f(`Removing child at path ${JSON.stringify(targetPath)}`);
            debugState(editor, 'before');
            if (prevSel && onSamePath && editor.isTextBlock(block)) {
                const needToAdjust = childIndex >= prevSel.focus.path[1];
                if (needToAdjust) {
                    const isMergeUnset = previousPatch?.type === 'set' &&
                        previousPatch.path[3] === 'text' &&
                        typeof previousPatch.value === 'string' &&
                        isEqual(previousPatch.value.slice(-block.children[childIndex].text.length), block.children[childIndex].text);
                    if (isMergeUnset) {
                        debug$f('Adjusting selection for merging of nodes');
                        prevSel.focus = { ...prevSel.focus };
                        prevSel.focus.path = [targetPath[0], targetPath[1] - 1];
                        prevSel.focus.offset =
                            block.children[childIndex - 1].text.length -
                                block.children[childIndex].text.length +
                                prevSel.focus.offset;
                        prevSel.anchor = prevSel.focus;
                        Transforms.select(editor, prevSel);
                        Transforms.removeNodes(editor, { at: [blockIndex, childIndex] });
                        debugState(editor, 'after');
                        return true;
                    }
                }
            }
            Transforms.removeNodes(editor, { at: [blockIndex, childIndex] });
            debugState(editor, 'after');
            return true;
        }
        // Inside block objects - patch block and set it again
        if (!isTextBlock && block) {
            const newBlock = applyAll([block], [patch])[0];
            Transforms.setNodes(editor, newBlock, { at: [blockIndex] });
            return true;
        }
        return false;
    }
    let previousPatch;
    return function (editor, patch) {
        let changed = false;
        debug$f('\n\nNEW PATCH =============================================================');
        debug$f(JSON.stringify(patch, null, 2));
        try {
            switch (patch.type) {
                case 'insert':
                    changed = insertPatch(editor, patch);
                    break;
                case 'unset':
                    changed = unsetPatch(editor, patch, previousPatch);
                    break;
                case 'set':
                    changed = setPatch(editor, patch);
                    break;
                case 'diffMatchPatch':
                    changed = diffMatchPatch(editor, patch);
                    break;
                default:
                    debug$f('Unhandled patch', patch.type);
            }
        }
        catch (err) {
            console.error(err);
        }
        previousPatch = patch;
        return changed;
    };
}
function isKeyedSegment(segment) {
    return typeof segment === 'object' && '_key' in segment;
}
// Helper function to find the last part of a patch path that has a known key
function findLastKey(path) {
    let key = null;
    path
        .concat('')
        .reverse()
        .forEach((part) => {
        if (isKeyedSegment(part)) {
            key = part._key;
        }
    });
    return key;
}
function debugState(editor, stateName) {
    debug$f(`Children ${stateName}:`, JSON.stringify(editor.children, null, 2));
    debug$f(`Selection ${stateName}: `, JSON.stringify(editor.selection, null, 2));
}

/* eslint-disable complexity */
const debug$e = debugWithName('plugin:withUndoRedo');
// eslint-disable-next-line new-cap
const dmp = new DMP.diff_match_patch();
const SAVING = new WeakMap();
const MERGING = new WeakMap();
const UNDO_STEP_LIMIT = 300;
const isMerging = (editor) => {
    return MERGING.get(editor);
};
const isSaving = (editor) => {
    if (!isPatching(editor)) {
        return false;
    }
    return SAVING.get(editor);
};
function createWithUndoRedo(incomingPatches$) {
    // TODO: unsubscribe to this
    // Subscribe to incoming patches
    let cleanupFn = () => undefined;
    const incomingPatches = [];
    if (incomingPatches$) {
        debug$e('Subscribing to patches');
        const sub = incomingPatches$.subscribe(({ patches }) => {
            patches.forEach((patch) => {
                if (patch.origin !== 'local') {
                    incomingPatches.push({ patch: patch, time: new Date() });
                }
            });
        });
        cleanupFn = () => {
            debug$e('Unsubscribing to patches');
            sub.unsubscribe();
        };
    }
    return [
        (editor) => {
            editor.history = { undos: [], redos: [] };
            const { apply } = editor;
            // Apply function for merging and saving local history inspired from 'slate-history' by Ian Storm Taylor
            editor.apply = (op) => {
                if (editor.readOnly) {
                    apply(op);
                    return;
                }
                const { operations, history } = editor;
                const { undos } = history;
                const step = undos[undos.length - 1];
                const lastOp = step && step.operations && step.operations[step.operations.length - 1];
                const overwrite = shouldOverwrite(op, lastOp);
                let save = isSaving(editor);
                let merge = isMerging(editor);
                if (save == null) {
                    save = shouldSave(op);
                }
                if (save) {
                    if (merge == null) {
                        if (step == null) {
                            merge = false;
                            // eslint-disable-next-line no-negated-condition
                        }
                        else if (operations.length !== 0) {
                            merge = true;
                        }
                        else {
                            merge = shouldMerge(op, lastOp) || overwrite;
                        }
                    }
                    if (step && merge) {
                        if (overwrite) {
                            step.operations.pop();
                        }
                        step.operations.push(op);
                    }
                    else {
                        const stp = {
                            operations: [
                                ...(editor.selection === null ? [] : [createSelectOperation(editor)]),
                                op,
                            ],
                            timestamp: new Date(),
                        };
                        undos.push(stp);
                        debug$e('Created new undo step', step);
                    }
                    while (undos.length > UNDO_STEP_LIMIT) {
                        undos.shift();
                    }
                    if (shouldClear(op)) {
                        history.redos = [];
                    }
                }
                apply(op);
            };
            editor.undo = () => {
                if (editor.readOnly) {
                    return;
                }
                const { undos } = editor.history;
                if (undos.length > 0) {
                    const step = undos[undos.length - 1];
                    debug$e('Undoing', step);
                    if (step.operations.length > 0) {
                        const otherPatches = [...incomingPatches.filter((item) => item.time >= step.timestamp)];
                        let transformedOperations = step.operations;
                        otherPatches.forEach((item) => {
                            transformedOperations = flatten$1(transformedOperations.map((op) => transformOperation(editor, item.patch, op)));
                        });
                        withoutSaving(editor, () => {
                            Editor.withoutNormalizing(editor, () => {
                                transformedOperations
                                    .map(Operation.inverse)
                                    .reverse()
                                    .forEach((op) => {
                                    // Try this as the document could be changed from the outside,
                                    // and sometimes we can't perform the undo operation on the current doc.
                                    try {
                                        editor.apply(op);
                                    }
                                    catch (err) {
                                        debug$e('Could not perform undo step', err);
                                        editor.history.redos.push(step);
                                        editor.history.undos.pop();
                                    }
                                });
                            });
                        });
                    }
                    editor.history.redos.push(step);
                    editor.history.undos.pop();
                    editor.onChange();
                }
            };
            editor.redo = () => {
                if (editor.readOnly) {
                    return;
                }
                const { redos } = editor.history;
                if (redos.length > 0) {
                    const step = redos[redos.length - 1];
                    debug$e('Redoing', step);
                    if (step.operations.length > 0) {
                        const otherPatches = incomingPatches.filter((item) => item.time > step.timestamp);
                        let transformedOperations = step.operations;
                        otherPatches.forEach((item) => {
                            transformedOperations = flatten$1(transformedOperations.map((op) => transformOperation(editor, item.patch, op)));
                        });
                        withoutSaving(editor, () => {
                            Editor.withoutNormalizing(editor, () => {
                                transformedOperations.forEach((op) => {
                                    try {
                                        editor.apply(op);
                                    }
                                    catch (err) {
                                        debug$e('Could not perform redo step', err);
                                        editor.history.undos.push(step);
                                        editor.history.redos.pop();
                                    }
                                });
                            });
                        });
                    }
                    editor.history.undos.push(step);
                    editor.history.redos.pop();
                    editor.onChange();
                }
            };
            // Plugin return
            return editor;
        },
        cleanupFn,
    ];
}
// This will adjust the user selection according to patcehes done by others.
// TODO: complete all necessary steps of the algorithm and write tests.
// eslint-disable-next-line max-statements
function transformOperation(editor, patch, operation) {
    // debug(`Rebasing selection for patch ${patch.type} against operation ${operation.type}`)
    let transformedOperation = { ...operation };
    if (patch.type === 'insert' && patch.path.length === 1) {
        return [adjustBlockPath(editor, patch, operation, patch.items.length)];
    }
    if (patch.type === 'unset' && patch.path.length === 1) {
        return [adjustBlockPath(editor, patch, operation, -1)];
    }
    // Someone reset the whole value
    if (patch.type === 'unset' && patch.path.length === 0) {
        debug$e(`Adjusting selection for unset everything patch and ${operation.type} operation`);
        return [operation];
    }
    if (patch.type === 'diffMatchPatch') {
        const blockIndex = editor.children.findIndex((blk) => isEqual({ _key: blk._key }, patch.path[0]));
        const block = editor.children[blockIndex];
        if (Element$1.isElement(block) && Array.isArray(block.children)) {
            const childIndex = block.children.findIndex((child) => isEqual({ _key: child._key }, patch.path[2]));
            const parsed = dmp.patch_fromText(patch.value)[0];
            if (!parsed) {
                debug$e('Could not parse diffMatchPatch', patch);
                return [operation];
            }
            const distance = parsed.length2 - parsed.length1;
            const patchIsRemovingText = parsed.diffs.some((diff) => diff[0] === -1);
            if (operation.type === 'split_node' && operation.path.length > 1) {
                const splitOperation = transformedOperation;
                if (patchIsRemovingText) {
                    splitOperation.position -= distance;
                }
                else {
                    splitOperation.position += distance;
                }
                return [splitOperation];
            }
            if ((operation.type === 'insert_text' || operation.type === 'remove_text') &&
                Path.isPath(operation.path) &&
                operation.path[0] !== undefined &&
                operation.path[0] === blockIndex &&
                operation.path[1] === childIndex) {
                if (operation.type === 'insert_text') {
                    let insertOffset = 0;
                    for (const diff of parsed.diffs) {
                        if (diff[0] === 0) {
                            insertOffset = diff[1].length;
                        }
                        if (diff[0] === 1) {
                            break;
                        }
                    }
                    if (parsed.start1 !== null && insertOffset + parsed.start1 <= operation.offset) {
                        const insertTextOperation = transformedOperation;
                        insertTextOperation.offset += distance;
                        transformedOperation = insertTextOperation;
                    }
                    // TODO: deal with overlapping ranges
                    return [transformedOperation];
                }
                if (operation.type === 'remove_text') {
                    let insertOffset = 0;
                    for (const diff of parsed.diffs) {
                        if (diff[0] === 0) {
                            insertOffset = diff[1].length;
                        }
                        if (diff[0] === -1) {
                            break;
                        }
                    }
                    if (parsed.start1 !== null && insertOffset + parsed.start1 <= operation.offset) {
                        const removeTextOperation = transformedOperation;
                        removeTextOperation.offset -= distance;
                        transformedOperation = removeTextOperation;
                    }
                    return [transformedOperation];
                }
            }
            // // Selection operations with diffPatchMatch
            // if (operation.type === 'set_selection') {
            //   const newProperties = transformedOperation.newProperties
            //   if (newProperties && patchIsRemovingText) {
            //     newProperties.offset = newProperties.offset - distance
            //   } else if (newProperties) {
            //     newProperties.offset = newProperties.offset + distance
            //   }
            //   return [newProperties ? {...transformedOperation, newProperties} : transformedOperation]
            // }
        }
        // TODO: transform this?
        // if (operation.type === 'set_selection' && patch.type !== 'diffMatchPatch') {
        //   console.log('set_selection other', JSON.stringify(patch))
        // }
    }
    return [operation];
}
function adjustBlockPath(editor, patch, operation, level) {
    const myIndex = editor.children.findIndex((blk) => isEqual({ _key: blk._key }, patch.path[0]));
    if (myIndex >= 0 &&
        operation.type !== 'set_selection' &&
        Array.isArray(operation.path) &&
        operation.path[0] !== undefined &&
        operation.path[0] >= myIndex + level) {
        const transformedOperation = { ...operation };
        const newPath = [operation.path[0] + level, ...operation.path.slice(1)];
        debug$e(`Adjusting ${operation.type} for block ${patch.type}`, operation.path, newPath);
        transformedOperation.path = newPath;
        return transformedOperation;
    }
    return operation;
}
// Helper functions for editor.apply above
const shouldMerge = (op, prev) => {
    if (op.type === 'set_selection') {
        return true;
    }
    // Text input
    if (prev &&
        op.type === 'insert_text' &&
        prev.type === 'insert_text' &&
        op.offset === prev.offset + prev.text.length &&
        Path.equals(op.path, prev.path) &&
        op.text !== ' ' // Tokenize between words
    ) {
        return true;
    }
    // Text deletion
    if (prev &&
        op.type === 'remove_text' &&
        prev.type === 'remove_text' &&
        op.offset + op.text.length === prev.offset &&
        Path.equals(op.path, prev.path)) {
        return true;
    }
    // Don't merge
    return false;
};
const shouldSave = (op, prev) => {
    if (op.type === 'set_selection' && op.newProperties === null) {
        return false;
    }
    return true;
};
const shouldOverwrite = (op, prev) => {
    if (prev && op.type === 'set_selection' && prev.type === 'set_selection') {
        return true;
    }
    return false;
};
const shouldClear = (op) => {
    if (op.type === 'set_selection') {
        return false;
    }
    return true;
};
function withoutSaving(editor, fn) {
    const prev = isSaving(editor);
    SAVING.set(editor, false);
    fn();
    SAVING.set(editor, prev);
}
function createSelectOperation(editor) {
    return {
        type: 'set_selection',
        properties: { ...editor.selection },
        newProperties: { ...editor.selection },
    };
}

const debug$d = debugWithName('plugin:withPatches');
function createWithPatches({ insertNodePatch, insertTextPatch, mergeNodePatch, moveNodePatch, removeNodePatch, removeTextPatch, setNodePatch, splitNodePatch, }, change$, portableTextFeatures, syncValue, incomingPatches$) {
    // The previous editor children are needed to figure out the _key of deleted nodes
    // The editor.children would no longer contain that information if the node is already deleted.
    let previousChildren;
    const patchToOperations = createPatchToOperations(portableTextFeatures);
    let patchSubscription;
    const cleanupFn = () => {
        if (patchSubscription) {
            debug$d('Unsubscribing to patches');
            patchSubscription.unsubscribe();
        }
    };
    return [
        function withPatches(editor) {
            PATCHING.set(editor, true);
            previousChildren = [...editor.children];
            // Sync the with props.value in PortableTextEditor after we have processed batches of incoming patches.
            // This is only for consistency checking against the props.value, so it can be debounced without problems.
            const syncValueAfterIncomingPatches = debounce(() => syncValue(), 100, {
                trailing: true,
                leading: false,
            });
            // Subscribe and deal with incoming patches
            if (incomingPatches$) {
                debug$d('Subscribing to patches');
                patchSubscription = incomingPatches$.subscribe(({ patches, snapshot }) => {
                    const remotePatches = patches.filter((p) => p.origin !== 'local');
                    if (remotePatches.length !== 0) {
                        Editor.withoutNormalizing(editor, () => {
                            remotePatches.forEach((patch) => {
                                debug$d(`Handling remote patch ${JSON.stringify(patch)}`);
                                withoutPatching(editor, () => {
                                    withoutSaving(editor, () => {
                                        withPreserveKeys(editor, () => {
                                            try {
                                                patchToOperations(editor, patch, patches, snapshot);
                                            }
                                            catch (err) {
                                                debug$d('Got error trying to create operations from patch');
                                                console.error(err);
                                            }
                                        });
                                    });
                                });
                            });
                        });
                    }
                    syncValueAfterIncomingPatches();
                });
            }
            const { apply } = editor;
            editor.apply = (operation) => {
                if (editor.readOnly) {
                    editor.apply(operation);
                    return editor;
                }
                let patches = [];
                // Update previous children here before we apply
                previousChildren = editor.children;
                const editorWasEmpty = isEqualToEmptyEditor(previousChildren, portableTextFeatures);
                // Apply the operation
                apply(operation);
                const editorIsEmpty = isEqualToEmptyEditor(editor.children, portableTextFeatures);
                if (!isPatching(editor)) {
                    debug$d(`Editor is not producing patch for operation ${operation.type}`, operation);
                    return editor;
                }
                if (editorWasEmpty && operation.type !== 'set_selection') {
                    patches.push(setIfMissing([], []));
                    patches.push(insert$1([
                        fromSlateValue(previousChildren.length === 0
                            ? [editor.createPlaceholderBlock()]
                            : previousChildren, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0],
                    ], 'before', [0]));
                }
                switch (operation.type) {
                    case 'insert_text':
                        patches = [...patches, ...insertTextPatch(editor, operation, previousChildren)];
                        break;
                    case 'remove_text':
                        patches = [...patches, ...removeTextPatch(editor, operation, previousChildren)];
                        break;
                    case 'remove_node':
                        patches = [...patches, ...removeNodePatch(editor, operation, previousChildren)];
                        break;
                    case 'split_node':
                        patches = [...patches, ...splitNodePatch(editor, operation, previousChildren)];
                        break;
                    case 'insert_node':
                        patches = [...patches, ...insertNodePatch(editor, operation, previousChildren)];
                        break;
                    case 'set_node':
                        patches = [...patches, ...setNodePatch(editor, operation, previousChildren)];
                        break;
                    case 'merge_node':
                        patches = [...patches, ...mergeNodePatch(editor, operation, previousChildren)];
                        break;
                    case 'move_node':
                        patches = [...patches, ...moveNodePatch(editor, operation, previousChildren)];
                        break;
                    // Do nothing
                }
                // Unset the value if the operation made the editor empty
                if (editorIsEmpty && ['remove_text', 'remove_node'].includes(operation.type)) {
                    patches = [...patches, unset([])];
                    change$.next({
                        type: 'unset',
                        previousValue: fromSlateValue(previousChildren, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),
                    });
                }
                // Emit all patches
                if (patches.length > 0) {
                    patches.forEach((patch) => {
                        change$.next({
                            type: 'patch',
                            patch: { ...patch, origin: 'local' },
                        });
                    });
                }
                return editor;
            };
            return editor;
        },
        cleanupFn,
    ];
}

function createKeyedPath(point, value, portableTextFeatures) {
    const blockPath = [point.path[0]];
    if (!value) {
        return null;
    }
    const block = value[blockPath[0]];
    if (!block) {
        return null;
    }
    const keyedBlockPath = [{ _key: block._key }];
    if (block._type !== portableTextFeatures.types.block.name) {
        return keyedBlockPath;
    }
    let keyedChildPath;
    const childPath = point.path.slice(0, 2);
    const child = block.children[childPath[1]];
    if (child) {
        keyedChildPath = ['children', { _key: child._key }];
    }
    return (keyedChildPath ? [...keyedBlockPath, ...keyedChildPath] : keyedBlockPath);
}
function createArrayedPath(point, editor) {
    if (!editor) {
        return [];
    }
    const [block, blockPath] = Array.from(Editor.nodes(editor, {
        at: [],
        match: (n) => isKeySegment(point.path[0]) && n._key === point.path[0]._key,
    }))[0] || [undefined, undefined];
    if (!block || !Element$1.isElement(block)) {
        return [];
    }
    if (editor.isVoid(block)) {
        return blockPath;
    }
    const childPath = [point.path[2]];
    const childIndex = block.children.findIndex((child) => isEqual([{ _key: child._key }], childPath));
    if (childIndex >= 0 && block.children[childIndex]) {
        const child = block.children[childIndex];
        if (Element$1.isElement(child) && editor.isVoid(child)) {
            return blockPath.concat(childIndex).concat(0);
        }
        return blockPath.concat(childIndex);
    }
    return blockPath;
}

function toPortableTextRange(value, range, portableTextFeatures) {
    if (!range) {
        return null;
    }
    let anchor = null;
    let focus = null;
    const anchorPath = range.anchor && createKeyedPath(range.anchor, value, portableTextFeatures);
    if (anchorPath && range.anchor) {
        anchor = {
            path: anchorPath,
            offset: range.anchor.offset,
        };
    }
    const focusPath = range.focus && createKeyedPath(range.focus, value, portableTextFeatures);
    if (focusPath && range.focus) {
        focus = {
            path: focusPath,
            offset: range.focus.offset,
        };
    }
    return anchor && focus ? { anchor, focus } : null;
}
function toSlateRange(selection, editor) {
    if (!selection || !editor) {
        return null;
    }
    const anchor = {
        path: createArrayedPath(selection.anchor, editor),
        offset: selection.anchor.offset,
    };
    const focus = {
        path: createArrayedPath(selection.focus, editor),
        offset: selection.focus.offset,
    };
    const range = anchor && focus ? { anchor, focus } : null;
    return range;
}

const debug$c = debugWithName('plugin:withPortableTextBlockStyle');
function createWithPortableTextBlockStyle(portableTextFeatures, change$) {
    const defaultStyle = portableTextFeatures.styles[0].value;
    return function withPortableTextBlockStyle(editor) {
        // Extend Slate's default normalization to reset split node to normal style
        // if there is no text at the right end of the split.
        const { normalizeNode } = editor;
        editor.normalizeNode = (nodeEntry) => {
            normalizeNode(nodeEntry);
            const [, path] = nodeEntry;
            for (const op of editor.operations) {
                if (op.type === 'split_node' &&
                    op.path.length === 1 &&
                    editor.isTextBlock(op.properties) &&
                    op.properties.style !== defaultStyle &&
                    op.path[0] === path[0] &&
                    !Path.equals(path, op.path)) {
                    const [child] = Editor.node(editor, [op.path[0] + 1, 0]);
                    if (Text.isText(child) && child.text === '') {
                        debug$c(`Normalizing split node to ${defaultStyle} style`, op);
                        Transforms.setNodes(editor, { style: defaultStyle }, { at: [op.path[0] + 1], voids: false });
                        break;
                    }
                }
            }
        };
        editor.pteHasBlockStyle = (style) => {
            if (!editor.selection) {
                return false;
            }
            const selectedBlocks = [
                ...Editor.nodes(editor, {
                    at: editor.selection,
                    match: (node) => editor.isTextBlock(node) && node.style === style,
                }),
            ];
            if (selectedBlocks.length > 0) {
                return true;
            }
            return false;
        };
        editor.pteToggleBlockStyle = (blockStyle) => {
            if (!editor.selection) {
                return;
            }
            const selectedBlocks = [
                ...Editor.nodes(editor, {
                    at: editor.selection,
                    match: (node) => Element$1.isElement(node) && node._type === portableTextFeatures.types.block.name,
                }),
            ];
            selectedBlocks.forEach(([node, path]) => {
                if (editor.isTextBlock(node) && node.style === blockStyle) {
                    debug$c(`Unsetting block style '${blockStyle}'`);
                    Transforms.setNodes(editor, { ...node, style: defaultStyle }, {
                        at: path,
                    });
                }
                else {
                    if (blockStyle) {
                        debug$c(`Setting style '${blockStyle}'`);
                    }
                    else {
                        debug$c('Setting default style', defaultStyle);
                    }
                    Transforms.setNodes(editor, {
                        ...node,
                        style: blockStyle || defaultStyle,
                    }, { at: path });
                }
            });
            // Emit a new selection here (though it might be the same).
            // Toolbars and similar on the outside may rely on selection changes to update themselves.
            change$.next({
                type: 'selection',
                selection: toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name), editor.selection, portableTextFeatures),
            });
            editor.onChange();
        };
        return editor;
    };
}

const debug$b = debugWithName('plugin:withPortableTextLists');
const MAX_LIST_LEVEL = 10;
function createWithPortableTextLists(portableTextFeatures) {
    return function withPortableTextLists(editor) {
        editor.pteToggleListItem = (listItemStyle) => {
            const isActive = editor.pteHasListStyle(listItemStyle);
            if (isActive) {
                debug$b(`Remove list item '${listItemStyle}'`);
                editor.pteUnsetListItem(listItemStyle);
            }
            else {
                debug$b(`Add list item '${listItemStyle}'`);
                editor.pteSetListItem(listItemStyle);
            }
        };
        editor.pteUnsetListItem = (listItemStyle) => {
            if (!editor.selection) {
                return;
            }
            const selectedBlocks = [
                ...Editor.nodes(editor, {
                    at: editor.selection,
                    match: (node) => Element$1.isElement(node) && node._type === portableTextFeatures.types.block.name,
                }),
            ];
            selectedBlocks.forEach(([node, path]) => {
                if (editor.isListBlock(node)) {
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    const { listItem, level, ...rest } = node;
                    const newNode = {
                        ...rest,
                        listItem: undefined,
                        level: undefined,
                    };
                    debug$b(`Unsetting list '${listItemStyle}'`);
                    Transforms.setNodes(editor, newNode, { at: path });
                }
            });
        };
        editor.pteSetListItem = (listItemStyle) => {
            if (!editor.selection) {
                return;
            }
            const selectedBlocks = [
                ...Editor.nodes(editor, {
                    at: editor.selection,
                    match: (node) => editor.isTextBlock(node),
                }),
            ];
            selectedBlocks.forEach(([node, path]) => {
                debug$b(`Setting list '${listItemStyle}'`);
                Transforms.setNodes(editor, {
                    ...node,
                    level: 1,
                    listItem: listItemStyle ||
                        (portableTextFeatures.lists[0] && portableTextFeatures.lists[0].value),
                }, { at: path });
            });
        };
        editor.pteEndList = () => {
            if (!editor.selection) {
                return false;
            }
            const selectedBlocks = [
                ...Editor.nodes(editor, {
                    at: editor.selection,
                    match: (node) => Element$1.isElement(node) &&
                        editor.isListBlock(node) &&
                        node.children.length === 1 &&
                        Text.isText(node.children[0]) &&
                        node.children[0].text === '',
                }),
            ];
            if (selectedBlocks.length === 0) {
                return false;
            }
            selectedBlocks.forEach(([node, path]) => {
                if (Element$1.isElement(node)) {
                    debug$b('Unset list');
                    Transforms.setNodes(editor, 
                    // @todo: fix typing
                    {
                        ...node,
                        level: undefined,
                        listItem: undefined,
                    }, { at: path });
                }
            });
            return true; // Note: we are exiting the plugin chain by not returning editor (or hotkey plugin 'enter' will fire)
        };
        editor.pteIncrementBlockLevels = (reverse) => {
            if (!editor.selection) {
                return false;
            }
            const selectedBlocks = [
                ...Editor.nodes(editor, {
                    at: editor.selection,
                    match: (node) => !!editor.isListBlock(node),
                }),
            ];
            if (selectedBlocks.length === 0) {
                return false;
            }
            selectedBlocks.forEach(([node, path]) => {
                if (editor.isListBlock(node)) {
                    let level = node.level || 1;
                    if (reverse) {
                        level--;
                        debug$b('Decrementing list level', Math.min(MAX_LIST_LEVEL, Math.max(1, level)));
                    }
                    else {
                        level++;
                        debug$b('Incrementing list level', Math.min(MAX_LIST_LEVEL, Math.max(1, level)));
                    }
                    Transforms.setNodes(editor, { level: Math.min(MAX_LIST_LEVEL, Math.max(1, level)) }, { at: path });
                }
            });
            return true;
        };
        editor.pteHasListStyle = (listStyle) => {
            if (!editor.selection) {
                return false;
            }
            const selectedBlocks = [
                ...Editor.nodes(editor, {
                    at: editor.selection,
                    match: (node) => editor.isListBlock(node) && node.listItem === listStyle,
                }),
            ];
            if (selectedBlocks.length > 0) {
                return true;
            }
            return false;
        };
        return editor;
    };
}

/* eslint-disable complexity */
const debug$a = debugWithName('plugin:withPortableTextMarkModel');
function createWithPortableTextMarkModel(portableTextFeatures, keyGenerator) {
    return function withPortableTextMarkModel(editor) {
        const { apply, normalizeNode } = editor;
        const decorators = portableTextFeatures.decorators.map((t) => t.value);
        // Extend Slate's default normalization. Merge spans with same set of .marks when doing merge_node operations, and clean up markDefs / marks
        editor.normalizeNode = (nodeEntry) => {
            normalizeNode(nodeEntry);
            if (editor.operations.some((op) => [
                'insert_node',
                'insert_text',
                'merge_node',
                'remove_node',
                'remove_text',
                'set_node',
            ].includes(op.type))) {
                mergeSpans(editor);
            }
            const [node, path] = nodeEntry;
            const isSpan = Text.isText(node) && node._type === portableTextFeatures.types.span.name;
            const isTextBlock = editor.isTextBlock(node);
            if (isSpan || isTextBlock) {
                if (!isTextBlock && !Array.isArray(node.marks)) {
                    debug$a('Adding .marks to span node');
                    Transforms.setNodes(editor, { marks: [] }, { at: path });
                    editor.onChange();
                }
                for (const op of editor.operations) {
                    // Make sure markDefs are copied over when merging two blocks.
                    if (op.type === 'merge_node' &&
                        op.path.length === 1 &&
                        'markDefs' in op.properties &&
                        op.properties._type === portableTextFeatures.types.block.name &&
                        Array.isArray(op.properties.markDefs) &&
                        op.properties.markDefs.length > 0 &&
                        op.path[0] - 1 >= 0) {
                        const [targetBlock, targetPath] = Editor.node(editor, [op.path[0] - 1]);
                        debug$a(`Copying markDefs over to merged block`, op);
                        if (editor.isTextBlock(targetBlock)) {
                            const oldDefs = (Array.isArray(targetBlock.markDefs) && targetBlock.markDefs) || [];
                            const newMarkDefs = uniq([...oldDefs, ...op.properties.markDefs]);
                            const isNormalized = isEqual(newMarkDefs, targetBlock.markDefs);
                            // eslint-disable-next-line max-depth
                            if (!isNormalized) {
                                Transforms.setNodes(editor, { markDefs: newMarkDefs }, { at: targetPath, voids: false });
                                editor.onChange();
                            }
                        }
                    }
                    // Make sure markDefs are copied over to new block when splitting a block.
                    if (op.type === 'split_node' &&
                        op.path.length === 1 &&
                        Element$1.isElementProps(op.properties) &&
                        op.properties._type === portableTextFeatures.types.block.name &&
                        'markDefs' in op.properties &&
                        Array.isArray(op.properties.markDefs) &&
                        op.properties.markDefs.length > 0 &&
                        op.path[0] + 1 < editor.children.length) {
                        const [targetBlock, targetPath] = Editor.node(editor, [op.path[0] + 1]);
                        debug$a(`Copying markDefs over to split block`, op);
                        if (editor.isTextBlock(targetBlock)) {
                            const oldDefs = (Array.isArray(targetBlock.markDefs) && targetBlock.markDefs) || [];
                            Transforms.setNodes(editor, { markDefs: uniq([...oldDefs, ...op.properties.markDefs]) }, { at: targetPath, voids: false });
                            editor.onChange();
                        }
                    }
                    // Make sure marks are reset, if a block is split at the end.
                    if (op.type === 'split_node' &&
                        op.path.length === 2 &&
                        op.properties._type === portableTextFeatures.types.span.name &&
                        'marks' in op.properties &&
                        Array.isArray(op.properties.marks) &&
                        op.properties.marks.length > 0 &&
                        op.path[0] + 1 < editor.children.length) {
                        const [child, childPath] = Editor.node(editor, [op.path[0] + 1, 0]);
                        if (Text.isText(child) &&
                            child.text === '' &&
                            Array.isArray(child.marks) &&
                            child.marks.length > 0) {
                            Transforms.setNodes(editor, { marks: [] }, { at: childPath, voids: false });
                            editor.onChange();
                        }
                    }
                    // Make sure markDefs are reset, if a block is split at start.
                    if (op.type === 'split_node' &&
                        op.path.length === 1 &&
                        op.properties._type === portableTextFeatures.types.block.name &&
                        'markDefs' in op.properties &&
                        Array.isArray(op.properties.markDefs) &&
                        op.properties.markDefs.length > 0) {
                        const [block, blockPath] = Editor.node(editor, [op.path[0]]);
                        if (editor.isTextBlock(block) &&
                            block.children.length === 1 &&
                            block.markDefs.length > 0 &&
                            Text.isText(block.children[0]) &&
                            block.children[0].text === '' &&
                            block.children[0].marks.length === 0) {
                            Transforms.setNodes(editor, { markDefs: [] }, { at: blockPath });
                            editor.onChange();
                        }
                    }
                }
                // Empty marks if text is empty
                if (isSpan && Array.isArray(node.marks) && node.marks.length > 0 && node.text === '') {
                    Transforms.setNodes(editor, { marks: [] }, { at: path, voids: false });
                    editor.onChange();
                }
            }
            // Check consistency of markDefs
            if (isTextBlock &&
                editor.operations.some((op) => ['split_node', 'remove_node', 'remove_text', 'merge_node'].includes(op.type))) {
                normalizeMarkDefs(editor);
            }
        };
        // Special hook before inserting text at the end of an annotation.
        editor.apply = (op) => {
            if (op.type === 'insert_text') {
                const { selection } = editor;
                if (selection &&
                    Range.isCollapsed(selection) &&
                    Editor.marks(editor)?.marks?.some((mark) => !decorators.includes(mark))) {
                    const [node] = Array.from(Editor.nodes(editor, {
                        mode: 'lowest',
                        at: selection.focus,
                        match: (n) => n._type === portableTextFeatures.types.span.name,
                        voids: false,
                    }))[0] || [undefined];
                    if (Text.isText(node) &&
                        node.text.length === selection.focus.offset &&
                        Array.isArray(node.marks) &&
                        node.marks.length > 0) {
                        apply(op);
                        Transforms.splitNodes(editor, {
                            match: Text.isText,
                            at: { ...selection.focus, offset: selection.focus.offset },
                        });
                        const marksWithoutAnnotationMarks = ({
                            ...(Editor.marks(editor) || {}),
                        }.marks || []).filter((mark) => decorators.includes(mark));
                        Transforms.setNodes(editor, { marks: marksWithoutAnnotationMarks }, { at: Path.next(selection.focus.path) });
                        return;
                    }
                }
            }
            apply(op);
        };
        // Override built in addMark function
        editor.addMark = (mark) => {
            if (editor.selection) {
                if (Range.isExpanded(editor.selection)) {
                    // Split if needed
                    Transforms.setNodes(editor, {}, { match: Text.isText, split: true });
                    // Use new selection
                    const splitTextNodes = [
                        ...Editor.nodes(editor, { at: editor.selection, match: Text.isText }),
                    ];
                    const shouldRemoveMark = flatten$1(splitTextNodes.map((item) => item[0]).map((node) => node.marks)).includes(mark);
                    if (shouldRemoveMark) {
                        editor.removeMark(mark);
                        return;
                    }
                    Editor.withoutNormalizing(editor, () => {
                        splitTextNodes.forEach(([node, path]) => {
                            const marks = [
                                ...(Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark),
                                mark,
                            ];
                            Transforms.setNodes(editor, { marks }, { at: path, match: Text.isText, split: true, hanging: true });
                        });
                    });
                    Editor.normalize(editor);
                }
                else {
                    const existingMarks = {
                        ...(Editor.marks(editor) || {}),
                    }.marks || [];
                    const marks = {
                        ...(Editor.marks(editor) || {}),
                        marks: [...existingMarks, mark],
                    };
                    editor.marks = marks;
                }
                editor.onChange();
            }
        };
        // Override built in removeMark function
        editor.removeMark = (mark) => {
            const { selection } = editor;
            if (selection) {
                if (Range.isExpanded(selection)) {
                    Editor.withoutNormalizing(editor, () => {
                        // Split if needed
                        Transforms.setNodes(editor, {}, { match: Text.isText, split: true });
                        if (editor.selection) {
                            const splitTextNodes = [
                                ...Editor.nodes(editor, { at: editor.selection, match: Text.isText }),
                            ];
                            splitTextNodes.forEach(([node, path]) => {
                                const block = editor.children[path[0]];
                                if (Element$1.isElement(block) && block.children.includes(node)) {
                                    Transforms.setNodes(editor, {
                                        marks: (Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark),
                                    }, { at: path });
                                }
                            });
                        }
                    });
                    Editor.normalize(editor);
                }
                else {
                    const existingMarks = {
                        ...(Editor.marks(editor) || {}),
                    }.marks || [];
                    const marks = {
                        ...(Editor.marks(editor) || {}),
                        marks: existingMarks.filter((eMark) => eMark !== mark),
                    };
                    editor.marks = marks;
                }
                editor.onChange();
            }
        };
        editor.pteIsMarkActive = (mark) => {
            if (!editor.selection || editor.selection.focus.path.length < 2) {
                return false;
            }
            let existingMarks = {
                ...(Editor.marks(editor) || {}),
            }.marks || [];
            if (Range.isExpanded(editor.selection)) {
                Array.from(Editor.nodes(editor, { match: Text.isText, at: editor.selection })).forEach((n) => {
                    const [node] = n;
                    existingMarks = uniq([...existingMarks, ...(node.marks || [])]);
                });
            }
            return existingMarks.includes(mark);
        };
        // Custom editor function to toggle a mark
        editor.pteToggleMark = (mark) => {
            const isActive = editor.pteIsMarkActive(mark);
            if (isActive) {
                debug$a(`Remove mark '${mark}'`);
                Editor.removeMark(editor, mark);
            }
            else {
                debug$a(`Add mark '${mark}'`);
                Editor.addMark(editor, mark, true);
            }
            editor.onChange();
        };
        return editor;
    };
    /**
     * Normalize re-marked spans in selection
     */
    function mergeSpans(editor) {
        const { selection } = editor;
        if (selection) {
            for (const [node, path] of Array.from(Editor.nodes(editor, {
                at: Editor.range(editor, [selection.anchor.path[0]], [selection.focus.path[0]]),
            })).reverse()) {
                const [parent] = path.length > 1 ? Editor.node(editor, Path.parent(path)) : [undefined];
                const nextPath = [path[0], path[1] + 1];
                if (Editor.isBlock(editor, parent)) {
                    const nextNode = parent.children[nextPath[1]];
                    if (Text.isText(node) && Text.isText(nextNode) && isEqual(nextNode.marks, node.marks)) {
                        debug$a('Merging spans');
                        Transforms.mergeNodes(editor, { at: nextPath, voids: true });
                        editor.onChange();
                    }
                }
            }
        }
    }
    /**
     * Normalize markDefs
     *
     */
    function normalizeMarkDefs(editor) {
        const { selection } = editor;
        if (selection) {
            const blocks = Editor.nodes(editor, {
                at: selection,
                match: (n) => n._type === portableTextFeatures.types.block.name,
            });
            for (const [block, path] of blocks) {
                if (editor.isTextBlock(block)) {
                    const newMarkDefs = block.markDefs.filter((def) => {
                        return block.children.find((child) => {
                            return (Text.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key));
                        });
                    });
                    if (!isEqual(newMarkDefs, block.markDefs)) {
                        debug$a('Removing markDef not in use');
                        Transforms.setNodes(editor, {
                            markDefs: newMarkDefs,
                        }, { at: path });
                        editor.onChange();
                    }
                }
            }
        }
    }
}

const debug$9 = debugWithName('plugin:withPortableTextSelections');
// This plugin will make sure that we emit a PT selection whenever the editor has changed.
function createWithPortableTextSelections(change$, portableTextFeatures) {
    return function withPortableTextSelections(editor) {
        const emitSelection = () => {
            let ptRange = null;
            if (editor.selection) {
                const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);
                if (existing) {
                    ptRange = existing;
                }
                else {
                    ptRange = toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures);
                    SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);
                }
            }
            if (ptRange) {
                debug$9(`Emitting selection ${JSON.stringify(ptRange)}`);
                change$.next({ type: 'selection', selection: ptRange });
            }
            else {
                change$.next({ type: 'selection', selection: null });
            }
        };
        const { onChange } = editor;
        editor.onChange = () => {
            const hasChanges = editor.operations.length > 0;
            onChange();
            if (hasChanges) {
                emitSelection();
            }
        };
        return editor;
    };
}

const debug$8 = debugWithName('plugin:withSchemaTypes');
/**
 * This plugin makes sure that shema types are recognized properly by Slate as blocks, voids, inlines
 *
 */
function createWithSchemaTypes(portableTextFeatures) {
    return function withSchemaTypes(editor) {
        editor.isTextBlock = (value) => {
            return (!editor.isVoid(value) &&
                'markDefs' in value &&
                'style' in value &&
                'children' in value &&
                '_type' in value &&
                portableTextFeatures.types.block.name === value._type);
        };
        editor.isTextSpan = (value) => {
            return (!editor.isVoid(value) &&
                'text' in value &&
                'marks' in value &&
                '_type' in value &&
                portableTextFeatures.types.span.name === value._type);
        };
        editor.isListBlock = (value) => {
            return Boolean(editor.isTextBlock(value) &&
                'listItem' in value &&
                'level' in value &&
                value.listItem &&
                Number.isInteger(value.level));
        };
        editor.isVoid = (element) => {
            return (portableTextFeatures.types.block.name !== element._type &&
                (portableTextFeatures.types.blockObjects.map((obj) => obj.name).includes(element._type) ||
                    portableTextFeatures.types.inlineObjects.map((obj) => obj.name).includes(element._type)));
        };
        editor.isInline = (element) => {
            const inlineSchemaTypes = portableTextFeatures.types.inlineObjects.map((obj) => obj.name);
            return (inlineSchemaTypes.includes(element._type) &&
                '__inline' in element &&
                element.__inline === true);
        };
        // Extend Slate's default normalization to add _type span to span inserted after a inline void object
        const { apply } = editor;
        editor.apply = (op) => {
            const isInsertTextWithoutType = op.type === 'insert_node' &&
                op.path.length === 2 &&
                Text.isText(op.node) &&
                op.node._type === undefined;
            if (isInsertTextWithoutType) {
                const insertNodeOperation = op;
                const newNode = {
                    ...insertNodeOperation.node,
                    _type: 'span',
                };
                op.node = newNode;
                debug$8('Setting span type to child without a type', op);
            }
            apply(op);
        };
        return editor;
    };
}

const debug$7 = debugWithName('plugin:withUtils');
/**
 * This plugin makes various util commands available in the editor
 *
 */
function createWithUtils({ portableTextFeatures, keyGenerator }) {
    return function withUtils(editor) {
        editor.createPlaceholderBlock = () => {
            return {
                _type: portableTextFeatures.types.block.name,
                _key: keyGenerator(),
                style: portableTextFeatures.styles[0].value,
                markDefs: [],
                children: [
                    {
                        _type: 'span',
                        _key: keyGenerator(),
                        text: '',
                        marks: [],
                    },
                ],
            };
        };
        // Expands the the selection to wrap around the word the focus is at
        editor.pteExpandToWord = () => {
            const { selection } = editor;
            if (selection && !Range.isExpanded(selection)) {
                const [textNode] = Editor.node(editor, selection.focus, { depth: 2 });
                if (!textNode || !Text.isText(textNode) || textNode.text.length === 0) {
                    debug$7(`pteExpandToWord: Can't expand to word here`);
                    return;
                }
                const { focus } = selection;
                const focusOffset = focus.offset;
                const charsBefore = textNode.text.slice(0, focusOffset);
                const charsAfter = textNode.text.slice(focusOffset, -1);
                const isEmpty = (str) => str.match(/\s/g);
                const whiteSpaceBeforeIndex = charsBefore
                    .split('')
                    .reverse()
                    .findIndex((str) => isEmpty(str));
                const newStartOffset = whiteSpaceBeforeIndex > -1 ? charsBefore.length - whiteSpaceBeforeIndex : 0;
                const whiteSpaceAfterIndex = charsAfter.split('').findIndex((obj) => isEmpty(obj));
                const newEndOffset = charsBefore.length +
                    (whiteSpaceAfterIndex > -1 ? whiteSpaceAfterIndex : charsAfter.length + 1);
                if (!(newStartOffset === newEndOffset || isNaN(newStartOffset) || isNaN(newEndOffset))) {
                    debug$7('pteExpandToWord: Expanding to focused word');
                    Transforms.setSelection(editor, {
                        anchor: { ...selection.anchor, offset: newStartOffset },
                        focus: { ...selection.focus, offset: newEndOffset },
                    });
                    return;
                }
                debug$7(`pteExpandToWord: Can't expand to word here`);
            }
        };
        return editor;
    };
}

const debug$6 = debugWithName('API:editable');
function createWithEditableAPI(portableTextEditor, portableTextFeatures, keyGenerator) {
    return function withEditableAPI(editor) {
        portableTextEditor.setEditable({
            focus: () => {
                // Make a selection if missing
                if (!editor.selection) {
                    const point = { path: [0, 0], offset: 0 };
                    Transforms.select(editor, { focus: point, anchor: point });
                    editor.onChange();
                }
                ReactEditor.focus(editor);
            },
            blur: () => {
                ReactEditor.blur(editor);
            },
            toggleMark: (mark) => {
                editor.pteToggleMark(mark);
            },
            toggleList: (listStyle) => {
                editor.pteToggleListItem(listStyle);
            },
            toggleBlockStyle: (blockStyle) => {
                editor.pteToggleBlockStyle(blockStyle);
            },
            isMarkActive: (mark) => {
                // Try/catch this, as Slate may error because the selection is currently wrong
                // TODO: catch only relevant error from Slate
                try {
                    return editor.pteIsMarkActive(mark);
                }
                catch (err) {
                    console.warn(err);
                    return false;
                }
            },
            marks: () => {
                return ({
                    ...(Editor.marks(editor) || {}),
                }.marks || []);
            },
            undo: () => editor.undo(),
            redo: () => editor.redo(),
            select: (selection) => {
                const slateSelection = toSlateRange(selection, editor);
                if (slateSelection) {
                    Transforms.select(editor, slateSelection);
                }
                else {
                    Transforms.deselect(editor);
                }
                editor.onChange();
            },
            focusBlock: () => {
                if (editor.selection) {
                    // Try/catch this, as Slate may error because the selection is currently wrong
                    // TODO: catch only relevant error from Slate
                    try {
                        const [block] = Array.from(Editor.nodes(editor, {
                            at: editor.selection.focus,
                            match: (n) => Editor.isBlock(editor, n),
                        }))[0] || [undefined];
                        if (block) {
                            return fromSlateValue([block], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
                        }
                    }
                    catch (err) {
                        return undefined;
                    }
                }
                return undefined;
            },
            focusChild: () => {
                if (editor.selection) {
                    try {
                        const [node] = Array.from(Editor.nodes(editor, {
                            mode: 'lowest',
                            at: editor.selection.focus,
                            match: (n) => n._type !== undefined,
                            voids: true,
                        }))[0] || [undefined];
                        if (node && !Editor.isBlock(editor, node)) {
                            const pseudoBlock = {
                                _key: 'pseudo',
                                _type: portableTextFeatures.types.block.name,
                                children: [node],
                            };
                            return fromSlateValue([pseudoBlock], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0].children[0];
                        }
                    }
                    catch (err) {
                        return undefined;
                    }
                }
                return undefined;
            },
            insertChild: (type, value) => {
                if (!editor.selection) {
                    throw new Error('The editor has no selection');
                }
                const [focusBlock] = Array.from(Editor.nodes(editor, {
                    at: editor.selection.focus,
                    match: (n) => Editor.isBlock(editor, n),
                }))[0] || [undefined];
                if (!focusBlock) {
                    throw new Error('No focus block');
                }
                if (focusBlock && Editor.isVoid(editor, focusBlock)) {
                    throw new Error("Can't insert childs into block objects");
                }
                const block = toSlateValue([
                    {
                        _key: keyGenerator(),
                        _type: portableTextFeatures.types.block.name,
                        children: [
                            {
                                _key: keyGenerator(),
                                _type: type.name,
                                ...(value ? value : {}),
                            },
                        ],
                    },
                ], portableTextEditor)[0];
                const child = block.children[0];
                Editor.insertNode(editor, child);
                editor.onChange();
                return (toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures)?.focus.path || []);
            },
            insertBlock: (type, value) => {
                if (!editor.selection) {
                    throw new Error('The editor has no selection');
                }
                const block = toSlateValue([
                    {
                        _key: keyGenerator(),
                        _type: type.name,
                        ...(value ? value : {}),
                    },
                ], portableTextEditor)[0];
                Editor.insertNode(editor, block);
                editor.onChange();
                return (toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures)?.focus.path || []);
            },
            hasBlockStyle: (style) => {
                try {
                    return editor.pteHasBlockStyle(style);
                }
                catch (err) {
                    // This is fine.
                    // debug(err)
                    return false;
                }
            },
            hasListStyle: (listStyle) => {
                try {
                    return editor.pteHasListStyle(listStyle);
                }
                catch (err) {
                    // This is fine.
                    // debug(err)
                    return false;
                }
            },
            isVoid: (element) => {
                return ![
                    portableTextFeatures.types.block.name,
                    portableTextFeatures.types.span.name,
                ].includes(element._type);
            },
            findByPath: (path) => {
                const slatePath = toSlateRange({ focus: { path, offset: 0 }, anchor: { path, offset: 0 } }, editor);
                if (slatePath) {
                    const [block, blockPath] = Editor.node(editor, slatePath.focus.path.slice(0, 1));
                    if (block && blockPath && typeof block._key === 'string') {
                        if (path.length === 1 && slatePath.focus.path.length === 1) {
                            return [
                                fromSlateValue([block], portableTextFeatures.types.block.name)[0],
                                [{ _key: block._key }],
                            ];
                        }
                        const ptBlock = fromSlateValue([block], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
                        const ptChild = ptBlock.children[slatePath.focus.path[1]];
                        if (ptChild) {
                            return [ptChild, [{ _key: block._key }, 'children', { _key: ptChild._key }]];
                        }
                    }
                }
                return [undefined, undefined];
            },
            findDOMNode: (element) => {
                let node;
                try {
                    const [item] = Array.from(Editor.nodes(editor, {
                        at: [],
                        match: (n) => n._key === element._key,
                    }) || [])[0] || [undefined];
                    node = ReactEditor.toDOMNode(editor, item);
                }
                catch (err) {
                    // Nothing
                }
                return node;
            },
            activeAnnotations: () => {
                if (!editor.selection || editor.selection.focus.path.length < 2) {
                    return [];
                }
                try {
                    const activeAnnotations = [];
                    const spans = Editor.nodes(editor, {
                        at: editor.selection,
                        match: (node) => Text.isText(node) &&
                            node.marks !== undefined &&
                            Array.isArray(node.marks) &&
                            node.marks.length > 0,
                    });
                    for (const [span, path] of spans) {
                        const [block] = Editor.node(editor, path, { depth: 1 });
                        if (editor.isTextBlock(block)) {
                            block.markDefs.forEach((def) => {
                                if (Text.isText(span) &&
                                    span.marks &&
                                    Array.isArray(span.marks) &&
                                    span.marks.includes(def._key)) {
                                    activeAnnotations.push(def);
                                }
                            });
                        }
                    }
                    return activeAnnotations;
                }
                catch (err) {
                    return [];
                }
            },
            addAnnotation: (type, value) => {
                const { selection } = editor;
                if (selection) {
                    const [block] = Editor.node(editor, selection.focus, { depth: 1 });
                    if (Element$1.isElement(block) &&
                        block._type === portableTextFeatures.types.block.name) {
                        const annotationKey = keyGenerator();
                        if (editor.isTextBlock(block)) {
                            Transforms.setNodes(editor, {
                                markDefs: [...block.markDefs, { _type: type.name, _key: annotationKey, ...value }],
                            }, { at: selection.focus });
                            editor.onChange();
                            if (Range.isCollapsed(selection)) {
                                editor.pteExpandToWord();
                                editor.onChange();
                            }
                            const [textNode] = Editor.node(editor, selection.focus, { depth: 2 });
                            if (editor.selection) {
                                Editor.withoutNormalizing(editor, () => {
                                    // Split if needed
                                    Transforms.setNodes(editor, {}, { match: Text.isText, split: true });
                                    if (editor.selection && Text.isText(textNode)) {
                                        Transforms.setNodes(editor, {
                                            marks: [...(textNode.marks || []), annotationKey],
                                        }, {
                                            at: editor.selection,
                                            match: (n) => n._type === portableTextFeatures.types.span.name,
                                        });
                                        editor.onChange();
                                    }
                                });
                                Editor.normalize(editor);
                                editor.onChange();
                                const newSelection = toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures);
                                // eslint-disable-next-line max-depth
                                if (newSelection && typeof block._key === 'string') {
                                    // Insert an empty string to continue writing non-annotated text
                                    Editor.withoutNormalizing(editor, () => {
                                        if (editor.selection) {
                                            Transforms.insertNodes(editor, [{ _type: 'span', text: '', marks: [], _key: keyGenerator() }], {
                                                at: Range.end(editor.selection),
                                            });
                                            editor.onChange();
                                        }
                                    });
                                    return {
                                        spanPath: newSelection.focus.path,
                                        markDefPath: [{ _key: block._key }, 'markDefs', { _key: annotationKey }],
                                    };
                                }
                            }
                        }
                    }
                }
                return undefined;
            },
            delete: (selection, options) => {
                if (selection) {
                    const range = toSlateRange(selection, editor);
                    if (range) {
                        if (!options?.mode || options?.mode === 'selected') {
                            debug$6(`Deleting content in selection`);
                            Transforms.delete(editor, {
                                at: range,
                                hanging: true,
                                voids: true,
                            });
                            editor.onChange();
                            return;
                        }
                        const nodes = Editor.nodes(editor, {
                            at: range,
                            match: (node) => {
                                if (options?.mode === 'blocks') {
                                    debug$6(`Deleting blocks touched by selection`);
                                    return (editor.isTextBlock(node) ||
                                        (!editor.isTextBlock(node) && Element$1.isElement(node)));
                                }
                                debug$6(`Deleting children touched by selection`);
                                return (node._type === portableTextFeatures.types.span.name || // Text children
                                    (!editor.isTextBlock(node) && Element$1.isElement(node)) // inline blocks
                                );
                            },
                        });
                        const nodeAndPaths = [...nodes];
                        nodeAndPaths.forEach(([, p]) => {
                            Transforms.removeNodes(editor, {
                                at: p,
                                voids: true,
                                hanging: true,
                            });
                        });
                        editor.onChange();
                    }
                }
            },
            removeAnnotation: (type) => {
                let { selection } = editor;
                debug$6('Removing annotation', type);
                if (selection) {
                    // Select the whole annotation if collapsed
                    if (Range.isCollapsed(selection)) {
                        const [node, nodePath] = Editor.node(editor, selection, { depth: 2 });
                        if (Text.isText(node) && node.marks && typeof node.text === 'string') {
                            Transforms.select(editor, nodePath);
                            selection = editor.selection;
                        }
                    }
                    // Do this without normalization or span references will be unstable!
                    Editor.withoutNormalizing(editor, () => {
                        if (selection && Range.isExpanded(selection)) {
                            selection = editor.selection;
                            if (!selection) {
                                return;
                            }
                            // Split the span first
                            Transforms.setNodes(editor, {}, { match: Text.isText, split: true });
                            editor.onChange();
                            // Everything in the selection which has marks
                            const spans = [
                                ...Editor.nodes(editor, {
                                    at: selection,
                                    match: (node) => Text.isText(node) &&
                                        node.marks !== undefined &&
                                        Array.isArray(node.marks) &&
                                        node.marks.length > 0,
                                }),
                            ];
                            spans.forEach(([span, path]) => {
                                const [block] = Editor.node(editor, path, { depth: 1 });
                                if (editor.isTextBlock(block)) {
                                    block.markDefs
                                        .filter((def) => def._type === type.name)
                                        .forEach((def) => {
                                        if (Text.isText(span) &&
                                            Array.isArray(span.marks) &&
                                            span.marks.includes(def._key)) {
                                            const newMarks = [...(span.marks || []).filter((mark) => mark !== def._key)];
                                            Transforms.setNodes(editor, {
                                                marks: newMarks,
                                            }, { at: path, voids: false, split: false });
                                        }
                                    });
                                }
                            });
                        }
                    });
                    Editor.normalize(editor);
                    editor.onChange();
                }
            },
            getSelection: () => {
                let ptRange = null;
                if (editor.selection) {
                    const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);
                    if (existing) {
                        return existing;
                    }
                    ptRange = toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures);
                    SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);
                }
                return ptRange;
            },
            getValue: () => {
                return fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor));
            },
            isCollapsedSelection: () => {
                return !!editor.selection && Range.isCollapsed(editor.selection);
            },
            isExpandedSelection: () => {
                return !!editor.selection && Range.isExpanded(editor.selection);
            },
        });
        return editor;
    };
}

/* eslint-disable max-statements */
const debug$5 = debugWithName('plugin:withHotKeys');
const DEFAULT_HOTKEYS = {
    marks: {
        'mod+b': 'strong',
        'mod+i': 'em',
        'mod+u': 'underline',
        "mod+'": 'code',
    },
    custom: {},
};
/**
 * This plugin takes care of all hotkeys in the editor
 *
 */
function createWithHotkeys(portableTextFeatures, keyGenerator, portableTextEditor, hotkeysFromOptions) {
    const reservedHotkeys = ['enter', 'tab', 'shift', 'delete', 'end'];
    const activeHotkeys = hotkeysFromOptions || DEFAULT_HOTKEYS; // TODO: Merge where possible? A union?
    const createEmptyBlock = () => toSlateValue([
        {
            _type: portableTextFeatures.types.block.name,
            _key: keyGenerator(),
            style: 'normal',
            markDefs: [],
            children: [
                {
                    _type: 'span',
                    _key: keyGenerator(),
                    text: '',
                    marks: [],
                },
            ],
        },
    ], portableTextEditor)[0];
    return function withHotKeys(editor) {
        editor.pteWithHotKeys = (event) => {
            // Wire up custom marks hotkeys
            Object.keys(activeHotkeys).forEach((cat) => {
                if (cat === 'marks') {
                    // eslint-disable-next-line guard-for-in
                    for (const hotkey in activeHotkeys[cat]) {
                        if (reservedHotkeys.includes(hotkey)) {
                            throw new Error(`The hotkey ${hotkey} is reserved!`);
                        }
                        if (isHotkey(hotkey, event.nativeEvent)) {
                            event.preventDefault();
                            const possibleMark = activeHotkeys[cat];
                            if (possibleMark) {
                                const mark = possibleMark[hotkey];
                                debug$5(`HotKey ${hotkey} to toggle ${mark}`);
                                editor.pteToggleMark(mark);
                            }
                        }
                    }
                }
                if (cat === 'custom') {
                    // eslint-disable-next-line guard-for-in
                    for (const hotkey in activeHotkeys[cat]) {
                        if (reservedHotkeys.includes(hotkey)) {
                            throw new Error(`The hotkey ${hotkey} is reserved!`);
                        }
                        if (isHotkey(hotkey, event.nativeEvent)) {
                            const possibleCommand = activeHotkeys[cat];
                            if (possibleCommand) {
                                const command = possibleCommand[hotkey];
                                command(event, portableTextEditor);
                            }
                        }
                    }
                }
            });
            const isEnter = isHotkey('enter', event.nativeEvent);
            const isTab = isHotkey('tab', event.nativeEvent);
            const isShiftEnter = isHotkey('shift+enter', event.nativeEvent);
            const isShiftTab = isHotkey('shift+tab', event.nativeEvent);
            const isBackspace = isHotkey('backspace', event.nativeEvent);
            const isDelete = isHotkey('delete', event.nativeEvent);
            // Disallow deleting void blocks by backspace from another line.
            // Otherwise it's so easy to delete the void block above when trying to delete text on
            // the line below or above
            if (isBackspace &&
                editor.selection &&
                editor.selection.focus.path[0] > 0 &&
                Range.isCollapsed(editor.selection)) {
                const [prevBlock, prevPath] = Editor.node(editor, Path.previous(editor.selection.focus.path.slice(0, 1)));
                const [focusBlock] = Editor.node(editor, editor.selection.focus, { depth: 1 });
                if (prevBlock &&
                    focusBlock &&
                    Editor.isVoid(editor, prevBlock) &&
                    editor.selection.focus.offset === 0) {
                    debug$5('Preventing deleting void block above');
                    event.preventDefault();
                    event.stopPropagation();
                    Transforms.removeNodes(editor, { match: (n) => n === focusBlock });
                    Transforms.select(editor, prevPath);
                    editor.onChange();
                    return;
                }
            }
            if (isDelete &&
                editor.selection &&
                editor.selection.focus.offset === 0 &&
                Range.isCollapsed(editor.selection) &&
                editor.children[editor.selection.focus.path[0] + 1]) {
                const [nextBlock] = Editor.node(editor, Path.next(editor.selection.focus.path.slice(0, 1)));
                const [focusBlock, focusBlockPath] = Editor.node(editor, editor.selection.focus, { depth: 1 });
                if (nextBlock &&
                    focusBlock &&
                    !Editor.isVoid(editor, focusBlock) &&
                    Editor.isVoid(editor, nextBlock)) {
                    debug$5('Preventing deleting void block below');
                    event.preventDefault();
                    event.stopPropagation();
                    Transforms.removeNodes(editor, { match: (n) => n === focusBlock });
                    Transforms.select(editor, focusBlockPath);
                    editor.onChange();
                    return;
                }
            }
            // Tab for lists
            if (isTab || isShiftTab) {
                if (editor.pteIncrementBlockLevels(isShiftTab)) {
                    event.preventDefault();
                }
            }
            // Deal with enter key combos
            if (isEnter && !isShiftEnter && editor.selection) {
                let focusBlock;
                try {
                    ;
                    [focusBlock] = Editor.node(editor, editor.selection.focus, { depth: 1 });
                }
                catch (err) {
                    // Just ignore
                }
                // List item enter key
                if (editor.isListBlock(focusBlock)) {
                    if (editor.pteEndList()) {
                        event.preventDefault();
                    }
                    return;
                }
                // Enter from another style than the first (default one)
                if (editor.isTextBlock(focusBlock) &&
                    focusBlock.style &&
                    focusBlock.style !== portableTextFeatures.styles[0].value) {
                    const [, end] = Range.edges(editor.selection);
                    const endAtEndOfNode = Editor.isEnd(editor, end, end.path);
                    if (endAtEndOfNode) {
                        Editor.insertNode(editor, createEmptyBlock());
                        event.preventDefault();
                        return;
                    }
                }
                // Block object enter key
                if (focusBlock && Editor.isVoid(editor, focusBlock)) {
                    Editor.insertNode(editor, createEmptyBlock());
                    event.preventDefault();
                    return;
                }
            }
            // Soft line breaks
            if (isShiftEnter) {
                event.preventDefault();
                editor.insertText('\n');
                return;
            }
            // Undo/redo
            if (isHotkey('mod+z', event.nativeEvent)) {
                event.preventDefault();
                editor.undo();
                return;
            }
            if (isHotkey('mod+y', event.nativeEvent) || isHotkey('mod+shift+z', event.nativeEvent)) {
                event.preventDefault();
                editor.redo();
            }
        };
        return editor;
    };
}

const debug$4 = debugWithName('plugin:withInsertData');
/**
 * This plugin handles copy/paste in the editor
 *
 */
function createWithInsertData(change$, portableTextFeatures, keyGenerator) {
    return function withInsertData(editor) {
        const blockTypeName = portableTextFeatures.types.block.name;
        const spanTypeName = portableTextFeatures.types.span.name;
        const toPlainText = (blocks) => {
            return blocks
                .map((block) => {
                if (block._type === blockTypeName) {
                    return block.children
                        .map((child) => {
                        if (child._type === spanTypeName) {
                            return child.text;
                        }
                        return `[${portableTextFeatures.types.inlineObjects.find((t) => t.name === child._type)
                            ?.title || 'Object'}]`;
                    })
                        .join('');
                }
                return `[${portableTextFeatures.types.blockObjects.find((t) => t.name === block._type)?.title ||
                    'Object'}]`;
            })
                .join('\n\n');
        };
        editor.setFragmentData = (data, originEvent) => {
            const { selection } = editor;
            if (!selection) {
                return;
            }
            const [start, end] = Range.edges(selection);
            const startVoid = Editor.void(editor, { at: start.path });
            const endVoid = Editor.void(editor, { at: end.path });
            if (Range.isCollapsed(selection) && !startVoid) {
                return;
            }
            // Create a fake selection so that we can add a Base64-encoded copy of the
            // fragment to the HTML, to decode on future pastes.
            const domRange = ReactEditor.toDOMRange(editor, selection);
            let contents = domRange.cloneContents();
            // COMPAT: If the end node is a void node, we need to move the end of the
            // range from the void node's spacer span, to the end of the void node's
            // content, since the spacer is before void's content in the DOM.
            if (endVoid) {
                const [voidNode] = endVoid;
                const r = domRange.cloneRange();
                const domNode = ReactEditor.toDOMNode(editor, voidNode);
                r.setEndAfter(domNode);
                contents = r.cloneContents();
            }
            // Remove any zero-width space spans from the cloned DOM so that they don't
            // show up elsewhere when pasted.
            Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach((zw) => {
                const isNewline = zw.getAttribute('data-slate-zero-width') === 'n';
                zw.textContent = isNewline ? '\n' : '';
            });
            // Clean up the clipboard HTML for editor spesific attributes
            Array.from(contents.querySelectorAll('*')).forEach((elm) => {
                elm.removeAttribute('contentEditable');
                elm.removeAttribute('data-slate-inline');
                elm.removeAttribute('data-slate-leaf');
                elm.removeAttribute('data-slate-node');
                elm.removeAttribute('data-slate-spacer');
                elm.removeAttribute('data-slate-string');
                elm.removeAttribute('data-slate-zero-width');
                elm.removeAttribute('draggable');
                for (const key in elm.attributes) {
                    if (elm.hasAttribute(key)) {
                        elm.removeAttribute(key);
                    }
                }
            });
            const div = contents.ownerDocument.createElement('div');
            div.appendChild(contents);
            div.setAttribute('hidden', 'true');
            contents.ownerDocument.body.appendChild(div);
            const asHTML = div.innerHTML;
            contents.ownerDocument.body.removeChild(div);
            const fragment = editor.getFragment();
            const portableText = fromSlateValue(fragment, portableTextFeatures.types.block.name);
            const asJSON = JSON.stringify(portableText);
            const asPlainText = toPlainText(portableText);
            data.clearData();
            data.setData('text/plain', asPlainText);
            data.setData('text/html', asHTML);
            data.setData('application/json', asJSON);
            data.setData('application/x-portable-text', asJSON);
            debug$4('text', asPlainText);
            data.setData('application/x-portable-text-event-origin', originEvent || 'external');
            debug$4('Set fragment data', asJSON, asHTML);
        };
        editor.insertPortableTextData = (data) => {
            if (!editor.selection) {
                return false;
            }
            const pText = data.getData('application/x-portable-text');
            const origin = data.getData('application/x-portable-text-event-origin');
            debug$4(`Inserting portable text from ${origin} event`, pText);
            if (pText) {
                const parsed = JSON.parse(pText);
                if (Array.isArray(parsed) && parsed.length > 0) {
                    const slateValue = regenerateKeys(editor, toSlateValue(parsed, { portableTextFeatures }), keyGenerator, spanTypeName);
                    // Validate the result
                    const validation = validateValue(parsed, portableTextFeatures, keyGenerator);
                    // Bail out if it's not valid
                    if (!validation.valid) {
                        const errorDescription = `${validation.resolution?.description}`;
                        change$.next({
                            type: 'error',
                            level: 'warning',
                            name: 'pasteError',
                            description: errorDescription,
                            data: validation,
                        });
                        debug$4('Invalid insert result', validation);
                        return false;
                    }
                    mixMarkDefs(editor, slateValue);
                    editor.insertFragment(slateValue);
                    editor.onChange();
                    return true;
                }
            }
            return false;
        };
        editor.insertTextOrHTMLData = (data) => {
            if (!editor.selection) {
                debug$4('No selection, not inserting');
                return false;
            }
            change$.next({ type: 'loading', isLoading: true }); // This could potentially take some time
            const html = data.getData('text/html');
            const text = data.getData('text/plain');
            if (html || text) {
                debug$4('Inserting data', data);
                let portableText;
                let fragment;
                let insertedType;
                if (html) {
                    portableText = htmlToBlocks(html, portableTextFeatures.types.portableText).map((block) => normalizeBlock(block, { blockTypeName }));
                    fragment = toSlateValue(portableText, { portableTextFeatures });
                    insertedType = 'HTML';
                }
                else {
                    // plain text
                    const blocks = escapeHtml(text)
                        .split(/\n{2,}/)
                        .map((line) => line ? `<p>${line.replace(/(?:\r\n|\r|\n)/g, '<br/>')}</p>` : '<p></p>')
                        .join('');
                    const textToHtml = `<html><body>${blocks}</body></html>`;
                    portableText = htmlToBlocks(textToHtml, portableTextFeatures.types.portableText).map((block) => normalizeBlock(block, { blockTypeName }));
                    fragment = toSlateValue(portableText, {
                        portableTextFeatures,
                    });
                    insertedType = 'text';
                }
                // Validate the result
                const validation = validateValue(portableText, portableTextFeatures, keyGenerator);
                // Bail out if it's not valid
                if (!validation.valid) {
                    const errorDescription = `Could not validate the resulting portable text to insert.\n${validation.resolution?.description}\nTry to insert as plain text (shift-paste) instead.`;
                    change$.next({
                        type: 'error',
                        level: 'warning',
                        name: 'pasteError',
                        description: errorDescription,
                        data: validation,
                    });
                    debug$4('Invalid insert result', validation);
                    return false;
                }
                debug$4(`Inserting ${insertedType} fragment at ${JSON.stringify(editor.selection)}`);
                mixMarkDefs(editor, fragment);
                editor.insertFragment(fragment);
                editor.onChange();
                change$.next({ type: 'loading', isLoading: false });
                return true;
            }
            change$.next({ type: 'loading', isLoading: false });
            return false;
        };
        editor.insertData = (data) => {
            if (!editor.insertPortableTextData(data)) {
                editor.insertTextOrHTMLData(data);
            }
        };
        editor.insertFragmentData = (data) => {
            const fragment = data.getData('application/x-portable-text');
            if (fragment) {
                const parsed = JSON.parse(fragment);
                editor.insertFragment(parsed);
                return true;
            }
            return false;
        };
        return editor;
    };
}
const entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;',
    '`': '&#x60;',
    '=': '&#x3D;',
};
function escapeHtml(str) {
    return String(str).replace(/[&<>"'`=/]/g, (s) => entityMap[s]);
}
function regenerateKeys(editor, fragment, keyGenerator, spanTypeName) {
    return fragment.map((node) => {
        const newNode = { ...node };
        // Ensure the copy has new keys
        if (editor.isTextBlock(newNode)) {
            newNode.markDefs = newNode.markDefs.map((def) => {
                const oldKey = def._key;
                const newKey = keyGenerator();
                if (Array.isArray(newNode.children)) {
                    newNode.children = newNode.children.map((child) => child._type === spanTypeName && Text.isText(child)
                        ? {
                            ...child,
                            marks: child.marks && child.marks.includes(oldKey)
                                ? // eslint-disable-next-line max-nested-callbacks
                                    [...child.marks].filter((mark) => mark !== oldKey).concat(newKey)
                                : child.marks,
                        }
                        : child);
                }
                return { ...def, _key: newKey };
            });
        }
        const nodeWithNewKeys = { ...newNode, _key: keyGenerator() };
        if (editor.isTextBlock(nodeWithNewKeys)) {
            nodeWithNewKeys.children = nodeWithNewKeys.children.map((child) => ({
                ...child,
                _key: keyGenerator(),
            }));
        }
        return nodeWithNewKeys;
    });
}
function mixMarkDefs(editor, fragment) {
    if (!editor.selection) {
        return false;
    }
    const [focusBlock, focusPath] = Editor.node(editor, editor.selection, { depth: 1 });
    if (editor.isTextBlock(focusBlock) && editor.isTextBlock(fragment[0])) {
        const { markDefs } = focusBlock;
        debug$4('Mixing markDefs of focusBlock and fragments[0] block', markDefs, fragment[0].markDefs);
        // As the first block will be inserted into another block (potentially), mix those markDefs
        Transforms.setNodes(editor, {
            markDefs: [...fragment[0].markDefs, ...markDefs],
        }, { at: focusPath, mode: 'lowest', voids: false });
        return true;
    }
    return false;
}

const withPlugins = (editor, options) => {
    const e = editor;
    e.maxBlocks = options.maxBlocks || -1;
    e.readOnly = options.readOnly || false;
    const { portableTextFeatures, keyGenerator, change$, incomingPatches$, syncValue } = options;
    const operationToPatches = createOperationToPatches(portableTextFeatures);
    const withObjectKeys = createWithObjectKeys(portableTextFeatures, keyGenerator);
    const withSchemaTypes = createWithSchemaTypes(portableTextFeatures);
    const [withPatches, withPatchesCleanupFunction] = options.readOnly
        ? []
        : createWithPatches(operationToPatches, change$, portableTextFeatures, syncValue, incomingPatches$);
    const withMaxBlocks = createWithMaxBlocks();
    const withPortableTextLists = createWithPortableTextLists(portableTextFeatures);
    const [withUndoRedo, withUndoRedoCleanupFunction] = options.readOnly
        ? []
        : createWithUndoRedo(incomingPatches$);
    const withPortableTextMarkModel = createWithPortableTextMarkModel(portableTextFeatures);
    const withPortableTextBlockStyle = createWithPortableTextBlockStyle(portableTextFeatures, change$);
    const withUtils = createWithUtils({ keyGenerator, portableTextFeatures });
    const withPortableTextSelections = createWithPortableTextSelections(change$, portableTextFeatures);
    e.destroy = () => {
        if (withPatchesCleanupFunction) {
            withPatchesCleanupFunction();
        }
        if (withUndoRedoCleanupFunction) {
            withUndoRedoCleanupFunction();
        }
    };
    const minimal = withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withUtils(withPortableTextLists(e))))));
    const full = (withUndoRedo &&
        withPatches &&
        withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withPortableTextLists(withUtils(withMaxBlocks(withUndoRedo(withPatches(withPortableTextSelections(e))))))))))) ||
        e;
    // Ordering is important here, selection dealing last, data manipulation in the middle and core model stuff first.
    return options.readOnly ? minimal : full;
};

// Debounce time for flushing local patches (ms since user haven't produced a patch)
// (lower time for tests to speed them up)
const FLUSH_PATCHES_DEBOUNCE_MS = process.env.NODE_ENV === 'test' ? 50 : 1000;
const defaultKeyGenerator = () => randomKey(12);
const debug$3 = debugWithName('component:PortableTextEditor');
class PortableTextEditor extends React.Component {
    change$ = new Subject();
    keyGenerator;
    maxBlocks;
    portableTextFeatures;
    readOnly;
    slateInstance;
    type;
    changeSubscription;
    editable;
    incomingPatches$;
    pendingPatches = [];
    returnedPatches = [];
    hasPendingLocalPatches;
    constructor(props) {
        super(props);
        if (!props.type) {
            throw new Error('PortableTextEditor: missing "type" property');
        }
        this.hasPendingLocalPatches = React.createRef();
        this.hasPendingLocalPatches.current = false;
        this.state = {
            invalidValueResolution: null,
            selection: null,
            initialValue: [], // Created in the constructor
        };
        // Test if we have a compiled schema type, if not, conveniently compile it
        this.type = props.type.hasOwnProperty('jsonType') ? props.type : compileType(props.type);
        // Indicate that we are loading
        this.change$.next({ type: 'loading', isLoading: true });
        // Get the block types feature set (lookup table)
        this.portableTextFeatures = getPortableTextFeatures(this.type);
        // Setup keyGenerator (either from props, or default)
        this.keyGenerator = props.keyGenerator || defaultKeyGenerator;
        // Setup processed incoming patches stream
        if (props.incomingPatches$) {
            // Buffer patches until we are no longer producing local patches
            this.incomingPatches$ = props.incomingPatches$
                .pipe(tap(({ patches }) => {
                // Reset hasPendingLocalPatches when local patches are returned
                if (patches.some((p) => p.origin === 'local')) {
                    this.hasPendingLocalPatches.current = false;
                }
            }))
                .pipe(bufferUntil(() => !this.hasPendingLocalPatches.current), concatMap((incoming) => {
                return incoming;
            }), share());
        }
        // Subscribe to editor events and set state for selection and pending patches
        this.changeSubscription = this.change$.subscribe((next) => {
            const { onChange } = this.props;
            switch (next.type) {
                case 'patch':
                    this.pendingPatches.push(next.patch);
                    if (this.props.incomingPatches$) {
                        this.hasPendingLocalPatches.current = true;
                    }
                    this.flushDebounced();
                    onChange(next);
                    break;
                case 'selection':
                    onChange(next);
                    this.setState({ selection: next.selection });
                    break;
                default:
                    onChange(next);
            }
        });
        // Set maxBlocks and readOnly
        this.maxBlocks =
            typeof props.maxBlocks === 'undefined'
                ? undefined
                : parseInt(props.maxBlocks.toString(), 10) || undefined;
        this.readOnly = Boolean(props.readOnly) || false;
        // Validate the incoming value
        if (props.value) {
            const validation = validateValue(props.value, this.portableTextFeatures, this.keyGenerator);
            if (props.value && !validation.valid) {
                this.change$.next({ type: 'loading', isLoading: false });
                this.change$.next({
                    type: 'invalidValue',
                    resolution: validation.resolution,
                    value: props.value,
                });
                this.state = { ...this.state, invalidValueResolution: validation.resolution };
            }
        }
        // Create the slate instance
        this.slateInstance = withPlugins(createEditor(), {
            change$: this.change$,
            incomingPatches$: this.incomingPatches$,
            keyGenerator: this.keyGenerator,
            maxBlocks: this.maxBlocks,
            portableTextFeatures: this.portableTextFeatures,
            readOnly: this.readOnly,
            syncValue: this.syncValue,
        });
        this.state = {
            ...this.state,
            initialValue: toSlateValue(getValueOrInitialValue(props.value, [this.slateInstance.createPlaceholderBlock()]), { portableTextFeatures: this.portableTextFeatures }, KEY_TO_SLATE_ELEMENT.get(this.slateInstance)),
        };
        KEY_TO_VALUE_ELEMENT.set(this.slateInstance, {});
        KEY_TO_SLATE_ELEMENT.set(this.slateInstance, {});
    }
    componentWillUnmount() {
        this.flush();
        this.changeSubscription.unsubscribe();
        this.slateInstance.destroy();
    }
    componentDidUpdate(prevProps) {
        // Whenever readOnly toggles, recreate the editor's plugin chain
        if (this.props.readOnly !== prevProps.readOnly) {
            this.readOnly = Boolean(this.props.readOnly);
            this.slateInstance = withPlugins(this.slateInstance, {
                change$: this.change$,
                incomingPatches$: this.incomingPatches$,
                keyGenerator: this.keyGenerator,
                maxBlocks: this.maxBlocks,
                portableTextFeatures: this.portableTextFeatures,
                readOnly: this.readOnly,
                syncValue: this.syncValue,
            });
        }
        // Update the maxBlocks prop
        if (this.props.maxBlocks !== prevProps.maxBlocks) {
            this.maxBlocks =
                typeof this.props.maxBlocks === 'undefined'
                    ? undefined
                    : parseInt(this.props.maxBlocks.toString(), 10) || undefined;
            this.slateInstance.maxBlocks = this.maxBlocks;
        }
        // Sync value from props, but not when we are responding to incoming patches
        // (if this is the case, we sync the value after the incoming patches has been processed - see createWithPatches plugin)
        if (this.props.value !== prevProps.value &&
            (!prevProps.value || this.readOnly || !this.props.incomingPatches$)) {
            this.syncValue();
        }
    }
    setEditable = (editable) => {
        this.editable = { ...this.editable, ...editable };
        this.change$.next({ type: 'value', value: this.props.value || undefined });
        this.change$.next({ type: 'ready' });
    };
    render() {
        if (this.state.invalidValueResolution) {
            return this.state.invalidValueResolution.description;
        }
        return (React.createElement(PortableTextEditorContext.Provider, { value: this },
            React.createElement(PortableTextEditorValueContext.Provider, { value: this.props.value },
                React.createElement(PortableTextEditorSelectionContext.Provider, { value: this.state.selection },
                    React.createElement(Slate, { onChange: NOOP$1, editor: this.slateInstance, value: this.state.initialValue }, this.props.children)))));
    }
    syncValue = (userCallbackFn) => {
        const val = this.props.value;
        const callbackFn = () => {
            debug$3('Updating slate instance');
            this.slateInstance.onChange();
            this.change$.next({ type: 'value', value: val });
            if (userCallbackFn) {
                userCallbackFn();
            }
        };
        if (this.hasPendingLocalPatches.current) {
            debug$3('Not syncing value (has pending local patches)');
            retrySync(() => this.syncValue(), callbackFn);
            return;
        }
        // If the  editor is empty and there is a new value, just set that value directly.
        if (isEqualToEmptyEditor(this.slateInstance.children, this.portableTextFeatures) &&
            this.props.value) {
            this.slateInstance.children = toSlateValue(val, {
                portableTextFeatures: this.portableTextFeatures,
            }, KEY_TO_SLATE_ELEMENT.get(this.slateInstance));
            callbackFn();
            return;
        }
        // Test for diffs between our state value and the incoming value.
        const isEqualToValue = !(val || []).some((blk, index) => {
            const compareBlock = toSlateValue([blk], { portableTextFeatures: this.portableTextFeatures }, KEY_TO_SLATE_ELEMENT.get(this.slateInstance))[0];
            if (!isEqual(compareBlock, this.slateInstance.children[index])) {
                return true;
            }
            return false;
        });
        if (isEqualToValue) {
            debug$3('Not syncing value (value is equal)');
            return;
        }
        // Value is different - validate it.
        debug$3('Validating');
        const validation = validateValue(val, this.portableTextFeatures, this.keyGenerator);
        if (val && !validation.valid) {
            this.change$.next({
                type: 'invalidValue',
                resolution: validation.resolution,
                value: val,
            });
            this.setState({ invalidValueResolution: validation.resolution });
        }
        // Set the new value
        debug$3('Replacing changed nodes');
        if (this.props.value) {
            const slateValueFromProps = toSlateValue(val, {
                portableTextFeatures: this.portableTextFeatures,
            }, KEY_TO_SLATE_ELEMENT.get(this.slateInstance));
            this.slateInstance.children = slateValueFromProps;
        }
        else {
            this.slateInstance.children = [this.slateInstance.createPlaceholderBlock()];
        }
        callbackFn();
    };
    flush = () => {
        const { onChange } = this.props;
        const finalPatches = [...this.pendingPatches];
        if (finalPatches.length > 0) {
            debug$3('Flushing', finalPatches);
            finalPatches.forEach((p) => {
                this.returnedPatches.push(p);
            });
            onChange({ type: 'mutation', patches: finalPatches });
            this.pendingPatches = [];
        }
    };
    flushDebounced = debounce(this.flush, FLUSH_PATCHES_DEBOUNCE_MS, {
        leading: false,
        trailing: true,
    });
    // Static API methods
    static activeAnnotations = (editor) => {
        return editor && editor.editable ? editor.editable.activeAnnotations() : [];
    };
    static addAnnotation = (editor, type, value) => editor.editable?.addAnnotation(type, value);
    static blur = (editor) => {
        debug$3('Host blurred');
        editor.editable?.blur();
    };
    static delete = (editor, selection, options) => editor.editable?.delete(selection, options);
    static findDOMNode = (editor, element) => {
        // eslint-disable-next-line react/no-find-dom-node
        return editor.editable?.findDOMNode(element);
    };
    static findByPath = (editor, path) => {
        return editor.editable?.findByPath(path) || [];
    };
    static focus = (editor) => {
        debug$3('Host requesting focus');
        editor.editable?.focus();
    };
    static focusBlock = (editor) => {
        return editor.editable?.focusBlock();
    };
    static focusChild = (editor) => {
        return editor.editable?.focusChild();
    };
    static getPortableTextFeatures = (editor) => {
        return editor.portableTextFeatures;
    };
    static getSelection = (editor) => {
        return editor.editable ? editor.editable.getSelection() : null;
    };
    static getValue = (editor) => {
        return editor.editable?.getValue();
    };
    static hasBlockStyle = (editor, blockStyle) => {
        return editor.editable?.hasBlockStyle(blockStyle);
    };
    static hasListStyle = (editor, listStyle) => {
        return editor.editable?.hasListStyle(listStyle);
    };
    static isCollapsedSelection = (editor) => editor.editable?.isCollapsedSelection();
    static isExpandedSelection = (editor) => editor.editable?.isExpandedSelection();
    static isMarkActive = (editor, mark) => editor.editable?.isMarkActive(mark);
    static insertChild = (editor, type, value) => {
        debug$3(`Host inserting child`);
        return editor.editable?.insertChild(type, value);
    };
    static insertBlock = (editor, type, value) => {
        return editor.editable?.insertBlock(type, value);
    };
    static isVoid = (editor, element) => {
        return editor.editable?.isVoid(element);
    };
    static isObjectPath = (editor, path) => {
        if (!path || !Array.isArray(path))
            return false;
        const isChildObjectEditPath = path.length > 3 && path[1] === 'children';
        const isBlockObjectEditPath = path.length > 1 && path[1] !== 'children';
        return isBlockObjectEditPath || isChildObjectEditPath;
    };
    static marks = (editor) => {
        return editor.editable?.marks();
    };
    static select = (editor, selection) => {
        debug$3(`Host setting selection`, selection);
        editor.editable?.select(selection);
    };
    static removeAnnotation = (editor, type) => editor.editable?.removeAnnotation(type);
    static toggleBlockStyle = (editor, blockStyle) => {
        debug$3(`Host is toggling block style`);
        return editor.editable?.toggleBlockStyle(blockStyle);
    };
    static toggleList = (editor, listStyle) => {
        return editor.editable?.toggleList(listStyle);
    };
    static toggleMark = (editor, mark) => {
        debug$3(`Host toggling mark`, mark);
        editor.editable?.toggleMark(mark);
    };
}
const retrySync = throttle((syncFn, callbackFn) => syncFn(callbackFn), 100);
function bufferUntil(emitWhen) {
    return (source) => defer(() => {
        let buffer = []; // custom buffer
        return source.pipe(tap((v) => buffer.push(v)), // add values to buffer
        switchMap(() => (emitWhen(buffer) ? of(buffer) : EMPTY)), // emit the buffer when the condition is met
        tap(() => (buffer = [])) // clear the buffer
        );
    });
}
const NOOP$1 = () => undefined;

/**
 * Try to compact a set of patches
 *
 */
function compactPatches(patches) {
    // If the last patch is unsetting everything, just do that
    const lastPatch = patches.slice(-1)[0];
    if (lastPatch && lastPatch.type === 'unset' && lastPatch.path.length === 0) {
        return [lastPatch];
    }
    let finalPatches = patches;
    // Run through the patches and remove any redundant ones.
    finalPatches = finalPatches.filter((patch, index) => {
        if (!patch) {
            return false;
        }
        const nextPatch = finalPatches[index + 1];
        if (nextPatch &&
            nextPatch.type === 'set' &&
            patch.type === 'set' &&
            isEqual(patch.path, nextPatch.path)) {
            return false;
        }
        return true;
    });
    if (finalPatches.length !== patches.length) {
        return finalPatches;
    }
    return patches;
}

function normalizePoint(point, value) {
    if (!point || !value) {
        return null;
    }
    const newPath = [];
    let newOffset = point.offset || 0;
    const blockKey = typeof point.path[0] === 'object' && '_key' in point.path[0] && point.path[0]._key;
    const childKey = typeof point.path[2] === 'object' && '_key' in point.path[2] && point.path[2]._key;
    const block = value.find((blk) => blk._key === blockKey);
    if (block) {
        newPath.push({ _key: block._key });
    }
    else {
        return null;
    }
    if (block && point.path[1] === 'children') {
        if (!block.children || block.children.length === 0) {
            return null;
        }
        const child = block.children.find((cld) => cld._key === childKey);
        if (child) {
            newPath.push('children');
            newPath.push({ _key: child._key });
            newOffset =
                child.text && child.text.length >= point.offset
                    ? point.offset
                    : (child.text && child.text.length) || 0;
        }
        else {
            return null;
        }
    }
    return { path: newPath, offset: newOffset };
}
function normalizeSelection(selection, value) {
    if (!selection || !value || value.length === 0) {
        return null;
    }
    let newAnchor = null;
    let newFocus = null;
    const { anchor, focus } = selection;
    if (anchor && value.find((blk) => isEqual({ _key: blk._key }, anchor.path[0]))) {
        newAnchor = normalizePoint(anchor, value);
    }
    if (focus && value.find((blk) => isEqual({ _key: blk._key }, focus.path[0]))) {
        newFocus = normalizePoint(focus, value);
    }
    if (newAnchor && newFocus) {
        return { anchor: newAnchor, focus: newFocus };
    }
    return null;
}

function DefaultAnnotation(props) {
    // eslint-disable-next-line no-alert
    const handleClick = useCallback(() => alert(JSON.stringify(props.annotation)), [props.annotation]);
    return (React.createElement("span", { style: { color: 'blue' }, onClick: handleClick }, props.children));
}

const debug$2 = debugWithName('components:DraggableChild');
const DraggableChild = ({ children, element, readOnly }) => {
    const editor = useSlateStatic();
    const dragGhostRef = useRef();
    const isVoid = useMemo(() => Editor.isVoid(editor, element), [editor, element]);
    // Note: this is called not for the dragging block, but for the targets when the block is dragged over them
    const handleDragOver = useCallback((event) => {
        const isMyDragOver = IS_DRAGGING_CHILD_ELEMENT.get(editor);
        if (!isMyDragOver) {
            return;
        }
        debug$2('handle drag over');
        event.preventDefault(); // Needed to get the dropEffect showing
        event.dataTransfer.dropEffect = 'move';
        // Find the range where the drop happened
        const range = ReactEditor.findEventRange(editor, event);
        if (range) {
            IS_DRAGGING_ELEMENT_RANGE.set(editor, range);
            Transforms.select(editor, range);
        }
    }, [editor]);
    // Note: this is called for the dragging child
    const handleDragStart = useCallback((event) => {
        debug$2('Drag start');
        IS_DRAGGING.set(editor, true);
        IS_DRAGGING_CHILD_ELEMENT.set(editor, element);
        if (isVoid) {
            event.dataTransfer.effectAllowed = 'move';
            // Specify dragImage so that single elements in the preview will not be the drag image,
            // but always the whole block preview itself.
            // Also clone it so that it will not be visually clipped by scroll-containers etc.
            const elm = event.currentTarget;
            if (elm instanceof HTMLElement) {
                const dragGhost = elm.cloneNode(true);
                dragGhostRef.current = dragGhost;
                dragGhost.style.width = `${elm.clientWidth}px`;
                dragGhost.style.height = `${elm.clientHeight}px`;
                dragGhost.style.position = 'absolute';
                dragGhost.style.top = '-99999px';
                dragGhost.style.left = '-99999px';
                if (document.body) {
                    document.body.appendChild(dragGhost);
                    const rect = elm.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    dragGhost.style.width = `${rect.width}px`;
                    dragGhost.style.height = `${rect.height}px`;
                    event.dataTransfer.setDragImage(dragGhost, x, y);
                }
            }
        }
    }, [editor, element, isVoid]);
    if (readOnly) {
        return children;
    }
    return (React.createElement("span", { draggable: isVoid, onDragStart: handleDragStart, onDragOver: handleDragOver }, children));
};

debugWithName('components:Leaf');
const Leaf = (props) => {
    const editor = useSlateStatic();
    const selected = useSelected();
    const { attributes, children, leaf, portableTextFeatures, keyGenerator, renderChild, readOnly } = props;
    const spanRef = React.useRef(null);
    let returnedChildren = children;
    const focused = (selected && editor.selection && Range.isCollapsed(editor.selection)) || false;
    const handleMouseDown = useCallback((event) => {
        // Slate will deselect this when it is already selected and clicked again, so prevent that. 2020/05/04
        if (focused) {
            event.stopPropagation();
            event.preventDefault();
        }
    }, [focused]);
    if (Text.isText(leaf) && leaf._type === portableTextFeatures.types.span.name) {
        const blockElement = children.props.parent;
        const path = blockElement ? [{ _key: blockElement._key }, 'children', { _key: leaf._key }] : [];
        const decoratorValues = portableTextFeatures.decorators.map((dec) => dec.value);
        const marks = uniq((Array.isArray(leaf.marks) ? leaf.marks : []).filter((mark) => decoratorValues.includes(mark)));
        marks.forEach((mark) => {
            const type = portableTextFeatures.decorators.find((dec) => dec.value === mark);
            if (type) {
                // TODO: look into this API!
                if (type?.blockEditor?.render) {
                    const CustomComponent = type?.blockEditor?.render;
                    returnedChildren = React.createElement(CustomComponent, { mark: mark }, returnedChildren);
                }
                if (props.renderDecorator) {
                    returnedChildren = props.renderDecorator(mark, type, { focused, selected, path }, () => React.createElement(React.Fragment, null, returnedChildren), spanRef);
                }
            }
        });
        const annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : [];
        const annotations = annotationMarks
            .map((mark) => !decoratorValues.includes(mark) &&
            blockElement &&
            blockElement.markDefs &&
            blockElement.markDefs.find((def) => def._key === mark))
            .filter(Boolean);
        if (annotations.length > 0) {
            annotations.forEach((annotation) => {
                const type = portableTextFeatures.types.annotations.find((t) => t.name === annotation._type);
                // TODO: look into this API!
                const CustomComponent = type?.blockEditor?.render;
                const defaultRender = () => 
                // TODO: annotation should be an own prop here, keeping for backward compability (2020/05/18).
                CustomComponent ? (React.createElement(CustomComponent, { ...annotation, attributes: attributes }, returnedChildren)) : (React.createElement(React.Fragment, null, returnedChildren));
                if (type) {
                    if (props.renderAnnotation) {
                        returnedChildren = (React.createElement("span", { ref: spanRef, key: keyGenerator() }, props.renderAnnotation(annotation, type, { focused, selected, path, annotations }, defaultRender, spanRef)));
                    }
                    else {
                        returnedChildren = (React.createElement(DefaultAnnotation, { annotation: annotation },
                            React.createElement("span", { ref: spanRef, key: keyGenerator(), onMouseDown: handleMouseDown }, defaultRender())));
                    }
                }
            });
        }
        if (blockElement && renderChild) {
            const child = blockElement.children.find((_child) => _child._key === leaf._key); // Ensure object equality
            if (child) {
                returnedChildren = renderChild(child, portableTextFeatures.types.span, { focused, selected, path, annotations }, () => returnedChildren, spanRef);
            }
        }
    }
    const key = leaf._key || keyGenerator();
    return (React.createElement("span", { key: key, ...attributes, ref: spanRef },
        React.createElement(DraggableChild, { element: leaf, readOnly: readOnly }, returnedChildren)));
};

const DefaultBlockObject = styled.div `
  user-select: none;
  border: ${(props) => {
    if (props.selected) {
        return '1px solid blue';
    }
    return '1px solid transparent';
}};
`;
styled.span `
  background: #999;
  border: ${(props) => {
    if (props.selected) {
        return '1px solid blue';
    }
    return '1px solid transparent';
}};
`;
const DefaultListItem = styled.div `
  &.pt-list-item {
    width: fit-content;
    position: relative;
    display: block;

    /* Important 'transform' in order to force refresh the ::before and ::after rules
      in Webkit: https://stackoverflow.com/a/21947628/831480
    */
    transform: translateZ(0);
    margin-left: ${(props) => getLeftPositionForListLevel(props.listLevel)};
  }
  &.pt-list-item > .pt-list-item-inner {
    display: flex;
    margin: 0;
    padding: 0;
    &:before {
      justify-content: flex-start;
      vertical-align: top;
    }
  }
  &.pt-list-item-bullet > .pt-list-item-inner:before {
      content: '${(props) => getContentForListLevelAndStyle(props.listLevel, props.listStyle)}';
      font-size: 0.4375rem; /* 7px */
      line-height: 1.5rem; /* Same as body text */
      /* Optical alignment */
      position: relative;
    }
  }
  &.pt-list-item-bullet > .pt-list-item-inner {
    &:before {
      min-width: 1.5rem; /* Make sure space between bullet and text never shrinks */
    }
  }
  &.pt-list-item-number {
    counter-increment: ${(props) => getCounterIncrementForListLevel(props.listLevel)};
    counter-reset: ${(props) => getCounterResetForListLevel(props.listLevel)};
  }
  & + :not(.pt-list-item-number) {
    counter-reset: listItemNumber;
  }
  &.pt-list-item-number > .pt-list-item-inner:before {
    content: ${(props) => getCounterContentForListLevel(props.listLevel)};
    min-width: 1.5rem; /* Make sure space between number and text never shrinks */
    /* Optical alignment */
    position: relative;
    top: 1px;
  }
`;
const DefaultListItemInner = styled.div ``;
function getLeftPositionForListLevel(level) {
    switch (Number(level)) {
        case 1:
            return '1.5em';
        case 2:
            return '3em';
        case 3:
            return '4.5em';
        case 4:
            return '6em';
        case 5:
            return '7.5em';
        case 6:
            return '9em';
        case 7:
            return '10.5em';
        case 8:
            return '12em';
        case 9:
            return '13.5em';
        case 10:
            return '15em';
        default:
            return '0em';
    }
}
const bullets = ['●', '○', '■'];
function getContentForListLevelAndStyle(level, style) {
    const normalizedLevel = (level - 1) % 3;
    if (style === 'bullet') {
        return bullets[normalizedLevel];
    }
    return '*';
}
function getCounterIncrementForListLevel(level) {
    switch (level) {
        case 1:
            return 'listItemNumber';
        case 2:
            return 'listItemAlpha';
        case 3:
            return 'listItemRoman';
        case 4:
            return 'listItemNumberNext';
        case 5:
            return 'listItemLetterNext';
        case 6:
            return 'listItemRomanNext';
        case 7:
            return 'listItemNumberNextNext';
        case 8:
            return 'listItemAlphaNextNext';
        case 9:
            return 'listItemRomanNextNext';
        default:
            return 'listItemNumberNextNextNext';
    }
}
function getCounterResetForListLevel(level) {
    switch (level) {
        case 1:
            return 'listItemAlpha';
        case 2:
            return 'listItemRoman';
        case 3:
            return 'listItemNumberNext';
        case 4:
            return 'listItemLetterNext';
        case 5:
            return 'listItemRomanNext';
        case 6:
            return 'listItemNumberNextNext';
        case 7:
            return 'listItemAlphaNextNext';
        case 8:
            return 'listItemRomanNextNext';
        case 9:
            return 'listItemNumberNextNextNext';
        default:
            return 'listItemNumberNextNextNext';
    }
}
function getCounterContentForListLevel(level) {
    switch (level) {
        case 1:
            return `counter(listItemNumber) '. '`;
        case 2:
            return `counter(listItemAlpha, lower-alpha) '. '`;
        case 3:
            return `counter(listItemRoman, lower-roman) '. '`;
        case 4:
            return `counter(listItemNumberNext) '. '`;
        case 5:
            return `counter(listItemLetterNext, lower-alpha) '. '`;
        case 6:
            return `counter(listItemRomanNext, lower-roman) '. '`;
        case 7:
            return `counter(listItemNumberNextNext) '. '`;
        case 8:
            return `counter(listItemAlphaNextNext, lower-alpha) '. '`;
        case 9:
            return `counter(listItemRomanNextNext, lower-roman) '. '`;
        default:
            return `counter(listItemNumberNextNextNext) '. '`;
    }
}

function TextBlock(props) {
    const { portableTextFeatures, children, block } = props;
    const style = block.style || portableTextFeatures.styles[0].value;
    // Should we render a custom style?
    // TODO: Look into this API. This is legacy support for older Sanity Studio versions via the type
    let CustomStyle;
    const blockStyle = portableTextFeatures && style
        ? portableTextFeatures.styles.find((item) => item.value === style)
        : undefined;
    if (blockStyle) {
        CustomStyle = blockStyle.blockEditor && blockStyle.blockEditor.render;
    }
    let renderedBlock = children;
    if ('listItem' in block && block.listItem) {
        renderedBlock = (React.createElement(DefaultListItem, { listStyle: block.listItem || portableTextFeatures.lists[0].value, listLevel: block.level || 0 },
            React.createElement(DefaultListItemInner, null, renderedBlock)));
    }
    return (React.createElement(React.Fragment, null,
        !CustomStyle && renderedBlock,
        CustomStyle && React.createElement(CustomStyle, { style: style }, renderedBlock)));
}

const DefaultObject = (props) => {
    return React.createElement("pre", null, JSON.stringify(props.value, null, 2));
};

const debug$1 = debugWithName('components:DraggableBlock');
const DraggableBlock = ({ children, element, readOnly, blockRef }) => {
    const editor = useSlateStatic();
    const dragGhostRef = useRef();
    const [isDragOver, setIsDragOver] = useState(false);
    const isVoid = useMemo(() => Editor.isVoid(editor, element), [editor, element]);
    const isInline = useMemo(() => Editor.isInline(editor, element), [editor, element]);
    const [blockElement, setBlockElement] = useState(null);
    useEffect(() => setBlockElement(blockRef ? blockRef.current : ReactEditor.toDOMNode(editor, element)), [editor, element, blockRef]);
    // Note: this is called not for the dragging block, but for the targets when the block is dragged over them
    const handleDragOver = useCallback((event) => {
        const isMyDragOver = IS_DRAGGING_BLOCK_ELEMENT.get(editor);
        // debug('Drag over', blockElement)
        if (!isMyDragOver || !blockElement) {
            return;
        }
        event.preventDefault();
        event.dataTransfer.dropEffect = 'move';
        IS_DRAGGING_ELEMENT_TARGET.set(editor, element);
        const elementRect = blockElement.getBoundingClientRect();
        const offset = elementRect.top;
        const height = elementRect.height;
        const Y = event.pageY;
        const loc = Math.abs(offset - Y);
        let position = 'bottom';
        if (element === editor.children[0]) {
            position = 'top';
        }
        else if (loc < height / 2) {
            position = 'top';
            IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position);
        }
        else {
            position = 'bottom';
            IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position);
        }
        if (isMyDragOver === element) {
            event.dataTransfer.dropEffect = 'none';
            return;
        }
        setIsDragOver(true);
    }, [blockElement, editor, element]);
    // Note: this is called not for the dragging block, but for the targets when the block is dragged over them
    const handleDragLeave = useCallback(() => {
        setIsDragOver(false);
    }, []);
    // Note: this is called for the dragging block
    const handleDragEnd = useCallback((event) => {
        const targetBlock = IS_DRAGGING_ELEMENT_TARGET.get(editor);
        if (targetBlock) {
            IS_DRAGGING.set(editor, false);
            event.preventDefault();
            event.stopPropagation();
            IS_DRAGGING_ELEMENT_TARGET.delete(editor);
            if (dragGhostRef.current) {
                debug$1('Removing drag ghost');
                document.body.removeChild(dragGhostRef.current);
            }
            const dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);
            IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor);
            let targetPath = ReactEditor.findPath(editor, targetBlock);
            const myPath = ReactEditor.findPath(editor, element);
            const isBefore = Path.isBefore(myPath, targetPath);
            if (dragPosition === 'bottom' && !isBefore) {
                // If it is already at the bottom, don't do anything.
                if (targetPath[0] >= editor.children.length - 1) {
                    debug$1('target is already at the bottom, not moving');
                    return;
                }
                const originalPath = targetPath;
                targetPath = Path.next(targetPath);
                debug$1(`Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(targetPath)}`);
            }
            if (dragPosition === 'top' && isBefore && targetPath[0] !== editor.children.length - 1) {
                const originalPath = targetPath;
                targetPath = Path.previous(targetPath);
                debug$1(`Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(targetPath)}`);
            }
            if (Path.equals(targetPath, myPath)) {
                event.preventDefault();
                debug$1('targetPath and myPath is the same, not moving');
                return;
            }
            debug$1(`Moving element ${element._key} from path ${JSON.stringify(myPath)} to ${JSON.stringify(targetPath)} (${dragPosition})`);
            Transforms.moveNodes(editor, { at: myPath, to: targetPath });
            editor.onChange();
            return;
        }
        debug$1('No target element, not doing anything');
    }, [editor, element]);
    // Note: this is called not for the dragging block, but for the drop target
    const handleDrop = useCallback((event) => {
        if (IS_DRAGGING_BLOCK_ELEMENT.get(editor)) {
            debug$1('On drop (prevented)', element);
            event.preventDefault();
            event.stopPropagation();
            setIsDragOver(false);
        }
    }, [editor, element]);
    // Note: this is called for the dragging block
    const handleDrag = useCallback((event) => {
        if (!isVoid) {
            IS_DRAGGING_BLOCK_ELEMENT.delete(editor);
            return;
        }
        IS_DRAGGING.set(editor, true);
        IS_DRAGGING_BLOCK_ELEMENT.set(editor, element);
        event.stopPropagation(); // Stop propagation so that leafs don't get this and take focus/selection!
        const target = event.target;
        if (target instanceof HTMLElement) {
            target.style.opacity = '1';
        }
    }, [editor, element, isVoid]);
    // Note: this is called for the dragging block
    const handleDragStart = useCallback((event) => {
        if (!isVoid || isInline) {
            debug$1('Not dragging block');
            IS_DRAGGING_BLOCK_ELEMENT.delete(editor);
            IS_DRAGGING.set(editor, false);
            return;
        }
        debug$1('Drag start');
        IS_DRAGGING.set(editor, true);
        if (event.dataTransfer) {
            event.dataTransfer.setData('application/portable-text', 'something');
            event.dataTransfer.effectAllowed = 'move';
        }
        // Clone blockElement so that it will not be visually clipped by scroll-containers etc.
        // The application that uses the portable-text-editor may indicate the element used as
        // drag ghost by adding a truthy data attribute 'data-pt-drag-ghost-element' to a HTML element.
        if (blockElement && blockElement instanceof HTMLElement) {
            let dragGhost = blockElement.cloneNode(true);
            const customGhost = dragGhost.querySelector('[data-pt-drag-ghost-element]');
            if (customGhost) {
                dragGhost = customGhost;
            }
            // Set the `data-dragged` attribute so the consumer can style the element while it’s dragged
            dragGhost.setAttribute('data-dragged', '');
            if (document.body) {
                dragGhostRef.current = dragGhost;
                dragGhost.style.position = 'absolute';
                dragGhost.style.left = '-99999px';
                dragGhost.style.boxSizing = 'border-box';
                document.body.appendChild(dragGhost);
                const rect = blockElement.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                dragGhost.style.width = `${rect.width}px`;
                dragGhost.style.height = `${rect.height}px`;
                event.dataTransfer.setDragImage(dragGhost, x, y);
            }
        }
        handleDrag(event);
    }, [blockElement, editor, handleDrag, isInline, isVoid]);
    const isDraggingOverFirstBlock = isDragOver && editor.children[0] === IS_DRAGGING_ELEMENT_TARGET.get(editor);
    const isDraggingOverLastBlock = isDragOver &&
        editor.children[editor.children.length - 1] === IS_DRAGGING_ELEMENT_TARGET.get(editor);
    const dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);
    const isDraggingOverTop = isDraggingOverFirstBlock ||
        (isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition === 'top');
    const isDraggingOverBottom = isDraggingOverLastBlock ||
        (isDragOver &&
            !isDraggingOverFirstBlock &&
            !isDraggingOverLastBlock &&
            dragPosition === 'bottom');
    const dropIndicator = useMemo(() => (React.createElement("div", { className: "pt-drop-indicator", style: {
            position: 'absolute',
            width: '100%',
            height: 1,
            borderBottom: '1px solid currentColor',
            zIndex: 5,
        } })), []);
    if (readOnly) {
        return React.createElement(React.Fragment, null, children);
    }
    return (React.createElement("div", { draggable: isVoid, onDragStart: handleDragStart, onDrag: handleDrag, onDragOver: handleDragOver, onDragLeave: handleDragLeave, onDragEnd: handleDragEnd, onDrop: handleDrop },
        isDraggingOverTop && dropIndicator,
        children,
        isDraggingOverBottom && dropIndicator));
};

debugWithName('components:Element');
const inlineBlockStyle = { display: 'inline-block' };
const defaultRender = (value) => {
    return React.createElement(DefaultObject, { value: value });
};
// eslint-disable-next-line max-statements
const Element = ({ attributes, children, element, portableTextFeatures, readOnly, renderBlock, renderChild, spellCheck, }) => {
    const editor = useSlateStatic();
    const selected = useSelected();
    const blockRef = useRef(null);
    const inlineBlockObjectRef = useRef(null);
    const focused = (selected && editor.selection && Range.isCollapsed(editor.selection)) || false;
    let className;
    if (typeof element._type !== 'string') {
        throw new Error(`Expected element to have a _type property`);
    }
    if (typeof element._key !== 'string') {
        throw new Error(`Expected element to have a _key property`);
    }
    // Test for inline objects first
    if (editor.isInline(element)) {
        const path = ReactEditor.findPath(editor, element);
        const [block] = Editor.node(editor, path, { depth: 1 });
        const type = portableTextFeatures.types.inlineObjects.find((_type) => _type.name === element._type);
        if (!type) {
            throw new Error('Could not find type for inline block element');
        }
        if (Element$1.isElement(block)) {
            const elmPath = [{ _key: block._key }, 'children', { _key: element._key }];
            return (React.createElement("span", { ...attributes },
                children,
                React.createElement(DraggableChild, { element: element, readOnly: readOnly },
                    React.createElement("span", { className: "pt-inline-object", ref: inlineBlockObjectRef, key: element._key, style: inlineBlockStyle, contentEditable: false },
                        renderChild &&
                            renderChild(fromSlateValue([element], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0], type, { focused, selected, path: elmPath }, defaultRender, inlineBlockObjectRef),
                        !renderChild &&
                            defaultRender(fromSlateValue([element], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0])))));
        }
        throw new Error('Block not found!');
    }
    const renderAttribs = { focused, selected, path: [{ _key: element._key }] };
    // If not inline, it's either a block (text) or a block object (non-text)
    // NOTE: text blocks aren't draggable with DraggableBlock (yet?)
    if (element._type === portableTextFeatures.types.block.name) {
        className = `pt-block pt-text-block`;
        const isListItem = 'listItem' in element;
        const hasStyle = 'style' in element;
        if (hasStyle) {
            renderAttribs.style = element.style || 'normal';
            className = `pt-block pt-text-block pt-text-block-style-${element.style}`;
        }
        if (isListItem) {
            renderAttribs.listItem = element.listItem;
            if (Number.isInteger(element.level)) {
                renderAttribs.level = element.level;
            }
            else {
                renderAttribs.level = 1;
            }
            className += ` pt-list-item pt-list-item-${renderAttribs.listItem} pt-list-item-level-${renderAttribs.level}`;
        }
        const textBlock = (React.createElement(TextBlock, { block: element, portableTextFeatures: portableTextFeatures }, children));
        const propsOrDefaultRendered = renderBlock
            ? renderBlock(fromSlateValue([element], element._type, KEY_TO_VALUE_ELEMENT.get(editor))[0], portableTextFeatures.types.block, renderAttribs, () => textBlock, blockRef)
            : textBlock;
        return (React.createElement("div", { key: element._key, ...attributes, className: className, spellCheck: spellCheck },
            React.createElement(DraggableBlock, { element: element, readOnly: readOnly, blockRef: blockRef },
                React.createElement("div", { ref: blockRef }, propsOrDefaultRendered))));
    }
    const type = portableTextFeatures.types.blockObjects.find((_type) => _type.name === element._type);
    if (!type) {
        throw new Error(`Could not find schema type for block element of _type ${element._type}`);
    }
    className = 'pt-block pt-object-block';
    const block = fromSlateValue([element], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
    const renderedBlockFromProps = renderBlock && renderBlock(block, type, renderAttribs, defaultRender, blockRef);
    return (React.createElement("div", { key: element._key, ...attributes, className: className },
        children,
        React.createElement(DraggableBlock, { element: element, readOnly: readOnly, blockRef: blockRef },
            renderedBlockFromProps && (React.createElement("div", { ref: blockRef, contentEditable: false }, renderedBlockFromProps)),
            !renderedBlockFromProps && (React.createElement(DefaultBlockObject, { selected: selected }, defaultRender(fromSlateValue([element], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0]))))));
};

const useIsomorphicEffect = typeof window === 'undefined' ? useEffect : useLayoutEffect;
function useForwardedRef(ref) {
    const innerRef = useRef(null);
    useIsomorphicEffect(() => {
        if (!ref)
            return;
        if (typeof ref === 'function') {
            ref(innerRef.current);
        }
        else {
            ref.current = innerRef.current;
        }
    });
    return innerRef;
}

const debug = debugWithName('component:Editable');
const PLACEHOLDER_STYLE = {
    opacity: 0.5,
    position: 'absolute',
    userSelect: 'none',
    pointerEvents: 'none',
};
const NOOP = () => {
    // Nope
};
const EMPTY_DECORATORS = [];
const PortableTextEditable = forwardRef(function PortableTextEditable(props, forwardedRef) {
    const { hotkeys, onBeforeInput, onPaste, onCopy, renderAnnotation, renderBlock, renderChild, renderDecorator, renderPlaceholder, readOnly, selection: propsSelection, scrollSelectionIntoView, spellCheck, ...restProps } = props;
    const portableTextEditor = usePortableTextEditor();
    const ref = useForwardedRef(forwardedRef);
    const { change$, keyGenerator, portableTextFeatures, slateInstance: slateEditor, } = portableTextEditor;
    const isEmpty = useMemo(() => isEqualToEmptyEditor(slateEditor.children, portableTextFeatures), [portableTextFeatures, slateEditor.children]);
    // React/UI-spesific plugins
    const withInsertData = useMemo(() => createWithInsertData(change$, portableTextFeatures, keyGenerator), [change$, keyGenerator, portableTextFeatures]);
    const withHotKeys = useMemo(() => createWithHotkeys(portableTextFeatures, keyGenerator, portableTextEditor, hotkeys), [hotkeys, keyGenerator, portableTextEditor, portableTextFeatures]);
    // Create the PortableTextEditor API
    const withEditableAPI = useMemo(() => createWithEditableAPI(portableTextEditor, portableTextFeatures, keyGenerator), [keyGenerator, portableTextEditor, portableTextFeatures]);
    // Update the Slate instance's plugins which are dependent on props for Editable
    useMemo(() => {
        if (readOnly) {
            debug('Editable is in read only mode');
            return withReact(slateEditor);
        }
        debug('Editable is in edit mode');
        return withEditableAPI(withInsertData(withHotKeys(withReact(slateEditor))));
    }, [readOnly, slateEditor, withEditableAPI, withHotKeys, withInsertData]);
    const renderElement = useCallback((eProps) => (React.createElement(Element, { ...eProps, portableTextFeatures: portableTextFeatures, readOnly: readOnly, renderBlock: renderBlock, renderChild: renderChild, spellCheck: spellCheck })), [portableTextFeatures, spellCheck, readOnly, renderBlock, renderChild]);
    const renderLeaf = useCallback((lProps) => {
        if (renderPlaceholder && lProps.leaf.placeholder && lProps.text.text === '') {
            return (React.createElement(React.Fragment, null,
                React.createElement("div", { style: PLACEHOLDER_STYLE, contentEditable: false }, renderPlaceholder()),
                React.createElement(Leaf, { ...lProps, keyGenerator: keyGenerator, portableTextFeatures: portableTextFeatures, renderAnnotation: renderAnnotation, renderChild: renderChild, renderDecorator: renderDecorator, readOnly: readOnly })));
        }
        return (React.createElement(Leaf, { ...lProps, keyGenerator: keyGenerator, portableTextFeatures: portableTextFeatures, renderAnnotation: renderAnnotation, renderChild: renderChild, renderDecorator: renderDecorator, readOnly: readOnly }));
    }, [
        readOnly,
        keyGenerator,
        portableTextFeatures,
        renderAnnotation,
        renderChild,
        renderDecorator,
        renderPlaceholder,
    ]);
    // Restore selection from props
    useEffect(() => {
        if (propsSelection) {
            debug(`Selection from props ${JSON.stringify(propsSelection)}`);
            const normalizedSelection = normalizeSelection(propsSelection, fromSlateValue(slateEditor.children, portableTextFeatures.types.block.name));
            if (normalizedSelection !== null) {
                debug(`Normalized selection from props ${JSON.stringify(normalizedSelection)}`);
                const slateRange = toSlateRange(normalizedSelection, slateEditor);
                if (slateRange) {
                    Transforms.select(slateEditor, slateRange);
                    // Output selection here in those cases where the editor selection was the same, and there are no set selection operations in the
                    // editor (this is usually automatically outputted by the withPortableTextSelections plugin)
                    if (!slateEditor.operations.some((o) => o.type === 'set_selection')) {
                        change$.next({ type: 'selection', selection: normalizedSelection });
                    }
                    slateEditor.onChange();
                }
            }
        }
    }, [slateEditor, propsSelection, portableTextFeatures.types.block.name, change$]);
    // Set initial selection from props
    useEffect(() => {
        if (propsSelection) {
            PortableTextEditor.select(portableTextEditor, propsSelection);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []); // Only initial
    // Handle from props onCopy function
    const handleCopy = useCallback((event) => {
        if (onCopy) {
            const result = onCopy(event);
            // CopyFn may return something to avoid doing default stuff
            if (result !== undefined) {
                event.preventDefault();
            }
        }
    }, [onCopy]);
    // Handle incoming pasting events in the editor
    const handlePaste = useCallback((event) => {
        if (!slateEditor.selection) {
            return;
        }
        if (onPaste) {
            const resolveOnPasteResultOrError = () => {
                try {
                    return onPaste({
                        event,
                        value: PortableTextEditor.getValue(portableTextEditor),
                        path: slateEditor.selection?.focus.path || [],
                        portableTextFeatures,
                        type: portableTextFeatures.types.portableText, // For legacy support
                    });
                }
                catch (error) {
                    return error;
                }
            };
            // Resolve it as promise (can be either async promise or sync return value)
            const resolved = Promise.resolve(resolveOnPasteResultOrError());
            resolved
                .then((result) => {
                debug('Custom paste function from client resolved', result);
                change$.next({ type: 'loading', isLoading: true });
                if (!result) {
                    return;
                }
                if (result instanceof Error) {
                    throw result;
                }
                if (result && result.insert) {
                    event.preventDefault(); // Stop the chain
                    slateEditor.insertFragment(toSlateValue(result.insert, { portableTextFeatures }));
                    change$.next({ type: 'loading', isLoading: false });
                    return;
                }
                console.warn('Your onPaste function returned something unexpected:', result);
            })
                .catch((error) => {
                change$.next({ type: 'loading', isLoading: false });
                console.error(error); // eslint-disable-line no-console
                return error;
            });
        }
        event.preventDefault();
        slateEditor.insertData(event.clipboardData);
    }, [change$, onPaste, portableTextEditor, portableTextFeatures, slateEditor]);
    const handleOnFocus = useCallback(() => {
        change$.next({ type: 'focus' });
    }, [change$]);
    const handleOnBlur = useCallback(() => {
        change$.next({ type: 'blur' });
    }, [change$]);
    const handleOnBeforeInput = useCallback((event) => {
        if (onBeforeInput) {
            onBeforeInput(event);
        }
    }, [onBeforeInput]);
    const handleKeyDown = slateEditor.pteWithHotKeys;
    const scrollSelectionIntoViewToSlate = useMemo(() => {
        // Use slate-react default scroll into view
        if (scrollSelectionIntoView === undefined) {
            return undefined;
        }
        // Disable scroll into view totally
        if (scrollSelectionIntoView === null) {
            return NOOP;
        }
        // Translate PortableTextEditor prop fn to Slate plugin fn
        return (editor, domRange) => {
            scrollSelectionIntoView(portableTextEditor, domRange);
        };
    }, [portableTextEditor, scrollSelectionIntoView]);
    const decorate = useCallback(() => {
        if (isEmpty && slateEditor.children.length <= 1) {
            return [
                {
                    anchor: {
                        path: [0, 0],
                        offset: 0,
                    },
                    focus: {
                        path: [0, 0],
                        offset: 0,
                    },
                    placeholder: true,
                },
            ];
        }
        return EMPTY_DECORATORS;
    }, [isEmpty, slateEditor.children]);
    // The editor
    const slateEditable = useMemo(() => (React.createElement(Editable, { autoFocus: false, className: "pt-editable", decorate: decorate, onBlur: handleOnBlur, onCopy: handleCopy, onDOMBeforeInput: handleOnBeforeInput, onFocus: handleOnFocus, onKeyDown: handleKeyDown, onPaste: handlePaste, readOnly: readOnly, renderElement: renderElement, renderLeaf: renderLeaf, scrollSelectionIntoView: scrollSelectionIntoViewToSlate })), [
        decorate,
        handleCopy,
        handleKeyDown,
        handleOnBeforeInput,
        handleOnBlur,
        handleOnFocus,
        handlePaste,
        readOnly,
        renderElement,
        renderLeaf,
        scrollSelectionIntoViewToSlate,
    ]);
    if (!portableTextEditor) {
        return null;
    }
    return (React.createElement("div", { ref: ref, ...restProps }, slateEditable));
});

export { PortableTextEditable, PortableTextEditor, compactPatches, getPortableTextFeatures, defaultKeyGenerator as keyGenerator, usePortableTextEditor, usePortableTextEditorSelection };
//# sourceMappingURL=index.js.map
