import React, { useCallback } from 'react';
import { Range, Text } from 'slate';
import { useSelected, useSlateStatic } from '@sanity/slate-react';
import { uniq } from 'lodash';
import { debugWithName } from '../utils/debug';
import { DefaultAnnotation } from './nodes/DefaultAnnotation';
import { DraggableChild } from './DraggableChild';
const debug = debugWithName('components:Leaf');
const debugRenders = false;
export const Leaf = (props) => {
    const editor = useSlateStatic();
    const selected = useSelected();
    const { attributes, children, leaf, portableTextFeatures, keyGenerator, renderChild, readOnly } = props;
    const spanRef = React.useRef(null);
    let returnedChildren = children;
    const focused = (selected && editor.selection && Range.isCollapsed(editor.selection)) || false;
    const handleMouseDown = useCallback((event) => {
        // Slate will deselect this when it is already selected and clicked again, so prevent that. 2020/05/04
        if (focused) {
            event.stopPropagation();
            event.preventDefault();
        }
    }, [focused]);
    if (Text.isText(leaf) && leaf._type === portableTextFeatures.types.span.name) {
        const blockElement = children.props.parent;
        const path = blockElement ? [{ _key: blockElement._key }, 'children', { _key: leaf._key }] : [];
        const decoratorValues = portableTextFeatures.decorators.map((dec) => dec.value);
        const marks = uniq((Array.isArray(leaf.marks) ? leaf.marks : []).filter((mark) => decoratorValues.includes(mark)));
        marks.forEach((mark) => {
            const type = portableTextFeatures.decorators.find((dec) => dec.value === mark);
            if (type) {
                // TODO: look into this API!
                if (type?.blockEditor?.render) {
                    const CustomComponent = type?.blockEditor?.render;
                    returnedChildren = React.createElement(CustomComponent, { mark: mark }, returnedChildren);
                }
                if (props.renderDecorator) {
                    returnedChildren = props.renderDecorator(mark, type, { focused, selected, path }, () => React.createElement(React.Fragment, null, returnedChildren), spanRef);
                }
            }
        });
        const annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : [];
        const annotations = annotationMarks
            .map((mark) => !decoratorValues.includes(mark) &&
            blockElement &&
            blockElement.markDefs &&
            blockElement.markDefs.find((def) => def._key === mark))
            .filter(Boolean);
        if (annotations.length > 0) {
            annotations.forEach((annotation) => {
                const type = portableTextFeatures.types.annotations.find((t) => t.name === annotation._type);
                // TODO: look into this API!
                const CustomComponent = type?.blockEditor?.render;
                const defaultRender = () => 
                // TODO: annotation should be an own prop here, keeping for backward compability (2020/05/18).
                CustomComponent ? (React.createElement(CustomComponent, { ...annotation, attributes: attributes }, returnedChildren)) : (React.createElement(React.Fragment, null, returnedChildren));
                if (type) {
                    if (props.renderAnnotation) {
                        returnedChildren = (React.createElement("span", { ref: spanRef, key: keyGenerator() }, props.renderAnnotation(annotation, type, { focused, selected, path, annotations }, defaultRender, spanRef)));
                    }
                    else {
                        returnedChildren = (React.createElement(DefaultAnnotation, { annotation: annotation },
                            React.createElement("span", { ref: spanRef, key: keyGenerator(), onMouseDown: handleMouseDown }, defaultRender())));
                    }
                }
            });
        }
        if (blockElement && renderChild) {
            const child = blockElement.children.find((_child) => _child._key === leaf._key); // Ensure object equality
            if (child) {
                returnedChildren = renderChild(child, portableTextFeatures.types.span, { focused, selected, path, annotations }, () => returnedChildren, spanRef);
            }
        }
    }
    if (debugRenders) {
        debug(`Render ${leaf._key} (span)`);
    }
    const key = leaf._key || keyGenerator();
    return (React.createElement("span", { key: key, ...attributes, ref: spanRef },
        React.createElement(DraggableChild, { element: leaf, readOnly: readOnly }, returnedChildren)));
};
//# sourceMappingURL=Leaf.js.map