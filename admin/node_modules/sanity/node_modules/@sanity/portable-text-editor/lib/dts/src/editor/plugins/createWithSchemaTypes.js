import { Text as SlateText } from 'slate';
import { debugWithName } from '../../utils/debug';
const debug = debugWithName('plugin:withSchemaTypes');
/**
 * This plugin makes sure that shema types are recognized properly by Slate as blocks, voids, inlines
 *
 */
export function createWithSchemaTypes(portableTextFeatures) {
    return function withSchemaTypes(editor) {
        editor.isTextBlock = (value) => {
            return (!editor.isVoid(value) &&
                'markDefs' in value &&
                'style' in value &&
                'children' in value &&
                '_type' in value &&
                portableTextFeatures.types.block.name === value._type);
        };
        editor.isTextSpan = (value) => {
            return (!editor.isVoid(value) &&
                'text' in value &&
                'marks' in value &&
                '_type' in value &&
                portableTextFeatures.types.span.name === value._type);
        };
        editor.isListBlock = (value) => {
            return Boolean(editor.isTextBlock(value) &&
                'listItem' in value &&
                'level' in value &&
                value.listItem &&
                Number.isInteger(value.level));
        };
        editor.isVoid = (element) => {
            return (portableTextFeatures.types.block.name !== element._type &&
                (portableTextFeatures.types.blockObjects.map((obj) => obj.name).includes(element._type) ||
                    portableTextFeatures.types.inlineObjects.map((obj) => obj.name).includes(element._type)));
        };
        editor.isInline = (element) => {
            const inlineSchemaTypes = portableTextFeatures.types.inlineObjects.map((obj) => obj.name);
            return (inlineSchemaTypes.includes(element._type) &&
                '__inline' in element &&
                element.__inline === true);
        };
        // Extend Slate's default normalization to add _type span to span inserted after a inline void object
        const { apply } = editor;
        editor.apply = (op) => {
            const isInsertTextWithoutType = op.type === 'insert_node' &&
                op.path.length === 2 &&
                SlateText.isText(op.node) &&
                op.node._type === undefined;
            if (isInsertTextWithoutType) {
                const insertNodeOperation = op;
                const newNode = {
                    ...insertNodeOperation.node,
                    _type: 'span',
                };
                op.node = newNode;
                debug('Setting span type to child without a type', op);
            }
            apply(op);
        };
        return editor;
    };
}
//# sourceMappingURL=createWithSchemaTypes.js.map