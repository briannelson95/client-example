import { Text, Range, Transforms, Editor, Element as SlateElement } from 'slate';
import { ReactEditor } from '@sanity/slate-react';
import { toSlateValue, fromSlateValue } from '../../utils/values';
import { toSlateRange, toPortableTextRange } from '../../utils/ranges';
import { debugWithName } from '../../utils/debug';
import { KEY_TO_VALUE_ELEMENT, SLATE_TO_PORTABLE_TEXT_RANGE } from '../../utils/weakMaps';
const debug = debugWithName('API:editable');
export function createWithEditableAPI(portableTextEditor, portableTextFeatures, keyGenerator) {
    return function withEditableAPI(editor) {
        portableTextEditor.setEditable({
            focus: () => {
                // Make a selection if missing
                if (!editor.selection) {
                    const point = { path: [0, 0], offset: 0 };
                    Transforms.select(editor, { focus: point, anchor: point });
                    editor.onChange();
                }
                ReactEditor.focus(editor);
            },
            blur: () => {
                ReactEditor.blur(editor);
            },
            toggleMark: (mark) => {
                editor.pteToggleMark(mark);
            },
            toggleList: (listStyle) => {
                editor.pteToggleListItem(listStyle);
            },
            toggleBlockStyle: (blockStyle) => {
                editor.pteToggleBlockStyle(blockStyle);
            },
            isMarkActive: (mark) => {
                // Try/catch this, as Slate may error because the selection is currently wrong
                // TODO: catch only relevant error from Slate
                try {
                    return editor.pteIsMarkActive(mark);
                }
                catch (err) {
                    console.warn(err);
                    return false;
                }
            },
            marks: () => {
                return ({
                    ...(Editor.marks(editor) || {}),
                }.marks || []);
            },
            undo: () => editor.undo(),
            redo: () => editor.redo(),
            select: (selection) => {
                const slateSelection = toSlateRange(selection, editor);
                if (slateSelection) {
                    Transforms.select(editor, slateSelection);
                }
                else {
                    Transforms.deselect(editor);
                }
                editor.onChange();
            },
            focusBlock: () => {
                if (editor.selection) {
                    // Try/catch this, as Slate may error because the selection is currently wrong
                    // TODO: catch only relevant error from Slate
                    try {
                        const [block] = Array.from(Editor.nodes(editor, {
                            at: editor.selection.focus,
                            match: (n) => Editor.isBlock(editor, n),
                        }))[0] || [undefined];
                        if (block) {
                            return fromSlateValue([block], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
                        }
                    }
                    catch (err) {
                        return undefined;
                    }
                }
                return undefined;
            },
            focusChild: () => {
                if (editor.selection) {
                    try {
                        const [node] = Array.from(Editor.nodes(editor, {
                            mode: 'lowest',
                            at: editor.selection.focus,
                            match: (n) => n._type !== undefined,
                            voids: true,
                        }))[0] || [undefined];
                        if (node && !Editor.isBlock(editor, node)) {
                            const pseudoBlock = {
                                _key: 'pseudo',
                                _type: portableTextFeatures.types.block.name,
                                children: [node],
                            };
                            return fromSlateValue([pseudoBlock], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0].children[0];
                        }
                    }
                    catch (err) {
                        return undefined;
                    }
                }
                return undefined;
            },
            insertChild: (type, value) => {
                if (!editor.selection) {
                    throw new Error('The editor has no selection');
                }
                const [focusBlock] = Array.from(Editor.nodes(editor, {
                    at: editor.selection.focus,
                    match: (n) => Editor.isBlock(editor, n),
                }))[0] || [undefined];
                if (!focusBlock) {
                    throw new Error('No focus block');
                }
                if (focusBlock && Editor.isVoid(editor, focusBlock)) {
                    throw new Error("Can't insert childs into block objects");
                }
                const block = toSlateValue([
                    {
                        _key: keyGenerator(),
                        _type: portableTextFeatures.types.block.name,
                        children: [
                            {
                                _key: keyGenerator(),
                                _type: type.name,
                                ...(value ? value : {}),
                            },
                        ],
                    },
                ], portableTextEditor)[0];
                const child = block.children[0];
                Editor.insertNode(editor, child);
                editor.onChange();
                return (toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures)?.focus.path || []);
            },
            insertBlock: (type, value) => {
                if (!editor.selection) {
                    throw new Error('The editor has no selection');
                }
                const block = toSlateValue([
                    {
                        _key: keyGenerator(),
                        _type: type.name,
                        ...(value ? value : {}),
                    },
                ], portableTextEditor)[0];
                Editor.insertNode(editor, block);
                editor.onChange();
                return (toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures)?.focus.path || []);
            },
            hasBlockStyle: (style) => {
                try {
                    return editor.pteHasBlockStyle(style);
                }
                catch (err) {
                    // This is fine.
                    // debug(err)
                    return false;
                }
            },
            hasListStyle: (listStyle) => {
                try {
                    return editor.pteHasListStyle(listStyle);
                }
                catch (err) {
                    // This is fine.
                    // debug(err)
                    return false;
                }
            },
            isVoid: (element) => {
                return ![
                    portableTextFeatures.types.block.name,
                    portableTextFeatures.types.span.name,
                ].includes(element._type);
            },
            findByPath: (path) => {
                const slatePath = toSlateRange({ focus: { path, offset: 0 }, anchor: { path, offset: 0 } }, editor);
                if (slatePath) {
                    const [block, blockPath] = Editor.node(editor, slatePath.focus.path.slice(0, 1));
                    if (block && blockPath && typeof block._key === 'string') {
                        if (path.length === 1 && slatePath.focus.path.length === 1) {
                            return [
                                fromSlateValue([block], portableTextFeatures.types.block.name)[0],
                                [{ _key: block._key }],
                            ];
                        }
                        const ptBlock = fromSlateValue([block], portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];
                        const ptChild = ptBlock.children[slatePath.focus.path[1]];
                        if (ptChild) {
                            return [ptChild, [{ _key: block._key }, 'children', { _key: ptChild._key }]];
                        }
                    }
                }
                return [undefined, undefined];
            },
            findDOMNode: (element) => {
                let node;
                try {
                    const [item] = Array.from(Editor.nodes(editor, {
                        at: [],
                        match: (n) => n._key === element._key,
                    }) || [])[0] || [undefined];
                    node = ReactEditor.toDOMNode(editor, item);
                }
                catch (err) {
                    // Nothing
                }
                return node;
            },
            activeAnnotations: () => {
                if (!editor.selection || editor.selection.focus.path.length < 2) {
                    return [];
                }
                try {
                    const activeAnnotations = [];
                    const spans = Editor.nodes(editor, {
                        at: editor.selection,
                        match: (node) => Text.isText(node) &&
                            node.marks !== undefined &&
                            Array.isArray(node.marks) &&
                            node.marks.length > 0,
                    });
                    for (const [span, path] of spans) {
                        const [block] = Editor.node(editor, path, { depth: 1 });
                        if (editor.isTextBlock(block)) {
                            block.markDefs.forEach((def) => {
                                if (Text.isText(span) &&
                                    span.marks &&
                                    Array.isArray(span.marks) &&
                                    span.marks.includes(def._key)) {
                                    activeAnnotations.push(def);
                                }
                            });
                        }
                    }
                    return activeAnnotations;
                }
                catch (err) {
                    return [];
                }
            },
            addAnnotation: (type, value) => {
                const { selection } = editor;
                if (selection) {
                    const [block] = Editor.node(editor, selection.focus, { depth: 1 });
                    if (SlateElement.isElement(block) &&
                        block._type === portableTextFeatures.types.block.name) {
                        const annotationKey = keyGenerator();
                        if (editor.isTextBlock(block)) {
                            Transforms.setNodes(editor, {
                                markDefs: [...block.markDefs, { _type: type.name, _key: annotationKey, ...value }],
                            }, { at: selection.focus });
                            editor.onChange();
                            if (Range.isCollapsed(selection)) {
                                editor.pteExpandToWord();
                                editor.onChange();
                            }
                            const [textNode] = Editor.node(editor, selection.focus, { depth: 2 });
                            if (editor.selection) {
                                Editor.withoutNormalizing(editor, () => {
                                    // Split if needed
                                    Transforms.setNodes(editor, {}, { match: Text.isText, split: true });
                                    if (editor.selection && Text.isText(textNode)) {
                                        Transforms.setNodes(editor, {
                                            marks: [...(textNode.marks || []), annotationKey],
                                        }, {
                                            at: editor.selection,
                                            match: (n) => n._type === portableTextFeatures.types.span.name,
                                        });
                                        editor.onChange();
                                    }
                                });
                                Editor.normalize(editor);
                                editor.onChange();
                                const newSelection = toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures);
                                // eslint-disable-next-line max-depth
                                if (newSelection && typeof block._key === 'string') {
                                    // Insert an empty string to continue writing non-annotated text
                                    Editor.withoutNormalizing(editor, () => {
                                        if (editor.selection) {
                                            Transforms.insertNodes(editor, [{ _type: 'span', text: '', marks: [], _key: keyGenerator() }], {
                                                at: Range.end(editor.selection),
                                            });
                                            editor.onChange();
                                        }
                                    });
                                    return {
                                        spanPath: newSelection.focus.path,
                                        markDefPath: [{ _key: block._key }, 'markDefs', { _key: annotationKey }],
                                    };
                                }
                            }
                        }
                    }
                }
                return undefined;
            },
            delete: (selection, options) => {
                if (selection) {
                    const range = toSlateRange(selection, editor);
                    if (range) {
                        if (!options?.mode || options?.mode === 'selected') {
                            debug(`Deleting content in selection`);
                            Transforms.delete(editor, {
                                at: range,
                                hanging: true,
                                voids: true,
                            });
                            editor.onChange();
                            return;
                        }
                        const nodes = Editor.nodes(editor, {
                            at: range,
                            match: (node) => {
                                if (options?.mode === 'blocks') {
                                    debug(`Deleting blocks touched by selection`);
                                    return (editor.isTextBlock(node) ||
                                        (!editor.isTextBlock(node) && SlateElement.isElement(node)));
                                }
                                debug(`Deleting children touched by selection`);
                                return (node._type === portableTextFeatures.types.span.name || // Text children
                                    (!editor.isTextBlock(node) && SlateElement.isElement(node)) // inline blocks
                                );
                            },
                        });
                        const nodeAndPaths = [...nodes];
                        nodeAndPaths.forEach(([, p]) => {
                            Transforms.removeNodes(editor, {
                                at: p,
                                voids: true,
                                hanging: true,
                            });
                        });
                        editor.onChange();
                    }
                }
            },
            removeAnnotation: (type) => {
                let { selection } = editor;
                debug('Removing annotation', type);
                if (selection) {
                    // Select the whole annotation if collapsed
                    if (Range.isCollapsed(selection)) {
                        const [node, nodePath] = Editor.node(editor, selection, { depth: 2 });
                        if (Text.isText(node) && node.marks && typeof node.text === 'string') {
                            Transforms.select(editor, nodePath);
                            selection = editor.selection;
                        }
                    }
                    // Do this without normalization or span references will be unstable!
                    Editor.withoutNormalizing(editor, () => {
                        if (selection && Range.isExpanded(selection)) {
                            selection = editor.selection;
                            if (!selection) {
                                return;
                            }
                            // Split the span first
                            Transforms.setNodes(editor, {}, { match: Text.isText, split: true });
                            editor.onChange();
                            // Everything in the selection which has marks
                            const spans = [
                                ...Editor.nodes(editor, {
                                    at: selection,
                                    match: (node) => Text.isText(node) &&
                                        node.marks !== undefined &&
                                        Array.isArray(node.marks) &&
                                        node.marks.length > 0,
                                }),
                            ];
                            spans.forEach(([span, path]) => {
                                const [block] = Editor.node(editor, path, { depth: 1 });
                                if (editor.isTextBlock(block)) {
                                    block.markDefs
                                        .filter((def) => def._type === type.name)
                                        .forEach((def) => {
                                        if (Text.isText(span) &&
                                            Array.isArray(span.marks) &&
                                            span.marks.includes(def._key)) {
                                            const newMarks = [...(span.marks || []).filter((mark) => mark !== def._key)];
                                            Transforms.setNodes(editor, {
                                                marks: newMarks,
                                            }, { at: path, voids: false, split: false });
                                        }
                                    });
                                }
                            });
                        }
                    });
                    Editor.normalize(editor);
                    editor.onChange();
                }
            },
            getSelection: () => {
                let ptRange = null;
                if (editor.selection) {
                    const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);
                    if (existing) {
                        return existing;
                    }
                    ptRange = toPortableTextRange(fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, portableTextFeatures);
                    SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);
                }
                return ptRange;
            },
            getValue: () => {
                return fromSlateValue(editor.children, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor));
            },
            isCollapsedSelection: () => {
                return !!editor.selection && Range.isCollapsed(editor.selection);
            },
            isExpandedSelection: () => {
                return !!editor.selection && Range.isExpanded(editor.selection);
            },
        });
        return editor;
    };
}
//# sourceMappingURL=createWithEditableAPI.js.map