import { Editor, } from 'slate';
import { debounce } from 'lodash';
import { insert, setIfMissing, unset } from '../../patch/PatchEvent';
import { fromSlateValue, isEqualToEmptyEditor } from '../../utils/values';
import { debugWithName } from '../../utils/debug';
import { PATCHING, isPatching, withoutPatching } from '../../utils/withoutPatching';
import { KEY_TO_VALUE_ELEMENT } from '../../utils/weakMaps';
import { createPatchToOperations } from '../../utils/patchToOperations';
import { keyGenerator } from '../..';
import { withPreserveKeys } from '../../utils/withPreserveKeys';
import { withoutSaving } from './createWithUndoRedo';
const debug = debugWithName('plugin:withPatches');
export function createWithPatches({ insertNodePatch, insertTextPatch, mergeNodePatch, moveNodePatch, removeNodePatch, removeTextPatch, setNodePatch, splitNodePatch, }, change$, portableTextFeatures, syncValue, incomingPatches$) {
    // The previous editor children are needed to figure out the _key of deleted nodes
    // The editor.children would no longer contain that information if the node is already deleted.
    let previousChildren;
    const patchToOperations = createPatchToOperations(portableTextFeatures, keyGenerator);
    let patchSubscription;
    const cleanupFn = () => {
        if (patchSubscription) {
            debug('Unsubscribing to patches');
            patchSubscription.unsubscribe();
        }
    };
    return [
        function withPatches(editor) {
            PATCHING.set(editor, true);
            previousChildren = [...editor.children];
            // Sync the with props.value in PortableTextEditor after we have processed batches of incoming patches.
            // This is only for consistency checking against the props.value, so it can be debounced without problems.
            const syncValueAfterIncomingPatches = debounce(() => syncValue(), 100, {
                trailing: true,
                leading: false,
            });
            // Subscribe and deal with incoming patches
            if (incomingPatches$) {
                debug('Subscribing to patches');
                patchSubscription = incomingPatches$.subscribe(({ patches, snapshot }) => {
                    const remotePatches = patches.filter((p) => p.origin !== 'local');
                    if (remotePatches.length !== 0) {
                        Editor.withoutNormalizing(editor, () => {
                            remotePatches.forEach((patch) => {
                                debug(`Handling remote patch ${JSON.stringify(patch)}`);
                                withoutPatching(editor, () => {
                                    withoutSaving(editor, () => {
                                        withPreserveKeys(editor, () => {
                                            try {
                                                patchToOperations(editor, patch, patches, snapshot);
                                            }
                                            catch (err) {
                                                debug('Got error trying to create operations from patch');
                                                console.error(err);
                                            }
                                        });
                                    });
                                });
                            });
                        });
                    }
                    syncValueAfterIncomingPatches();
                });
            }
            const { apply } = editor;
            editor.apply = (operation) => {
                if (editor.readOnly) {
                    editor.apply(operation);
                    return editor;
                }
                let patches = [];
                // Update previous children here before we apply
                previousChildren = editor.children;
                const editorWasEmpty = isEqualToEmptyEditor(previousChildren, portableTextFeatures);
                // Apply the operation
                apply(operation);
                const editorIsEmpty = isEqualToEmptyEditor(editor.children, portableTextFeatures);
                if (!isPatching(editor)) {
                    debug(`Editor is not producing patch for operation ${operation.type}`, operation);
                    return editor;
                }
                if (editorWasEmpty && operation.type !== 'set_selection') {
                    patches.push(setIfMissing([], []));
                    patches.push(insert([
                        fromSlateValue(previousChildren.length === 0
                            ? [editor.createPlaceholderBlock()]
                            : previousChildren, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0],
                    ], 'before', [0]));
                }
                switch (operation.type) {
                    case 'insert_text':
                        patches = [...patches, ...insertTextPatch(editor, operation, previousChildren)];
                        break;
                    case 'remove_text':
                        patches = [...patches, ...removeTextPatch(editor, operation, previousChildren)];
                        break;
                    case 'remove_node':
                        patches = [...patches, ...removeNodePatch(editor, operation, previousChildren)];
                        break;
                    case 'split_node':
                        patches = [...patches, ...splitNodePatch(editor, operation, previousChildren)];
                        break;
                    case 'insert_node':
                        patches = [...patches, ...insertNodePatch(editor, operation, previousChildren)];
                        break;
                    case 'set_node':
                        patches = [...patches, ...setNodePatch(editor, operation, previousChildren)];
                        break;
                    case 'merge_node':
                        patches = [...patches, ...mergeNodePatch(editor, operation, previousChildren)];
                        break;
                    case 'move_node':
                        patches = [...patches, ...moveNodePatch(editor, operation, previousChildren)];
                        break;
                    case 'set_selection':
                    default:
                    // Do nothing
                }
                // Unset the value if the operation made the editor empty
                if (editorIsEmpty && ['remove_text', 'remove_node'].includes(operation.type)) {
                    patches = [...patches, unset([])];
                    change$.next({
                        type: 'unset',
                        previousValue: fromSlateValue(previousChildren, portableTextFeatures.types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),
                    });
                }
                // Emit all patches
                if (patches.length > 0) {
                    patches.forEach((patch) => {
                        change$.next({
                            type: 'patch',
                            patch: { ...patch, origin: 'local' },
                        });
                    });
                }
                return editor;
            };
            return editor;
        },
        cleanupFn,
    ];
}
//# sourceMappingURL=createWithPatches.js.map