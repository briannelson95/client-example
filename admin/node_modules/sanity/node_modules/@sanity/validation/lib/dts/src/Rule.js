var _a;
import { cloneDeep, get } from 'lodash';
import ValidationErrorClass from './ValidationError';
import escapeRegex from './util/escapeRegex';
import { convertToValidationMarker } from './util/convertToValidationMarker';
import pathToString from './util/pathToString';
import genericValidator from './validators/genericValidator';
import booleanValidator from './validators/booleanValidator';
import numberValidator from './validators/numberValidator';
import stringValidator from './validators/stringValidator';
import arrayValidator from './validators/arrayValidator';
import objectValidator from './validators/objectValidator';
import dateValidator from './validators/dateValidator';
const typeValidators = {
    Boolean: booleanValidator,
    Number: numberValidator,
    String: stringValidator,
    Array: arrayValidator,
    Object: objectValidator,
    Date: dateValidator,
};
const getBaseType = (type) => {
    return type && type.type ? getBaseType(type.type) : type;
};
const isFieldRef = (constraint) => {
    if (typeof constraint !== 'object' || !constraint)
        return false;
    return constraint.type === Rule.FIELD_REF;
};
const EMPTY_ARRAY = [];
const FIELD_REF = Symbol('FIELD_REF');
const ruleConstraintTypes = [
    'Array',
    'Boolean',
    'Date',
    'Number',
    'Object',
    'String',
];
// Note: `RuleClass` and `Rule` are split to fit the current `@sanity/types`
// setup. Classes are a bit weird in the `@sanity/types` package because classes
// create an actual javascript class while simultaneously creating a type
// definition.
//
// This implicitly creates two types:
// 1. the instance type â€” `Rule` and
// 2. the static/class type - `RuleClass`
//
// The `RuleClass` type contains the static methods and the `Rule` instance
// contains the instance methods.
//
// This package exports the RuleClass as a value without implicitly exporting
// an instance definition. This should help reminder downstream users to import
// from the `@sanity/types` package.
const Rule = (_a = class Rule {
        constructor(typeDef) {
            this._type = undefined;
            this._level = undefined;
            this._required = undefined;
            this._typeDef = undefined;
            this._message = undefined;
            this._rules = [];
            this._fieldRules = undefined;
            // Alias to static method, since we often have access to an _instance_ of a rule but not the actual Rule class
            this.valueOfField = Rule.valueOfField.bind(Rule);
            this._typeDef = typeDef;
            this.reset();
        }
        _mergeRequired(next) {
            if (this._required === 'required' || next._required === 'required')
                return 'required';
            if (this._required === 'optional' || next._required === 'optional')
                return 'optional';
            return undefined;
        }
        error(message) {
            const rule = this.clone();
            rule._level = 'error';
            rule._message = message || undefined;
            return rule;
        }
        warning(message) {
            const rule = this.clone();
            rule._level = 'warning';
            rule._message = message || undefined;
            return rule;
        }
        info(message) {
            const rule = this.clone();
            rule._level = 'info';
            rule._message = message || undefined;
            return rule;
        }
        reset() {
            this._type = this._type || undefined;
            this._rules = (this._rules || []).filter((rule) => rule.flag === 'type');
            this._message = undefined;
            this._required = undefined;
            this._level = 'error';
            this._fieldRules = undefined;
            return this;
        }
        isRequired() {
            return this._required === 'required';
        }
        clone() {
            const rule = new Rule();
            rule._type = this._type;
            rule._message = this._message;
            rule._required = this._required;
            rule._rules = cloneDeep(this._rules);
            rule._level = this._level;
            rule._fieldRules = this._fieldRules;
            rule._typeDef = this._typeDef;
            return rule;
        }
        cloneWithRules(rules) {
            const rule = this.clone();
            const newRules = new Set();
            rules.forEach((curr) => {
                if (curr.flag === 'type') {
                    rule._type = curr.constraint;
                }
                newRules.add(curr.flag);
            });
            rule._rules = rule._rules
                .filter((curr) => {
                const disallowDuplicate = ['type', 'uri', 'email'].includes(curr.flag);
                const isDuplicate = newRules.has(curr.flag);
                return !(disallowDuplicate && isDuplicate);
            })
                .concat(rules);
            return rule;
        }
        merge(rule) {
            if (this._type && rule._type && this._type !== rule._type) {
                throw new Error('merge() failed: conflicting types');
            }
            const newRule = this.cloneWithRules(rule._rules);
            newRule._type = this._type || rule._type;
            newRule._message = this._message || rule._message;
            newRule._required = this._mergeRequired(rule);
            newRule._level = this._level === 'error' ? rule._level : this._level;
            return newRule;
        }
        // Validation flag setters
        type(targetType) {
            const type = `${targetType.slice(0, 1).toUpperCase()}${targetType.slice(1)}`;
            if (!ruleConstraintTypes.includes(type)) {
                throw new Error(`Unknown type "${targetType}"`);
            }
            const rule = this.cloneWithRules([{ flag: 'type', constraint: type }]);
            rule._type = type;
            return rule;
        }
        all(children) {
            return this.cloneWithRules([{ flag: 'all', constraint: children }]);
        }
        either(children) {
            return this.cloneWithRules([{ flag: 'either', constraint: children }]);
        }
        // Shared rules
        optional() {
            const rule = this.cloneWithRules([{ flag: 'presence', constraint: 'optional' }]);
            rule._required = 'optional';
            return rule;
        }
        required() {
            const rule = this.cloneWithRules([{ flag: 'presence', constraint: 'required' }]);
            rule._required = 'required';
            return rule;
        }
        custom(fn) {
            return this.cloneWithRules([{ flag: 'custom', constraint: fn }]);
        }
        /**
         * @deprecated use `Rule.custom` instead
         */
        block(fn) {
            return this.cloneWithRules([{ flag: 'custom', constraint: fn }]);
        }
        min(len) {
            return this.cloneWithRules([{ flag: 'min', constraint: len }]);
        }
        max(len) {
            return this.cloneWithRules([{ flag: 'max', constraint: len }]);
        }
        length(len) {
            return this.cloneWithRules([{ flag: 'length', constraint: len }]);
        }
        valid(value) {
            const values = Array.isArray(value) ? value : [value];
            return this.cloneWithRules([{ flag: 'valid', constraint: values }]);
        }
        // Numbers only
        integer() {
            return this.cloneWithRules([{ flag: 'integer' }]);
        }
        precision(limit) {
            return this.cloneWithRules([{ flag: 'precision', constraint: limit }]);
        }
        positive() {
            return this.cloneWithRules([{ flag: 'min', constraint: 0 }]);
        }
        negative() {
            return this.cloneWithRules([{ flag: 'lessThan', constraint: 0 }]);
        }
        greaterThan(num) {
            return this.cloneWithRules([{ flag: 'greaterThan', constraint: num }]);
        }
        lessThan(num) {
            return this.cloneWithRules([{ flag: 'lessThan', constraint: num }]);
        }
        // String only
        uppercase() {
            return this.cloneWithRules([{ flag: 'stringCasing', constraint: 'uppercase' }]);
        }
        lowercase() {
            return this.cloneWithRules([{ flag: 'stringCasing', constraint: 'lowercase' }]);
        }
        regex(pattern, a, b) {
            const name = typeof a === 'string' ? a : a?.name ?? b?.name;
            const invert = typeof a === 'string' ? false : a?.invert ?? b?.invert;
            const constraint = {
                pattern,
                name,
                invert: invert || false,
            };
            return this.cloneWithRules([{ flag: 'regex', constraint }]);
        }
        email() {
            return this.cloneWithRules([{ flag: 'email' }]);
        }
        uri(opts) {
            const optsScheme = opts?.scheme || ['http', 'https'];
            const schemes = Array.isArray(optsScheme) ? optsScheme : [optsScheme];
            if (!schemes.length) {
                throw new Error('scheme must have at least 1 scheme specified');
            }
            const constraint = {
                options: {
                    scheme: schemes.map((scheme) => {
                        if (!(scheme instanceof RegExp) && typeof scheme !== 'string') {
                            throw new Error('scheme must be a RegExp or a String');
                        }
                        return typeof scheme === 'string' ? new RegExp(`^${escapeRegex(scheme)}$`) : scheme;
                    }),
                    allowRelative: opts?.allowRelative || false,
                    relativeOnly: opts?.relativeOnly || false,
                    allowCredentials: opts?.allowCredentials || false,
                },
            };
            return this.cloneWithRules([{ flag: 'uri', constraint }]);
        }
        // Array only
        unique() {
            return this.cloneWithRules([{ flag: 'unique' }]);
        }
        // Objects only
        reference() {
            return this.cloneWithRules([{ flag: 'reference' }]);
        }
        fields(rules) {
            if (this._type !== 'Object') {
                throw new Error('fields() can only be called on an object type');
            }
            const rule = this.cloneWithRules([]);
            rule._fieldRules = rules;
            return rule;
        }
        assetRequired() {
            const base = getBaseType(this._typeDef);
            let assetType;
            if (base && ['image', 'file'].includes(base.name)) {
                assetType = base.name === 'image' ? 'Image' : 'File';
            }
            else {
                assetType = 'Asset';
            }
            return this.cloneWithRules([{ flag: 'assetRequired', constraint: { assetType } }]);
        }
        async validate(value, context) {
            if (!context) {
                throw new Error('missing context');
            }
            const valueIsEmpty = value === null || value === undefined;
            // Short-circuit on optional, empty fields
            if (valueIsEmpty && this._required === 'optional') {
                return EMPTY_ARRAY;
            }
            const rules = 
            // Run only the _custom_ functions if the rule is not set to required or optional
            this._required === undefined && valueIsEmpty
                ? this._rules.filter((curr) => curr.flag === 'custom')
                : this._rules;
            const validators = (this._type && typeValidators[this._type]) || genericValidator;
            const results = await Promise.all(rules.map(async (curr) => {
                if (curr.flag === undefined) {
                    throw new Error('Invalid rule, did not contain "flag"-property');
                }
                const validator = validators[curr.flag];
                if (!validator) {
                    const forType = this._type ? `type "${this._type}"` : 'rule without declared type';
                    throw new Error(`Validator for flag "${curr.flag}" not found for ${forType}`);
                }
                let specConstraint = 'constraint' in curr ? curr.constraint : null;
                if (isFieldRef(specConstraint)) {
                    specConstraint = get(context.parent, specConstraint.path);
                }
                let result;
                try {
                    result = await validator(specConstraint, value, this._message, context);
                }
                catch (err) {
                    const errorFromException = new ValidationErrorClass(`${pathToString(context.path)}: Exception occurred while validating value: ${err.message}`);
                    return convertToValidationMarker(errorFromException, 'error', context);
                }
                return convertToValidationMarker(result, this._level, context);
            }));
            return results.flat();
        }
    },
    _a.FIELD_REF = FIELD_REF,
    _a.array = (def) => new _a(def).type('Array'),
    _a.object = (def) => new _a(def).type('Object'),
    _a.string = (def) => new _a(def).type('String'),
    _a.number = (def) => new _a(def).type('Number'),
    _a.boolean = (def) => new _a(def).type('Boolean'),
    _a.dateTime = (def) => new _a(def).type('Date'),
    _a.valueOfField = (path) => ({
        type: FIELD_REF,
        path,
    }),
    _a);
export default Rule;
//# sourceMappingURL=Rule.js.map