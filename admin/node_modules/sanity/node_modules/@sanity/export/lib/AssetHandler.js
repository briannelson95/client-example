"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const path = require('path');

const crypto = require('crypto');

const {
  parse: parseUrl,
  format: formatUrl
} = require('url');

const {
  mkdirSync,
  createWriteStream
} = require('fs');

const miss = require('mississippi');

const PQueue = require('p-queue');

const {
  omit,
  noop
} = require('lodash');

const pkg = require('../package.json');

const requestStream = require('./requestStream');

const debug = require('./debug');

const rimraf = require('./util/rimraf');

const EXCLUDE_PROPS = ['_id', '_type', 'assetId', 'extension', 'mimeType', 'path', 'url'];
const ACTION_REMOVE = 'remove';
const ACTION_REWRITE = 'rewrite';
const ASSET_DOWNLOAD_CONCURRENCY = 8;

class AssetHandler {
  constructor(options) {
    _defineProperty(this, "rewriteAssets", miss.through.obj(async (doc, enc, callback) => {
      if (['sanity.imageAsset', 'sanity.fileAsset'].includes(doc._type)) {
        const type = doc._type === 'sanity.imageAsset' ? 'image' : 'file';
        const filePath = "".concat(type, "s/").concat(generateFilename(doc._id));
        this.assetsSeen.set(doc._id, type);
        this.queueAssetDownload(doc, filePath, type);
        callback();
        return;
      }

      callback(null, this.findAndModify(doc, ACTION_REWRITE));
    }));

    _defineProperty(this, "stripAssets", miss.through.obj(async (doc, enc, callback) => {
      if (['sanity.imageAsset', 'sanity.fileAsset'].includes(doc._type)) {
        callback();
        return;
      }

      callback(null, this.findAndModify(doc, ACTION_REMOVE));
    }));

    _defineProperty(this, "skipAssets", miss.through.obj((doc, enc, callback) => {
      const isAsset = ['sanity.imageAsset', 'sanity.fileAsset'].includes(doc._type);

      if (isAsset) {
        callback();
        return;
      }

      callback(null, doc);
    }));

    _defineProperty(this, "noop", miss.through.obj((doc, enc, callback) => callback(null, doc)));

    _defineProperty(this, "findAndModify", (item, action) => {
      if (Array.isArray(item)) {
        const children = item.map(child => this.findAndModify(child, action));
        return children.filter(Boolean);
      }

      if (!item || typeof item !== 'object') {
        return item;
      }

      const isAsset = isAssetField(item);

      if (isAsset && action === ACTION_REMOVE) {
        return undefined;
      }

      if (isAsset && action === ACTION_REWRITE) {
        const {
          asset,
          ...other
        } = item;
        const assetId = asset._ref;
        const assetType = getAssetType(item);
        const filePath = "".concat(assetType, "s/").concat(generateFilename(assetId));
        return {
          _sanityAsset: "".concat(assetType, "@file://./").concat(filePath),
          ...this.findAndModify(other, action)
        };
      }

      const newItem = {};
      const keys = Object.keys(item);

      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = item[key];
        newItem[key] = this.findAndModify(value, action);

        if (typeof newItem[key] === 'undefined') {
          delete newItem[key];
        }
      }

      return newItem;
    });

    const concurrency = options.concurrency || ASSET_DOWNLOAD_CONCURRENCY;
    debug('Using asset download concurrency of %d', concurrency);
    this.client = options.client;
    this.tmpDir = options.tmpDir;
    this.assetDirsCreated = false;
    this.downloading = [];
    this.assetsSeen = new Map();
    this.assetMap = {};
    this.filesWritten = 0;
    this.queueSize = 0;
    this.queue = options.queue || new PQueue({
      concurrency
    });
    this.rejectedError = null;

    this.reject = err => {
      this.rejectedError = err;
    };
  }

  clear() {
    this.assetsSeen.clear();
    this.queue.clear();
    this.queueSize = 0;
  }

  finish() {
    return new Promise((resolve, reject) => {
      if (this.rejectedError) {
        reject(this.rejectedError);
        return;
      }

      this.reject = reject;
      this.queue.onIdle().then(() => resolve(this.assetMap));
    });
  } // Called when we want to download all assets to local filesystem and rewrite documents to hold
  // placeholder asset references (_sanityAsset: 'image@file:///local/path')


  queueAssetDownload(assetDoc, dstPath, type) {
    if (!assetDoc.url) {
      debug('Asset document "%s" does not have a URL property, skipping', assetDoc._id);
      return;
    }

    debug('Adding download task for %s (destination: %s)', assetDoc._id, dstPath);
    this.queueSize++;
    this.downloading.push(assetDoc.url);
    this.queue.add(() => this.downloadAsset(assetDoc, dstPath));
  }

  maybeCreateAssetDirs() {
    if (this.assetDirsCreated) {
      return;
    }
    /* eslint-disable no-sync */


    mkdirSync(path.join(this.tmpDir, 'files'), {
      recursive: true
    });
    mkdirSync(path.join(this.tmpDir, 'images'), {
      recursive: true
    });
    /* eslint-enable no-sync */

    this.assetDirsCreated = true;
  }

  getAssetRequestOptions(assetDoc) {
    const token = this.client.config().token;
    const headers = {
      'User-Agent': "".concat(pkg.name, "@").concat(pkg.version)
    };
    const isImage = assetDoc._type === 'sanity.imageAsset';
    const url = parseUrl(assetDoc.url, true);

    if (isImage && ['cdn.sanity.io', 'cdn.sanity.work'].includes(url.hostname) && token) {
      headers.Authorization = "Bearer ".concat(token);
      url.query = { ...(url.query || {}),
        dlRaw: 'true'
      };
    }

    return {
      url: formatUrl(url),
      headers
    };
  }

  async downloadAsset(assetDoc, dstPath) {
    let attemptNum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    const {
      url
    } = assetDoc;
    const options = this.getAssetRequestOptions(assetDoc);
    let stream;

    try {
      stream = await requestStream(options);
    } catch (err) {
      this.reject(err);
      return false;
    }

    if (stream.statusCode !== 200) {
      this.queue.clear();
      const err = await tryGetErrorFromStream(stream);
      let errMsg = "Referenced asset URL \"".concat(url, "\" returned HTTP ").concat(stream.statusCode);

      if (err) {
        errMsg = "".concat(errMsg, ":\n\n").concat(err);
      }

      this.reject(new Error(errMsg));
      return false;
    }

    this.maybeCreateAssetDirs();
    debug('Asset stream ready, writing to filesystem at %s', dstPath);
    const tmpPath = path.join(this.tmpDir, dstPath);
    const {
      sha1,
      md5,
      size
    } = await writeHashedStream(tmpPath, stream); // Verify it against our downloaded stream to make sure we have the same copy

    const contentLength = stream.headers['content-length'];
    const remoteSha1 = stream.headers['x-sanity-sha1'];
    const remoteMd5 = stream.headers['x-sanity-md5'];
    const hasHash = Boolean(remoteSha1 || remoteMd5);
    const method = sha1 ? 'sha1' : 'md5'; // Asset validity is primarily determined by the sha1 hash. However, the sha1 hash is computed
    // before certain processes (i.e. svg sanitization) which can result in a different hash.
    // When the sha1 hashes don't match, fallback to using the md5 hash.

    const sha1Differs = remoteSha1 && sha1 !== remoteSha1;
    const md5Differs = remoteMd5 && md5 !== remoteMd5;
    const differs = sha1Differs && md5Differs;

    if (differs && attemptNum < 3) {
      debug('%s does not match downloaded asset, retrying (#%d) [%s]', method, attemptNum + 1, url);
      return this.downloadAsset(assetDoc, dstPath, attemptNum + 1);
    } else if (differs) {
      const details = [hasHash && (method === 'md5' ? "md5 should be ".concat(remoteMd5, ", got ").concat(md5) : "sha1 should be ".concat(remoteSha1, ", got ").concat(sha1)), contentLength && parseInt(contentLength, 10) !== size && "Asset should be ".concat(contentLength, " bytes, got ").concat(size), "Did not succeed after ".concat(attemptNum, " attempts.")];
      const detailsString = "Details:\n - ".concat(details.filter(Boolean).join('\n - '));
      await rimraf(tmpPath);
      this.queue.clear();
      const error = new Error("Failed to download asset at ".concat(assetDoc.url, ", giving up. ").concat(detailsString));
      this.reject(error);
      return false;
    }

    const isImage = assetDoc._type === 'sanity.imageAsset';
    const type = isImage ? 'image' : 'file';
    const id = "".concat(type, "-").concat(sha1);
    const metaProps = omit(assetDoc, EXCLUDE_PROPS);

    if (Object.keys(metaProps).length > 0) {
      this.assetMap[id] = metaProps;
    }

    this.downloading.splice(this.downloading.findIndex(datUrl => datUrl === url), 1);
    this.filesWritten++;
    return true;
  }

}

function isAssetField(item) {
  return item.asset && item.asset._ref && isSanityAsset(item.asset._ref);
}

function getAssetType(item) {
  if (!item.asset || typeof item.asset._ref !== 'string') {
    return null;
  }

  const [, type] = item.asset._ref.match(/^(image|file)-/) || [];
  return type || null;
}

function isSanityAsset(assetId) {
  return /^image-[a-f0-9]{40}-\d+x\d+-[a-z]+$/.test(assetId) || /^file-[a-f0-9]{40}-[a-z0-9]+$/.test(assetId);
}

function generateFilename(assetId) {
  const [,, asset, ext] = assetId.match(/^(image|file)-(.*?)(-[a-z]+)?$/) || [];
  const extension = (ext || 'bin').replace(/^-/, '');
  return asset ? "".concat(asset, ".").concat(extension) : "".concat(assetId, ".bin");
}

function writeHashedStream(filePath, stream) {
  let size = 0;
  const md5 = crypto.createHash('md5');
  const sha1 = crypto.createHash('sha1');
  const hasher = miss.through((chunk, enc, cb) => {
    size += chunk.length;
    md5.update(chunk);
    sha1.update(chunk);
    cb(null, chunk);
  });
  return new Promise((resolve, reject) => miss.pipe(stream, hasher, createWriteStream(filePath), err => {
    if (err) {
      reject(err);
      return;
    }

    resolve({
      size,
      sha1: sha1.digest('hex'),
      md5: md5.digest('hex')
    });
  }));
}

function tryGetErrorFromStream(stream) {
  return new Promise((resolve, reject) => {
    miss.pipe(stream, miss.concat(parse), err => err ? reject(err) : noop);

    function parse(body) {
      try {
        const parsed = JSON.parse(body.toString('utf8'));
        resolve(parsed.message || parsed.error || null);
      } catch (err) {
        resolve(body.toString('utf8').slice(0, 16000));
      }
    }
  });
}

module.exports = AssetHandler;