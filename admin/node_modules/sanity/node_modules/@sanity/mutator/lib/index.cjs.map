{"version":3,"file":"index.cjs","sources":["../src/jsonpath/tokenize.ts","../src/jsonpath/parse.ts","../src/jsonpath/descend.ts","../src/jsonpath/toPath.ts","../src/jsonpath/Expression.ts","../src/jsonpath/Descender.ts","../src/jsonpath/Matcher.ts","../src/util.ts","../src/jsonpath/PlainProbe.ts","../src/jsonpath/extractAccessors.ts","../src/jsonpath/extractWithPath.ts","../src/jsonpath/arrayToJSONMatchPath.ts","../src/patch/SetPatch.ts","../src/patch/IncPatch.ts","../src/patch/util.ts","../src/patch/InsertPatch.ts","../src/patch/SetIfMissingPatch.ts","../src/patch/UnsetPatch.ts","../src/patch/DiffMatchPatch.ts","../src/patch/parse.ts","../src/patch/ImmutableAccessor.ts","../src/patch/Patcher.ts","../src/document/luid.ts","../src/document/debug.ts","../src/document/Mutation.ts","../src/document/Document.ts","../src/document/SquashingBuffer.ts","../src/document/BufferedDocument.ts"],"sourcesContent":["import type {\n  IdentifierToken,\n  NumberToken,\n  QuotedToken,\n  SymbolClass,\n  SymbolToken,\n  Token,\n} from './types'\n\n// TODO: Support '*'\n\nconst digitChar = /[0-9]/\nconst attributeCharMatcher = /^[a-zA-Z0-9_]$/\nconst attributeFirstCharMatcher = /^[a-zA-Z_]$/\n\nconst symbols: Record<SymbolClass, string[]> = {\n  operator: ['..', '.', ',', ':', '?'],\n  comparator: ['>', '>=', '<', '<=', '==', '!='],\n  keyword: ['$', '@'],\n  boolean: ['true', 'false'],\n  paren: ['[', ']'],\n}\n\nconst symbolClasses = Object.keys(symbols) as SymbolClass[]\n\ntype TokenizerFn = () => Token | null\n\n/**\n * Tokenizes a jsonpath2 expression\n */\nclass Tokenizer {\n  source: string\n  i: number\n  length: number\n  tokenizers: TokenizerFn[]\n\n  constructor(path: string) {\n    this.source = path\n    this.length = path.length\n    this.i = 0\n    this.tokenizers = [\n      this.tokenizeSymbol,\n      this.tokenizeIdentifier,\n      this.tokenizeNumber,\n      this.tokenizeQuoted,\n    ].map((fn) => fn.bind(this))\n  }\n\n  tokenize(): Token[] {\n    const result: Token[] = []\n    while (!this.EOF()) {\n      this.chompWhitespace()\n      let token: Token | null = null\n      // @todo refactor into a simpler `.find()`?\n      const found = this.tokenizers.some((tokenizer) => {\n        token = tokenizer()\n        return Boolean(token)\n      })\n      if (!found || !token) {\n        throw new Error(`Invalid tokens in jsonpath '${this.source}' @ ${this.i}`)\n      }\n      result.push(token)\n    }\n    return result\n  }\n\n  takeWhile(fn: (character: string) => string | null): string | null {\n    const start = this.i\n    let result = ''\n    while (!this.EOF()) {\n      const nextChar = fn(this.source[this.i])\n      if (nextChar === null) {\n        break\n      }\n      result += nextChar\n      this.i++\n    }\n    if (this.i === start) {\n      return null\n    }\n    return result\n  }\n\n  EOF(): boolean {\n    return this.i >= this.length\n  }\n\n  peek(): string | null {\n    if (this.EOF()) {\n      return null\n    }\n    return this.source[this.i]\n  }\n\n  consume(str: string) {\n    if (this.i + str.length > this.length) {\n      throw new Error(`Expected ${str} at end of jsonpath`)\n    }\n    if (str === this.source.slice(this.i, this.i + str.length)) {\n      this.i += str.length\n    } else {\n      throw new Error(`Expected \"${str}\", but source contained \"${this.source.slice()}`)\n    }\n  }\n\n  // Tries to match the upcoming bit of string with the provided string. If it matches, returns\n  // the string, then advances the read pointer to the next bit. If not, returns null and nothing\n  // happens.\n  tryConsume(str: string) {\n    if (this.i + str.length > this.length) {\n      return null\n    }\n    if (str === this.source.slice(this.i, this.i + str.length)) {\n      this.i += str.length\n      return str\n    }\n    return null\n  }\n\n  chompWhitespace(): void {\n    this.takeWhile((char): string | null => {\n      return char === ' ' ? '' : null\n    })\n  }\n\n  tokenizeQuoted(): QuotedToken | null {\n    const quote = this.peek()\n    if (quote === \"'\" || quote === '\"') {\n      this.consume(quote)\n      let escape = false\n      const inner = this.takeWhile((char) => {\n        if (escape) {\n          escape = false\n          return char\n        }\n        if (char === '\\\\') {\n          escape = true\n          return ''\n        }\n        if (char != quote) {\n          return char\n        }\n        return null\n      })\n      this.consume(quote)\n      return {\n        type: 'quoted',\n        value: inner,\n        quote: quote === '\"' ? 'double' : 'single',\n      }\n    }\n    return null\n  }\n\n  tokenizeIdentifier(): IdentifierToken | null {\n    let first = true\n    const identifier = this.takeWhile((char) => {\n      if (first) {\n        first = false\n        return char.match(attributeFirstCharMatcher) ? char : null\n      }\n      return char.match(attributeCharMatcher) ? char : null\n    })\n    if (identifier !== null) {\n      return {\n        type: 'identifier',\n        name: identifier,\n      }\n    }\n    return null\n  }\n\n  tokenizeNumber(): NumberToken | null {\n    const start = this.i\n    let dotSeen = false\n    let digitSeen = false\n    let negative = false\n    if (this.peek() === '-') {\n      negative = true\n      this.consume('-')\n    }\n    const number = this.takeWhile((char) => {\n      if (char === '.' && !dotSeen && digitSeen) {\n        dotSeen = true\n        return char\n      }\n      digitSeen = true\n      return char.match(digitChar) ? char : null\n    })\n    if (number !== null) {\n      return {\n        type: 'number',\n        value: negative ? -number : +number,\n        raw: negative ? `-${number}` : number,\n      }\n    }\n    // No number, rewind\n    this.i = start\n    return null\n  }\n\n  tokenizeSymbol(): SymbolToken | null {\n    for (const symbolClass of symbolClasses) {\n      const patterns = symbols[symbolClass]\n      const symbol = patterns.find((pattern) => this.tryConsume(pattern))\n      if (symbol) {\n        return {\n          type: symbolClass,\n          symbol,\n        }\n      }\n    }\n\n    return null\n  }\n}\n\nexport function tokenize(jsonpath: string): Token[] {\n  return new Tokenizer(jsonpath).tokenize()\n}\n","// Converts a string into an abstract syntax tree representation\n\nimport {tokenize} from './tokenize'\nimport type {\n  AliasExpr,\n  AttributeExpr,\n  BooleanExpr,\n  ConstraintExpr,\n  IndexExpr,\n  NumberExpr,\n  PathExpr,\n  RangeExpr,\n  RecursiveExpr,\n  StringExpr,\n  Token,\n  UnionExpr,\n} from './types'\n\n// TODO: Support '*'\n\nclass Parser {\n  tokens: Token[]\n  length: number\n  i: number\n\n  constructor(path: string) {\n    this.tokens = tokenize(path)\n    this.length = this.tokens.length\n    this.i = 0\n  }\n\n  parse() {\n    return this.parsePath()\n  }\n\n  EOF() {\n    return this.i >= this.length\n  }\n\n  // Look at upcoming token\n  peek() {\n    if (this.EOF()) {\n      return null\n    }\n    return this.tokens[this.i]\n  }\n\n  consume() {\n    const result = this.peek()\n    this.i += 1\n    return result\n  }\n\n  // Return next token if it matches the pattern\n  probe(pattern: Record<string, unknown>): Token | null {\n    const token = this.peek()\n    if (!token) {\n      return null\n    }\n\n    const record = token as unknown as Record<string, unknown>\n    const match = Object.keys(pattern).every((key) => {\n      return key in token && pattern[key] === record[key]\n    })\n\n    return match ? token : null\n  }\n\n  // Return and consume next token if it matches the pattern\n  match(pattern: Partial<Token>): Token | null {\n    return this.probe(pattern) ? this.consume() : null\n  }\n\n  parseAttribute(): AttributeExpr | null {\n    const token = this.match({type: 'identifier'})\n    if (token && token.type === 'identifier') {\n      return {\n        type: 'attribute',\n        name: token.name,\n      }\n    }\n    const quoted = this.match({type: 'quoted', quote: 'single'})\n    if (quoted && quoted.type === 'quoted') {\n      return {\n        type: 'attribute',\n        name: quoted.value || '',\n      }\n    }\n    return null\n  }\n\n  parseAlias(): AliasExpr | null {\n    if (this.match({type: 'keyword', symbol: '@'}) || this.match({type: 'keyword', symbol: '$'})) {\n      return {\n        type: 'alias',\n        target: 'self',\n      }\n    }\n    return null\n  }\n\n  parseNumber(): NumberExpr | null {\n    const token = this.match({type: 'number'})\n    if (token && token.type === 'number') {\n      return {\n        type: 'number',\n        value: token.value,\n      }\n    }\n    return null\n  }\n\n  parseNumberValue(): number | null {\n    const expr = this.parseNumber()\n    if (expr) {\n      return expr.value\n    }\n    return null\n  }\n\n  parseSliceSelector(): RangeExpr | IndexExpr | null {\n    const start = this.i\n    const rangeStart = this.parseNumberValue()\n\n    const colon1 = this.match({type: 'operator', symbol: ':'})\n    if (!colon1) {\n      if (rangeStart === null) {\n        // Rewind, this was actually nothing\n        this.i = start\n        return null\n      }\n\n      // Unwrap, this was just a single index not followed by colon\n      return {type: 'index', value: rangeStart}\n    }\n\n    const result: RangeExpr = {\n      type: 'range',\n      start: rangeStart,\n      end: this.parseNumberValue(),\n    }\n\n    const colon2 = this.match({type: 'operator', symbol: ':'})\n    if (colon2) {\n      result.step = this.parseNumberValue()\n    }\n\n    if (result.start === null && result.end === null) {\n      // rewind, this wasnt' a slice selector\n      this.i = start\n      return null\n    }\n\n    return result\n  }\n\n  parseValueReference(): AttributeExpr | RangeExpr | IndexExpr | null {\n    return this.parseAttribute() || this.parseSliceSelector()\n  }\n\n  parseLiteralValue(): StringExpr | BooleanExpr | NumberExpr | null {\n    const literalString = this.match({type: 'quoted', quote: 'double'})\n    if (literalString && literalString.type === 'quoted') {\n      return {\n        type: 'string',\n        value: literalString.value || '',\n      }\n    }\n    const literalBoolean = this.match({type: 'boolean'})\n    if (literalBoolean && literalBoolean.type === 'boolean') {\n      return {\n        type: 'boolean',\n        value: literalBoolean.symbol === 'true',\n      }\n    }\n    return this.parseNumber()\n  }\n\n  // TODO: Reorder constraints so that literal value is always on rhs, and variable is always\n  // on lhs.\n  parseFilterExpression(): ConstraintExpr | null {\n    const start = this.i\n    const expr = this.parseAttribute() || this.parseAlias()\n    if (!expr) {\n      return null\n    }\n\n    if (this.match({type: 'operator', symbol: '?'})) {\n      return {\n        type: 'constraint',\n        operator: '?',\n        lhs: expr,\n      }\n    }\n\n    const binOp = this.match({type: 'comparator'})\n    if (!binOp || binOp.type !== 'comparator') {\n      // No expression, rewind!\n      this.i = start\n      return null\n    }\n\n    const lhs = expr\n    const rhs = this.parseLiteralValue()\n    if (!rhs) {\n      throw new Error(`Operator ${binOp.symbol} needs a literal value at the right hand side`)\n    }\n\n    return {\n      type: 'constraint',\n      operator: binOp.symbol,\n      lhs: lhs,\n      rhs: rhs,\n    }\n  }\n\n  parseExpression(): ConstraintExpr | AttributeExpr | RangeExpr | IndexExpr | null {\n    return this.parseFilterExpression() || this.parseValueReference()\n  }\n\n  parseUnion(): UnionExpr | null {\n    if (!this.match({type: 'paren', symbol: '['})) {\n      return null\n    }\n\n    const terms = []\n    let expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference()\n    while (expr) {\n      terms.push(expr)\n      // End of union?\n      if (this.match({type: 'paren', symbol: ']'})) {\n        break\n      }\n\n      if (!this.match({type: 'operator', symbol: ','})) {\n        throw new Error('Expected ]')\n      }\n\n      expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference()\n      if (!expr) {\n        throw new Error(\"Expected expression following ','\")\n      }\n    }\n\n    return {\n      type: 'union',\n      nodes: terms,\n    }\n  }\n\n  parseRecursive(): RecursiveExpr | null {\n    if (!this.match({type: 'operator', symbol: '..'})) {\n      return null\n    }\n\n    const subpath = this.parsePath()\n    if (!subpath) {\n      throw new Error(\"Expected path following '..' operator\")\n    }\n\n    return {\n      type: 'recursive',\n      term: subpath,\n    }\n  }\n\n  parsePath(): PathExpr | AttributeExpr | UnionExpr | RecursiveExpr | null {\n    const nodes: (AttributeExpr | UnionExpr | RecursiveExpr)[] = []\n    const expr = this.parseAttribute() || this.parseUnion() || this.parseRecursive()\n    if (!expr) {\n      return null\n    }\n\n    nodes.push(expr)\n    while (!this.EOF()) {\n      if (this.match({type: 'operator', symbol: '.'})) {\n        const attr = this.parseAttribute()\n        if (!attr) {\n          throw new Error(\"Expected attribute name following '.\")\n        }\n        nodes.push(attr)\n        continue\n      } else if (this.probe({type: 'paren', symbol: '['})) {\n        const union = this.parseUnion()\n        if (!union) {\n          throw new Error(\"Expected union following '['\")\n        }\n        nodes.push(union)\n      } else {\n        const recursive = this.parseRecursive()\n        if (recursive) {\n          nodes.push(recursive)\n        }\n        break\n      }\n    }\n\n    if (nodes.length === 1) {\n      return nodes[0]\n    }\n\n    return {\n      type: 'path',\n      nodes: nodes,\n    }\n  }\n}\n\nexport function parseJsonPath(path: string): PathExpr | AttributeExpr | UnionExpr | RecursiveExpr {\n  const parsed = new Parser(path).parse()\n  if (!parsed) {\n    throw new Error(`Failed to parse JSON path \"${path}\"`)\n  }\n  return parsed\n}\n","import type {Expr, PathExpr} from './types'\n\n/**\n * Splits an expression into a set of heads, tails. A head is the next leaf node to\n * check for matches, and a tail is everything that follows it. Matching is done by\n * matching heads, then proceedint to the matching value, splitting the tail into\n * heads and tails and checking the heads against the new value, and so on.\n */\nexport function descend(tail: Expr): [Expr | null, PathExpr | null][] {\n  const [head, newTail] = splitIfPath(tail)\n  if (!head) {\n    throw new Error('Head cannot be null')\n  }\n\n  return spreadIfUnionHead(head, newTail)\n}\n\n// Split path in [head, tail]\nfunction splitIfPath(tail: Expr): [Expr | null, PathExpr | null] {\n  if (tail.type !== 'path') {\n    return [tail, null]\n  }\n\n  const nodes = tail.nodes\n  if (nodes.length === 0) {\n    return [null, null]\n  }\n\n  if (nodes.length === 1) {\n    return [nodes[0], null]\n  }\n\n  return [nodes[0], {type: 'path', nodes: nodes.slice(1)}]\n}\n\nfunction concatPaths(path1: PathExpr | null, path2: PathExpr | null): PathExpr | null {\n  if (!path1 && !path2) {\n    return null\n  }\n\n  const nodes1 = path1 ? path1.nodes : []\n  const nodes2 = path2 ? path2.nodes : []\n  return {\n    type: 'path',\n    nodes: nodes1.concat(nodes2),\n  }\n}\n\n// Spreads a union head into several heads/tails\nfunction spreadIfUnionHead(head: Expr, tail: PathExpr | null): [Expr | null, PathExpr | null][] {\n  if (head.type !== 'union') {\n    return [[head, tail]]\n  }\n\n  return head.nodes.map((node) => {\n    if (node.type === 'path') {\n      const [subHead, subTail] = splitIfPath(node)\n      return [subHead, concatPaths(subTail, tail)]\n    }\n\n    return [node, tail]\n  })\n}\n","import type {Expr} from './types'\n\n/**\n * Converts a parsed expression back into jsonpath2, roughly -\n * mostly for use with tests.\n *\n * @param expr - Expression to convert to path\n * @returns a string representation of the path\n * @internal\n */\nexport function toPath(expr: Expr): string {\n  return toPathInner(expr, false)\n}\n\nfunction toPathInner(expr: Expr, inUnion: boolean): string {\n  switch (expr.type) {\n    case 'attribute':\n      return expr.name\n    case 'alias':\n      return expr.target === 'self' ? '@' : '$'\n    case 'number':\n      return `${expr.value}`\n    case 'range': {\n      const result = []\n      if (!inUnion) {\n        result.push('[')\n      }\n      if (expr.start) {\n        result.push(`${expr.start}`)\n      }\n      result.push(':')\n      if (expr.end) {\n        result.push(`${expr.end}`)\n      }\n      if (expr.step) {\n        result.push(`:${expr.step}`)\n      }\n      if (!inUnion) {\n        result.push(']')\n      }\n      return result.join('')\n    }\n    case 'index':\n      if (inUnion) {\n        return `${expr.value}`\n      }\n\n      return `[${expr.value}]`\n    case 'constraint': {\n      const rhs = expr.rhs ? ` ${toPathInner(expr.rhs, false)}` : ''\n      const inner = `${toPathInner(expr.lhs, false)} ${expr.operator}${rhs}`\n\n      if (inUnion) {\n        return inner\n      }\n\n      return `[${inner}]`\n    }\n    case 'string':\n      return JSON.stringify(expr.value)\n    case 'path': {\n      const result = []\n      const nodes = expr.nodes.slice()\n      while (nodes.length > 0) {\n        const node = nodes.shift()\n        if (node) {\n          result.push(toPath(node))\n        }\n\n        const upcoming = nodes[0]\n        if (upcoming && toPathInner(upcoming, false)[0] !== '[') {\n          result.push('.')\n        }\n      }\n      return result.join('')\n    }\n    case 'union':\n      return `[${expr.nodes.map((e) => toPathInner(e, true)).join(',')}]`\n    default:\n      throw new Error(`Unknown node type ${expr.type}`)\n    case 'recursive':\n      return `..${toPathInner(expr.term, false)}`\n  }\n}\n","// A utility wrapper class to process parsed jsonpath expressions\n\nimport type {Expr, HeadTail} from './types'\nimport type {Probe} from './Probe'\nimport {descend} from './descend'\nimport {toPath} from './toPath'\nimport {parseJsonPath} from './parse'\n\nexport interface Range {\n  start: number\n  end: number\n  step: number\n}\n\nexport class Expression {\n  expr: Expr\n\n  constructor(expr: Expr | Expression | null) {\n    if (!expr) {\n      throw new Error('Attempted to create Expression from null-value')\n    }\n\n    // This is a wrapped expr\n    if ('expr' in expr) {\n      this.expr = expr.expr\n    } else {\n      this.expr = expr\n    }\n\n    if (!('type' in this.expr)) {\n      throw new Error('Attempt to create Expression for expression with no type')\n    }\n  }\n\n  isPath(): boolean {\n    return this.expr.type === 'path'\n  }\n\n  isUnion(): boolean {\n    return this.expr.type === 'union'\n  }\n\n  isCollection(): boolean {\n    return this.isPath() || this.isUnion()\n  }\n\n  isConstraint(): boolean {\n    return this.expr.type === 'constraint'\n  }\n\n  isRecursive(): boolean {\n    return this.expr.type === 'recursive'\n  }\n\n  isExistenceConstraint(): boolean {\n    return this.expr.type === 'constraint' && this.expr.operator === '?'\n  }\n\n  isIndex(): boolean {\n    return this.expr.type === 'index'\n  }\n\n  isRange(): boolean {\n    return this.expr.type === 'range'\n  }\n\n  expandRange(probe?: Probe): Range {\n    const probeLength = () => {\n      if (!probe) {\n        throw new Error('expandRange() required a probe that was not passed')\n      }\n\n      return probe.length()\n    }\n\n    let start = 'start' in this.expr ? this.expr.start || 0 : 0\n    start = interpretNegativeIndex(start, probe)\n    let end = 'end' in this.expr ? this.expr.end || probeLength() : probeLength()\n    end = interpretNegativeIndex(end, probe)\n    const step = 'step' in this.expr ? this.expr.step || 1 : 1\n    return {start, end, step}\n  }\n\n  isAttributeReference(): boolean {\n    return this.expr.type === 'attribute'\n  }\n\n  // Is a range or index -> something referencing indexes\n  isIndexReference(): boolean {\n    return this.isIndex() || this.isRange()\n  }\n\n  name(): string {\n    return 'name' in this.expr ? this.expr.name : ''\n  }\n\n  isSelfReference(): boolean {\n    return this.expr.type === 'alias' && this.expr.target === 'self'\n  }\n\n  constraintTargetIsSelf(): boolean {\n    return (\n      this.expr.type === 'constraint' &&\n      this.expr.lhs.type === 'alias' &&\n      this.expr.lhs.target === 'self'\n    )\n  }\n\n  constraintTargetIsAttribute(): boolean {\n    return this.expr.type === 'constraint' && this.expr.lhs.type === 'attribute'\n  }\n\n  testConstraint(probe: Probe): boolean {\n    const expr = this.expr\n\n    if (expr.type === 'constraint' && expr.lhs.type === 'alias' && expr.lhs.target === 'self') {\n      if (probe.containerType() !== 'primitive') {\n        return false\n      }\n\n      if (expr.type === 'constraint' && expr.operator === '?') {\n        return true\n      }\n\n      const lhs = probe.get()\n      const rhs = expr.rhs && 'value' in expr.rhs ? expr.rhs.value : undefined\n      return testBinaryOperator(lhs, expr.operator, rhs)\n    }\n\n    if (expr.type !== 'constraint') {\n      return false\n    }\n\n    const lhs = expr.lhs\n    if (!lhs) {\n      throw new Error('No LHS of expression')\n    }\n\n    if (lhs.type !== 'attribute') {\n      throw new Error(`Constraint target ${lhs.type} not supported`)\n    }\n\n    if (probe.containerType() !== 'object') {\n      return false\n    }\n\n    const lhsValue = probe.getAttribute(lhs.name)\n    if (lhsValue === undefined || lhsValue === null || lhsValue.containerType() !== 'primitive') {\n      // LHS is void and empty, or it is a collection\n      return false\n    }\n\n    if (this.isExistenceConstraint()) {\n      // There is no rhs, and if we're here the key did exist\n      return true\n    }\n\n    const rhs = expr.rhs && 'value' in expr.rhs ? expr.rhs.value : undefined\n    return testBinaryOperator(lhsValue.get(), expr.operator, rhs)\n  }\n\n  pathNodes(): Expr[] {\n    return this.expr.type === 'path' ? this.expr.nodes : [this.expr]\n  }\n\n  prepend(node: Expression): Expression {\n    if (!node) {\n      return this\n    }\n\n    return new Expression({\n      type: 'path',\n      nodes: node.pathNodes().concat(this.pathNodes()),\n    })\n  }\n\n  concat(other: Expression | null): Expression {\n    return other ? other.prepend(this) : this\n  }\n\n  descend(): HeadTail[] {\n    return descend(this.expr).map((headTail) => {\n      const [head, tail] = headTail\n      return {\n        head: head ? new Expression(head) : null,\n        tail: tail ? new Expression(tail) : null,\n      }\n    })\n  }\n\n  unwrapRecursive(): Expression {\n    if (this.expr.type !== 'recursive') {\n      throw new Error(`Attempt to unwrap recursive on type ${this.expr.type}`)\n    }\n\n    return new Expression(this.expr.term)\n  }\n\n  toIndicies(probe?: Probe): number[] {\n    if (this.expr.type !== 'index' && this.expr.type !== 'range') {\n      throw new Error('Node cannot be converted to indexes')\n    }\n\n    if (this.expr.type === 'index') {\n      return [interpretNegativeIndex(this.expr.value, probe)]\n    }\n\n    const result: number[] = []\n    const range = this.expandRange(probe)\n    let {start, end} = range\n    if (range.step < 0) {\n      ;[start, end] = [end, start]\n    }\n\n    for (let i = start; i < end; i++) {\n      result.push(i)\n    }\n\n    return result\n  }\n\n  toFieldReferences(): number[] | string[] {\n    if (this.isIndexReference()) {\n      return this.toIndicies()\n    }\n    if (this.expr.type === 'attribute') {\n      return [this.expr.name]\n    }\n    throw new Error(`Can't convert ${this.expr.type} to field references`)\n  }\n\n  toString(): string {\n    return toPath(this.expr)\n  }\n\n  static fromPath(path: string): Expression {\n    const parsed = parseJsonPath(path)\n    if (!parsed) {\n      throw new Error(`Failed to parse path \"${path}\"`)\n    }\n\n    return new Expression(parsed)\n  }\n\n  static attributeReference(name: string): Expression {\n    return new Expression({\n      type: 'attribute',\n      name: name,\n    })\n  }\n\n  static indexReference(i: number): Expression {\n    return new Expression({\n      type: 'index',\n      value: i,\n    })\n  }\n}\n\n// Tests an operator on two given primitive values\nfunction testBinaryOperator(lhsValue: any, operator: string, rhsValue: any) {\n  switch (operator) {\n    case '>':\n      return lhsValue > rhsValue\n    case '>=':\n      return lhsValue >= rhsValue\n    case '<':\n      return lhsValue < rhsValue\n    case '<=':\n      return lhsValue <= rhsValue\n    case '==':\n      return lhsValue === rhsValue\n    case '!=':\n      return lhsValue !== rhsValue\n    default:\n      throw new Error(`Unsupported binary operator ${operator}`)\n  }\n}\n\nfunction interpretNegativeIndex(index: number, probe?: Probe): number {\n  if (index >= 0) {\n    return index\n  }\n\n  if (!probe) {\n    throw new Error('interpretNegativeIndex() must have a probe when < 0')\n  }\n\n  return index + probe.length()\n}\n","import {flatten} from 'lodash'\nimport {Expression} from './Expression'\nimport type {Probe} from './Probe'\n\n/**\n * Descender models the state of one partial jsonpath evaluation. Head is the\n * next thing to match, tail is the upcoming things once the head is matched.\n */\nexport class Descender {\n  head: Expression | null\n  tail: Expression | null\n\n  constructor(head: Expression | null, tail: Expression | null) {\n    this.head = head\n    this.tail = tail\n  }\n\n  // Iterate this descender once processing any constraints that are\n  // resolvable on the current value. Returns an array of new descenders\n  // that are guaranteed to be without constraints in the head\n  iterate(probe: Probe): Descender[] {\n    let result: Descender[] = [this]\n    if (this.head && this.head.isConstraint()) {\n      let anyConstraints = true\n      // Keep rewriting constraints until there are none left\n      while (anyConstraints) {\n        result = flatten(\n          result.map((descender) => {\n            return descender.iterateConstraints(probe)\n          })\n        )\n        anyConstraints = result.some((descender) => {\n          return descender.head && descender.head.isConstraint()\n        })\n      }\n    }\n    return result\n  }\n\n  isRecursive(): boolean {\n    return Boolean(this.head && this.head.isRecursive())\n  }\n\n  hasArrived(): boolean {\n    return this.head === null && this.tail === null\n  }\n\n  extractRecursives(): Descender[] {\n    if (this.head && this.head.isRecursive()) {\n      const term = this.head.unwrapRecursive()\n      return new Descender(null, term.concat(this.tail)).descend()\n    }\n    return []\n  }\n\n  iterateConstraints(probe: Probe): Descender[] {\n    const head = this.head\n    if (head === null || !head.isConstraint()) {\n      // Not a constraint, no rewrite\n      return [this]\n    }\n\n    const result: Descender[] = []\n\n    if (probe.containerType() === 'primitive' && head.constraintTargetIsSelf()) {\n      if (head.testConstraint(probe)) {\n        result.push(...this.descend())\n      }\n      return result\n    }\n\n    // The value is an array\n    if (probe.containerType() === 'array') {\n      const length = probe.length()\n      for (let i = 0; i < length; i++) {\n        // Push new descenders with constraint translated to literal indices\n        // where they match\n        const constraint = probe.getIndex(i)\n        if (constraint && head.testConstraint(constraint)) {\n          result.push(new Descender(new Expression({type: 'index', value: i}), this.tail))\n        }\n      }\n      return result\n    }\n\n    // The value is an object\n    if (probe.containerType() === 'object') {\n      if (head.constraintTargetIsSelf()) {\n        // There are no matches for target self ('@') on a plain object\n        return []\n      }\n\n      if (head.testConstraint(probe)) {\n        return this.descend()\n      }\n\n      return result\n    }\n\n    return result\n  }\n\n  descend(): Descender[] {\n    if (!this.tail) {\n      return [new Descender(null, null)]\n    }\n\n    return this.tail.descend().map((ht) => {\n      return new Descender(ht.head, ht.tail)\n    })\n  }\n\n  toString(): string {\n    const result = ['<']\n    if (this.head) {\n      result.push(this.head.toString())\n    }\n    result.push('|')\n    if (this.tail) {\n      result.push(this.tail.toString())\n    }\n    result.push('>')\n    return result.join('')\n  }\n}\n","import {parseJsonPath} from './parse'\nimport {Descender} from './Descender'\nimport {Expression} from './Expression'\nimport type {Probe} from './Probe'\n\ninterface Result<P = unknown> {\n  leads: {\n    target: Expression\n    matcher: Matcher\n  }[]\n\n  delivery?: {\n    targets: Expression[]\n    payload: P\n  }\n}\n\n/**\n * @internal\n */\nexport class Matcher {\n  active: Descender[]\n  recursives: Descender[]\n  payload: unknown\n\n  constructor(active: Descender[], parent?: Matcher) {\n    this.active = active || []\n    if (parent) {\n      this.recursives = parent.recursives\n      this.payload = parent.payload\n    } else {\n      this.recursives = []\n    }\n    this.extractRecursives()\n  }\n\n  setPayload(payload: unknown): this {\n    this.payload = payload\n    return this\n  }\n\n  // Moves any recursive descenders onto the recursive track, removing them from\n  // the active set\n  extractRecursives(): void {\n    this.active = this.active.filter((descender) => {\n      if (descender.isRecursive()) {\n        this.recursives.push(...descender.extractRecursives())\n        return false\n      }\n      return true\n    })\n  }\n\n  // Find recursives that are relevant now and should be considered part of the active set\n  activeRecursives(probe: Probe): Descender[] {\n    return this.recursives.filter((descender) => {\n      const head = descender.head\n      if (!head) {\n        return false\n      }\n\n      // Constraints are always relevant\n      if (head.isConstraint()) {\n        return true\n      }\n\n      // Index references are only relevant for indexable values\n      if (probe.containerType() === 'array' && head.isIndexReference()) {\n        return true\n      }\n\n      // Attribute references are relevant for plain objects\n      if (probe.containerType() === 'object') {\n        return head.isAttributeReference() && probe.hasAttribute(head.name())\n      }\n\n      return false\n    })\n  }\n\n  match(probe: Probe): Result {\n    return this.iterate(probe).extractMatches(probe)\n  }\n\n  iterate(probe: Probe): Matcher {\n    const newActiveSet: Descender[] = []\n    this.active.concat(this.activeRecursives(probe)).forEach((descender) => {\n      newActiveSet.push(...descender.iterate(probe))\n    })\n    return new Matcher(newActiveSet, this)\n  }\n\n  // Returns true if any of the descenders in the active or recursive set\n  // consider the current state a final destination\n  isDestination(): boolean {\n    return this.active.some((descender) => descender.hasArrived())\n  }\n\n  hasRecursives(): boolean {\n    return this.recursives.length > 0\n  }\n\n  // Returns any payload delivieries and leads that needs to be followed to complete\n  // the process.\n  extractMatches(probe: Probe): Result {\n    const leads: {target: Expression; matcher: Matcher}[] = []\n    const targets: Expression[] = []\n    this.active.forEach((descender) => {\n      if (descender.hasArrived()) {\n        // This was already arrived, so matches this value, not descenders\n        targets.push(\n          new Expression({\n            type: 'alias',\n            target: 'self',\n          })\n        )\n        return\n      }\n\n      const descenderHead = descender.head\n      if (!descenderHead) {\n        return\n      }\n\n      if (probe.containerType() === 'array' && !descenderHead.isIndexReference()) {\n        // This descender does not match an indexable value\n        return\n      }\n\n      if (probe.containerType() === 'object' && !descenderHead.isAttributeReference()) {\n        // This descender never match a plain object\n        return\n      }\n\n      if (descender.tail) {\n        // Not arrived yet\n        const matcher = new Matcher(descender.descend(), this)\n        descenderHead.toFieldReferences().forEach(() => {\n          leads.push({\n            target: descenderHead,\n            matcher: matcher,\n          })\n        })\n      } else {\n        // arrived\n        targets.push(descenderHead)\n      }\n    })\n\n    // If there are recursive terms, we need to add a lead for every descendant ...\n    if (this.hasRecursives()) {\n      // The recustives matcher will have no active set, only inherit recursives from this\n      const recursivesMatcher = new Matcher([], this)\n      if (probe.containerType() === 'array') {\n        const length = probe.length()\n        for (let i = 0; i < length; i++) {\n          leads.push({\n            target: Expression.indexReference(i),\n            matcher: recursivesMatcher,\n          })\n        }\n      } else if (probe.containerType() === 'object') {\n        probe.attributeKeys().forEach((name) => {\n          leads.push({\n            target: Expression.attributeReference(name),\n            matcher: recursivesMatcher,\n          })\n        })\n      }\n    }\n\n    return targets.length > 0\n      ? {leads: leads, delivery: {targets, payload: this.payload}}\n      : {leads: leads}\n  }\n\n  static fromPath(jsonpath: string): Matcher {\n    const path = parseJsonPath(jsonpath)\n    if (!path) {\n      throw new Error(`Failed to parse path from \"${jsonpath}\"`)\n    }\n\n    const descender = new Descender(null, new Expression(path))\n    return new Matcher(descender.descend())\n  }\n}\n","export function isRecord(value: unknown): value is {[key: string]: unknown} {\n  return value !== null && typeof value === 'object'\n}\n","import {isRecord} from '../util'\nimport type {Probe} from './Probe'\n\n// A default implementation of a probe for vanilla JS _values\nexport class PlainProbe implements Probe {\n  _value: unknown\n  path: (string | number)[]\n\n  constructor(value: unknown, path?: (string | number)[]) {\n    this._value = value\n    this.path = path || []\n  }\n\n  containerType(): 'array' | 'object' | 'primitive' {\n    if (Array.isArray(this._value)) {\n      return 'array'\n    } else if (this._value !== null && typeof this._value === 'object') {\n      return 'object'\n    }\n    return 'primitive'\n  }\n\n  length(): number {\n    if (!Array.isArray(this._value)) {\n      throw new Error(\"Won't return length of non-indexable _value\")\n    }\n\n    return this._value.length\n  }\n\n  getIndex(i: number): false | null | PlainProbe {\n    if (!Array.isArray(this._value)) {\n      return false\n    }\n\n    if (i >= this.length()) {\n      return null\n    }\n\n    return new PlainProbe(this._value[i], this.path.concat(i))\n  }\n\n  hasAttribute(key: string): boolean {\n    if (!isRecord(this._value)) {\n      return false\n    }\n\n    return this._value.hasOwnProperty(key)\n  }\n\n  attributeKeys(): string[] {\n    return isRecord(this._value) ? Object.keys(this._value) : []\n  }\n\n  getAttribute(key: string): null | PlainProbe {\n    if (!isRecord(this._value)) {\n      throw new Error('getAttribute only applies to plain objects')\n    }\n\n    if (!this.hasAttribute(key)) {\n      return null\n    }\n\n    return new PlainProbe(this._value[key], this.path.concat(key))\n  }\n\n  get(): unknown {\n    return this._value\n  }\n}\n","import {compact} from 'lodash'\nimport {Expression} from './Expression'\nimport {Matcher} from './Matcher'\nimport {PlainProbe} from './PlainProbe'\nimport {Probe} from './Probe'\n\nexport function extractAccessors(path: string, value: unknown): Probe[] {\n  const result: Probe[] = []\n  const matcher = Matcher.fromPath(path).setPayload(function appendResult(values: Probe[]) {\n    result.push(...values)\n  })\n  const accessor = new PlainProbe(value)\n  descend(matcher, accessor)\n  return result\n}\n\nfunction descend(matcher: Matcher, accessor: Probe) {\n  const {leads, delivery} = matcher.match(accessor)\n\n  leads.forEach((lead) => {\n    accessorsFromTarget(lead.target, accessor).forEach((childAccessor) => {\n      descend(lead.matcher, childAccessor)\n    })\n  })\n\n  if (delivery) {\n    delivery.targets.forEach((target) => {\n      if (typeof delivery.payload === 'function') {\n        delivery.payload(accessorsFromTarget(target, accessor))\n      }\n    })\n  }\n}\n\nfunction accessorsFromTarget(target: Expression, accessor: Probe) {\n  const result = []\n  if (target.isIndexReference()) {\n    target.toIndicies(accessor).forEach((i) => {\n      result.push(accessor.getIndex(i))\n    })\n  } else if (target.isAttributeReference()) {\n    result.push(accessor.getAttribute(target.name()))\n  } else if (target.isSelfReference()) {\n    result.push(accessor)\n  } else {\n    throw new Error(`Unable to derive accessor for target ${target.toString()}`)\n  }\n  return compact(result)\n}\n","import {extractAccessors} from './extractAccessors'\n\n/**\n * Extracts a value for the given JsonPath, and includes the specific path of where it was found\n *\n * @param path - Path to extract\n * @param value - Value to extract from\n * @returns An array of objects with `path` and `value` keys\n * @internal\n */\nexport function extractWithPath(\n  path: string,\n  value: unknown\n): {path: (string | number)[]; value: unknown}[] {\n  const accessors = extractAccessors(path, value)\n  return accessors.map((acc) => ({path: acc.path, value: acc.get()}))\n}\n","import type {Path, PathSegment} from '@sanity/types'\nimport {isRecord} from '../util'\n\nconst IS_DOTTABLE = /^[a-z_$]+/\n\n/**\n * Converts a path in array form to a JSONPath string\n *\n * @param pathArray - Array of path segments\n * @returns String representation of the path\n * @internal\n */\nexport function arrayToJSONMatchPath(pathArray: Path): string {\n  let path = ''\n  pathArray.forEach((segment, index) => {\n    path += stringifySegment(segment, index === 0)\n  })\n  return path\n}\n\n// Converts an array of simple values (strings, numbers only) to a jsonmatch path string.\nfunction stringifySegment(\n  segment: PathSegment | Record<string, unknown>,\n  hasLeading: boolean\n): string {\n  if (typeof segment === 'number') {\n    return `[${segment}]`\n  }\n\n  if (isRecord(segment)) {\n    const seg = segment as Record<string, unknown>\n    return Object.keys(segment)\n      .map((key) => (isPrimitiveValue(seg[key]) ? `[${key}==\"${seg[key]}\"]` : ''))\n      .join('')\n  }\n\n  if (typeof segment === 'string' && IS_DOTTABLE.test(segment)) {\n    return hasLeading ? segment : `.${segment}`\n  }\n\n  return `['${segment}']`\n}\n\nfunction isPrimitiveValue(val: unknown): val is string | number | boolean {\n  switch (typeof val) {\n    case 'number':\n    case 'string':\n    case 'boolean':\n      return true\n    default:\n      return false\n  }\n}\n","import type {Expression} from '../jsonpath'\nimport type {ImmutableAccessor} from './ImmutableAccessor'\n\nexport class SetPatch {\n  id: string\n  path: string\n  value: unknown\n\n  constructor(id: string, path: string, value: unknown) {\n    this.id = id\n    this.path = path\n    this.value = value\n  }\n\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n    targets.forEach((target) => {\n      if (target.isSelfReference()) {\n        result = result.set(this.value)\n      } else if (target.isIndexReference()) {\n        target.toIndicies(accessor).forEach((i) => {\n          result = result.setIndex(i, this.value)\n        })\n      } else if (target.isAttributeReference()) {\n        result = result.setAttribute(target.name(), this.value)\n      } else {\n        throw new Error(`Unable to apply to target ${target.toString()}`)\n      }\n    })\n    return result\n  }\n}\n","import type {Expression} from '../jsonpath'\nimport type {ImmutableAccessor} from './ImmutableAccessor'\n\nfunction performIncrement(previousValue: unknown, delta: number): number {\n  if (typeof previousValue !== 'number' || !Number.isFinite(previousValue)) {\n    return previousValue as number\n  }\n\n  return previousValue + delta\n}\n\nexport class IncPatch {\n  path: string\n  value: number\n  id: string\n\n  constructor(id: string, path: string, value: number) {\n    this.path = path\n    this.value = value\n    this.id = id\n  }\n\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n\n    // The target must be a container type\n    if (result.containerType() === 'primitive') {\n      return result\n    }\n\n    for (const target of targets) {\n      if (target.isIndexReference()) {\n        for (const index of target.toIndicies(accessor)) {\n          // Skip patching unless the index actually currently exists\n          const item = result.getIndex(index)\n          if (!item) {\n            continue\n          }\n\n          const previousValue = item.get()\n          result = result.setIndex(index, performIncrement(previousValue, this.value))\n        }\n\n        continue\n      }\n\n      if (target.isAttributeReference()) {\n        const attribute = result.getAttribute(target.name())\n        if (!attribute) {\n          continue\n        }\n\n        const previousValue = attribute.get()\n        result = result.setAttribute(target.name(), performIncrement(previousValue, this.value))\n        continue\n      }\n\n      throw new Error(`Unable to apply to target ${target.toString()}`)\n    }\n\n    return result\n  }\n}\n","import type {Expression} from '../jsonpath'\nimport type {ImmutableAccessor} from './ImmutableAccessor'\n\nexport function targetsToIndicies(targets: Expression[], accessor: ImmutableAccessor): number[] {\n  const result: number[] = []\n  targets.forEach((target) => {\n    if (target.isIndexReference()) {\n      result.push(...target.toIndicies(accessor))\n    }\n  })\n  return result.sort()\n}\n","import {min, max} from 'lodash'\nimport type {Expression} from '../jsonpath'\nimport type {ImmutableAccessor} from './ImmutableAccessor'\nimport {targetsToIndicies} from './util'\n\nexport class InsertPatch {\n  location: string\n  path: string\n  items: unknown[]\n  id: string\n\n  constructor(id: string, location: string, path: string, items: unknown[]) {\n    this.id = id\n    this.location = location\n    this.path = path\n    this.items = items\n  }\n\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n    if (accessor.containerType() !== 'array') {\n      throw new Error('Attempt to apply insert patch to non-array value')\n    }\n\n    switch (this.location) {\n      case 'before': {\n        const pos = minIndex(targets, accessor)\n        result = result.insertItemsAt(pos, this.items)\n        break\n      }\n      case 'after': {\n        const pos = maxIndex(targets, accessor)\n        result = result.insertItemsAt(pos + 1, this.items)\n        break\n      }\n      case 'replace': {\n        // TODO: Properly implement ranges in compliance with content lake\n        // This will only properly support single contiguous ranges\n        const indicies = targetsToIndicies(targets, accessor)\n        result = result.unsetIndices(indicies)\n        result = result.insertItemsAt(indicies[0], this.items)\n        break\n      }\n      default: {\n        throw new Error(`Unsupported location atm: ${this.location}`)\n      }\n    }\n    return result\n  }\n}\n\nfunction minIndex(targets: Expression[], accessor: ImmutableAccessor): number {\n  let result = min(targetsToIndicies(targets, accessor)) || 0\n\n  // Ranges may be zero-length and not turn up in indices\n  targets.forEach((target) => {\n    if (target.isRange()) {\n      const {start} = target.expandRange()\n      if (start < result) {\n        result = start\n      }\n    }\n  })\n  return result\n}\n\nfunction maxIndex(targets: Expression[], accessor: ImmutableAccessor): number {\n  let result = max(targetsToIndicies(targets, accessor)) || 0\n\n  // Ranges may be zero-length and not turn up in indices\n  targets.forEach((target) => {\n    if (target.isRange()) {\n      const {end} = target.expandRange()\n      if (end > result) {\n        result = end\n      }\n    }\n  })\n  return result\n}\n","import type {Expression} from '../jsonpath'\nimport type {ImmutableAccessor} from './ImmutableAccessor'\n\nexport class SetIfMissingPatch {\n  id: string\n  path: string\n  value: unknown\n\n  constructor(id: string, path: string, value: unknown) {\n    this.id = id\n    this.path = path\n    this.value = value\n  }\n\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n    targets.forEach((target) => {\n      if (target.isIndexReference()) {\n        // setIfMissing do not apply to arrays, since Gradient will reject nulls in arrays\n      } else if (target.isAttributeReference()) {\n        if (!result.hasAttribute(target.name())) {\n          result = accessor.setAttribute(target.name(), this.value)\n        }\n      } else {\n        throw new Error(`Unable to apply to target ${target.toString()}`)\n      }\n    })\n    return result\n  }\n}\n","import type {Expression} from '../jsonpath'\nimport type {ImmutableAccessor} from './ImmutableAccessor'\nimport {targetsToIndicies} from './util'\n\nexport class UnsetPatch {\n  id: string\n  path: string\n  value: unknown\n\n  constructor(id: string, path: string) {\n    this.id = id\n    this.path = path\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n    switch (accessor.containerType()) {\n      case 'array':\n        result = result.unsetIndices(targetsToIndicies(targets, accessor))\n        break\n      case 'object':\n        targets.forEach((target) => {\n          result = result.unsetAttribute(target.name())\n        })\n        break\n      default:\n        throw new Error(\n          'Target value is neither indexable or an object. This error should potentially just be silently ignored?'\n        )\n    }\n    return result\n  }\n}\n","/* eslint-disable new-cap, camelcase */\nimport * as DMP from 'diff-match-patch'\nimport {Expression} from '../jsonpath'\nimport {ImmutableAccessor} from './ImmutableAccessor'\n\nconst dmp = new DMP.diff_match_patch()\n\nfunction applyPatch(patch: DMP.patch_obj[], oldValue: unknown) {\n  // Silently avoid patching if the value type is not string\n  if (typeof oldValue !== 'string') return oldValue\n  return dmp.patch_apply(patch, oldValue)[0]\n}\n\nexport class DiffMatchPatch {\n  path: string\n  dmpPatch: DMP.patch_obj[]\n  id: string\n\n  constructor(id: string, path: string, dmpPatchSrc: string) {\n    this.id = id\n    this.path = path\n    this.dmpPatch = dmp.patch_fromText(dmpPatchSrc)\n  }\n\n  apply(targets: Expression[], accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n\n    // The target must be a container type\n    if (result.containerType() === 'primitive') {\n      return result\n    }\n\n    for (const target of targets) {\n      if (target.isIndexReference()) {\n        for (const index of target.toIndicies(accessor)) {\n          // Skip patching unless the index actually currently exists\n          const item = result.getIndex(index)\n          if (!item) {\n            continue\n          }\n\n          const oldValue = item.get()\n          const nextValue = applyPatch(this.dmpPatch, oldValue)\n          result = result.setIndex(index, nextValue)\n        }\n\n        continue\n      }\n\n      if (target.isAttributeReference() && result.hasAttribute(target.name())) {\n        const attribute = result.getAttribute(target.name())\n        if (!attribute) {\n          continue\n        }\n\n        const oldValue = attribute.get()\n        const nextValue = applyPatch(this.dmpPatch, oldValue)\n        result = result.setAttribute(target.name(), nextValue)\n        continue\n      }\n\n      throw new Error(`Unable to apply diffMatchPatch to target ${target.toString()}`)\n    }\n\n    return result\n  }\n}\n","import {SetPatch} from './SetPatch'\nimport {IncPatch} from './IncPatch'\nimport {InsertPatch} from './InsertPatch'\nimport {SetIfMissingPatch} from './SetIfMissingPatch'\nimport {UnsetPatch} from './UnsetPatch'\nimport {DiffMatchPatch} from './DiffMatchPatch'\nimport type {PatchTypes, SingleDocumentPatch} from './types'\n\n// Parses a content lake patch into our own personal patch implementations\nexport function parsePatch(patch: SingleDocumentPatch | SingleDocumentPatch[]): PatchTypes[] {\n  const result: PatchTypes[] = []\n  if (Array.isArray(patch)) {\n    return patch.reduce((r, p) => r.concat(parsePatch(p)), result)\n  }\n\n  const {set, setIfMissing, unset, diffMatchPatch, inc, dec, insert} = patch\n  if (set) {\n    Object.keys(set).forEach((path) => {\n      result.push(new SetPatch(patch.id, path, set[path]))\n    })\n  }\n\n  if (setIfMissing) {\n    Object.keys(setIfMissing).forEach((path) => {\n      result.push(new SetIfMissingPatch(patch.id, path, setIfMissing[path]))\n    })\n  }\n\n  if (unset) {\n    unset.forEach((path) => {\n      result.push(new UnsetPatch(patch.id, path))\n    })\n  }\n\n  if (diffMatchPatch) {\n    Object.keys(diffMatchPatch).forEach((path) => {\n      result.push(new DiffMatchPatch(patch.id, path, diffMatchPatch[path]))\n    })\n  }\n\n  if (inc) {\n    Object.keys(inc).forEach((path) => {\n      result.push(new IncPatch(patch.id, path, inc[path]))\n    })\n  }\n\n  if (dec) {\n    Object.keys(dec).forEach((path) => {\n      result.push(new IncPatch(patch.id, path, -dec[path]))\n    })\n  }\n\n  if (insert) {\n    let location: string\n    let path: string\n    const spec = insert\n    if ('before' in spec) {\n      location = 'before'\n      path = spec.before\n    } else if ('after' in spec) {\n      location = 'after'\n      path = spec.after\n    } else if ('replace' in spec) {\n      location = 'replace'\n      path = spec.replace\n    } else {\n      throw new Error('Invalid insert patch')\n    }\n\n    result.push(new InsertPatch(patch.id, location, path, spec.items))\n  }\n\n  return result\n}\n","import type {Probe} from '../jsonpath/Probe'\n\n/**\n * An immutable probe/writer for plain JS objects that will never mutate\n * the provided _value in place. Each setter returns a new (wrapped) version\n * of the value.\n */\nexport class ImmutableAccessor implements Probe {\n  _value: unknown\n  path: (string | number)[]\n\n  constructor(value: unknown, path?: (string | number)[]) {\n    this._value = value\n    this.path = path || []\n  }\n\n  containerType(): 'array' | 'object' | 'primitive' {\n    if (Array.isArray(this._value)) {\n      return 'array'\n    } else if (this._value !== null && typeof this._value === 'object') {\n      return 'object'\n    }\n    return 'primitive'\n  }\n\n  // Common reader, supported by all containers\n  get(): unknown {\n    return this._value\n  }\n\n  // Array reader\n  length(): number {\n    if (!Array.isArray(this._value)) {\n      throw new Error(\"Won't return length of non-indexable _value\")\n    }\n\n    return this._value.length\n  }\n\n  getIndex(i: number): ImmutableAccessor | false | null {\n    if (!Array.isArray(this._value)) {\n      return false\n    }\n\n    if (i >= this.length()) {\n      return null\n    }\n\n    return new ImmutableAccessor(this._value[i], this.path.concat(i))\n  }\n\n  // Object reader\n  hasAttribute(key: string): boolean {\n    return isRecord(this._value) ? this._value.hasOwnProperty(key) : false\n  }\n\n  attributeKeys(): string[] {\n    return isRecord(this._value) ? Object.keys(this._value) : []\n  }\n\n  getAttribute(key: string): ImmutableAccessor | null {\n    if (!isRecord(this._value)) {\n      throw new Error('getAttribute only applies to plain objects')\n    }\n\n    if (!this.hasAttribute(key)) {\n      return null\n    }\n\n    return new ImmutableAccessor(this._value[key], this.path.concat(key))\n  }\n\n  // Common writer, supported by all containers\n  set(value: unknown): ImmutableAccessor {\n    return value === this._value ? this : new ImmutableAccessor(value, this.path)\n  }\n\n  // array writer interface\n  setIndex(i: number, value: unknown): ImmutableAccessor {\n    if (!Array.isArray(this._value)) {\n      throw new Error('setIndex only applies to arrays')\n    }\n\n    if (value === this._value[i]) {\n      return this\n    }\n\n    const nextValue = this._value.slice()\n    nextValue[i] = value\n    return new ImmutableAccessor(nextValue, this.path)\n  }\n\n  setIndexAccessor(i: number, accessor: ImmutableAccessor): ImmutableAccessor {\n    return this.setIndex(i, accessor.get())\n  }\n\n  unsetIndices(indices: number[]): ImmutableAccessor {\n    if (!Array.isArray(this._value)) {\n      throw new Error('unsetIndices only applies to arrays')\n    }\n\n    const length = this._value.length\n    const nextValue = []\n    // Copy every _value _not_ in the indices array over to the newValue\n    for (let i = 0; i < length; i++) {\n      if (indices.indexOf(i) === -1) {\n        nextValue.push(this._value[i])\n      }\n    }\n    return new ImmutableAccessor(nextValue, this.path)\n  }\n\n  insertItemsAt(pos: number, items: unknown[]): ImmutableAccessor {\n    if (!Array.isArray(this._value)) {\n      throw new Error('insertItemsAt only applies to arrays')\n    }\n\n    let nextValue\n    if (this._value.length === 0 && pos === 0) {\n      nextValue = items\n    } else {\n      nextValue = this._value.slice(0, pos).concat(items).concat(this._value.slice(pos))\n    }\n\n    return new ImmutableAccessor(nextValue, this.path)\n  }\n\n  // Object writer interface\n  setAttribute(key: string, value: unknown): ImmutableAccessor {\n    if (!isRecord(this._value)) {\n      throw new Error('Unable to set attribute of non-object container')\n    }\n\n    if (value === this._value[key]) {\n      return this\n    }\n\n    const nextValue = Object.assign({}, this._value, {[key]: value})\n    return new ImmutableAccessor(nextValue, this.path)\n  }\n\n  setAttributeAccessor(key: string, accessor: ImmutableAccessor): ImmutableAccessor {\n    return this.setAttribute(key, accessor.get())\n  }\n\n  unsetAttribute(key: string): ImmutableAccessor {\n    if (!isRecord(this._value)) {\n      throw new Error('Unable to unset attribute of non-object container')\n    }\n\n    const nextValue = Object.assign({}, this._value)\n    delete nextValue[key]\n    return new ImmutableAccessor(nextValue, this.path)\n  }\n}\n\nfunction isRecord(value: unknown): value is {[key: string]: unknown} {\n  return value !== null && typeof value === 'object'\n}\n","import type {Doc} from '../document/types'\nimport {Matcher} from '../jsonpath'\nimport {parsePatch} from './parse'\nimport {ImmutableAccessor} from './ImmutableAccessor'\nimport {PatchTypes, SingleDocumentPatch} from './types'\n\nexport interface Patch {\n  id: string\n  path: string\n}\n\nexport class Patcher {\n  patches: PatchTypes[]\n\n  constructor(patch: SingleDocumentPatch | SingleDocumentPatch[]) {\n    this.patches = parsePatch(patch)\n  }\n\n  apply(value: Doc | null): unknown {\n    // Apply just makes a root accessor around the provided\n    // value, then applies the patches. Due to the use of\n    // ImmutableAccessor it is guaranteed to return either the\n    // exact same object it was provided (in the case of no changes),\n    // or a completely new object. It will never mutate the object in place.\n    const accessor = new ImmutableAccessor(value)\n    return this.applyViaAccessor(accessor).get()\n  }\n\n  // If you want to use your own accessor implementation, you can use this method\n  // to invoke the patcher. Since all subsequent accessors for children of this accessor\n  // are obtained through the methods in the accessors, you retain full control of the\n  // implementation throguhgout the application. Have a look in ImmutableAccessor\n  // to see an example of how accessors are implemented.\n  applyViaAccessor(accessor: ImmutableAccessor): ImmutableAccessor {\n    let result = accessor\n    const idAccessor = accessor.getAttribute('_id')\n    if (!idAccessor) {\n      throw new Error('Cannot apply patch to document with no _id')\n    }\n\n    const id = idAccessor.get()\n    for (const patch of this.patches) {\n      if (patch.id !== id) {\n        // Ignore patches that are not targetted at this document\n        continue\n      }\n\n      const matcher = Matcher.fromPath(patch.path).setPayload(patch)\n      result = process(matcher, result)\n    }\n\n    return result\n  }\n}\n\n// Recursively (depth first) follows any leads generated by the matcher, expecting\n// a patch to be the payload. When matchers report a delivery, the\n// apply(targets, accessor) is called on the patch\nfunction process(matcher: Matcher, accessor: ImmutableAccessor) {\n  let result = accessor\n  // Every time we execute the matcher a new set of leads is generated. Each lead\n  // is a target (being an index, an attribute name or a range) in the form of an\n  // Expression instance. For each lead target there is also a matcher. Our job is to obtain\n  // accessor(s) for each target (there might be more than one, since the targets may\n  // be ranges) and run the provided matcher on those accessors.\n  const {leads, delivery} = matcher.match(accessor)\n  leads.forEach((lead) => {\n    if (lead.target.isIndexReference()) {\n      lead.target.toIndicies().forEach((i) => {\n        const item = result.getIndex(i)\n        if (!item) {\n          throw new Error('Index out of bounds')\n        }\n\n        result = result.setIndexAccessor(i, process(lead.matcher, item))\n      })\n    } else if (lead.target.isAttributeReference()) {\n      const oldValueAccessor = result.getAttribute(lead.target.name())\n      if (!oldValueAccessor) {\n        // Don't follow lead, no such attribute\n        return\n      }\n\n      const newValueAccessor = process(lead.matcher, oldValueAccessor)\n      if (oldValueAccessor !== newValueAccessor) {\n        result = result.setAttributeAccessor(lead.target.name(), newValueAccessor)\n      }\n    } else {\n      throw new Error(`Unable to handle target ${lead.target.toString()}`)\n    }\n  })\n\n  // Each time we run the matcher, we might also get a delivery. This means that a\n  // term in the jsonpath terminated here and the patch should be applied. The delivery\n  // arrives in the form of an array of targets and a payload (which in this application\n  // is the patch). Conveniently the patches accept an array of targets and an accessor\n  // to do its work, so here we just pass those to the patch and we're done.\n  if (delivery && isPatcher(delivery.payload)) {\n    const patch = delivery.payload\n    result = patch.apply(delivery.targets, result)\n  }\n\n  return result\n}\n\nfunction isPatcher(payload: unknown): payload is PatchTypes {\n  return Boolean(\n    payload &&\n      typeof payload === 'object' &&\n      payload !== null &&\n      'apply' in payload &&\n      typeof (payload as PatchTypes).apply === 'function'\n  )\n}\n","import {uuid} from '@sanity/uuid'\n\n/**\n * Locally unique id's. We use this to generate transaction ids, and they don't have to be\n * cryptographically unique, as the worst that can happen is that they get rejected because\n * of a collision, and then we should just retry with a new id.\n */\nexport const luid = uuid\n","import debugIt from 'debug'\n\nexport const debug = debugIt('mutator-document')\n","import {Patcher} from '../patch'\nimport {luid} from './luid'\nimport {debug} from './debug'\nimport type {Doc, Mut} from './types'\n\n/**\n * Parameters attached to the mutation\n *\n * @internal\n */\nexport interface MutationParams {\n  transactionId?: string\n  transition?: string\n  identity?: string\n  previousRev?: string\n  resultRev?: string\n  mutations: Mut[]\n  timestamp?: string\n  effects?: {apply: unknown; revert: unknown}\n}\n\n/**\n * A mutation describing a number of operations on a single document.\n * This should be considered an immutable structure. Mutations are compiled\n * on first application, and any changes in properties will not effectively\n * change its behavior after that.\n *\n * @internal\n */\nexport class Mutation {\n  params: MutationParams\n\n  compiled?: (doc: Doc | null) => Doc | null\n\n  _appliesToMissingDocument: boolean | undefined\n\n  constructor(options: MutationParams) {\n    this.params = options\n  }\n\n  get transactionId(): string | undefined {\n    return this.params.transactionId\n  }\n\n  get transition(): string | undefined {\n    return this.params.transition\n  }\n\n  get identity(): string | undefined {\n    return this.params.identity\n  }\n\n  get previousRev(): string | undefined {\n    return this.params.previousRev\n  }\n\n  get resultRev(): string | undefined {\n    return this.params.resultRev\n  }\n\n  get mutations(): Mut[] {\n    return this.params.mutations\n  }\n\n  get timestamp(): Date | undefined {\n    if (typeof this.params.timestamp === 'string') {\n      return new Date(this.params.timestamp)\n    }\n\n    return undefined\n  }\n\n  get effects():\n    | {\n        apply: unknown\n        revert: unknown\n      }\n    | undefined {\n    return this.params.effects\n  }\n\n  assignRandomTransactionId(): void {\n    this.params.transactionId = luid()\n    this.params.resultRev = this.params.transactionId\n  }\n\n  appliesToMissingDocument(): boolean {\n    if (typeof this._appliesToMissingDocument !== 'undefined') {\n      return this._appliesToMissingDocument\n    }\n\n    // Only mutations starting with a create operation apply to documents that do not exist ...\n    const firstMut = this.mutations[0]\n    if (firstMut) {\n      this._appliesToMissingDocument = Boolean(\n        firstMut.create || firstMut.createIfNotExists || firstMut.createOrReplace\n      )\n    } else {\n      this._appliesToMissingDocument = true\n    }\n\n    return this._appliesToMissingDocument\n  }\n\n  // Compiles all mutations into a handy function\n  compile(): void {\n    const operations: ((doc: Doc | null) => Doc | null)[] = []\n\n    this.mutations.forEach((mutation) => {\n      if (mutation.create) {\n        // TODO: Fail entire patch if document did exist\n        const create = mutation.create || {}\n        operations.push((doc): Doc => {\n          if (doc) {\n            return doc\n          }\n\n          return Object.assign(create as Doc, {\n            _createdAt: create._createdAt || this.params.timestamp,\n          })\n        })\n        return\n      }\n\n      if (mutation.createIfNotExists) {\n        const createIfNotExists = mutation.createIfNotExists || {}\n        operations.push((doc) =>\n          doc === null\n            ? Object.assign(createIfNotExists, {\n                _createdAt: createIfNotExists._createdAt || this.params.timestamp,\n              })\n            : doc\n        )\n        return\n      }\n\n      if (mutation.createOrReplace) {\n        const createOrReplace = mutation.createOrReplace || {}\n        operations.push(() =>\n          Object.assign(createOrReplace, {\n            _createdAt: createOrReplace._createdAt || this.params.timestamp,\n          })\n        )\n        return\n      }\n\n      if (mutation.delete) {\n        operations.push(() => null)\n        return\n      }\n\n      if (mutation.patch) {\n        if ('query' in mutation.patch) {\n          // @todo Warn/throw? Investigate if this can ever happen\n          return\n        }\n\n        const patch = new Patcher(mutation.patch)\n        operations.push((doc) => patch.apply(doc) as Doc | null)\n        return\n      }\n\n      throw new Error(`Unsupported mutation ${JSON.stringify(mutation, null, 2)}`)\n    })\n\n    // Assign `_updatedAt` to the timestamp of the mutation if set\n    if (typeof this.params.timestamp === 'string') {\n      operations.push((doc) => {\n        return doc ? Object.assign(doc, {_updatedAt: this.params.timestamp}) : null\n      })\n    }\n\n    const prevRev = this.previousRev\n    const rev = this.resultRev || this.transactionId\n    this.compiled = (doc: Doc | null) => {\n      if (prevRev && doc && prevRev !== doc._rev) {\n        throw new Error(\n          `Previous revision for this mutation was ${prevRev}, but the document revision is ${doc._rev}`\n        )\n      }\n\n      let result: Doc | null = doc\n      for (const operation of operations) {\n        result = operation(result)\n      }\n\n      // Should update _rev?\n      if (result && rev) {\n        // Ensure that result is a unique object, even if the operation was a no-op\n        if (result === doc) {\n          result = Object.assign({}, doc)\n        }\n        result._rev = rev\n      }\n\n      return result\n    }\n  }\n\n  apply(document: Doc | null): Doc | null {\n    debug('Applying mutation %O to document %O', this.mutations, document)\n    if (!this.compiled) {\n      this.compile()\n    }\n\n    const result = this.compiled!(document)\n    debug('  => %O', result)\n    return result\n  }\n\n  static applyAll(document: Doc | null, mutations: Mutation[]): Doc | null {\n    return mutations.reduce((doc, mutation) => mutation.apply(doc), document)\n  }\n\n  // Given a number of yet-to-be-committed mutation objects, collects them into one big mutation\n  // any metadata like transactionId is ignored and must be submitted by the client. It is assumed\n  // that all mutations are on the same document.\n  // TOOO: Optimize mutations, eliminating mutations that overwrite themselves!\n  static squash(document: Doc | null, mutations: Mutation[]): Mutation {\n    const squashed = mutations.reduce(\n      (result, mutation) => result.concat(...mutation.mutations),\n      [] as Mut[]\n    )\n    return new Mutation({mutations: squashed})\n  }\n}\n","// TODO: When we have timestamps on mutation notifications, we can reject incoming mutations that are older\n// than the document we are seeing.\n\nimport {isEqual} from 'lodash'\nimport {Mutation} from './Mutation'\nimport {debug} from './debug'\nimport type {Doc} from './types'\n\n/**\n * @internal\n */\nexport interface SubmissionResponder {\n  success: () => void\n  failure: () => void\n}\n\n/**\n * Models a document as it is changed by our own local patches and remote patches coming in from\n * the server. Consolidates incoming patches with our own submitted patches and maintains two\n * versions of the document. EDGE is the optimistic document that the user sees that will always\n * immediately reflect whatever she is doing to it, and HEAD which is the confirmed version of the\n * document consistent with the mutations we have received from the server. As long as nothing out of\n * the ordinary happens, we can track all changes by hooking into the onMutation callback, but we\n * must also respect onRebase events that fire when we have to backtrack because one of our optimistically\n * applied patches were rejected, or some bastard was able to slip a mutation in between ours own.\n *\n * @internal\n */\nexport class Document {\n  /**\n   * Incoming patches from the server waiting to be applied to HEAD\n   */\n  incoming: Mutation[] = []\n\n  /**\n   * Patches we know has been subitted to the server, but has not been seen yet in the return channel\n   * so we can't be sure about the ordering yet (someone else might have slipped something between them)\n   */\n  submitted: Mutation[] = []\n\n  /**\n   * Pending mutations\n   */\n  pending: Mutation[] = []\n\n  /**\n   * Our model of the document according to the incoming patches from the server\n   */\n  HEAD: Doc | null\n\n  /**\n   * Our optimistic model of what the document will probably look like as soon as all our patches\n   * have been processed. Updated every time we stage a new mutation, but also might revert back\n   * to previous states if our mutations fail, or could change if unexpected mutations arrive\n   * between our own. The `onRebase` callback will be called when EDGE changes in this manner.\n   */\n  EDGE: Doc | null\n\n  /**\n   * Called with the EDGE document when that document changes for a reason other than us staging\n   * a new patch or receiving a mutation from the server while our EDGE is in sync with HEAD:\n   * I.e. when EDGE changes because the order of mutations has changed in relation to our\n   * optimistic predictions.\n   */\n  onRebase?: (edge: Doc | null, incomingMutations: Mutation[], pendingMutations: Mutation[]) => void\n\n  /**\n   * Called when we receive a patch in the normal order of things, but the mutation is not ours\n   */\n  onMutation?: (msg: {mutation: Mutation; document: Doc | null; remote: boolean}) => void\n\n  /**\n   * Called when consistency state changes with the boolean value of the current consistency state\n   */\n  onConsistencyChanged?: (isConsistent: boolean) => void\n\n  /**\n   * Called whenever a new incoming mutation comes in. These are always ordered correctly.\n   */\n  onRemoteMutation?: (mut: Mutation) => void\n\n  /**\n   * We are consistent when there are no unresolved mutations of our own, and no un-applicable\n   * incoming mutations. When this has been going on for too long, and there has been a while\n   * since we staged a new mutation, it is time to reset your state.\n   */\n  inconsistentAt: Date | null = null\n\n  /**\n   * The last time we staged a patch of our own. If we have been inconsistent for a while, but it\n   * hasn't been long since we staged a new mutation, the reason is probably just because the user\n   * is typing or something.\n   *\n   * Should be used as a guard against resetting state for inconsistency reasons.\n   */\n  lastStagedAt: Date | null = null\n\n  constructor(doc: Doc | null) {\n    this.reset(doc)\n    this.HEAD = doc\n    this.EDGE = doc\n  }\n\n  // Reset the state of the Document, used to recover from unsavory states by reloading the document\n  reset(doc: Doc | null): void {\n    this.incoming = []\n    this.submitted = []\n    this.pending = []\n    this.inconsistentAt = null\n    this.HEAD = doc\n    this.EDGE = doc\n    this.considerIncoming()\n    this.updateConsistencyFlag()\n  }\n\n  // Call when a mutation arrives from Sanity\n  arrive(mutation: Mutation): void {\n    this.incoming.push(mutation)\n    this.considerIncoming()\n    this.updateConsistencyFlag()\n  }\n\n  // Call to signal that we are submitting a mutation. Returns a callback object with a\n  // success and failure handler that must be called according to the outcome of our\n  // submission.\n  stage(mutation: Mutation, silent?: boolean): SubmissionResponder {\n    if (!mutation.transactionId) {\n      throw new Error('Mutations _must_ have transactionId when submitted')\n    }\n    this.lastStagedAt = new Date()\n\n    debug('Staging mutation %s (pushed to pending)', mutation.transactionId)\n    this.pending.push(mutation)\n    this.EDGE = mutation.apply(this.EDGE)\n\n    if (this.onMutation && !silent) {\n      this.onMutation({\n        mutation,\n        document: this.EDGE,\n        remote: false,\n      })\n    }\n\n    const txnId = mutation.transactionId\n\n    this.updateConsistencyFlag()\n\n    return {\n      success: () => {\n        this.pendingSuccessfullySubmitted(txnId)\n        this.updateConsistencyFlag()\n      },\n      failure: () => {\n        this.pendingFailed(txnId)\n        this.updateConsistencyFlag()\n      },\n    }\n  }\n\n  // Call to check if everything is nice and quiet and there are no unresolved mutations.\n  // Means this model thinks both HEAD and EDGE is up to date with what the server sees.\n  isConsistent(): boolean {\n    return !this.inconsistentAt\n  }\n\n  // Private\n\n  // Attempts to apply any resolvable incoming patches to HEAD. Will keep patching as long as there\n  // are applicable patches to be applied\n  considerIncoming(): void {\n    let mustRebase = false\n    let nextMut: Mutation | undefined\n    const rebaseMutations: Mutation[] = []\n\n    // Filter mutations that are older than the document\n    if (this.HEAD && this.HEAD._updatedAt) {\n      const updatedAt = new Date(this.HEAD._updatedAt)\n      if (this.incoming.find((mut) => mut.timestamp && mut.timestamp < updatedAt)) {\n        this.incoming = this.incoming.filter((mut) => mut.timestamp && mut.timestamp < updatedAt)\n      }\n    }\n\n    // Keep applying mutations as long as any apply\n    let protect = 0\n    do {\n      // Find next mutation that can be applied to HEAD (if any)\n      if (this.HEAD) {\n        const HEAD = this.HEAD\n        nextMut = HEAD._rev ? this.incoming.find((mut) => mut.previousRev === HEAD._rev) : undefined\n      } else {\n        // When HEAD is null, that means the document is currently deleted. Only mutations that start with a create\n        // operation will be considered.\n        nextMut = this.incoming.find((mut) => mut.appliesToMissingDocument())\n      }\n\n      if (nextMut) {\n        const applied = this.applyIncoming(nextMut)\n        mustRebase = mustRebase || applied\n        if (mustRebase) {\n          rebaseMutations.push(nextMut)\n        }\n\n        if (protect++ > 10) {\n          throw new Error(\n            `Mutator stuck flushing incoming mutations. Probably stuck here: ${JSON.stringify(\n              nextMut\n            )}`\n          )\n        }\n      }\n    } while (nextMut)\n\n    if (this.incoming.length > 0 && debug.enabled) {\n      debug(\n        'Unable to apply mutations %s',\n        this.incoming.map((mut) => mut.transactionId).join(', ')\n      )\n    }\n\n    if (mustRebase) {\n      this.rebase(rebaseMutations)\n    }\n  }\n\n  // check current consistency state, update flag and invoke callback if needed\n  updateConsistencyFlag(): void {\n    const wasConsistent = this.isConsistent()\n    const isConsistent =\n      this.pending.length === 0 && this.submitted.length === 0 && this.incoming.length === 0\n    // Update the consistency state, taking care not to update the timestamp if we were inconsistent and still are\n    if (isConsistent) {\n      this.inconsistentAt = null\n    } else if (!this.inconsistentAt) {\n      this.inconsistentAt = new Date()\n    }\n    // Handle onConsistencyChanged callback\n    if (wasConsistent != isConsistent && this.onConsistencyChanged) {\n      if (isConsistent) {\n        debug('Buffered document is inconsistent')\n      } else {\n        debug('Buffered document is consistent')\n      }\n      this.onConsistencyChanged(isConsistent)\n    }\n  }\n\n  // apply an incoming patch that has been prequalified as the next in line for this document\n  applyIncoming(mut: Mutation | undefined): boolean {\n    if (!mut) {\n      return false\n    }\n\n    if (!mut.transactionId) {\n      throw new Error('Received incoming mutation without a transaction ID')\n    }\n\n    debug(\n      'Applying mutation %s -> %s to rev %s',\n      mut.previousRev,\n      mut.resultRev,\n      this.HEAD && this.HEAD._rev\n    )\n\n    this.HEAD = mut.apply(this.HEAD)\n\n    if (this.onRemoteMutation) {\n      this.onRemoteMutation(mut)\n    }\n\n    // Eliminate from incoming set\n    this.incoming = this.incoming.filter((m) => m.transactionId !== mut.transactionId)\n\n    if (this.hasUnresolvedMutations()) {\n      const needRebase = this.consumeUnresolved(mut.transactionId)\n      if (debug.enabled) {\n        debug(\n          `Incoming mutation ${mut.transactionId} appeared while there were pending or submitted local mutations`\n        )\n        debug(`Submitted txnIds: ${this.submitted.map((m) => m.transactionId).join(', ')}`)\n        debug(`Pending txnIds: ${this.pending.map((m) => m.transactionId).join(', ')}`)\n        debug(`needRebase === %s`, needRebase)\n      }\n      return needRebase\n    }\n    debug(\n      `Remote mutation %s arrived w/o any pending or submitted local mutations`,\n      mut.transactionId\n    )\n    this.EDGE = this.HEAD\n    if (this.onMutation) {\n      this.onMutation({\n        mutation: mut,\n        document: this.EDGE,\n        remote: true,\n      })\n    }\n    return false\n  }\n\n  /**\n   * Returns true if there are unresolved mutations between HEAD and EDGE, meaning we have\n   * mutations that are still waiting to be either submitted, or to be confirmed by the server.\n   *\n   * @returns true if there are unresolved mutations between HEAD and EDGE, false otherwise\n   */\n  hasUnresolvedMutations(): boolean {\n    return this.submitted.length > 0 || this.pending.length > 0\n  }\n\n  /**\n   * When an incoming mutation is applied to HEAD, this is called to remove the mutation from\n   * the unresolved state. If the newly applied patch is the next upcoming unresolved mutation,\n   * no rebase is needed, but we might have the wrong idea about the ordering of mutations, so in\n   * that case we are given the flag `needRebase` to tell us that this mutation arrived out of\n   * order in terms of our optimistic version, so a rebase is needed.\n   *\n   * @param txnId - Transaction ID of the remote mutation\n   * @returns true if rebase is needed, false otherwise\n   */\n  consumeUnresolved(txnId: string): boolean {\n    // If we have nothing queued up, we are in sync and can apply patch with no\n    // rebasing\n    if (this.submitted.length === 0 && this.pending.length === 0) {\n      return false\n    }\n\n    // If we can consume the directly upcoming mutation, we won't have to rebase\n    if (this.submitted.length !== 0) {\n      if (this.submitted[0].transactionId === txnId) {\n        debug(\n          `Remote mutation %s matches upcoming submitted mutation, consumed from 'submitted' buffer`,\n          txnId\n        )\n        this.submitted.shift()\n        return false\n      }\n    } else if (this.pending.length > 0 && this.pending[0].transactionId === txnId) {\n      // There are no submitted, but some are pending so let's check the upcoming pending\n      debug(\n        `Remote mutation %s matches upcoming pending mutation, consumed from 'pending' buffer`,\n        txnId\n      )\n      this.pending.shift()\n      return false\n    }\n\n    debug(\n      'The mutation was not the upcoming mutation, scrubbing. Pending: %d, Submitted: %d',\n      this.pending.length,\n      this.submitted.length\n    )\n\n    // The mutation was not the upcoming mutation, so we'll have to check everything to\n    // see if we have an out of order situation\n    this.submitted = this.submitted.filter((mut) => mut.transactionId !== txnId)\n    this.pending = this.pending.filter((mut) => mut.transactionId !== txnId)\n    debug(`After scrubbing: Pending: %d, Submitted: %d`, this.pending.length, this.submitted.length)\n\n    // Whether we had it or not we have either a reordering, or an unexpected mutation\n    // so must rebase\n    return true\n  }\n\n  pendingSuccessfullySubmitted(pendingTxnId: string): void {\n    if (this.pending.length === 0) {\n      // If there are no pending, it has probably arrived allready\n      return\n    }\n\n    const first = this.pending[0]\n    if (first.transactionId === pendingTxnId) {\n      // Nice, the pending transaction arrived in order\n      this.pending.shift()\n      this.submitted.push(first)\n      return\n    }\n\n    // Oh, no. Submitted out of order.\n    let justSubmitted: Mutation | undefined\n    const stillPending: Mutation[] = []\n    this.pending.forEach((mutation) => {\n      if (mutation.transactionId === pendingTxnId) {\n        justSubmitted = mutation\n        return\n      }\n\n      stillPending.push(mutation)\n    })\n\n    // Not found? Hopefully it has already arrived. Might have been forgotten by now\n    if (justSubmitted) {\n      this.submitted.push(justSubmitted)\n    }\n\n    this.pending = stillPending\n\n    // Must rebase since mutation order has changed\n    this.rebase([])\n  }\n\n  pendingFailed(pendingTxnId: string): void {\n    this.pending = this.pending.filter((mutation) => mutation.transactionId !== pendingTxnId)\n\n    // Rebase to revert document to what it looked like before the failed mutation\n    this.rebase([])\n  }\n\n  rebase(incomingMutations: Mutation[]): void {\n    const oldEdge = this.EDGE\n    this.EDGE = Mutation.applyAll(this.HEAD, this.submitted.concat(this.pending))\n\n    // Copy over rev, since we don't care if it changed, we only care about the content\n    if (oldEdge !== null && this.EDGE !== null) {\n      oldEdge._rev = this.EDGE._rev\n    }\n\n    const changed = !isEqual(this.EDGE, oldEdge)\n    if (changed && this.onRebase) {\n      this.onRebase(this.EDGE, incomingMutations, this.pending)\n    }\n  }\n}\n","import * as DiffMatchPatch from 'diff-match-patch'\nimport {extractWithPath} from '../jsonpath/extractWithPath'\nimport {arrayToJSONMatchPath} from '../jsonpath/arrayToJSONMatchPath'\nimport {Mutation} from './Mutation'\nimport {debug} from './debug'\nimport type {Doc, Mut} from './types'\n\n/**\n * Implements a buffer for mutations that incrementally optimises the mutations by\n * eliminating set-operations that overwrite earlier set-operations, and rewrite\n * set-operations that change strings into other strings into diffMatchPatch operations.\n *\n * @internal\n */\nexport class SquashingBuffer {\n  /**\n   * The document forming the basis of this squash\n   */\n  BASIS: Doc | null\n\n  /**\n   * The document after the out-Mutation has been applied, but before the staged\n   * operations are committed.\n   */\n  PRESTAGE: Doc | null\n\n  /**\n   * setOperations contain the latest set operation by path. If the set-operations are\n   * updating strings to new strings, they are rewritten as diffMatchPatch operations,\n   * any new set operations on the same paths overwrites any older set operations.\n   * Only set-operations assigning plain values to plain values gets optimized like this.\n   */\n  setOperations: Record<string, Mut | undefined>\n\n  /**\n   * `documentPresent` is true whenever we know that the document must be present due\n   * to preceeding mutations. `false` implies that it may or may not already exist.\n   */\n  documentPresent: boolean\n\n  /**\n   * The operations in the out-Mutation are not able to be optimized any further\n   */\n  out: Mut[] = []\n\n  /**\n   * Staged mutation operations\n   */\n  staged: Mut[]\n\n  /**\n   * Internal reusable diffMatchPatch instance\n   * @internal\n   */\n  private dmp: DiffMatchPatch.diff_match_patch // eslint-disable-line camelcase\n\n  constructor(doc: Doc | null) {\n    if (doc) {\n      debug('Reset mutation buffer to rev %s', doc._rev)\n    } else {\n      debug('Reset mutation buffer state to document being deleted')\n    }\n\n    this.staged = []\n    this.setOperations = {}\n    this.documentPresent = false\n\n    this.BASIS = doc\n    this.PRESTAGE = doc\n\n    // eslint-disable-next-line new-cap\n    this.dmp = new DiffMatchPatch.diff_match_patch()\n  }\n\n  add(mut: Mutation): void {\n    mut.mutations.forEach((op) => this.addOperation(op))\n  }\n\n  hasChanges(): boolean {\n    return this.out.length > 0 || Object.keys(this.setOperations).length > 0\n  }\n\n  /**\n   * Extracts the mutations in this buffer.\n   * After this is done, the buffer lifecycle is over and the client should\n   * create an new one with the new, updated BASIS.\n   *\n   * @param txnId - Transaction ID\n   * @returns A `Mutation` instance if we had outgoing mutations pending, null otherwise\n   */\n  purge(txnId?: string): Mutation | null {\n    this.stashStagedOperations()\n    let result = null\n    if (this.out.length > 0) {\n      debug('Purged mutation buffer')\n      result = new Mutation({\n        mutations: this.out,\n        resultRev: txnId,\n        transactionId: txnId,\n      })\n    }\n    this.out = []\n    this.documentPresent = false\n    return result\n  }\n\n  addOperation(op: Mut): void {\n    // Is this a set patch, and only a set patch, and does it apply to the document at hand?\n    if (\n      op.patch &&\n      op.patch.set &&\n      'id' in op.patch &&\n      op.patch.id === this.PRESTAGE?._id &&\n      Object.keys(op.patch).length === 2 // `id` + `set`\n    ) {\n      const setPatch = op.patch.set\n      const unoptimizable: Record<string, unknown> = {}\n      // Apply all optimisable keys in the patch\n      for (const path of Object.keys(setPatch)) {\n        if (setPatch.hasOwnProperty(path)) {\n          if (!this.optimiseSetOperation(path, setPatch[path])) {\n            // If not optimisable, add to unoptimizable set\n            unoptimizable[path] = setPatch[path]\n          }\n        }\n      }\n\n      // If any weren't optimisable, add them to an unoptimised set-operation, then\n      // stash everything.\n      if (Object.keys(unoptimizable).length > 0) {\n        debug('Unoptimizable set-operation detected, purging optimization buffer')\n        this.staged.push({patch: {id: this.PRESTAGE._id, set: unoptimizable}})\n        this.stashStagedOperations()\n      }\n\n      return\n    }\n\n    // Is this a createIfNotExists for our document?\n    if (op.createIfNotExists && this.PRESTAGE && op.createIfNotExists._id === this.PRESTAGE._id) {\n      if (!this.documentPresent) {\n        // If we don't know that it's present we'll have to stage and stash.\n        this.staged.push(op)\n        this.documentPresent = true\n        this.stashStagedOperations()\n      }\n\n      // Otherwise we can fully ignore it.\n      return\n    }\n\n    debug('Unoptimizable mutation detected, purging optimization buffer')\n    // console.log(\"Unoptimizable operation, stashing\", JSON.stringify(op))\n    // Un-optimisable operations causes everything to be stashed\n    this.staged.push(op)\n    this.stashStagedOperations()\n  }\n\n  /**\n   * Attempt to perform one single set operation in an optimised manner, return value\n   * reflects whether or not the operation could be performed.\n\n   * @param path - The JSONPath to the set operation in question\n   * @param nextValue - The value to be set\n   * @returns True of optimized, false otherwise\n   */\n  optimiseSetOperation(path: string, nextValue: unknown): boolean {\n    // console.log('optimiseSetOperation', path, nextValue)\n    // If target value is not a plain value, unable to optimise\n    if (typeof nextValue === 'object') {\n      // console.log(\"Not optimisable because next value is object\")\n      return false\n    }\n\n    // Check the source values, if there is more than one value being assigned,\n    // we won't optimise\n    const matches = extractWithPath(path, this.PRESTAGE)\n    // If we are not overwriting exactly one key, this cannot be optimised, so we bail\n    if (matches.length !== 1) {\n      // console.log('Not optimisable because match count is != 1', JSON.stringify(matches))\n      return false\n    }\n\n    // Okay, we are assigning exactly one value to exactly one existing slot, so we might optimise\n    const match = matches[0]\n    // If the value of the match is an array or object, we cannot safely optimise this since the meaning\n    // of pre-existing operations might change (in theory, at least), so we bail\n    if (typeof match.value === 'object') {\n      // console.log(\"Not optimisable because old value is object\")\n      return false\n    }\n\n    if (!this.PRESTAGE) {\n      // Shouldn't happen, but makes typescript happy\n      return false\n    }\n\n    // If the new and old value are the equal, we optimise this operation by discarding it\n    // Now, let's build the operation\n    let op: Mut | null = null\n    if (match.value === nextValue) {\n      // If new and old values are equal, we optimise this by deleting the operation\n      // console.log(\"Omitting operation\")\n      op = null\n    } else if (typeof match.value === 'string' && typeof nextValue === 'string') {\n      // console.log(\"Rewriting to dmp\")\n      // We are updating a string to another string, so we are making a diffMatchPatch\n      try {\n        const patch = this.dmp\n          .patch_make(match.value, nextValue)\n          .map((dmpPatch) => dmpPatch.toString())\n          .join('')\n        op = {patch: {id: this.PRESTAGE._id, diffMatchPatch: {[path]: patch}}}\n      } catch {\n        // patch_make failed due to unicode issue https://github.com/google/diff-match-patch/issues/59\n        return false\n      }\n    } else {\n      // console.log(\"Not able to rewrite to dmp, making normal set\")\n      // We are changing the type of the value, so must make a normal set-operation\n      op = {patch: {id: this.PRESTAGE._id, set: {[path]: nextValue}}}\n    }\n\n    // Let's make a plain, concrete path from the array-path. We use this to keep only the latest set\n    // operation touching this path in the buffer.\n    const canonicalPath = arrayToJSONMatchPath(match.path)\n\n    // Store this operation, overwriting any previous operations touching this same path\n    if (op) {\n      this.setOperations[canonicalPath] = op\n    } else {\n      delete this.setOperations[canonicalPath]\n    }\n\n    // Signal that we succeeded in optimizing this patch\n    return true\n  }\n\n  stashStagedOperations(): void {\n    // Short circuit if there are no staged operations\n    const nextOps: Mut[] = []\n\n    // Extract the existing outgoing operations if any\n    Object.keys(this.setOperations).forEach((key) => {\n      const op = this.setOperations[key]\n      if (op) {\n        nextOps.push(op)\n      }\n    })\n\n    nextOps.push(...this.staged)\n    if (nextOps.length > 0) {\n      this.PRESTAGE = new Mutation({mutations: nextOps}).apply(this.PRESTAGE) as Doc\n      this.staged = []\n      this.setOperations = {}\n    }\n\n    this.out.push(...nextOps)\n  }\n\n  /**\n   * Rebases given the new base-document\n   *\n   * @param newBasis - New base document to rebase on\n   * @returns New \"edge\" document with buffered changes integrated\n   */\n  rebase(newBasis: Doc | null): Doc | null {\n    this.stashStagedOperations()\n\n    if (newBasis === null) {\n      // If document was just deleted, we must throw out local changes\n      this.out = []\n      this.BASIS = newBasis\n      this.PRESTAGE = newBasis\n      this.documentPresent = false\n    } else {\n      this.BASIS = newBasis\n\n      // @todo was this supposed to be `this.out.length > 0`?\n      // surely this is always `true`?\n      if (this.out) {\n        this.PRESTAGE = new Mutation({mutations: this.out}).apply(this.BASIS) as Doc\n      } else {\n        this.PRESTAGE = this.BASIS\n      }\n    }\n\n    return this.PRESTAGE\n  }\n}\n","import {isEqual} from 'lodash'\nimport {Document} from './Document'\nimport {Mutation} from './Mutation'\nimport {SquashingBuffer} from './SquashingBuffer'\nimport {debug} from './debug'\nimport type {Doc, Mut} from './types'\n\nconst ONE_MINUTE = 1000 * 60\n\n/**\n * @internal\n */\nexport interface CommitHandlerMessage {\n  mutation: Mutation\n  success: () => void\n  failure: () => void\n  cancel: (error: Error) => void\n}\n\n/**\n * A wrapper for Document that allows the client to gather mutations on the\n * client side and commit them when it wants to.\n */\nclass Commit {\n  mutations: Mutation[]\n  tries: number\n  resolve: () => void\n  reject: (error: Error) => void\n\n  constructor(\n    mutations: Mutation[],\n    {resolve, reject}: {resolve: () => void; reject: (error: Error) => void}\n  ) {\n    this.mutations = mutations\n    this.tries = 0\n    this.resolve = resolve\n    this.reject = reject\n  }\n\n  apply(doc: Doc | null): Doc | null {\n    return Mutation.applyAll(doc, this.mutations)\n  }\n\n  squash(doc: Doc | null) {\n    const result = Mutation.squash(doc, this.mutations)\n    result.assignRandomTransactionId()\n    return result\n  }\n}\n\nconst mutReducerFn = (acc: Mut[], mut: Mutation): Mut[] => acc.concat(mut.mutations)\n\n/**\n * @internal\n */\nexport class BufferedDocument {\n  private mutations: Mutation[]\n\n  /**\n   * The Document we are wrapping\n   */\n  document: Document\n\n  /**\n   * The Document with local changes applied\n   */\n  LOCAL: Doc | null\n\n  /**\n   * Commits that are waiting to be delivered to the server\n   */\n  private commits: Commit[]\n\n  /**\n   * Local mutations that are not scheduled to be committed yet\n   */\n  buffer: SquashingBuffer\n\n  /**\n   * Assignable event handler for when the buffered document applies a mutation\n   */\n  onMutation?: (message: {mutation: Mutation; document: Doc | null; remote: boolean}) => void\n\n  /**\n   * Assignable event handler for when a remote mutation happened\n   */\n  onRemoteMutation?: Document['onRemoteMutation']\n\n  /**\n   * Assignable event handler for when the buffered document rebased\n   */\n  onRebase?: (localDoc: Doc | null, remoteMutations: Mut[], localMutations: Mut[]) => void\n\n  /**\n   * Assignable event handler for when the document is deleted\n   */\n  onDelete?: (doc: Doc | null) => void\n\n  /**\n   * Assignable event handler for when the state of consistency changed\n   */\n  onConsistencyChanged?: (isConsistent: boolean) => void\n\n  /**\n   * Assignable event handler for when the buffered document should commit changes\n   */\n  commitHandler?: (msg: CommitHandlerMessage) => void\n\n  /**\n   * Whether or not we are currently commiting\n   */\n  committerRunning = false\n\n  constructor(doc: Doc | null) {\n    this.buffer = new SquashingBuffer(doc)\n    this.document = new Document(doc)\n    this.document.onMutation = (msg) => this.handleDocMutation(msg)\n    this.document.onRemoteMutation = (mut) => this.onRemoteMutation && this.onRemoteMutation(mut)\n    this.document.onRebase = (edge, remoteMutations, localMutations) =>\n      this.handleDocRebase(edge, remoteMutations, localMutations)\n    this.document.onConsistencyChanged = (msg) => this.handleDocConsistencyChanged(msg)\n    this.LOCAL = doc\n    this.mutations = []\n    this.commits = []\n  }\n\n  // Used to reset the state of the local document model. If the model has been inconsistent\n  // for too long, it has probably missed a notification, and should reload the document from the server\n  reset(doc: Doc | null): void {\n    if (doc) {\n      debug('Document state reset to revision %s', doc._rev)\n    } else {\n      debug('Document state reset to being deleted')\n    }\n    this.document.reset(doc)\n    this.rebase([], [])\n    this.handleDocConsistencyChanged(this.document.isConsistent())\n  }\n\n  // Add a change to the buffer\n  add(mutation: Mutation): void {\n    if (this.onConsistencyChanged) {\n      this.onConsistencyChanged(false)\n    }\n    debug('Staged local mutation')\n    this.buffer.add(mutation)\n    const oldLocal = this.LOCAL\n    this.LOCAL = mutation.apply(this.LOCAL)\n    if (this.onMutation && oldLocal !== this.LOCAL) {\n      debug('onMutation fired')\n      this.onMutation({\n        mutation,\n        document: this.LOCAL,\n        remote: false,\n      })\n      if (this.LOCAL === null && this.onDelete) {\n        this.onDelete(this.LOCAL)\n      }\n    }\n  }\n\n  // Call when a mutation arrives from Sanity\n  arrive(mutation: Mutation): void {\n    debug('Remote mutation arrived %s -> %s', mutation.previousRev, mutation.resultRev)\n    if (mutation.previousRev === mutation.resultRev) {\n      throw new Error(\n        `Mutation ${mutation.transactionId} has previousRev === resultRev (${mutation.previousRev})`\n      )\n    }\n    return this.document.arrive(mutation)\n  }\n\n  // Submit all mutations in the buffer to be committed\n  commit(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      // Anything to commit?\n      if (!this.buffer.hasChanges()) {\n        resolve()\n        return\n      }\n      debug('Committing local changes')\n      // Collect current staged mutations into a commit and ...\n      const pendingMutations = this.buffer.purge()\n      this.commits.push(new Commit(pendingMutations ? [pendingMutations] : [], {resolve, reject}))\n      // ... clear the table for the next commit.\n      this.buffer = new SquashingBuffer(this.LOCAL)\n      this.performCommits()\n    })\n  }\n\n  // Starts the committer that will try to committ all staged commits to the database\n  // by calling the commitHandler. Will keep running until all commits are successfully\n  // committed.\n  performCommits(): void {\n    if (!this.commitHandler) {\n      throw new Error('No commitHandler configured for this BufferedDocument')\n    }\n    if (this.committerRunning) {\n      // We can have only one committer at any given time\n      return\n    }\n    this._cycleCommitter()\n  }\n\n  // TODO: Error handling, right now retries after every error\n  _cycleCommitter(): void {\n    const commit = this.commits.shift()\n    if (!commit) {\n      this.committerRunning = false\n      return\n    }\n\n    this.committerRunning = true\n    const squashed = commit.squash(this.LOCAL)\n    const docResponder = this.document.stage(squashed, true)\n\n    const responder = {\n      success: () => {\n        debug('Commit succeeded')\n        docResponder.success()\n        commit.resolve()\n        // Keep running the committer until no more commits\n        this._cycleCommitter()\n      },\n\n      failure: () => {\n        debug('Commit failed')\n        // Re stage commit\n        commit.tries += 1\n        if (this.LOCAL !== null) {\n          // Only schedule this commit for a retry of the document still exist to avoid looping\n          // indefinitely when the document was deleted from under our noses\n          this.commits.unshift(commit)\n        }\n        docResponder.failure()\n\n        // Todo: Need better error handling (i.e. propagate to user and provide means of retrying)\n        if (commit.tries < 200) {\n          setTimeout(() => this._cycleCommitter(), Math.min(commit.tries * 1000, ONE_MINUTE))\n        }\n      },\n\n      cancel: (error: Error) => {\n        this.commits.forEach((comm) => comm.reject(error))\n\n        // Throw away waiting commits\n        this.commits = []\n\n        // Reset back to last known state from content lake and cause a rebase that will\n        // reset the view in the form\n        this.reset(this.document.HEAD)\n\n        // Clear the buffer of recent mutations\n        this.buffer = new SquashingBuffer(this.LOCAL)\n\n        // Stop the committer loop\n        this.committerRunning = false\n      },\n    }\n\n    debug('Posting commit')\n    if (this.commitHandler) {\n      this.commitHandler({\n        mutation: squashed,\n        success: responder.success,\n        failure: responder.failure,\n        cancel: responder.cancel,\n      })\n    }\n  }\n\n  handleDocRebase(edge: Doc | null, remoteMutations: Mutation[], localMutations: Mutation[]): void {\n    this.rebase(remoteMutations, localMutations)\n  }\n\n  handleDocumentDeleted(): void {\n    debug('Document deleted')\n    // If the document was just deleted, fire the onDelete event with the absolutely latest\n    // version of the document before someone deleted it so that the client may revive the\n    // document in the last state the user saw it, should they so desire.\n    if (this.LOCAL !== null && this.onDelete) {\n      this.onDelete(this.LOCAL)\n    }\n\n    this.commits = []\n    this.mutations = []\n  }\n\n  handleDocMutation(msg: {mutation: Mutation; document: Doc | null; remote: boolean}): void {\n    // If we have no local changes, we can just pass this on to the client\n    if (this.commits.length === 0 && !this.buffer.hasChanges()) {\n      debug('Document mutated from remote with no local changes')\n      this.LOCAL = this.document.EDGE\n      this.buffer = new SquashingBuffer(this.LOCAL)\n      if (this.onMutation) {\n        this.onMutation(msg)\n      }\n      return\n    }\n\n    debug('Document mutated from remote with local changes')\n\n    // If there are local edits, and the document was deleted, we need to purge those local edits now\n    if (this.document.EDGE === null) {\n      this.handleDocumentDeleted()\n    }\n\n    // We had local changes, so need to signal rebase\n    this.rebase([msg.mutation], [])\n  }\n\n  rebase(remoteMutations: Mutation[], localMutations: Mutation[]): void {\n    debug('Rebasing document')\n    if (this.document.EDGE === null) {\n      this.handleDocumentDeleted()\n    }\n\n    const oldLocal = this.LOCAL\n    this.LOCAL = this.commits.reduce((doc, commit) => commit.apply(doc), this.document.EDGE)\n    this.LOCAL = this.buffer.rebase(this.LOCAL)\n\n    // Copy over rev, since we don't care if it changed, we only care about the content\n    if (oldLocal !== null && this.LOCAL !== null) {\n      oldLocal._rev = this.LOCAL._rev\n    }\n\n    const changed = !isEqual(this.LOCAL, oldLocal)\n    if (changed && this.onRebase) {\n      this.onRebase(\n        this.LOCAL,\n        remoteMutations.reduce(mutReducerFn, []),\n        localMutations.reduce(mutReducerFn, [])\n      )\n    }\n  }\n\n  handleDocConsistencyChanged(isConsistent: boolean): void {\n    if (!this.onConsistencyChanged) {\n      return\n    }\n\n    const hasLocalChanges = this.commits.length > 0 || this.buffer.hasChanges()\n\n    if (isConsistent && !hasLocalChanges) {\n      this.onConsistencyChanged(true)\n    }\n\n    if (!isConsistent) {\n      this.onConsistencyChanged(false)\n    }\n  }\n}\n"],"names":["descend","flatten","isRecord","compact","min","max","DMP","uuid","debugIt","isEqual","DiffMatchPatch"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;AAEA,MAAM,SAAS,GAAG,OAAO,CAAA;AACzB,MAAM,oBAAoB,GAAG,gBAAgB,CAAA;AAC7C,MAAM,yBAAyB,GAAG,aAAa,CAAA;AAE/C,MAAM,OAAO,GAAkC;IAC7C,QAAQ,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AACpC,IAAA,UAAU,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;AAC9C,IAAA,OAAO,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC;AACnB,IAAA,OAAO,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC;AAC1B,IAAA,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC;CAClB,CAAA;AAED,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,CAAkB,CAAA;AAI3D;;AAEG;AACH,MAAM,SAAS,CAAA;AACb,IAAA,MAAM,CAAQ;AACd,IAAA,CAAC,CAAQ;AACT,IAAA,MAAM,CAAQ;AACd,IAAA,UAAU,CAAe;AAEzB,IAAA,WAAA,CAAY,IAAY,EAAA;AACtB,QAAA,IAAI,CAAC,MAAM,GAAG,IAAI,CAAA;AAClB,QAAA,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAA;AACzB,QAAA,IAAI,CAAC,CAAC,GAAG,CAAC,CAAA;QACV,IAAI,CAAC,UAAU,GAAG;AAChB,YAAA,IAAI,CAAC,cAAc;AACnB,YAAA,IAAI,CAAC,kBAAkB;AACvB,YAAA,IAAI,CAAC,cAAc;AACnB,YAAA,IAAI,CAAC,cAAc;AACpB,SAAA,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAA;KAC7B;IAED,QAAQ,GAAA;QACN,MAAM,MAAM,GAAY,EAAE,CAAA;AAC1B,QAAA,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,EAAE;YAClB,IAAI,CAAC,eAAe,EAAE,CAAA;YACtB,IAAI,KAAK,GAAiB,IAAI,CAAA;;YAE9B,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,SAAS,KAAI;gBAC/C,KAAK,GAAG,SAAS,EAAE,CAAA;AACnB,gBAAA,OAAO,OAAO,CAAC,KAAK,CAAC,CAAA;AACvB,aAAC,CAAC,CAAA;AACF,YAAA,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,EAAE;AACpB,gBAAA,MAAM,IAAI,KAAK,CAAC,CAAA,4BAAA,EAA+B,IAAI,CAAC,MAAM,CAAA,IAAA,EAAO,IAAI,CAAC,CAAC,CAAA,CAAE,CAAC,CAAA;AAC3E,aAAA;AACD,YAAA,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;AACnB,SAAA;AACD,QAAA,OAAO,MAAM,CAAA;KACd;AAED,IAAA,SAAS,CAAC,EAAwC,EAAA;AAChD,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,CAAC,CAAA;QACpB,IAAI,MAAM,GAAG,EAAE,CAAA;AACf,QAAA,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,EAAE;AAClB,YAAA,MAAM,QAAQ,GAAG,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA;YACxC,IAAI,QAAQ,KAAK,IAAI,EAAE;gBACrB,MAAK;AACN,aAAA;YACD,MAAM,IAAI,QAAQ,CAAA;YAClB,IAAI,CAAC,CAAC,EAAE,CAAA;AACT,SAAA;AACD,QAAA,IAAI,IAAI,CAAC,CAAC,KAAK,KAAK,EAAE;AACpB,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;AACD,QAAA,OAAO,MAAM,CAAA;KACd;IAED,GAAG,GAAA;AACD,QAAA,OAAO,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,MAAM,CAAA;KAC7B;IAED,IAAI,GAAA;AACF,QAAA,IAAI,IAAI,CAAC,GAAG,EAAE,EAAE;AACd,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;QACD,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;KAC3B;AAED,IAAA,OAAO,CAAC,GAAW,EAAA;QACjB,IAAI,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE;AACrC,YAAA,MAAM,IAAI,KAAK,CAAC,YAAY,GAAG,CAAA,mBAAA,CAAqB,CAAC,CAAA;AACtD,SAAA;QACD,IAAI,GAAG,KAAK,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,EAAE;AAC1D,YAAA,IAAI,CAAC,CAAC,IAAI,GAAG,CAAC,MAAM,CAAA;AACrB,SAAA;AAAM,aAAA;AACL,YAAA,MAAM,IAAI,KAAK,CAAC,CAAA,UAAA,EAAa,GAAG,CAA4B,yBAAA,EAAA,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAA,CAAE,CAAC,CAAA;AACnF,SAAA;KACF;;;;AAKD,IAAA,UAAU,CAAC,GAAW,EAAA;QACpB,IAAI,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE;AACrC,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;QACD,IAAI,GAAG,KAAK,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,EAAE;AAC1D,YAAA,IAAI,CAAC,CAAC,IAAI,GAAG,CAAC,MAAM,CAAA;AACpB,YAAA,OAAO,GAAG,CAAA;AACX,SAAA;AACD,QAAA,OAAO,IAAI,CAAA;KACZ;IAED,eAAe,GAAA;AACb,QAAA,IAAI,CAAC,SAAS,CAAC,CAAC,IAAI,KAAmB;YACrC,OAAO,IAAI,KAAK,GAAG,GAAG,EAAE,GAAG,IAAI,CAAA;AACjC,SAAC,CAAC,CAAA;KACH;IAED,cAAc,GAAA;AACZ,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,EAAE,CAAA;AACzB,QAAA,IAAI,KAAK,KAAK,GAAG,IAAI,KAAK,KAAK,GAAG,EAAE;AAClC,YAAA,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAA;YACnB,IAAI,MAAM,GAAG,KAAK,CAAA;YAClB,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,IAAI,KAAI;AACpC,gBAAA,IAAI,MAAM,EAAE;oBACV,MAAM,GAAG,KAAK,CAAA;AACd,oBAAA,OAAO,IAAI,CAAA;AACZ,iBAAA;gBACD,IAAI,IAAI,KAAK,IAAI,EAAE;oBACjB,MAAM,GAAG,IAAI,CAAA;AACb,oBAAA,OAAO,EAAE,CAAA;AACV,iBAAA;gBACD,IAAI,IAAI,IAAI,KAAK,EAAE;AACjB,oBAAA,OAAO,IAAI,CAAA;AACZ,iBAAA;AACD,gBAAA,OAAO,IAAI,CAAA;AACb,aAAC,CAAC,CAAA;AACF,YAAA,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAA;YACnB,OAAO;AACL,gBAAA,IAAI,EAAE,QAAQ;AACd,gBAAA,KAAK,EAAE,KAAK;gBACZ,KAAK,EAAE,KAAK,KAAK,GAAG,GAAG,QAAQ,GAAG,QAAQ;aAC3C,CAAA;AACF,SAAA;AACD,QAAA,OAAO,IAAI,CAAA;KACZ;IAED,kBAAkB,GAAA;QAChB,IAAI,KAAK,GAAG,IAAI,CAAA;QAChB,MAAM,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,IAAI,KAAI;AACzC,YAAA,IAAI,KAAK,EAAE;gBACT,KAAK,GAAG,KAAK,CAAA;AACb,gBAAA,OAAO,IAAI,CAAC,KAAK,CAAC,yBAAyB,CAAC,GAAG,IAAI,GAAG,IAAI,CAAA;AAC3D,aAAA;AACD,YAAA,OAAO,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,GAAG,IAAI,GAAG,IAAI,CAAA;AACvD,SAAC,CAAC,CAAA;QACF,IAAI,UAAU,KAAK,IAAI,EAAE;YACvB,OAAO;AACL,gBAAA,IAAI,EAAE,YAAY;AAClB,gBAAA,IAAI,EAAE,UAAU;aACjB,CAAA;AACF,SAAA;AACD,QAAA,OAAO,IAAI,CAAA;KACZ;IAED,cAAc,GAAA;AACZ,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,CAAC,CAAA;QACpB,IAAI,OAAO,GAAG,KAAK,CAAA;QACnB,IAAI,SAAS,GAAG,KAAK,CAAA;QACrB,IAAI,QAAQ,GAAG,KAAK,CAAA;AACpB,QAAA,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,EAAE;YACvB,QAAQ,GAAG,IAAI,CAAA;AACf,YAAA,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA;AAClB,SAAA;QACD,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,IAAI,KAAI;YACrC,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC,OAAO,IAAI,SAAS,EAAE;gBACzC,OAAO,GAAG,IAAI,CAAA;AACd,gBAAA,OAAO,IAAI,CAAA;AACZ,aAAA;YACD,SAAS,GAAG,IAAI,CAAA;AAChB,YAAA,OAAO,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,IAAI,GAAG,IAAI,CAAA;AAC5C,SAAC,CAAC,CAAA;QACF,IAAI,MAAM,KAAK,IAAI,EAAE;YACnB,OAAO;AACL,gBAAA,IAAI,EAAE,QAAQ;gBACd,KAAK,EAAE,QAAQ,GAAG,CAAC,MAAM,GAAG,CAAC,MAAM;gBACnC,GAAG,EAAE,QAAQ,GAAG,CAAI,CAAA,EAAA,MAAM,CAAE,CAAA,GAAG,MAAM;aACtC,CAAA;AACF,SAAA;;AAED,QAAA,IAAI,CAAC,CAAC,GAAG,KAAK,CAAA;AACd,QAAA,OAAO,IAAI,CAAA;KACZ;IAED,cAAc,GAAA;AACZ,QAAA,KAAK,MAAM,WAAW,IAAI,aAAa,EAAE;AACvC,YAAA,MAAM,QAAQ,GAAG,OAAO,CAAC,WAAW,CAAC,CAAA;AACrC,YAAA,MAAM,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,OAAO,KAAK,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAA;AACnE,YAAA,IAAI,MAAM,EAAE;gBACV,OAAO;AACL,oBAAA,IAAI,EAAE,WAAW;oBACjB,MAAM;iBACP,CAAA;AACF,aAAA;AACF,SAAA;AAED,QAAA,OAAO,IAAI,CAAA;KACZ;AACF,CAAA;AAEK,SAAU,QAAQ,CAAC,QAAgB,EAAA;IACvC,OAAO,IAAI,SAAS,CAAC,QAAQ,CAAC,CAAC,QAAQ,EAAE,CAAA;AAC3C;;AC3NA;AAkBA;AAEA,MAAM,MAAM,CAAA;AACV,IAAA,MAAM,CAAS;AACf,IAAA,MAAM,CAAQ;AACd,IAAA,CAAC,CAAQ;AAET,IAAA,WAAA,CAAY,IAAY,EAAA;AACtB,QAAA,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAA;QAC5B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAA;AAChC,QAAA,IAAI,CAAC,CAAC,GAAG,CAAC,CAAA;KACX;IAED,KAAK,GAAA;AACH,QAAA,OAAO,IAAI,CAAC,SAAS,EAAE,CAAA;KACxB;IAED,GAAG,GAAA;AACD,QAAA,OAAO,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,MAAM,CAAA;KAC7B;;IAGD,IAAI,GAAA;AACF,QAAA,IAAI,IAAI,CAAC,GAAG,EAAE,EAAE;AACd,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;QACD,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;KAC3B;IAED,OAAO,GAAA;AACL,QAAA,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,EAAE,CAAA;AAC1B,QAAA,IAAI,CAAC,CAAC,IAAI,CAAC,CAAA;AACX,QAAA,OAAO,MAAM,CAAA;KACd;;AAGD,IAAA,KAAK,CAAC,OAAgC,EAAA;AACpC,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,EAAE,CAAA;QACzB,IAAI,CAAC,KAAK,EAAE;AACV,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;QAED,MAAM,MAAM,GAAG,KAA2C,CAAA;AAC1D,QAAA,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,KAAI;AAC/C,YAAA,OAAO,GAAG,IAAI,KAAK,IAAI,OAAO,CAAC,GAAG,CAAC,KAAK,MAAM,CAAC,GAAG,CAAC,CAAA;AACrD,SAAC,CAAC,CAAA;QAEF,OAAO,KAAK,GAAG,KAAK,GAAG,IAAI,CAAA;KAC5B;;AAGD,IAAA,KAAK,CAAC,OAAuB,EAAA;AAC3B,QAAA,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,OAAO,EAAE,GAAG,IAAI,CAAA;KACnD;IAED,cAAc,GAAA;AACZ,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,YAAY,EAAC,CAAC,CAAA;AAC9C,QAAA,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,YAAY,EAAE;YACxC,OAAO;AACL,gBAAA,IAAI,EAAE,WAAW;gBACjB,IAAI,EAAE,KAAK,CAAC,IAAI;aACjB,CAAA;AACF,SAAA;AACD,QAAA,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,QAAQ,EAAC,CAAC,CAAA;AAC5D,QAAA,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,KAAK,QAAQ,EAAE;YACtC,OAAO;AACL,gBAAA,IAAI,EAAE,WAAW;AACjB,gBAAA,IAAI,EAAE,MAAM,CAAC,KAAK,IAAI,EAAE;aACzB,CAAA;AACF,SAAA;AACD,QAAA,OAAO,IAAI,CAAA;KACZ;IAED,UAAU,GAAA;AACR,QAAA,IAAI,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,SAAS,EAAE,MAAM,EAAE,GAAG,EAAC,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,SAAS,EAAE,MAAM,EAAE,GAAG,EAAC,CAAC,EAAE;YAC5F,OAAO;AACL,gBAAA,IAAI,EAAE,OAAO;AACb,gBAAA,MAAM,EAAE,MAAM;aACf,CAAA;AACF,SAAA;AACD,QAAA,OAAO,IAAI,CAAA;KACZ;IAED,WAAW,GAAA;AACT,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,QAAQ,EAAC,CAAC,CAAA;AAC1C,QAAA,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE;YACpC,OAAO;AACL,gBAAA,IAAI,EAAE,QAAQ;gBACd,KAAK,EAAE,KAAK,CAAC,KAAK;aACnB,CAAA;AACF,SAAA;AACD,QAAA,OAAO,IAAI,CAAA;KACZ;IAED,gBAAgB,GAAA;AACd,QAAA,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,EAAE,CAAA;AAC/B,QAAA,IAAI,IAAI,EAAE;YACR,OAAO,IAAI,CAAC,KAAK,CAAA;AAClB,SAAA;AACD,QAAA,OAAO,IAAI,CAAA;KACZ;IAED,kBAAkB,GAAA;AAChB,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,CAAC,CAAA;AACpB,QAAA,MAAM,UAAU,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAA;AAE1C,QAAA,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,GAAG,EAAC,CAAC,CAAA;QAC1D,IAAI,CAAC,MAAM,EAAE;YACX,IAAI,UAAU,KAAK,IAAI,EAAE;;AAEvB,gBAAA,IAAI,CAAC,CAAC,GAAG,KAAK,CAAA;AACd,gBAAA,OAAO,IAAI,CAAA;AACZ,aAAA;;YAGD,OAAO,EAAC,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,UAAU,EAAC,CAAA;AAC1C,SAAA;AAED,QAAA,MAAM,MAAM,GAAc;AACxB,YAAA,IAAI,EAAE,OAAO;AACb,YAAA,KAAK,EAAE,UAAU;AACjB,YAAA,GAAG,EAAE,IAAI,CAAC,gBAAgB,EAAE;SAC7B,CAAA;AAED,QAAA,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,GAAG,EAAC,CAAC,CAAA;AAC1D,QAAA,IAAI,MAAM,EAAE;AACV,YAAA,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAA;AACtC,SAAA;QAED,IAAI,MAAM,CAAC,KAAK,KAAK,IAAI,IAAI,MAAM,CAAC,GAAG,KAAK,IAAI,EAAE;;AAEhD,YAAA,IAAI,CAAC,CAAC,GAAG,KAAK,CAAA;AACd,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;AAED,QAAA,OAAO,MAAM,CAAA;KACd;IAED,mBAAmB,GAAA;QACjB,OAAO,IAAI,CAAC,cAAc,EAAE,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAA;KAC1D;IAED,iBAAiB,GAAA;AACf,QAAA,MAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,QAAQ,EAAC,CAAC,CAAA;AACnE,QAAA,IAAI,aAAa,IAAI,aAAa,CAAC,IAAI,KAAK,QAAQ,EAAE;YACpD,OAAO;AACL,gBAAA,IAAI,EAAE,QAAQ;AACd,gBAAA,KAAK,EAAE,aAAa,CAAC,KAAK,IAAI,EAAE;aACjC,CAAA;AACF,SAAA;AACD,QAAA,MAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,SAAS,EAAC,CAAC,CAAA;AACpD,QAAA,IAAI,cAAc,IAAI,cAAc,CAAC,IAAI,KAAK,SAAS,EAAE;YACvD,OAAO;AACL,gBAAA,IAAI,EAAE,SAAS;AACf,gBAAA,KAAK,EAAE,cAAc,CAAC,MAAM,KAAK,MAAM;aACxC,CAAA;AACF,SAAA;AACD,QAAA,OAAO,IAAI,CAAC,WAAW,EAAE,CAAA;KAC1B;;;IAID,qBAAqB,GAAA;AACnB,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,CAAC,CAAA;QACpB,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,EAAE,IAAI,IAAI,CAAC,UAAU,EAAE,CAAA;QACvD,IAAI,CAAC,IAAI,EAAE;AACT,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;AAED,QAAA,IAAI,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,GAAG,EAAC,CAAC,EAAE;YAC/C,OAAO;AACL,gBAAA,IAAI,EAAE,YAAY;AAClB,gBAAA,QAAQ,EAAE,GAAG;AACb,gBAAA,GAAG,EAAE,IAAI;aACV,CAAA;AACF,SAAA;AAED,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,YAAY,EAAC,CAAC,CAAA;QAC9C,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,YAAY,EAAE;;AAEzC,YAAA,IAAI,CAAC,CAAC,GAAG,KAAK,CAAA;AACd,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;QAED,MAAM,GAAG,GAAG,IAAI,CAAA;AAChB,QAAA,MAAM,GAAG,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAA;QACpC,IAAI,CAAC,GAAG,EAAE;YACR,MAAM,IAAI,KAAK,CAAC,CAAA,SAAA,EAAY,KAAK,CAAC,MAAM,CAA+C,6CAAA,CAAA,CAAC,CAAA;AACzF,SAAA;QAED,OAAO;AACL,YAAA,IAAI,EAAE,YAAY;YAClB,QAAQ,EAAE,KAAK,CAAC,MAAM;AACtB,YAAA,GAAG,EAAE,GAAG;AACR,YAAA,GAAG,EAAE,GAAG;SACT,CAAA;KACF;IAED,eAAe,GAAA;QACb,OAAO,IAAI,CAAC,qBAAqB,EAAE,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAA;KAClE;IAED,UAAU,GAAA;AACR,QAAA,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,EAAC,CAAC,EAAE;AAC7C,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;QAED,MAAM,KAAK,GAAG,EAAE,CAAA;AAChB,QAAA,IAAI,IAAI,GAAG,IAAI,CAAC,qBAAqB,EAAE,IAAI,IAAI,CAAC,SAAS,EAAE,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAA;AACzF,QAAA,OAAO,IAAI,EAAE;AACX,YAAA,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;;AAEhB,YAAA,IAAI,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,EAAC,CAAC,EAAE;gBAC5C,MAAK;AACN,aAAA;AAED,YAAA,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,GAAG,EAAC,CAAC,EAAE;AAChD,gBAAA,MAAM,IAAI,KAAK,CAAC,YAAY,CAAC,CAAA;AAC9B,aAAA;AAED,YAAA,IAAI,GAAG,IAAI,CAAC,qBAAqB,EAAE,IAAI,IAAI,CAAC,SAAS,EAAE,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAA;YACrF,IAAI,CAAC,IAAI,EAAE;AACT,gBAAA,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAA;AACrD,aAAA;AACF,SAAA;QAED,OAAO;AACL,YAAA,IAAI,EAAE,OAAO;AACb,YAAA,KAAK,EAAE,KAAK;SACb,CAAA;KACF;IAED,cAAc,GAAA;AACZ,QAAA,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,IAAI,EAAC,CAAC,EAAE;AACjD,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;AAED,QAAA,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,EAAE,CAAA;QAChC,IAAI,CAAC,OAAO,EAAE;AACZ,YAAA,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAA;AACzD,SAAA;QAED,OAAO;AACL,YAAA,IAAI,EAAE,WAAW;AACjB,YAAA,IAAI,EAAE,OAAO;SACd,CAAA;KACF;IAED,SAAS,GAAA;QACP,MAAM,KAAK,GAAkD,EAAE,CAAA;AAC/D,QAAA,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,EAAE,IAAI,IAAI,CAAC,UAAU,EAAE,IAAI,IAAI,CAAC,cAAc,EAAE,CAAA;QAChF,IAAI,CAAC,IAAI,EAAE;AACT,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;AAED,QAAA,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;AAChB,QAAA,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,EAAE;AAClB,YAAA,IAAI,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,GAAG,EAAC,CAAC,EAAE;AAC/C,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,EAAE,CAAA;gBAClC,IAAI,CAAC,IAAI,EAAE;AACT,oBAAA,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAA;AACxD,iBAAA;AACD,gBAAA,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;gBAChB,SAAQ;AACT,aAAA;AAAM,iBAAA,IAAI,IAAI,CAAC,KAAK,CAAC,EAAC,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,EAAC,CAAC,EAAE;AACnD,gBAAA,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,EAAE,CAAA;gBAC/B,IAAI,CAAC,KAAK,EAAE;AACV,oBAAA,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAA;AAChD,iBAAA;AACD,gBAAA,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;AAClB,aAAA;AAAM,iBAAA;AACL,gBAAA,MAAM,SAAS,GAAG,IAAI,CAAC,cAAc,EAAE,CAAA;AACvC,gBAAA,IAAI,SAAS,EAAE;AACb,oBAAA,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;AACtB,iBAAA;gBACD,MAAK;AACN,aAAA;AACF,SAAA;AAED,QAAA,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;AACtB,YAAA,OAAO,KAAK,CAAC,CAAC,CAAC,CAAA;AAChB,SAAA;QAED,OAAO;AACL,YAAA,IAAI,EAAE,MAAM;AACZ,YAAA,KAAK,EAAE,KAAK;SACb,CAAA;KACF;AACF,CAAA;AAEK,SAAU,aAAa,CAAC,IAAY,EAAA;IACxC,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,CAAA;IACvC,IAAI,CAAC,MAAM,EAAE;AACX,QAAA,MAAM,IAAI,KAAK,CAAC,8BAA8B,IAAI,CAAA,CAAA,CAAG,CAAC,CAAA;AACvD,KAAA;AACD,IAAA,OAAO,MAAM,CAAA;AACf;;ACxTA;;;;;AAKG;AACG,SAAUA,SAAO,CAAC,IAAU,EAAA;IAChC,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,GAAG,WAAW,CAAC,IAAI,CAAC,CAAA;IACzC,IAAI,CAAC,IAAI,EAAE;AACT,QAAA,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAA;AACvC,KAAA;AAED,IAAA,OAAO,iBAAiB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;AACzC,CAAC;AAED;AACA,SAAS,WAAW,CAAC,IAAU,EAAA;AAC7B,IAAA,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM,EAAE;AACxB,QAAA,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;AACpB,KAAA;AAED,IAAA,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAA;AACxB,IAAA,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;AACtB,QAAA,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;AACpB,KAAA;AAED,IAAA,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;QACtB,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAA;AACxB,KAAA;IAED,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAC,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,EAAC,CAAC,CAAA;AAC1D,CAAC;AAED,SAAS,WAAW,CAAC,KAAsB,EAAE,KAAsB,EAAA;AACjE,IAAA,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,EAAE;AACpB,QAAA,OAAO,IAAI,CAAA;AACZ,KAAA;AAED,IAAA,MAAM,MAAM,GAAG,KAAK,GAAG,KAAK,CAAC,KAAK,GAAG,EAAE,CAAA;AACvC,IAAA,MAAM,MAAM,GAAG,KAAK,GAAG,KAAK,CAAC,KAAK,GAAG,EAAE,CAAA;IACvC,OAAO;AACL,QAAA,IAAI,EAAE,MAAM;AACZ,QAAA,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC;KAC7B,CAAA;AACH,CAAC;AAED;AACA,SAAS,iBAAiB,CAAC,IAAU,EAAE,IAAqB,EAAA;AAC1D,IAAA,IAAI,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE;AACzB,QAAA,OAAO,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAA;AACtB,KAAA;IAED,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,KAAI;AAC7B,QAAA,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM,EAAE;YACxB,MAAM,CAAC,OAAO,EAAE,OAAO,CAAC,GAAG,WAAW,CAAC,IAAI,CAAC,CAAA;YAC5C,OAAO,CAAC,OAAO,EAAE,WAAW,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAA;AAC7C,SAAA;AAED,QAAA,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;AACrB,KAAC,CAAC,CAAA;AACJ;;AC5DA;;;;;;;AAOG;AACG,SAAU,MAAM,CAAC,IAAU,EAAA;AAC/B,IAAA,OAAO,WAAW,CAAC,IAAI,EAAE,KAAK,CAAC,CAAA;AACjC,CAAC;AAED,SAAS,WAAW,CAAC,IAAU,EAAE,OAAgB,EAAA;IAC/C,QAAQ,IAAI,CAAC,IAAI;AACf,QAAA,KAAK,WAAW;YACd,OAAO,IAAI,CAAC,IAAI,CAAA;AAClB,QAAA,KAAK,OAAO;AACV,YAAA,OAAO,IAAI,CAAC,MAAM,KAAK,MAAM,GAAG,GAAG,GAAG,GAAG,CAAA;AAC3C,QAAA,KAAK,QAAQ;AACX,YAAA,OAAO,CAAG,EAAA,IAAI,CAAC,KAAK,EAAE,CAAA;QACxB,KAAK,OAAO,EAAE;YACZ,MAAM,MAAM,GAAG,EAAE,CAAA;YACjB,IAAI,CAAC,OAAO,EAAE;AACZ,gBAAA,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;AACjB,aAAA;YACD,IAAI,IAAI,CAAC,KAAK,EAAE;gBACd,MAAM,CAAC,IAAI,CAAC,CAAA,EAAG,IAAI,CAAC,KAAK,CAAE,CAAA,CAAC,CAAA;AAC7B,aAAA;AACD,YAAA,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;YAChB,IAAI,IAAI,CAAC,GAAG,EAAE;gBACZ,MAAM,CAAC,IAAI,CAAC,CAAA,EAAG,IAAI,CAAC,GAAG,CAAE,CAAA,CAAC,CAAA;AAC3B,aAAA;YACD,IAAI,IAAI,CAAC,IAAI,EAAE;gBACb,MAAM,CAAC,IAAI,CAAC,CAAA,CAAA,EAAI,IAAI,CAAC,IAAI,CAAE,CAAA,CAAC,CAAA;AAC7B,aAAA;YACD,IAAI,CAAC,OAAO,EAAE;AACZ,gBAAA,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;AACjB,aAAA;AACD,YAAA,OAAO,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;AACvB,SAAA;AACD,QAAA,KAAK,OAAO;AACV,YAAA,IAAI,OAAO,EAAE;AACX,gBAAA,OAAO,CAAG,EAAA,IAAI,CAAC,KAAK,EAAE,CAAA;AACvB,aAAA;AAED,YAAA,OAAO,CAAI,CAAA,EAAA,IAAI,CAAC,KAAK,GAAG,CAAA;QAC1B,KAAK,YAAY,EAAE;YACjB,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,GAAG,CAAA,CAAA,EAAI,WAAW,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,GAAG,EAAE,CAAA;AAC9D,YAAA,MAAM,KAAK,GAAG,CAAA,EAAG,WAAW,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAG,EAAA,GAAG,EAAE,CAAA;AAEtE,YAAA,IAAI,OAAO,EAAE;AACX,gBAAA,OAAO,KAAK,CAAA;AACb,aAAA;YAED,OAAO,CAAA,CAAA,EAAI,KAAK,CAAA,CAAA,CAAG,CAAA;AACpB,SAAA;AACD,QAAA,KAAK,QAAQ;YACX,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;QACnC,KAAK,MAAM,EAAE;YACX,MAAM,MAAM,GAAG,EAAE,CAAA;YACjB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAA;AAChC,YAAA,OAAO,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;AACvB,gBAAA,MAAM,IAAI,GAAG,KAAK,CAAC,KAAK,EAAE,CAAA;AAC1B,gBAAA,IAAI,IAAI,EAAE;oBACR,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAA;AAC1B,iBAAA;AAED,gBAAA,MAAM,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,CAAA;AACzB,gBAAA,IAAI,QAAQ,IAAI,WAAW,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AACvD,oBAAA,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;AACjB,iBAAA;AACF,aAAA;AACD,YAAA,OAAO,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;AACvB,SAAA;AACD,QAAA,KAAK,OAAO;YACV,OAAO,CAAA,CAAA,EAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,WAAW,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA,CAAA,CAAG,CAAA;AACrE,QAAA;YACE,MAAM,IAAI,KAAK,CAAC,CAAA,kBAAA,EAAqB,IAAI,CAAC,IAAI,CAAE,CAAA,CAAC,CAAA;AACnD,QAAA,KAAK,WAAW;YACd,OAAO,CAAA,EAAA,EAAK,WAAW,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAA,CAAE,CAAA;AAC9C,KAAA;AACH;;ACnFA;MAca,UAAU,CAAA;AACrB,IAAA,IAAI,CAAM;AAEV,IAAA,WAAA,CAAY,IAA8B,EAAA;QACxC,IAAI,CAAC,IAAI,EAAE;AACT,YAAA,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC,CAAA;AAClE,SAAA;;QAGD,IAAI,MAAM,IAAI,IAAI,EAAE;AAClB,YAAA,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAA;AACtB,SAAA;AAAM,aAAA;AACL,YAAA,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;AACjB,SAAA;QAED,IAAI,EAAE,MAAM,IAAI,IAAI,CAAC,IAAI,CAAC,EAAE;AAC1B,YAAA,MAAM,IAAI,KAAK,CAAC,0DAA0D,CAAC,CAAA;AAC5E,SAAA;KACF;IAED,MAAM,GAAA;AACJ,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,MAAM,CAAA;KACjC;IAED,OAAO,GAAA;AACL,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,OAAO,CAAA;KAClC;IAED,YAAY,GAAA;QACV,OAAO,IAAI,CAAC,MAAM,EAAE,IAAI,IAAI,CAAC,OAAO,EAAE,CAAA;KACvC;IAED,YAAY,GAAA;AACV,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,YAAY,CAAA;KACvC;IAED,WAAW,GAAA;AACT,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,WAAW,CAAA;KACtC;IAED,qBAAqB,GAAA;AACnB,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,YAAY,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,GAAG,CAAA;KACrE;IAED,OAAO,GAAA;AACL,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,OAAO,CAAA;KAClC;IAED,OAAO,GAAA;AACL,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,OAAO,CAAA;KAClC;AAED,IAAA,WAAW,CAAC,KAAa,EAAA;QACvB,MAAM,WAAW,GAAG,MAAK;YACvB,IAAI,CAAC,KAAK,EAAE;AACV,gBAAA,MAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC,CAAA;AACtE,aAAA;AAED,YAAA,OAAO,KAAK,CAAC,MAAM,EAAE,CAAA;AACvB,SAAC,CAAA;QAED,IAAI,KAAK,GAAG,OAAO,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,GAAG,CAAC,CAAA;AAC3D,QAAA,KAAK,GAAG,sBAAsB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAA;QAC5C,IAAI,GAAG,GAAG,KAAK,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,WAAW,EAAE,GAAG,WAAW,EAAE,CAAA;AAC7E,QAAA,GAAG,GAAG,sBAAsB,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;QACxC,MAAM,IAAI,GAAG,MAAM,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,CAAA;AAC1D,QAAA,OAAO,EAAC,KAAK,EAAE,GAAG,EAAE,IAAI,EAAC,CAAA;KAC1B;IAED,oBAAoB,GAAA;AAClB,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,WAAW,CAAA;KACtC;;IAGD,gBAAgB,GAAA;QACd,OAAO,IAAI,CAAC,OAAO,EAAE,IAAI,IAAI,CAAC,OAAO,EAAE,CAAA;KACxC;IAED,IAAI,GAAA;AACF,QAAA,OAAO,MAAM,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,EAAE,CAAA;KACjD;IAED,eAAe,GAAA;AACb,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,KAAK,MAAM,CAAA;KACjE;IAED,sBAAsB,GAAA;AACpB,QAAA,QACE,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,YAAY;AAC/B,YAAA,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,KAAK,OAAO;YAC9B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,KAAK,MAAM,EAChC;KACF;IAED,2BAA2B,GAAA;AACzB,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,YAAY,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,KAAK,WAAW,CAAA;KAC7E;AAED,IAAA,cAAc,CAAC,KAAY,EAAA;AACzB,QAAA,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAA;QAEtB,IAAI,IAAI,CAAC,IAAI,KAAK,YAAY,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,KAAK,OAAO,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,KAAK,MAAM,EAAE;AACzF,YAAA,IAAI,KAAK,CAAC,aAAa,EAAE,KAAK,WAAW,EAAE;AACzC,gBAAA,OAAO,KAAK,CAAA;AACb,aAAA;YAED,IAAI,IAAI,CAAC,IAAI,KAAK,YAAY,IAAI,IAAI,CAAC,QAAQ,KAAK,GAAG,EAAE;AACvD,gBAAA,OAAO,IAAI,CAAA;AACZ,aAAA;AAED,YAAA,MAAM,GAAG,GAAG,KAAK,CAAC,GAAG,EAAE,CAAA;YACvB,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,IAAI,OAAO,IAAI,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,SAAS,CAAA;YACxE,OAAO,kBAAkB,CAAC,GAAG,EAAE,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAA;AACnD,SAAA;AAED,QAAA,IAAI,IAAI,CAAC,IAAI,KAAK,YAAY,EAAE;AAC9B,YAAA,OAAO,KAAK,CAAA;AACb,SAAA;AAED,QAAA,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAA;QACpB,IAAI,CAAC,GAAG,EAAE;AACR,YAAA,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAA;AACxC,SAAA;AAED,QAAA,IAAI,GAAG,CAAC,IAAI,KAAK,WAAW,EAAE;YAC5B,MAAM,IAAI,KAAK,CAAC,CAAA,kBAAA,EAAqB,GAAG,CAAC,IAAI,CAAgB,cAAA,CAAA,CAAC,CAAA;AAC/D,SAAA;AAED,QAAA,IAAI,KAAK,CAAC,aAAa,EAAE,KAAK,QAAQ,EAAE;AACtC,YAAA,OAAO,KAAK,CAAA;AACb,SAAA;QAED,MAAM,QAAQ,GAAG,KAAK,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;AAC7C,QAAA,IAAI,QAAQ,KAAK,SAAS,IAAI,QAAQ,KAAK,IAAI,IAAI,QAAQ,CAAC,aAAa,EAAE,KAAK,WAAW,EAAE;;AAE3F,YAAA,OAAO,KAAK,CAAA;AACb,SAAA;AAED,QAAA,IAAI,IAAI,CAAC,qBAAqB,EAAE,EAAE;;AAEhC,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;QAED,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,IAAI,OAAO,IAAI,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,SAAS,CAAA;AACxE,QAAA,OAAO,kBAAkB,CAAC,QAAQ,CAAC,GAAG,EAAE,EAAE,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAA;KAC9D;IAED,SAAS,GAAA;QACP,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;KACjE;AAED,IAAA,OAAO,CAAC,IAAgB,EAAA;QACtB,IAAI,CAAC,IAAI,EAAE;AACT,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;QAED,OAAO,IAAI,UAAU,CAAC;AACpB,YAAA,IAAI,EAAE,MAAM;AACZ,YAAA,KAAK,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;AACjD,SAAA,CAAC,CAAA;KACH;AAED,IAAA,MAAM,CAAC,KAAwB,EAAA;AAC7B,QAAA,OAAO,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,CAAA;KAC1C;IAED,OAAO,GAAA;AACL,QAAA,OAAOA,SAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,QAAQ,KAAI;AACzC,YAAA,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,QAAQ,CAAA;YAC7B,OAAO;AACL,gBAAA,IAAI,EAAE,IAAI,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,GAAG,IAAI;AACxC,gBAAA,IAAI,EAAE,IAAI,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,GAAG,IAAI;aACzC,CAAA;AACH,SAAC,CAAC,CAAA;KACH;IAED,eAAe,GAAA;AACb,QAAA,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,WAAW,EAAE;YAClC,MAAM,IAAI,KAAK,CAAC,CAAuC,oCAAA,EAAA,IAAI,CAAC,IAAI,CAAC,IAAI,CAAE,CAAA,CAAC,CAAA;AACzE,SAAA;QAED,OAAO,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;KACtC;AAED,IAAA,UAAU,CAAC,KAAa,EAAA;AACtB,QAAA,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE;AAC5D,YAAA,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAA;AACvD,SAAA;AAED,QAAA,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE;AAC9B,YAAA,OAAO,CAAC,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAA;AACxD,SAAA;QAED,MAAM,MAAM,GAAa,EAAE,CAAA;QAC3B,MAAM,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAA;AACrC,QAAA,IAAI,EAAC,KAAK,EAAE,GAAG,EAAC,GAAG,KAAK,CAAA;AACxB,QAAA,IAAI,KAAK,CAAC,IAAI,GAAG,CAAC,EAAE;YACjB,CAAC,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;AAC7B,SAAA;QAED,KAAK,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;AAChC,YAAA,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;AACf,SAAA;AAED,QAAA,OAAO,MAAM,CAAA;KACd;IAED,iBAAiB,GAAA;AACf,QAAA,IAAI,IAAI,CAAC,gBAAgB,EAAE,EAAE;AAC3B,YAAA,OAAO,IAAI,CAAC,UAAU,EAAE,CAAA;AACzB,SAAA;AACD,QAAA,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,WAAW,EAAE;AAClC,YAAA,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;AACxB,SAAA;QACD,MAAM,IAAI,KAAK,CAAC,CAAiB,cAAA,EAAA,IAAI,CAAC,IAAI,CAAC,IAAI,CAAsB,oBAAA,CAAA,CAAC,CAAA;KACvE;IAED,QAAQ,GAAA;AACN,QAAA,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;KACzB;IAED,OAAO,QAAQ,CAAC,IAAY,EAAA;AAC1B,QAAA,MAAM,MAAM,GAAG,aAAa,CAAC,IAAI,CAAC,CAAA;QAClC,IAAI,CAAC,MAAM,EAAE;AACX,YAAA,MAAM,IAAI,KAAK,CAAC,yBAAyB,IAAI,CAAA,CAAA,CAAG,CAAC,CAAA;AAClD,SAAA;AAED,QAAA,OAAO,IAAI,UAAU,CAAC,MAAM,CAAC,CAAA;KAC9B;IAED,OAAO,kBAAkB,CAAC,IAAY,EAAA;QACpC,OAAO,IAAI,UAAU,CAAC;AACpB,YAAA,IAAI,EAAE,WAAW;AACjB,YAAA,IAAI,EAAE,IAAI;AACX,SAAA,CAAC,CAAA;KACH;IAED,OAAO,cAAc,CAAC,CAAS,EAAA;QAC7B,OAAO,IAAI,UAAU,CAAC;AACpB,YAAA,IAAI,EAAE,OAAO;AACb,YAAA,KAAK,EAAE,CAAC;AACT,SAAA,CAAC,CAAA;KACH;AACF,CAAA;AAED;AACA,SAAS,kBAAkB,CAAC,QAAa,EAAE,QAAgB,EAAE,QAAa,EAAA;AACxE,IAAA,QAAQ,QAAQ;AACd,QAAA,KAAK,GAAG;YACN,OAAO,QAAQ,GAAG,QAAQ,CAAA;AAC5B,QAAA,KAAK,IAAI;YACP,OAAO,QAAQ,IAAI,QAAQ,CAAA;AAC7B,QAAA,KAAK,GAAG;YACN,OAAO,QAAQ,GAAG,QAAQ,CAAA;AAC5B,QAAA,KAAK,IAAI;YACP,OAAO,QAAQ,IAAI,QAAQ,CAAA;AAC7B,QAAA,KAAK,IAAI;YACP,OAAO,QAAQ,KAAK,QAAQ,CAAA;AAC9B,QAAA,KAAK,IAAI;YACP,OAAO,QAAQ,KAAK,QAAQ,CAAA;AAC9B,QAAA;AACE,YAAA,MAAM,IAAI,KAAK,CAAC,+BAA+B,QAAQ,CAAA,CAAE,CAAC,CAAA;AAC7D,KAAA;AACH,CAAC;AAED,SAAS,sBAAsB,CAAC,KAAa,EAAE,KAAa,EAAA;IAC1D,IAAI,KAAK,IAAI,CAAC,EAAE;AACd,QAAA,OAAO,KAAK,CAAA;AACb,KAAA;IAED,IAAI,CAAC,KAAK,EAAE;AACV,QAAA,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC,CAAA;AACvE,KAAA;AAED,IAAA,OAAO,KAAK,GAAG,KAAK,CAAC,MAAM,EAAE,CAAA;AAC/B;;AC7RA;;;AAGG;MACU,SAAS,CAAA;AACpB,IAAA,IAAI,CAAmB;AACvB,IAAA,IAAI,CAAmB;IAEvB,WAAY,CAAA,IAAuB,EAAE,IAAuB,EAAA;AAC1D,QAAA,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;AAChB,QAAA,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;KACjB;;;;AAKD,IAAA,OAAO,CAAC,KAAY,EAAA;AAClB,QAAA,IAAI,MAAM,GAAgB,CAAC,IAAI,CAAC,CAAA;QAChC,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,EAAE;YACzC,IAAI,cAAc,GAAG,IAAI,CAAA;;AAEzB,YAAA,OAAO,cAAc,EAAE;gBACrB,MAAM,GAAGC,cAAO,CACd,MAAM,CAAC,GAAG,CAAC,CAAC,SAAS,KAAI;AACvB,oBAAA,OAAO,SAAS,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAA;iBAC3C,CAAC,CACH,CAAA;gBACD,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,SAAS,KAAI;oBACzC,OAAO,SAAS,CAAC,IAAI,IAAI,SAAS,CAAC,IAAI,CAAC,YAAY,EAAE,CAAA;AACxD,iBAAC,CAAC,CAAA;AACH,aAAA;AACF,SAAA;AACD,QAAA,OAAO,MAAM,CAAA;KACd;IAED,WAAW,GAAA;AACT,QAAA,OAAO,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAA;KACrD;IAED,UAAU,GAAA;QACR,OAAO,IAAI,CAAC,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,CAAA;KAChD;IAED,iBAAiB,GAAA;QACf,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,EAAE;YACxC,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAA;AACxC,YAAA,OAAO,IAAI,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,EAAE,CAAA;AAC7D,SAAA;AACD,QAAA,OAAO,EAAE,CAAA;KACV;AAED,IAAA,kBAAkB,CAAC,KAAY,EAAA;AAC7B,QAAA,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAA;QACtB,IAAI,IAAI,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,EAAE;;YAEzC,OAAO,CAAC,IAAI,CAAC,CAAA;AACd,SAAA;QAED,MAAM,MAAM,GAAgB,EAAE,CAAA;QAE9B,IAAI,KAAK,CAAC,aAAa,EAAE,KAAK,WAAW,IAAI,IAAI,CAAC,sBAAsB,EAAE,EAAE;AAC1E,YAAA,IAAI,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE;gBAC9B,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC,CAAA;AAC/B,aAAA;AACD,YAAA,OAAO,MAAM,CAAA;AACd,SAAA;;AAGD,QAAA,IAAI,KAAK,CAAC,aAAa,EAAE,KAAK,OAAO,EAAE;AACrC,YAAA,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,EAAE,CAAA;YAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;;;gBAG/B,MAAM,UAAU,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA;gBACpC,IAAI,UAAU,IAAI,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,EAAE;oBACjD,MAAM,CAAC,IAAI,CAAC,IAAI,SAAS,CAAC,IAAI,UAAU,CAAC,EAAC,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAA;AACjF,iBAAA;AACF,aAAA;AACD,YAAA,OAAO,MAAM,CAAA;AACd,SAAA;;AAGD,QAAA,IAAI,KAAK,CAAC,aAAa,EAAE,KAAK,QAAQ,EAAE;AACtC,YAAA,IAAI,IAAI,CAAC,sBAAsB,EAAE,EAAE;;AAEjC,gBAAA,OAAO,EAAE,CAAA;AACV,aAAA;AAED,YAAA,IAAI,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE;AAC9B,gBAAA,OAAO,IAAI,CAAC,OAAO,EAAE,CAAA;AACtB,aAAA;AAED,YAAA,OAAO,MAAM,CAAA;AACd,SAAA;AAED,QAAA,OAAO,MAAM,CAAA;KACd;IAED,OAAO,GAAA;AACL,QAAA,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;YACd,OAAO,CAAC,IAAI,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAA;AACnC,SAAA;AAED,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,KAAI;YACpC,OAAO,IAAI,SAAS,CAAC,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,CAAA;AACxC,SAAC,CAAC,CAAA;KACH;IAED,QAAQ,GAAA;AACN,QAAA,MAAM,MAAM,GAAG,CAAC,GAAG,CAAC,CAAA;QACpB,IAAI,IAAI,CAAC,IAAI,EAAE;YACb,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAA;AAClC,SAAA;AACD,QAAA,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;QAChB,IAAI,IAAI,CAAC,IAAI,EAAE;YACb,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAA;AAClC,SAAA;AACD,QAAA,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;AAChB,QAAA,OAAO,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;KACvB;AACF;;AC3GD;;AAEG;MACU,OAAO,CAAA;AAClB,IAAA,MAAM,CAAa;AACnB,IAAA,UAAU,CAAa;AACvB,IAAA,OAAO,CAAS;IAEhB,WAAY,CAAA,MAAmB,EAAE,MAAgB,EAAA;AAC/C,QAAA,IAAI,CAAC,MAAM,GAAG,MAAM,IAAI,EAAE,CAAA;AAC1B,QAAA,IAAI,MAAM,EAAE;AACV,YAAA,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,UAAU,CAAA;AACnC,YAAA,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,OAAO,CAAA;AAC9B,SAAA;AAAM,aAAA;AACL,YAAA,IAAI,CAAC,UAAU,GAAG,EAAE,CAAA;AACrB,SAAA;QACD,IAAI,CAAC,iBAAiB,EAAE,CAAA;KACzB;AAED,IAAA,UAAU,CAAC,OAAgB,EAAA;AACzB,QAAA,IAAI,CAAC,OAAO,GAAG,OAAO,CAAA;AACtB,QAAA,OAAO,IAAI,CAAA;KACZ;;;IAID,iBAAiB,GAAA;AACf,QAAA,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,SAAS,KAAI;AAC7C,YAAA,IAAI,SAAS,CAAC,WAAW,EAAE,EAAE;gBAC3B,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,iBAAiB,EAAE,CAAC,CAAA;AACtD,gBAAA,OAAO,KAAK,CAAA;AACb,aAAA;AACD,YAAA,OAAO,IAAI,CAAA;AACb,SAAC,CAAC,CAAA;KACH;;AAGD,IAAA,gBAAgB,CAAC,KAAY,EAAA;QAC3B,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,SAAS,KAAI;AAC1C,YAAA,MAAM,IAAI,GAAG,SAAS,CAAC,IAAI,CAAA;YAC3B,IAAI,CAAC,IAAI,EAAE;AACT,gBAAA,OAAO,KAAK,CAAA;AACb,aAAA;;AAGD,YAAA,IAAI,IAAI,CAAC,YAAY,EAAE,EAAE;AACvB,gBAAA,OAAO,IAAI,CAAA;AACZ,aAAA;;YAGD,IAAI,KAAK,CAAC,aAAa,EAAE,KAAK,OAAO,IAAI,IAAI,CAAC,gBAAgB,EAAE,EAAE;AAChE,gBAAA,OAAO,IAAI,CAAA;AACZ,aAAA;;AAGD,YAAA,IAAI,KAAK,CAAC,aAAa,EAAE,KAAK,QAAQ,EAAE;AACtC,gBAAA,OAAO,IAAI,CAAC,oBAAoB,EAAE,IAAI,KAAK,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAA;AACtE,aAAA;AAED,YAAA,OAAO,KAAK,CAAA;AACd,SAAC,CAAC,CAAA;KACH;AAED,IAAA,KAAK,CAAC,KAAY,EAAA;QAChB,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,CAAA;KACjD;AAED,IAAA,OAAO,CAAC,KAAY,EAAA;QAClB,MAAM,YAAY,GAAgB,EAAE,CAAA;AACpC,QAAA,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,SAAS,KAAI;YACrE,YAAY,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAA;AAChD,SAAC,CAAC,CAAA;AACF,QAAA,OAAO,IAAI,OAAO,CAAC,YAAY,EAAE,IAAI,CAAC,CAAA;KACvC;;;IAID,aAAa,GAAA;AACX,QAAA,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,SAAS,KAAK,SAAS,CAAC,UAAU,EAAE,CAAC,CAAA;KAC/D;IAED,aAAa,GAAA;AACX,QAAA,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAA;KAClC;;;AAID,IAAA,cAAc,CAAC,KAAY,EAAA;QACzB,MAAM,KAAK,GAA6C,EAAE,CAAA;QAC1D,MAAM,OAAO,GAAiB,EAAE,CAAA;QAChC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,SAAS,KAAI;AAChC,YAAA,IAAI,SAAS,CAAC,UAAU,EAAE,EAAE;;AAE1B,gBAAA,OAAO,CAAC,IAAI,CACV,IAAI,UAAU,CAAC;AACb,oBAAA,IAAI,EAAE,OAAO;AACb,oBAAA,MAAM,EAAE,MAAM;AACf,iBAAA,CAAC,CACH,CAAA;gBACD,OAAM;AACP,aAAA;AAED,YAAA,MAAM,aAAa,GAAG,SAAS,CAAC,IAAI,CAAA;YACpC,IAAI,CAAC,aAAa,EAAE;gBAClB,OAAM;AACP,aAAA;AAED,YAAA,IAAI,KAAK,CAAC,aAAa,EAAE,KAAK,OAAO,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,EAAE;;gBAE1E,OAAM;AACP,aAAA;AAED,YAAA,IAAI,KAAK,CAAC,aAAa,EAAE,KAAK,QAAQ,IAAI,CAAC,aAAa,CAAC,oBAAoB,EAAE,EAAE;;gBAE/E,OAAM;AACP,aAAA;YAED,IAAI,SAAS,CAAC,IAAI,EAAE;;AAElB,gBAAA,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,SAAS,CAAC,OAAO,EAAE,EAAE,IAAI,CAAC,CAAA;AACtD,gBAAA,aAAa,CAAC,iBAAiB,EAAE,CAAC,OAAO,CAAC,MAAK;oBAC7C,KAAK,CAAC,IAAI,CAAC;AACT,wBAAA,MAAM,EAAE,aAAa;AACrB,wBAAA,OAAO,EAAE,OAAO;AACjB,qBAAA,CAAC,CAAA;AACJ,iBAAC,CAAC,CAAA;AACH,aAAA;AAAM,iBAAA;;AAEL,gBAAA,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,CAAA;AAC5B,aAAA;AACH,SAAC,CAAC,CAAA;;AAGF,QAAA,IAAI,IAAI,CAAC,aAAa,EAAE,EAAE;;YAExB,MAAM,iBAAiB,GAAG,IAAI,OAAO,CAAC,EAAE,EAAE,IAAI,CAAC,CAAA;AAC/C,YAAA,IAAI,KAAK,CAAC,aAAa,EAAE,KAAK,OAAO,EAAE;AACrC,gBAAA,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,EAAE,CAAA;gBAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;oBAC/B,KAAK,CAAC,IAAI,CAAC;AACT,wBAAA,MAAM,EAAE,UAAU,CAAC,cAAc,CAAC,CAAC,CAAC;AACpC,wBAAA,OAAO,EAAE,iBAAiB;AAC3B,qBAAA,CAAC,CAAA;AACH,iBAAA;AACF,aAAA;AAAM,iBAAA,IAAI,KAAK,CAAC,aAAa,EAAE,KAAK,QAAQ,EAAE;gBAC7C,KAAK,CAAC,aAAa,EAAE,CAAC,OAAO,CAAC,CAAC,IAAI,KAAI;oBACrC,KAAK,CAAC,IAAI,CAAC;AACT,wBAAA,MAAM,EAAE,UAAU,CAAC,kBAAkB,CAAC,IAAI,CAAC;AAC3C,wBAAA,OAAO,EAAE,iBAAiB;AAC3B,qBAAA,CAAC,CAAA;AACJ,iBAAC,CAAC,CAAA;AACH,aAAA;AACF,SAAA;AAED,QAAA,OAAO,OAAO,CAAC,MAAM,GAAG,CAAC;AACvB,cAAE,EAAC,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAC,OAAO,EAAE,OAAO,EAAE,IAAI,CAAC,OAAO,EAAC,EAAC;AAC5D,cAAE,EAAC,KAAK,EAAE,KAAK,EAAC,CAAA;KACnB;IAED,OAAO,QAAQ,CAAC,QAAgB,EAAA;AAC9B,QAAA,MAAM,IAAI,GAAG,aAAa,CAAC,QAAQ,CAAC,CAAA;QACpC,IAAI,CAAC,IAAI,EAAE;AACT,YAAA,MAAM,IAAI,KAAK,CAAC,8BAA8B,QAAQ,CAAA,CAAA,CAAG,CAAC,CAAA;AAC3D,SAAA;AAED,QAAA,MAAM,SAAS,GAAG,IAAI,SAAS,CAAC,IAAI,EAAE,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC,CAAA;QAC3D,OAAO,IAAI,OAAO,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC,CAAA;KACxC;AACF;;ACzLK,SAAUC,UAAQ,CAAC,KAAc,EAAA;IACrC,OAAO,KAAK,KAAK,IAAI,IAAI,OAAO,KAAK,KAAK,QAAQ,CAAA;AACpD;;ACCA;MACa,UAAU,CAAA;AACrB,IAAA,MAAM,CAAS;AACf,IAAA,IAAI,CAAqB;IAEzB,WAAY,CAAA,KAAc,EAAE,IAA0B,EAAA;AACpD,QAAA,IAAI,CAAC,MAAM,GAAG,KAAK,CAAA;AACnB,QAAA,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI,EAAE,CAAA;KACvB;IAED,aAAa,GAAA;QACX,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AAC9B,YAAA,OAAO,OAAO,CAAA;AACf,SAAA;AAAM,aAAA,IAAI,IAAI,CAAC,MAAM,KAAK,IAAI,IAAI,OAAO,IAAI,CAAC,MAAM,KAAK,QAAQ,EAAE;AAClE,YAAA,OAAO,QAAQ,CAAA;AAChB,SAAA;AACD,QAAA,OAAO,WAAW,CAAA;KACnB;IAED,MAAM,GAAA;QACJ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AAC/B,YAAA,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC,CAAA;AAC/D,SAAA;AAED,QAAA,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAA;KAC1B;AAED,IAAA,QAAQ,CAAC,CAAS,EAAA;QAChB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AAC/B,YAAA,OAAO,KAAK,CAAA;AACb,SAAA;AAED,QAAA,IAAI,CAAC,IAAI,IAAI,CAAC,MAAM,EAAE,EAAE;AACtB,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;AAED,QAAA,OAAO,IAAI,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAA;KAC3D;AAED,IAAA,YAAY,CAAC,GAAW,EAAA;AACtB,QAAA,IAAI,CAACA,UAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AAC1B,YAAA,OAAO,KAAK,CAAA;AACb,SAAA;QAED,OAAO,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAA;KACvC;IAED,aAAa,GAAA;QACX,OAAOA,UAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,CAAA;KAC7D;AAED,IAAA,YAAY,CAAC,GAAW,EAAA;AACtB,QAAA,IAAI,CAACA,UAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AAC1B,YAAA,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAA;AAC9D,SAAA;AAED,QAAA,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AAC3B,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;AAED,QAAA,OAAO,IAAI,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAA;KAC/D;IAED,GAAG,GAAA;QACD,OAAO,IAAI,CAAC,MAAM,CAAA;KACnB;AACF;;AC/De,SAAA,gBAAgB,CAAC,IAAY,EAAE,KAAc,EAAA;IAC3D,MAAM,MAAM,GAAY,EAAE,CAAA;AAC1B,IAAA,MAAM,OAAO,GAAG,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,UAAU,CAAC,SAAS,YAAY,CAAC,MAAe,EAAA;AACrF,QAAA,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,CAAA;AACxB,KAAC,CAAC,CAAA;AACF,IAAA,MAAM,QAAQ,GAAG,IAAI,UAAU,CAAC,KAAK,CAAC,CAAA;AACtC,IAAA,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAA;AAC1B,IAAA,OAAO,MAAM,CAAA;AACf,CAAC;AAED,SAAS,OAAO,CAAC,OAAgB,EAAE,QAAe,EAAA;AAChD,IAAA,MAAM,EAAC,KAAK,EAAE,QAAQ,EAAC,GAAG,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAA;AAEjD,IAAA,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,KAAI;AACrB,QAAA,mBAAmB,CAAC,IAAI,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,OAAO,CAAC,CAAC,aAAa,KAAI;AACnE,YAAA,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,aAAa,CAAC,CAAA;AACtC,SAAC,CAAC,CAAA;AACJ,KAAC,CAAC,CAAA;AAEF,IAAA,IAAI,QAAQ,EAAE;QACZ,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,KAAI;AAClC,YAAA,IAAI,OAAO,QAAQ,CAAC,OAAO,KAAK,UAAU,EAAE;gBAC1C,QAAQ,CAAC,OAAO,CAAC,mBAAmB,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,CAAA;AACxD,aAAA;AACH,SAAC,CAAC,CAAA;AACH,KAAA;AACH,CAAC;AAED,SAAS,mBAAmB,CAAC,MAAkB,EAAE,QAAe,EAAA;IAC9D,MAAM,MAAM,GAAG,EAAE,CAAA;AACjB,IAAA,IAAI,MAAM,CAAC,gBAAgB,EAAE,EAAE;QAC7B,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAI;YACxC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAA;AACnC,SAAC,CAAC,CAAA;AACH,KAAA;AAAM,SAAA,IAAI,MAAM,CAAC,oBAAoB,EAAE,EAAE;AACxC,QAAA,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC,CAAA;AAClD,KAAA;AAAM,SAAA,IAAI,MAAM,CAAC,eAAe,EAAE,EAAE;AACnC,QAAA,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;AACtB,KAAA;AAAM,SAAA;QACL,MAAM,IAAI,KAAK,CAAC,CAAwC,qCAAA,EAAA,MAAM,CAAC,QAAQ,EAAE,CAAE,CAAA,CAAC,CAAA;AAC7E,KAAA;AACD,IAAA,OAAOC,cAAO,CAAC,MAAM,CAAC,CAAA;AACxB;;AC9CA;;;;;;;AAOG;AACa,SAAA,eAAe,CAC7B,IAAY,EACZ,KAAc,EAAA;IAEd,MAAM,SAAS,GAAG,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAA;IAC/C,OAAO,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM,EAAC,IAAI,EAAE,GAAG,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,CAAC,GAAG,EAAE,EAAC,CAAC,CAAC,CAAA;AACrE;;ACbA,MAAM,WAAW,GAAG,WAAW,CAAA;AAE/B;;;;;;AAMG;AACG,SAAU,oBAAoB,CAAC,SAAe,EAAA;IAClD,IAAI,IAAI,GAAG,EAAE,CAAA;IACb,SAAS,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,KAAK,KAAI;QACnC,IAAI,IAAI,gBAAgB,CAAC,OAAO,EAAE,KAAK,KAAK,CAAC,CAAC,CAAA;AAChD,KAAC,CAAC,CAAA;AACF,IAAA,OAAO,IAAI,CAAA;AACb,CAAC;AAED;AACA,SAAS,gBAAgB,CACvB,OAA8C,EAC9C,UAAmB,EAAA;AAEnB,IAAA,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;QAC/B,OAAO,CAAA,CAAA,EAAI,OAAO,CAAA,CAAA,CAAG,CAAA;AACtB,KAAA;AAED,IAAA,IAAID,UAAQ,CAAC,OAAO,CAAC,EAAE;QACrB,MAAM,GAAG,GAAG,OAAkC,CAAA;AAC9C,QAAA,OAAO,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC;AACxB,aAAA,GAAG,CAAC,CAAC,GAAG,MAAM,gBAAgB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAI,CAAA,EAAA,GAAG,CAAM,GAAA,EAAA,GAAG,CAAC,GAAG,CAAC,CAAA,EAAA,CAAI,GAAG,EAAE,CAAC,CAAC;aAC3E,IAAI,CAAC,EAAE,CAAC,CAAA;AACZ,KAAA;IAED,IAAI,OAAO,OAAO,KAAK,QAAQ,IAAI,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;QAC5D,OAAO,UAAU,GAAG,OAAO,GAAG,CAAA,CAAA,EAAI,OAAO,CAAA,CAAE,CAAA;AAC5C,KAAA;IAED,OAAO,CAAA,EAAA,EAAK,OAAO,CAAA,EAAA,CAAI,CAAA;AACzB,CAAC;AAED,SAAS,gBAAgB,CAAC,GAAY,EAAA;IACpC,QAAQ,OAAO,GAAG;AAChB,QAAA,KAAK,QAAQ,CAAC;AACd,QAAA,KAAK,QAAQ,CAAC;AACd,QAAA,KAAK,SAAS;AACZ,YAAA,OAAO,IAAI,CAAA;AACb,QAAA;AACE,YAAA,OAAO,KAAK,CAAA;AACf,KAAA;AACH;;MCjDa,QAAQ,CAAA;AACnB,IAAA,EAAE,CAAQ;AACV,IAAA,IAAI,CAAQ;AACZ,IAAA,KAAK,CAAS;AAEd,IAAA,WAAA,CAAY,EAAU,EAAE,IAAY,EAAE,KAAc,EAAA;AAClD,QAAA,IAAI,CAAC,EAAE,GAAG,EAAE,CAAA;AACZ,QAAA,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;AAChB,QAAA,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;KACnB;IAED,KAAK,CAAC,OAAqB,EAAE,QAA2B,EAAA;QACtD,IAAI,MAAM,GAAG,QAAQ,CAAA;AACrB,QAAA,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,KAAI;AACzB,YAAA,IAAI,MAAM,CAAC,eAAe,EAAE,EAAE;gBAC5B,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;AAChC,aAAA;AAAM,iBAAA,IAAI,MAAM,CAAC,gBAAgB,EAAE,EAAE;gBACpC,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,KAAI;oBACxC,MAAM,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAA;AACzC,iBAAC,CAAC,CAAA;AACH,aAAA;AAAM,iBAAA,IAAI,MAAM,CAAC,oBAAoB,EAAE,EAAE;AACxC,gBAAA,MAAM,GAAG,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,IAAI,CAAC,KAAK,CAAC,CAAA;AACxD,aAAA;AAAM,iBAAA;gBACL,MAAM,IAAI,KAAK,CAAC,CAA6B,0BAAA,EAAA,MAAM,CAAC,QAAQ,EAAE,CAAE,CAAA,CAAC,CAAA;AAClE,aAAA;AACH,SAAC,CAAC,CAAA;AACF,QAAA,OAAO,MAAM,CAAA;KACd;AACF;;AC5BD,SAAS,gBAAgB,CAAC,aAAsB,EAAE,KAAa,EAAA;AAC7D,IAAA,IAAI,OAAO,aAAa,KAAK,QAAQ,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE;AACxE,QAAA,OAAO,aAAuB,CAAA;AAC/B,KAAA;IAED,OAAO,aAAa,GAAG,KAAK,CAAA;AAC9B,CAAC;MAEY,QAAQ,CAAA;AACnB,IAAA,IAAI,CAAQ;AACZ,IAAA,KAAK,CAAQ;AACb,IAAA,EAAE,CAAQ;AAEV,IAAA,WAAA,CAAY,EAAU,EAAE,IAAY,EAAE,KAAa,EAAA;AACjD,QAAA,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;AAChB,QAAA,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;AAClB,QAAA,IAAI,CAAC,EAAE,GAAG,EAAE,CAAA;KACb;IAED,KAAK,CAAC,OAAqB,EAAE,QAA2B,EAAA;QACtD,IAAI,MAAM,GAAG,QAAQ,CAAA;;AAGrB,QAAA,IAAI,MAAM,CAAC,aAAa,EAAE,KAAK,WAAW,EAAE;AAC1C,YAAA,OAAO,MAAM,CAAA;AACd,SAAA;AAED,QAAA,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;AAC5B,YAAA,IAAI,MAAM,CAAC,gBAAgB,EAAE,EAAE;gBAC7B,KAAK,MAAM,KAAK,IAAI,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;;oBAE/C,MAAM,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAA;oBACnC,IAAI,CAAC,IAAI,EAAE;wBACT,SAAQ;AACT,qBAAA;AAED,oBAAA,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,EAAE,CAAA;AAChC,oBAAA,MAAM,GAAG,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,gBAAgB,CAAC,aAAa,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAA;AAC7E,iBAAA;gBAED,SAAQ;AACT,aAAA;AAED,YAAA,IAAI,MAAM,CAAC,oBAAoB,EAAE,EAAE;gBACjC,MAAM,SAAS,GAAG,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAA;gBACpD,IAAI,CAAC,SAAS,EAAE;oBACd,SAAQ;AACT,iBAAA;AAED,gBAAA,MAAM,aAAa,GAAG,SAAS,CAAC,GAAG,EAAE,CAAA;AACrC,gBAAA,MAAM,GAAG,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,gBAAgB,CAAC,aAAa,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAA;gBACxF,SAAQ;AACT,aAAA;YAED,MAAM,IAAI,KAAK,CAAC,CAA6B,0BAAA,EAAA,MAAM,CAAC,QAAQ,EAAE,CAAE,CAAA,CAAC,CAAA;AAClE,SAAA;AAED,QAAA,OAAO,MAAM,CAAA;KACd;AACF;;AC3De,SAAA,iBAAiB,CAAC,OAAqB,EAAE,QAA2B,EAAA;IAClF,MAAM,MAAM,GAAa,EAAE,CAAA;AAC3B,IAAA,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,KAAI;AACzB,QAAA,IAAI,MAAM,CAAC,gBAAgB,EAAE,EAAE;YAC7B,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAA;AAC5C,SAAA;AACH,KAAC,CAAC,CAAA;AACF,IAAA,OAAO,MAAM,CAAC,IAAI,EAAE,CAAA;AACtB;;MCNa,WAAW,CAAA;AACtB,IAAA,QAAQ,CAAQ;AAChB,IAAA,IAAI,CAAQ;AACZ,IAAA,KAAK,CAAW;AAChB,IAAA,EAAE,CAAQ;AAEV,IAAA,WAAA,CAAY,EAAU,EAAE,QAAgB,EAAE,IAAY,EAAE,KAAgB,EAAA;AACtE,QAAA,IAAI,CAAC,EAAE,GAAG,EAAE,CAAA;AACZ,QAAA,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAA;AACxB,QAAA,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;AAChB,QAAA,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;KACnB;IAED,KAAK,CAAC,OAAqB,EAAE,QAA2B,EAAA;QACtD,IAAI,MAAM,GAAG,QAAQ,CAAA;AACrB,QAAA,IAAI,QAAQ,CAAC,aAAa,EAAE,KAAK,OAAO,EAAE;AACxC,YAAA,MAAM,IAAI,KAAK,CAAC,kDAAkD,CAAC,CAAA;AACpE,SAAA;QAED,QAAQ,IAAI,CAAC,QAAQ;YACnB,KAAK,QAAQ,EAAE;gBACb,MAAM,GAAG,GAAG,QAAQ,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAA;gBACvC,MAAM,GAAG,MAAM,CAAC,aAAa,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,CAAA;gBAC9C,MAAK;AACN,aAAA;YACD,KAAK,OAAO,EAAE;gBACZ,MAAM,GAAG,GAAG,QAAQ,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAA;AACvC,gBAAA,MAAM,GAAG,MAAM,CAAC,aAAa,CAAC,GAAG,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAA;gBAClD,MAAK;AACN,aAAA;YACD,KAAK,SAAS,EAAE;;;gBAGd,MAAM,QAAQ,GAAG,iBAAiB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAA;AACrD,gBAAA,MAAM,GAAG,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAA;AACtC,gBAAA,MAAM,GAAG,MAAM,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAA;gBACtD,MAAK;AACN,aAAA;AACD,YAAA,SAAS;gBACP,MAAM,IAAI,KAAK,CAAC,CAAA,0BAAA,EAA6B,IAAI,CAAC,QAAQ,CAAE,CAAA,CAAC,CAAA;AAC9D,aAAA;AACF,SAAA;AACD,QAAA,OAAO,MAAM,CAAA;KACd;AACF,CAAA;AAED,SAAS,QAAQ,CAAC,OAAqB,EAAE,QAA2B,EAAA;AAClE,IAAA,IAAI,MAAM,GAAGE,UAAG,CAAC,iBAAiB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,IAAI,CAAC,CAAA;;AAG3D,IAAA,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,KAAI;AACzB,QAAA,IAAI,MAAM,CAAC,OAAO,EAAE,EAAE;YACpB,MAAM,EAAC,KAAK,EAAC,GAAG,MAAM,CAAC,WAAW,EAAE,CAAA;YACpC,IAAI,KAAK,GAAG,MAAM,EAAE;gBAClB,MAAM,GAAG,KAAK,CAAA;AACf,aAAA;AACF,SAAA;AACH,KAAC,CAAC,CAAA;AACF,IAAA,OAAO,MAAM,CAAA;AACf,CAAC;AAED,SAAS,QAAQ,CAAC,OAAqB,EAAE,QAA2B,EAAA;AAClE,IAAA,IAAI,MAAM,GAAGC,UAAG,CAAC,iBAAiB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,IAAI,CAAC,CAAA;;AAG3D,IAAA,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,KAAI;AACzB,QAAA,IAAI,MAAM,CAAC,OAAO,EAAE,EAAE;YACpB,MAAM,EAAC,GAAG,EAAC,GAAG,MAAM,CAAC,WAAW,EAAE,CAAA;YAClC,IAAI,GAAG,GAAG,MAAM,EAAE;gBAChB,MAAM,GAAG,GAAG,CAAA;AACb,aAAA;AACF,SAAA;AACH,KAAC,CAAC,CAAA;AACF,IAAA,OAAO,MAAM,CAAA;AACf;;MC5Ea,iBAAiB,CAAA;AAC5B,IAAA,EAAE,CAAQ;AACV,IAAA,IAAI,CAAQ;AACZ,IAAA,KAAK,CAAS;AAEd,IAAA,WAAA,CAAY,EAAU,EAAE,IAAY,EAAE,KAAc,EAAA;AAClD,QAAA,IAAI,CAAC,EAAE,GAAG,EAAE,CAAA;AACZ,QAAA,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;AAChB,QAAA,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;KACnB;IAED,KAAK,CAAC,OAAqB,EAAE,QAA2B,EAAA;QACtD,IAAI,MAAM,GAAG,QAAQ,CAAA;AACrB,QAAA,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,KAAI;AACzB,YAAA,IAAI,MAAM,CAAC,gBAAgB,EAAE,EAAE,CAE9B;AAAM,iBAAA,IAAI,MAAM,CAAC,oBAAoB,EAAE,EAAE;gBACxC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,EAAE;AACvC,oBAAA,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,IAAI,CAAC,KAAK,CAAC,CAAA;AAC1D,iBAAA;AACF,aAAA;AAAM,iBAAA;gBACL,MAAM,IAAI,KAAK,CAAC,CAA6B,0BAAA,EAAA,MAAM,CAAC,QAAQ,EAAE,CAAE,CAAA,CAAC,CAAA;AAClE,aAAA;AACH,SAAC,CAAC,CAAA;AACF,QAAA,OAAO,MAAM,CAAA;KACd;AACF;;MCzBY,UAAU,CAAA;AACrB,IAAA,EAAE,CAAQ;AACV,IAAA,IAAI,CAAQ;AACZ,IAAA,KAAK,CAAS;IAEd,WAAY,CAAA,EAAU,EAAE,IAAY,EAAA;AAClC,QAAA,IAAI,CAAC,EAAE,GAAG,EAAE,CAAA;AACZ,QAAA,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;KACjB;;IAGD,KAAK,CAAC,OAAqB,EAAE,QAA2B,EAAA;QACtD,IAAI,MAAM,GAAG,QAAQ,CAAA;AACrB,QAAA,QAAQ,QAAQ,CAAC,aAAa,EAAE;AAC9B,YAAA,KAAK,OAAO;AACV,gBAAA,MAAM,GAAG,MAAM,CAAC,YAAY,CAAC,iBAAiB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,CAAA;gBAClE,MAAK;AACP,YAAA,KAAK,QAAQ;AACX,gBAAA,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,KAAI;oBACzB,MAAM,GAAG,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAA;AAC/C,iBAAC,CAAC,CAAA;gBACF,MAAK;AACP,YAAA;AACE,gBAAA,MAAM,IAAI,KAAK,CACb,yGAAyG,CAC1G,CAAA;AACJ,SAAA;AACD,QAAA,OAAO,MAAM,CAAA;KACd;AACF;;ACjCD;AAKA,MAAM,GAAG,GAAG,IAAIC,cAAG,CAAC,gBAAgB,EAAE,CAAA;AAEtC,SAAS,UAAU,CAAC,KAAsB,EAAE,QAAiB,EAAA;;IAE3D,IAAI,OAAO,QAAQ,KAAK,QAAQ;AAAE,QAAA,OAAO,QAAQ,CAAA;IACjD,OAAO,GAAG,CAAC,WAAW,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAA;AAC5C,CAAC;MAEY,cAAc,CAAA;AACzB,IAAA,IAAI,CAAQ;AACZ,IAAA,QAAQ,CAAiB;AACzB,IAAA,EAAE,CAAQ;AAEV,IAAA,WAAA,CAAY,EAAU,EAAE,IAAY,EAAE,WAAmB,EAAA;AACvD,QAAA,IAAI,CAAC,EAAE,GAAG,EAAE,CAAA;AACZ,QAAA,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;QAChB,IAAI,CAAC,QAAQ,GAAG,GAAG,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;KAChD;IAED,KAAK,CAAC,OAAqB,EAAE,QAA2B,EAAA;QACtD,IAAI,MAAM,GAAG,QAAQ,CAAA;;AAGrB,QAAA,IAAI,MAAM,CAAC,aAAa,EAAE,KAAK,WAAW,EAAE;AAC1C,YAAA,OAAO,MAAM,CAAA;AACd,SAAA;AAED,QAAA,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;AAC5B,YAAA,IAAI,MAAM,CAAC,gBAAgB,EAAE,EAAE;gBAC7B,KAAK,MAAM,KAAK,IAAI,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;;oBAE/C,MAAM,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAA;oBACnC,IAAI,CAAC,IAAI,EAAE;wBACT,SAAQ;AACT,qBAAA;AAED,oBAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,CAAA;oBAC3B,MAAM,SAAS,GAAG,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAA;oBACrD,MAAM,GAAG,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,SAAS,CAAC,CAAA;AAC3C,iBAAA;gBAED,SAAQ;AACT,aAAA;AAED,YAAA,IAAI,MAAM,CAAC,oBAAoB,EAAE,IAAI,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,EAAE;gBACvE,MAAM,SAAS,GAAG,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAA;gBACpD,IAAI,CAAC,SAAS,EAAE;oBACd,SAAQ;AACT,iBAAA;AAED,gBAAA,MAAM,QAAQ,GAAG,SAAS,CAAC,GAAG,EAAE,CAAA;gBAChC,MAAM,SAAS,GAAG,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAA;AACrD,gBAAA,MAAM,GAAG,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,SAAS,CAAC,CAAA;gBACtD,SAAQ;AACT,aAAA;YAED,MAAM,IAAI,KAAK,CAAC,CAA4C,yCAAA,EAAA,MAAM,CAAC,QAAQ,EAAE,CAAE,CAAA,CAAC,CAAA;AACjF,SAAA;AAED,QAAA,OAAO,MAAM,CAAA;KACd;AACF;;AC1DD;AACM,SAAU,UAAU,CAAC,KAAkD,EAAA;IAC3E,MAAM,MAAM,GAAiB,EAAE,CAAA;AAC/B,IAAA,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;QACxB,OAAO,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAA;AAC/D,KAAA;AAED,IAAA,MAAM,EAAC,GAAG,EAAE,YAAY,EAAE,KAAK,EAAE,cAAc,EAAE,GAAG,EAAE,GAAG,EAAE,MAAM,EAAC,GAAG,KAAK,CAAA;AAC1E,IAAA,IAAI,GAAG,EAAE;QACP,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,KAAI;AAChC,YAAA,MAAM,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,KAAK,CAAC,EAAE,EAAE,IAAI,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;AACtD,SAAC,CAAC,CAAA;AACH,KAAA;AAED,IAAA,IAAI,YAAY,EAAE;QAChB,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,KAAI;AACzC,YAAA,MAAM,CAAC,IAAI,CAAC,IAAI,iBAAiB,CAAC,KAAK,CAAC,EAAE,EAAE,IAAI,EAAE,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;AACxE,SAAC,CAAC,CAAA;AACH,KAAA;AAED,IAAA,IAAI,KAAK,EAAE;AACT,QAAA,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,KAAI;AACrB,YAAA,MAAM,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,KAAK,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC,CAAA;AAC7C,SAAC,CAAC,CAAA;AACH,KAAA;AAED,IAAA,IAAI,cAAc,EAAE;QAClB,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,KAAI;AAC3C,YAAA,MAAM,CAAC,IAAI,CAAC,IAAI,cAAc,CAAC,KAAK,CAAC,EAAE,EAAE,IAAI,EAAE,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;AACvE,SAAC,CAAC,CAAA;AACH,KAAA;AAED,IAAA,IAAI,GAAG,EAAE;QACP,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,KAAI;AAChC,YAAA,MAAM,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,KAAK,CAAC,EAAE,EAAE,IAAI,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;AACtD,SAAC,CAAC,CAAA;AACH,KAAA;AAED,IAAA,IAAI,GAAG,EAAE;QACP,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,KAAI;AAChC,YAAA,MAAM,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,KAAK,CAAC,EAAE,EAAE,IAAI,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;AACvD,SAAC,CAAC,CAAA;AACH,KAAA;AAED,IAAA,IAAI,MAAM,EAAE;AACV,QAAA,IAAI,QAAgB,CAAA;AACpB,QAAA,IAAI,IAAY,CAAA;QAChB,MAAM,IAAI,GAAG,MAAM,CAAA;QACnB,IAAI,QAAQ,IAAI,IAAI,EAAE;YACpB,QAAQ,GAAG,QAAQ,CAAA;AACnB,YAAA,IAAI,GAAG,IAAI,CAAC,MAAM,CAAA;AACnB,SAAA;aAAM,IAAI,OAAO,IAAI,IAAI,EAAE;YAC1B,QAAQ,GAAG,OAAO,CAAA;AAClB,YAAA,IAAI,GAAG,IAAI,CAAC,KAAK,CAAA;AAClB,SAAA;aAAM,IAAI,SAAS,IAAI,IAAI,EAAE;YAC5B,QAAQ,GAAG,SAAS,CAAA;AACpB,YAAA,IAAI,GAAG,IAAI,CAAC,OAAO,CAAA;AACpB,SAAA;AAAM,aAAA;AACL,YAAA,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAA;AACxC,SAAA;AAED,QAAA,MAAM,CAAC,IAAI,CAAC,IAAI,WAAW,CAAC,KAAK,CAAC,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAA;AACnE,KAAA;AAED,IAAA,OAAO,MAAM,CAAA;AACf;;ACvEA;;;;AAIG;MACU,iBAAiB,CAAA;AAC5B,IAAA,MAAM,CAAS;AACf,IAAA,IAAI,CAAqB;IAEzB,WAAY,CAAA,KAAc,EAAE,IAA0B,EAAA;AACpD,QAAA,IAAI,CAAC,MAAM,GAAG,KAAK,CAAA;AACnB,QAAA,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI,EAAE,CAAA;KACvB;IAED,aAAa,GAAA;QACX,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AAC9B,YAAA,OAAO,OAAO,CAAA;AACf,SAAA;AAAM,aAAA,IAAI,IAAI,CAAC,MAAM,KAAK,IAAI,IAAI,OAAO,IAAI,CAAC,MAAM,KAAK,QAAQ,EAAE;AAClE,YAAA,OAAO,QAAQ,CAAA;AAChB,SAAA;AACD,QAAA,OAAO,WAAW,CAAA;KACnB;;IAGD,GAAG,GAAA;QACD,OAAO,IAAI,CAAC,MAAM,CAAA;KACnB;;IAGD,MAAM,GAAA;QACJ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AAC/B,YAAA,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC,CAAA;AAC/D,SAAA;AAED,QAAA,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAA;KAC1B;AAED,IAAA,QAAQ,CAAC,CAAS,EAAA;QAChB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AAC/B,YAAA,OAAO,KAAK,CAAA;AACb,SAAA;AAED,QAAA,IAAI,CAAC,IAAI,IAAI,CAAC,MAAM,EAAE,EAAE;AACtB,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;AAED,QAAA,OAAO,IAAI,iBAAiB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAA;KAClE;;AAGD,IAAA,YAAY,CAAC,GAAW,EAAA;QACtB,OAAO,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,KAAK,CAAA;KACvE;IAED,aAAa,GAAA;QACX,OAAO,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,CAAA;KAC7D;AAED,IAAA,YAAY,CAAC,GAAW,EAAA;AACtB,QAAA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AAC1B,YAAA,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAA;AAC9D,SAAA;AAED,QAAA,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;AAC3B,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;AAED,QAAA,OAAO,IAAI,iBAAiB,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAA;KACtE;;AAGD,IAAA,GAAG,CAAC,KAAc,EAAA;QAChB,OAAO,KAAK,KAAK,IAAI,CAAC,MAAM,GAAG,IAAI,GAAG,IAAI,iBAAiB,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,CAAA;KAC9E;;IAGD,QAAQ,CAAC,CAAS,EAAE,KAAc,EAAA;QAChC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AAC/B,YAAA,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAA;AACnD,SAAA;QAED,IAAI,KAAK,KAAK,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE;AAC5B,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;QAED,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAA;AACrC,QAAA,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK,CAAA;QACpB,OAAO,IAAI,iBAAiB,CAAC,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,CAAA;KACnD;IAED,gBAAgB,CAAC,CAAS,EAAE,QAA2B,EAAA;QACrD,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAA;KACxC;AAED,IAAA,YAAY,CAAC,OAAiB,EAAA;QAC5B,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AAC/B,YAAA,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAA;AACvD,SAAA;AAED,QAAA,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAA;QACjC,MAAM,SAAS,GAAG,EAAE,CAAA;;QAEpB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;YAC/B,IAAI,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;gBAC7B,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAA;AAC/B,aAAA;AACF,SAAA;QACD,OAAO,IAAI,iBAAiB,CAAC,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,CAAA;KACnD;IAED,aAAa,CAAC,GAAW,EAAE,KAAgB,EAAA;QACzC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AAC/B,YAAA,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAA;AACxD,SAAA;AAED,QAAA,IAAI,SAAS,CAAA;QACb,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,IAAI,GAAG,KAAK,CAAC,EAAE;YACzC,SAAS,GAAG,KAAK,CAAA;AAClB,SAAA;AAAM,aAAA;AACL,YAAA,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAA;AACnF,SAAA;QAED,OAAO,IAAI,iBAAiB,CAAC,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,CAAA;KACnD;;IAGD,YAAY,CAAC,GAAW,EAAE,KAAc,EAAA;AACtC,QAAA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AAC1B,YAAA,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAA;AACnE,SAAA;QAED,IAAI,KAAK,KAAK,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE;AAC9B,YAAA,OAAO,IAAI,CAAA;AACZ,SAAA;QAED,MAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM,EAAE,EAAC,CAAC,GAAG,GAAG,KAAK,EAAC,CAAC,CAAA;QAChE,OAAO,IAAI,iBAAiB,CAAC,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,CAAA;KACnD;IAED,oBAAoB,CAAC,GAAW,EAAE,QAA2B,EAAA;QAC3D,OAAO,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAA;KAC9C;AAED,IAAA,cAAc,CAAC,GAAW,EAAA;AACxB,QAAA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;AAC1B,YAAA,MAAM,IAAI,KAAK,CAAC,mDAAmD,CAAC,CAAA;AACrE,SAAA;AAED,QAAA,MAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,CAAA;AAChD,QAAA,OAAO,SAAS,CAAC,GAAG,CAAC,CAAA;QACrB,OAAO,IAAI,iBAAiB,CAAC,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,CAAA;KACnD;AACF,CAAA;AAED,SAAS,QAAQ,CAAC,KAAc,EAAA;IAC9B,OAAO,KAAK,KAAK,IAAI,IAAI,OAAO,KAAK,KAAK,QAAQ,CAAA;AACpD;;MCnJa,OAAO,CAAA;AAClB,IAAA,OAAO,CAAc;AAErB,IAAA,WAAA,CAAY,KAAkD,EAAA;AAC5D,QAAA,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC,KAAK,CAAC,CAAA;KACjC;AAED,IAAA,KAAK,CAAC,KAAiB,EAAA;;;;;;AAMrB,QAAA,MAAM,QAAQ,GAAG,IAAI,iBAAiB,CAAC,KAAK,CAAC,CAAA;QAC7C,OAAO,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC,GAAG,EAAE,CAAA;KAC7C;;;;;;AAOD,IAAA,gBAAgB,CAAC,QAA2B,EAAA;QAC1C,IAAI,MAAM,GAAG,QAAQ,CAAA;QACrB,MAAM,UAAU,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,CAAA;QAC/C,IAAI,CAAC,UAAU,EAAE;AACf,YAAA,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAA;AAC9D,SAAA;AAED,QAAA,MAAM,EAAE,GAAG,UAAU,CAAC,GAAG,EAAE,CAAA;AAC3B,QAAA,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,OAAO,EAAE;AAChC,YAAA,IAAI,KAAK,CAAC,EAAE,KAAK,EAAE,EAAE;;gBAEnB,SAAQ;AACT,aAAA;AAED,YAAA,MAAM,OAAO,GAAG,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,CAAA;AAC9D,YAAA,MAAM,GAAG,OAAO,CAAC,OAAO,EAAE,MAAM,CAAC,CAAA;AAClC,SAAA;AAED,QAAA,OAAO,MAAM,CAAA;KACd;AACF,CAAA;AAED;AACA;AACA;AACA,SAAS,OAAO,CAAC,OAAgB,EAAE,QAA2B,EAAA;IAC5D,IAAI,MAAM,GAAG,QAAQ,CAAA;;;;;;AAMrB,IAAA,MAAM,EAAC,KAAK,EAAE,QAAQ,EAAC,GAAG,OAAO,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAA;AACjD,IAAA,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,KAAI;AACrB,QAAA,IAAI,IAAI,CAAC,MAAM,CAAC,gBAAgB,EAAE,EAAE;YAClC,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,KAAI;gBACrC,MAAM,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA;gBAC/B,IAAI,CAAC,IAAI,EAAE;AACT,oBAAA,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAA;AACvC,iBAAA;AAED,gBAAA,MAAM,GAAG,MAAM,CAAC,gBAAgB,CAAC,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAA;AAClE,aAAC,CAAC,CAAA;AACH,SAAA;AAAM,aAAA,IAAI,IAAI,CAAC,MAAM,CAAC,oBAAoB,EAAE,EAAE;AAC7C,YAAA,MAAM,gBAAgB,GAAG,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAA;YAChE,IAAI,CAAC,gBAAgB,EAAE;;gBAErB,OAAM;AACP,aAAA;YAED,MAAM,gBAAgB,GAAG,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAA;YAChE,IAAI,gBAAgB,KAAK,gBAAgB,EAAE;AACzC,gBAAA,MAAM,GAAG,MAAM,CAAC,oBAAoB,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,gBAAgB,CAAC,CAAA;AAC3E,aAAA;AACF,SAAA;AAAM,aAAA;AACL,YAAA,MAAM,IAAI,KAAK,CAAC,CAAA,wBAAA,EAA2B,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAE,CAAA,CAAC,CAAA;AACrE,SAAA;AACH,KAAC,CAAC,CAAA;;;;;;IAOF,IAAI,QAAQ,IAAI,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;AAC3C,QAAA,MAAM,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAA;QAC9B,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,EAAE,MAAM,CAAC,CAAA;AAC/C,KAAA;AAED,IAAA,OAAO,MAAM,CAAA;AACf,CAAC;AAED,SAAS,SAAS,CAAC,OAAgB,EAAA;IACjC,OAAO,OAAO,CACZ,OAAO;QACL,OAAO,OAAO,KAAK,QAAQ;AAC3B,QAAA,OAAO,KAAK,IAAI;AAChB,QAAA,OAAO,IAAI,OAAO;AAClB,QAAA,OAAQ,OAAsB,CAAC,KAAK,KAAK,UAAU,CACtD,CAAA;AACH;;AC/GA;;;;AAIG;AACI,MAAM,IAAI,GAAGC,SAAI;;ACLjB,MAAM,KAAK,GAAGC,2BAAO,CAAC,kBAAkB,CAAC;;ACmBhD;;;;;;;AAOG;MACU,QAAQ,CAAA;AACnB,IAAA,MAAM,CAAgB;AAEtB,IAAA,QAAQ,CAAkC;AAE1C,IAAA,yBAAyB,CAAqB;AAE9C,IAAA,WAAA,CAAY,OAAuB,EAAA;AACjC,QAAA,IAAI,CAAC,MAAM,GAAG,OAAO,CAAA;KACtB;AAED,IAAA,IAAI,aAAa,GAAA;AACf,QAAA,OAAO,IAAI,CAAC,MAAM,CAAC,aAAa,CAAA;KACjC;AAED,IAAA,IAAI,UAAU,GAAA;AACZ,QAAA,OAAO,IAAI,CAAC,MAAM,CAAC,UAAU,CAAA;KAC9B;AAED,IAAA,IAAI,QAAQ,GAAA;AACV,QAAA,OAAO,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAA;KAC5B;AAED,IAAA,IAAI,WAAW,GAAA;AACb,QAAA,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW,CAAA;KAC/B;AAED,IAAA,IAAI,SAAS,GAAA;AACX,QAAA,OAAO,IAAI,CAAC,MAAM,CAAC,SAAS,CAAA;KAC7B;AAED,IAAA,IAAI,SAAS,GAAA;AACX,QAAA,OAAO,IAAI,CAAC,MAAM,CAAC,SAAS,CAAA;KAC7B;AAED,IAAA,IAAI,SAAS,GAAA;QACX,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,SAAS,KAAK,QAAQ,EAAE;YAC7C,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;AACvC,SAAA;AAED,QAAA,OAAO,SAAS,CAAA;KACjB;AAED,IAAA,IAAI,OAAO,GAAA;AAMT,QAAA,OAAO,IAAI,CAAC,MAAM,CAAC,OAAO,CAAA;KAC3B;IAED,yBAAyB,GAAA;AACvB,QAAA,IAAI,CAAC,MAAM,CAAC,aAAa,GAAG,IAAI,EAAE,CAAA;QAClC,IAAI,CAAC,MAAM,CAAC,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,aAAa,CAAA;KAClD;IAED,wBAAwB,GAAA;AACtB,QAAA,IAAI,OAAO,IAAI,CAAC,yBAAyB,KAAK,WAAW,EAAE;YACzD,OAAO,IAAI,CAAC,yBAAyB,CAAA;AACtC,SAAA;;QAGD,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAA;AAClC,QAAA,IAAI,QAAQ,EAAE;AACZ,YAAA,IAAI,CAAC,yBAAyB,GAAG,OAAO,CACtC,QAAQ,CAAC,MAAM,IAAI,QAAQ,CAAC,iBAAiB,IAAI,QAAQ,CAAC,eAAe,CAC1E,CAAA;AACF,SAAA;AAAM,aAAA;AACL,YAAA,IAAI,CAAC,yBAAyB,GAAG,IAAI,CAAA;AACtC,SAAA;QAED,OAAO,IAAI,CAAC,yBAAyB,CAAA;KACtC;;IAGD,OAAO,GAAA;QACL,MAAM,UAAU,GAAwC,EAAE,CAAA;QAE1D,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,QAAQ,KAAI;YAClC,IAAI,QAAQ,CAAC,MAAM,EAAE;;AAEnB,gBAAA,MAAM,MAAM,GAAG,QAAQ,CAAC,MAAM,IAAI,EAAE,CAAA;AACpC,gBAAA,UAAU,CAAC,IAAI,CAAC,CAAC,GAAG,KAAS;AAC3B,oBAAA,IAAI,GAAG,EAAE;AACP,wBAAA,OAAO,GAAG,CAAA;AACX,qBAAA;AAED,oBAAA,OAAO,MAAM,CAAC,MAAM,CAAC,MAAa,EAAE;wBAClC,UAAU,EAAE,MAAM,CAAC,UAAU,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS;AACvD,qBAAA,CAAC,CAAA;AACJ,iBAAC,CAAC,CAAA;gBACF,OAAM;AACP,aAAA;YAED,IAAI,QAAQ,CAAC,iBAAiB,EAAE;AAC9B,gBAAA,MAAM,iBAAiB,GAAG,QAAQ,CAAC,iBAAiB,IAAI,EAAE,CAAA;gBAC1D,UAAU,CAAC,IAAI,CAAC,CAAC,GAAG,KAClB,GAAG,KAAK,IAAI;AACV,sBAAE,MAAM,CAAC,MAAM,CAAC,iBAAiB,EAAE;wBAC/B,UAAU,EAAE,iBAAiB,CAAC,UAAU,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS;qBAClE,CAAC;sBACF,GAAG,CACR,CAAA;gBACD,OAAM;AACP,aAAA;YAED,IAAI,QAAQ,CAAC,eAAe,EAAE;AAC5B,gBAAA,MAAM,eAAe,GAAG,QAAQ,CAAC,eAAe,IAAI,EAAE,CAAA;gBACtD,UAAU,CAAC,IAAI,CAAC,MACd,MAAM,CAAC,MAAM,CAAC,eAAe,EAAE;oBAC7B,UAAU,EAAE,eAAe,CAAC,UAAU,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS;AAChE,iBAAA,CAAC,CACH,CAAA;gBACD,OAAM;AACP,aAAA;YAED,IAAI,QAAQ,CAAC,MAAM,EAAE;gBACnB,UAAU,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,CAAA;gBAC3B,OAAM;AACP,aAAA;YAED,IAAI,QAAQ,CAAC,KAAK,EAAE;AAClB,gBAAA,IAAI,OAAO,IAAI,QAAQ,CAAC,KAAK,EAAE;;oBAE7B,OAAM;AACP,iBAAA;gBAED,MAAM,KAAK,GAAG,IAAI,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAA;AACzC,gBAAA,UAAU,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,KAAK,CAAC,KAAK,CAAC,GAAG,CAAe,CAAC,CAAA;gBACxD,OAAM;AACP,aAAA;AAED,YAAA,MAAM,IAAI,KAAK,CAAC,CAAwB,qBAAA,EAAA,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC,CAAA,CAAE,CAAC,CAAA;AAC9E,SAAC,CAAC,CAAA;;QAGF,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,SAAS,KAAK,QAAQ,EAAE;AAC7C,YAAA,UAAU,CAAC,IAAI,CAAC,CAAC,GAAG,KAAI;gBACtB,OAAO,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,EAAC,UAAU,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,EAAC,CAAC,GAAG,IAAI,CAAA;AAC7E,aAAC,CAAC,CAAA;AACH,SAAA;AAED,QAAA,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAA;QAChC,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,aAAa,CAAA;AAChD,QAAA,IAAI,CAAC,QAAQ,GAAG,CAAC,GAAe,KAAI;YAClC,IAAI,OAAO,IAAI,GAAG,IAAI,OAAO,KAAK,GAAG,CAAC,IAAI,EAAE;gBAC1C,MAAM,IAAI,KAAK,CACb,CAA2C,wCAAA,EAAA,OAAO,CAAkC,+BAAA,EAAA,GAAG,CAAC,IAAI,CAAE,CAAA,CAC/F,CAAA;AACF,aAAA;YAED,IAAI,MAAM,GAAe,GAAG,CAAA;AAC5B,YAAA,KAAK,MAAM,SAAS,IAAI,UAAU,EAAE;AAClC,gBAAA,MAAM,GAAG,SAAS,CAAC,MAAM,CAAC,CAAA;AAC3B,aAAA;;YAGD,IAAI,MAAM,IAAI,GAAG,EAAE;;gBAEjB,IAAI,MAAM,KAAK,GAAG,EAAE;oBAClB,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,GAAG,CAAC,CAAA;AAChC,iBAAA;AACD,gBAAA,MAAM,CAAC,IAAI,GAAG,GAAG,CAAA;AAClB,aAAA;AAED,YAAA,OAAO,MAAM,CAAA;AACf,SAAC,CAAA;KACF;AAED,IAAA,KAAK,CAAC,QAAoB,EAAA;QACxB,KAAK,CAAC,qCAAqC,EAAE,IAAI,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAA;AACtE,QAAA,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAClB,IAAI,CAAC,OAAO,EAAE,CAAA;AACf,SAAA;QAED,MAAM,MAAM,GAAG,IAAI,CAAC,QAAS,CAAC,QAAQ,CAAC,CAAA;AACvC,QAAA,KAAK,CAAC,SAAS,EAAE,MAAM,CAAC,CAAA;AACxB,QAAA,OAAO,MAAM,CAAA;KACd;AAED,IAAA,OAAO,QAAQ,CAAC,QAAoB,EAAE,SAAqB,EAAA;QACzD,OAAO,SAAS,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,QAAQ,KAAK,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,QAAQ,CAAC,CAAA;KAC1E;;;;;AAMD,IAAA,OAAO,MAAM,CAAC,QAAoB,EAAE,SAAqB,EAAA;QACvD,MAAM,QAAQ,GAAG,SAAS,CAAC,MAAM,CAC/B,CAAC,MAAM,EAAE,QAAQ,KAAK,MAAM,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC,SAAS,CAAC,EAC1D,EAAW,CACZ,CAAA;QACD,OAAO,IAAI,QAAQ,CAAC,EAAC,SAAS,EAAE,QAAQ,EAAC,CAAC,CAAA;KAC3C;AACF;;ACjOD;AAgBA;;;;;;;;;;;AAWG;MACU,QAAQ,CAAA;AACnB;;AAEG;IACH,QAAQ,GAAe,EAAE,CAAA;AAEzB;;;AAGG;IACH,SAAS,GAAe,EAAE,CAAA;AAE1B;;AAEG;IACH,OAAO,GAAe,EAAE,CAAA;AAExB;;AAEG;AACH,IAAA,IAAI,CAAY;AAEhB;;;;;AAKG;AACH,IAAA,IAAI,CAAY;AAEhB;;;;;AAKG;AACH,IAAA,QAAQ,CAA0F;AAElG;;AAEG;AACH,IAAA,UAAU,CAA6E;AAEvF;;AAEG;AACH,IAAA,oBAAoB,CAAkC;AAEtD;;AAEG;AACH,IAAA,gBAAgB,CAA0B;AAE1C;;;;AAIG;IACH,cAAc,GAAgB,IAAI,CAAA;AAElC;;;;;;AAMG;IACH,YAAY,GAAgB,IAAI,CAAA;AAEhC,IAAA,WAAA,CAAY,GAAe,EAAA;AACzB,QAAA,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;AACf,QAAA,IAAI,CAAC,IAAI,GAAG,GAAG,CAAA;AACf,QAAA,IAAI,CAAC,IAAI,GAAG,GAAG,CAAA;KAChB;;AAGD,IAAA,KAAK,CAAC,GAAe,EAAA;AACnB,QAAA,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAA;AAClB,QAAA,IAAI,CAAC,SAAS,GAAG,EAAE,CAAA;AACnB,QAAA,IAAI,CAAC,OAAO,GAAG,EAAE,CAAA;AACjB,QAAA,IAAI,CAAC,cAAc,GAAG,IAAI,CAAA;AAC1B,QAAA,IAAI,CAAC,IAAI,GAAG,GAAG,CAAA;AACf,QAAA,IAAI,CAAC,IAAI,GAAG,GAAG,CAAA;QACf,IAAI,CAAC,gBAAgB,EAAE,CAAA;QACvB,IAAI,CAAC,qBAAqB,EAAE,CAAA;KAC7B;;AAGD,IAAA,MAAM,CAAC,QAAkB,EAAA;AACvB,QAAA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;QAC5B,IAAI,CAAC,gBAAgB,EAAE,CAAA;QACvB,IAAI,CAAC,qBAAqB,EAAE,CAAA;KAC7B;;;;IAKD,KAAK,CAAC,QAAkB,EAAE,MAAgB,EAAA;AACxC,QAAA,IAAI,CAAC,QAAQ,CAAC,aAAa,EAAE;AAC3B,YAAA,MAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC,CAAA;AACtE,SAAA;AACD,QAAA,IAAI,CAAC,YAAY,GAAG,IAAI,IAAI,EAAE,CAAA;AAE9B,QAAA,KAAK,CAAC,yCAAyC,EAAE,QAAQ,CAAC,aAAa,CAAC,CAAA;AACxE,QAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;QAC3B,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;AAErC,QAAA,IAAI,IAAI,CAAC,UAAU,IAAI,CAAC,MAAM,EAAE;YAC9B,IAAI,CAAC,UAAU,CAAC;gBACd,QAAQ;gBACR,QAAQ,EAAE,IAAI,CAAC,IAAI;AACnB,gBAAA,MAAM,EAAE,KAAK;AACd,aAAA,CAAC,CAAA;AACH,SAAA;AAED,QAAA,MAAM,KAAK,GAAG,QAAQ,CAAC,aAAa,CAAA;QAEpC,IAAI,CAAC,qBAAqB,EAAE,CAAA;QAE5B,OAAO;YACL,OAAO,EAAE,MAAK;AACZ,gBAAA,IAAI,CAAC,4BAA4B,CAAC,KAAK,CAAC,CAAA;gBACxC,IAAI,CAAC,qBAAqB,EAAE,CAAA;aAC7B;YACD,OAAO,EAAE,MAAK;AACZ,gBAAA,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,CAAA;gBACzB,IAAI,CAAC,qBAAqB,EAAE,CAAA;aAC7B;SACF,CAAA;KACF;;;IAID,YAAY,GAAA;AACV,QAAA,OAAO,CAAC,IAAI,CAAC,cAAc,CAAA;KAC5B;;;;IAMD,gBAAgB,GAAA;QACd,IAAI,UAAU,GAAG,KAAK,CAAA;AACtB,QAAA,IAAI,OAA6B,CAAA;QACjC,MAAM,eAAe,GAAe,EAAE,CAAA;;QAGtC,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YACrC,MAAM,SAAS,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAA;YAChD,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,GAAG,CAAC,SAAS,IAAI,GAAG,CAAC,SAAS,GAAG,SAAS,CAAC,EAAE;gBAC3E,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAG,KAAK,GAAG,CAAC,SAAS,IAAI,GAAG,CAAC,SAAS,GAAG,SAAS,CAAC,CAAA;AAC1F,aAAA;AACF,SAAA;;QAGD,IAAI,OAAO,GAAG,CAAC,CAAA;QACf,GAAG;;YAED,IAAI,IAAI,CAAC,IAAI,EAAE;AACb,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAA;AACtB,gBAAA,OAAO,GAAG,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,GAAG,CAAC,WAAW,KAAK,IAAI,CAAC,IAAI,CAAC,GAAG,SAAS,CAAA;AAC7F,aAAA;AAAM,iBAAA;;;AAGL,gBAAA,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,GAAG,CAAC,wBAAwB,EAAE,CAAC,CAAA;AACtE,aAAA;AAED,YAAA,IAAI,OAAO,EAAE;gBACX,MAAM,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAA;AAC3C,gBAAA,UAAU,GAAG,UAAU,IAAI,OAAO,CAAA;AAClC,gBAAA,IAAI,UAAU,EAAE;AACd,oBAAA,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;AAC9B,iBAAA;AAED,gBAAA,IAAI,OAAO,EAAE,GAAG,EAAE,EAAE;AAClB,oBAAA,MAAM,IAAI,KAAK,CACb,CAAA,gEAAA,EAAmE,IAAI,CAAC,SAAS,CAC/E,OAAO,CACR,CAAE,CAAA,CACJ,CAAA;AACF,iBAAA;AACF,aAAA;AACF,SAAA,QAAQ,OAAO,EAAC;QAEjB,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,IAAI,KAAK,CAAC,OAAO,EAAE;YAC7C,KAAK,CACH,8BAA8B,EAC9B,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,GAAG,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CACzD,CAAA;AACF,SAAA;AAED,QAAA,IAAI,UAAU,EAAE;AACd,YAAA,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,CAAA;AAC7B,SAAA;KACF;;IAGD,qBAAqB,GAAA;AACnB,QAAA,MAAM,aAAa,GAAG,IAAI,CAAC,YAAY,EAAE,CAAA;QACzC,MAAM,YAAY,GAChB,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,CAAA;;AAExF,QAAA,IAAI,YAAY,EAAE;AAChB,YAAA,IAAI,CAAC,cAAc,GAAG,IAAI,CAAA;AAC3B,SAAA;AAAM,aAAA,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;AAC/B,YAAA,IAAI,CAAC,cAAc,GAAG,IAAI,IAAI,EAAE,CAAA;AACjC,SAAA;;AAED,QAAA,IAAI,aAAa,IAAI,YAAY,IAAI,IAAI,CAAC,oBAAoB,EAAE;AAC9D,YAAA,IAAI,YAAY,EAAE;gBAChB,KAAK,CAAC,mCAAmC,CAAC,CAAA;AAC3C,aAAA;AAAM,iBAAA;gBACL,KAAK,CAAC,iCAAiC,CAAC,CAAA;AACzC,aAAA;AACD,YAAA,IAAI,CAAC,oBAAoB,CAAC,YAAY,CAAC,CAAA;AACxC,SAAA;KACF;;AAGD,IAAA,aAAa,CAAC,GAAyB,EAAA;QACrC,IAAI,CAAC,GAAG,EAAE;AACR,YAAA,OAAO,KAAK,CAAA;AACb,SAAA;AAED,QAAA,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE;AACtB,YAAA,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC,CAAA;AACvE,SAAA;QAED,KAAK,CACH,sCAAsC,EACtC,GAAG,CAAC,WAAW,EACf,GAAG,CAAC,SAAS,EACb,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAC5B,CAAA;QAED,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;QAEhC,IAAI,IAAI,CAAC,gBAAgB,EAAE;AACzB,YAAA,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAA;AAC3B,SAAA;;QAGD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,aAAa,KAAK,GAAG,CAAC,aAAa,CAAC,CAAA;AAElF,QAAA,IAAI,IAAI,CAAC,sBAAsB,EAAE,EAAE;YACjC,MAAM,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,aAAa,CAAC,CAAA;YAC5D,IAAI,KAAK,CAAC,OAAO,EAAE;AACjB,gBAAA,KAAK,CACH,CAAqB,kBAAA,EAAA,GAAG,CAAC,aAAa,CAAA,+DAAA,CAAiE,CACxG,CAAA;gBACD,KAAK,CAAC,CAAqB,kBAAA,EAAA,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAE,CAAA,CAAC,CAAA;gBACnF,KAAK,CAAC,CAAmB,gBAAA,EAAA,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAE,CAAA,CAAC,CAAA;AAC/E,gBAAA,KAAK,CAAC,CAAA,iBAAA,CAAmB,EAAE,UAAU,CAAC,CAAA;AACvC,aAAA;AACD,YAAA,OAAO,UAAU,CAAA;AAClB,SAAA;AACD,QAAA,KAAK,CACH,CAAyE,uEAAA,CAAA,EACzE,GAAG,CAAC,aAAa,CAClB,CAAA;AACD,QAAA,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAA;QACrB,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,IAAI,CAAC,UAAU,CAAC;AACd,gBAAA,QAAQ,EAAE,GAAG;gBACb,QAAQ,EAAE,IAAI,CAAC,IAAI;AACnB,gBAAA,MAAM,EAAE,IAAI;AACb,aAAA,CAAC,CAAA;AACH,SAAA;AACD,QAAA,OAAO,KAAK,CAAA;KACb;AAED;;;;;AAKG;IACH,sBAAsB,GAAA;AACpB,QAAA,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAA;KAC5D;AAED;;;;;;;;;AASG;AACH,IAAA,iBAAiB,CAAC,KAAa,EAAA;;;AAG7B,QAAA,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;AAC5D,YAAA,OAAO,KAAK,CAAA;AACb,SAAA;;AAGD,QAAA,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;YAC/B,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,aAAa,KAAK,KAAK,EAAE;AAC7C,gBAAA,KAAK,CACH,CAAA,wFAAA,CAA0F,EAC1F,KAAK,CACN,CAAA;AACD,gBAAA,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAA;AACtB,gBAAA,OAAO,KAAK,CAAA;AACb,aAAA;AACF,SAAA;AAAM,aAAA,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,aAAa,KAAK,KAAK,EAAE;;AAE7E,YAAA,KAAK,CACH,CAAA,oFAAA,CAAsF,EACtF,KAAK,CACN,CAAA;AACD,YAAA,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAA;AACpB,YAAA,OAAO,KAAK,CAAA;AACb,SAAA;AAED,QAAA,KAAK,CACH,mFAAmF,EACnF,IAAI,CAAC,OAAO,CAAC,MAAM,EACnB,IAAI,CAAC,SAAS,CAAC,MAAM,CACtB,CAAA;;;QAID,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,GAAG,KAAK,GAAG,CAAC,aAAa,KAAK,KAAK,CAAC,CAAA;QAC5E,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,GAAG,KAAK,GAAG,CAAC,aAAa,KAAK,KAAK,CAAC,CAAA;AACxE,QAAA,KAAK,CAAC,CAAA,2CAAA,CAA6C,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAA;;;AAIhG,QAAA,OAAO,IAAI,CAAA;KACZ;AAED,IAAA,4BAA4B,CAAC,YAAoB,EAAA;AAC/C,QAAA,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;;YAE7B,OAAM;AACP,SAAA;QAED,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAA;AAC7B,QAAA,IAAI,KAAK,CAAC,aAAa,KAAK,YAAY,EAAE;;AAExC,YAAA,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAA;AACpB,YAAA,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;YAC1B,OAAM;AACP,SAAA;;AAGD,QAAA,IAAI,aAAmC,CAAA;QACvC,MAAM,YAAY,GAAe,EAAE,CAAA;QACnC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,QAAQ,KAAI;AAChC,YAAA,IAAI,QAAQ,CAAC,aAAa,KAAK,YAAY,EAAE;gBAC3C,aAAa,GAAG,QAAQ,CAAA;gBACxB,OAAM;AACP,aAAA;AAED,YAAA,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;AAC7B,SAAC,CAAC,CAAA;;AAGF,QAAA,IAAI,aAAa,EAAE;AACjB,YAAA,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,aAAa,CAAC,CAAA;AACnC,SAAA;AAED,QAAA,IAAI,CAAC,OAAO,GAAG,YAAY,CAAA;;AAG3B,QAAA,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAA;KAChB;AAED,IAAA,aAAa,CAAC,YAAoB,EAAA;QAChC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,QAAQ,KAAK,QAAQ,CAAC,aAAa,KAAK,YAAY,CAAC,CAAA;;AAGzF,QAAA,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAA;KAChB;AAED,IAAA,MAAM,CAAC,iBAA6B,EAAA;AAClC,QAAA,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAA;QACzB,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAA;;QAG7E,IAAI,OAAO,KAAK,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE;YAC1C,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAA;AAC9B,SAAA;QAED,MAAM,OAAO,GAAG,CAACC,cAAO,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAA;AAC5C,QAAA,IAAI,OAAO,IAAI,IAAI,CAAC,QAAQ,EAAE;AAC5B,YAAA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,iBAAiB,EAAE,IAAI,CAAC,OAAO,CAAC,CAAA;AAC1D,SAAA;KACF;AACF;;AC9ZD;;;;;;AAMG;MACU,eAAe,CAAA;AAC1B;;AAEG;AACH,IAAA,KAAK,CAAY;AAEjB;;;AAGG;AACH,IAAA,QAAQ,CAAY;AAEpB;;;;;AAKG;AACH,IAAA,aAAa,CAAiC;AAE9C;;;AAGG;AACH,IAAA,eAAe,CAAS;AAExB;;AAEG;IACH,GAAG,GAAU,EAAE,CAAA;AAEf;;AAEG;AACH,IAAA,MAAM,CAAO;AAEb;;;AAGG;IACK,GAAG,CAAiC;AAE5C,IAAA,WAAA,CAAY,GAAe,EAAA;AACzB,QAAA,IAAI,GAAG,EAAE;AACP,YAAA,KAAK,CAAC,iCAAiC,EAAE,GAAG,CAAC,IAAI,CAAC,CAAA;AACnD,SAAA;AAAM,aAAA;YACL,KAAK,CAAC,uDAAuD,CAAC,CAAA;AAC/D,SAAA;AAED,QAAA,IAAI,CAAC,MAAM,GAAG,EAAE,CAAA;AAChB,QAAA,IAAI,CAAC,aAAa,GAAG,EAAE,CAAA;AACvB,QAAA,IAAI,CAAC,eAAe,GAAG,KAAK,CAAA;AAE5B,QAAA,IAAI,CAAC,KAAK,GAAG,GAAG,CAAA;AAChB,QAAA,IAAI,CAAC,QAAQ,GAAG,GAAG,CAAA;;QAGnB,IAAI,CAAC,GAAG,GAAG,IAAIC,cAAc,CAAC,gBAAgB,EAAE,CAAA;KACjD;AAED,IAAA,GAAG,CAAC,GAAa,EAAA;AACf,QAAA,GAAG,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,EAAE,KAAK,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC,CAAA;KACrD;IAED,UAAU,GAAA;QACR,OAAO,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,MAAM,GAAG,CAAC,CAAA;KACzE;AAED;;;;;;;AAOG;AACH,IAAA,KAAK,CAAC,KAAc,EAAA;QAClB,IAAI,CAAC,qBAAqB,EAAE,CAAA;QAC5B,IAAI,MAAM,GAAG,IAAI,CAAA;AACjB,QAAA,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE;YACvB,KAAK,CAAC,wBAAwB,CAAC,CAAA;YAC/B,MAAM,GAAG,IAAI,QAAQ,CAAC;gBACpB,SAAS,EAAE,IAAI,CAAC,GAAG;AACnB,gBAAA,SAAS,EAAE,KAAK;AAChB,gBAAA,aAAa,EAAE,KAAK;AACrB,aAAA,CAAC,CAAA;AACH,SAAA;AACD,QAAA,IAAI,CAAC,GAAG,GAAG,EAAE,CAAA;AACb,QAAA,IAAI,CAAC,eAAe,GAAG,KAAK,CAAA;AAC5B,QAAA,OAAO,MAAM,CAAA;KACd;AAED,IAAA,YAAY,CAAC,EAAO,EAAA;;QAElB,IACE,EAAE,CAAC,KAAK;YACR,EAAE,CAAC,KAAK,CAAC,GAAG;YACZ,IAAI,IAAI,EAAE,CAAC,KAAK;YAChB,EAAE,CAAC,KAAK,CAAC,EAAE,KAAK,IAAI,CAAC,QAAQ,EAAE,GAAG;AAClC,YAAA,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,MAAM,KAAK,CAAC;AAClC,UAAA;AACA,YAAA,MAAM,QAAQ,GAAG,EAAE,CAAC,KAAK,CAAC,GAAG,CAAA;YAC7B,MAAM,aAAa,GAA4B,EAAE,CAAA;;YAEjD,KAAK,MAAM,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;AACxC,gBAAA,IAAI,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE;AACjC,oBAAA,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC,EAAE;;wBAEpD,aAAa,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAA;AACrC,qBAAA;AACF,iBAAA;AACF,aAAA;;;YAID,IAAI,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;gBACzC,KAAK,CAAC,mEAAmE,CAAC,CAAA;gBAC1E,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,EAAC,EAAE,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,EAAE,aAAa,EAAC,EAAC,CAAC,CAAA;gBACtE,IAAI,CAAC,qBAAqB,EAAE,CAAA;AAC7B,aAAA;YAED,OAAM;AACP,SAAA;;AAGD,QAAA,IAAI,EAAE,CAAC,iBAAiB,IAAI,IAAI,CAAC,QAAQ,IAAI,EAAE,CAAC,iBAAiB,CAAC,GAAG,KAAK,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE;AAC3F,YAAA,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;;AAEzB,gBAAA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;AACpB,gBAAA,IAAI,CAAC,eAAe,GAAG,IAAI,CAAA;gBAC3B,IAAI,CAAC,qBAAqB,EAAE,CAAA;AAC7B,aAAA;;YAGD,OAAM;AACP,SAAA;QAED,KAAK,CAAC,8DAA8D,CAAC,CAAA;;;AAGrE,QAAA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;QACpB,IAAI,CAAC,qBAAqB,EAAE,CAAA;KAC7B;AAED;;;;;;;AAOG;IACH,oBAAoB,CAAC,IAAY,EAAE,SAAkB,EAAA;;;AAGnD,QAAA,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;;AAEjC,YAAA,OAAO,KAAK,CAAA;AACb,SAAA;;;QAID,MAAM,OAAO,GAAG,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAA;;AAEpD,QAAA,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;;AAExB,YAAA,OAAO,KAAK,CAAA;AACb,SAAA;;AAGD,QAAA,MAAM,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,CAAA;;;AAGxB,QAAA,IAAI,OAAO,KAAK,CAAC,KAAK,KAAK,QAAQ,EAAE;;AAEnC,YAAA,OAAO,KAAK,CAAA;AACb,SAAA;AAED,QAAA,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;;AAElB,YAAA,OAAO,KAAK,CAAA;AACb,SAAA;;;QAID,IAAI,EAAE,GAAe,IAAI,CAAA;AACzB,QAAA,IAAI,KAAK,CAAC,KAAK,KAAK,SAAS,EAAE;;;YAG7B,EAAE,GAAG,IAAI,CAAA;AACV,SAAA;aAAM,IAAI,OAAO,KAAK,CAAC,KAAK,KAAK,QAAQ,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;;;YAG3E,IAAI;AACF,gBAAA,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG;AACnB,qBAAA,UAAU,CAAC,KAAK,CAAC,KAAK,EAAE,SAAS,CAAC;qBAClC,GAAG,CAAC,CAAC,QAAQ,KAAK,QAAQ,CAAC,QAAQ,EAAE,CAAC;qBACtC,IAAI,CAAC,EAAE,CAAC,CAAA;gBACX,EAAE,GAAG,EAAC,KAAK,EAAE,EAAC,EAAE,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,cAAc,EAAE,EAAC,CAAC,IAAI,GAAG,KAAK,EAAC,EAAC,EAAC,CAAA;AACvE,aAAA;YAAC,MAAM;;AAEN,gBAAA,OAAO,KAAK,CAAA;AACb,aAAA;AACF,SAAA;AAAM,aAAA;;;YAGL,EAAE,GAAG,EAAC,KAAK,EAAE,EAAC,EAAE,EAAE,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,EAAE,EAAC,CAAC,IAAI,GAAG,SAAS,EAAC,EAAC,EAAC,CAAA;AAChE,SAAA;;;QAID,MAAM,aAAa,GAAG,oBAAoB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA;;AAGtD,QAAA,IAAI,EAAE,EAAE;AACN,YAAA,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,GAAG,EAAE,CAAA;AACvC,SAAA;AAAM,aAAA;AACL,YAAA,OAAO,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,CAAA;AACzC,SAAA;;AAGD,QAAA,OAAO,IAAI,CAAA;KACZ;IAED,qBAAqB,GAAA;;QAEnB,MAAM,OAAO,GAAU,EAAE,CAAA;;AAGzB,QAAA,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,KAAI;YAC9C,MAAM,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAA;AAClC,YAAA,IAAI,EAAE,EAAE;AACN,gBAAA,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;AACjB,aAAA;AACH,SAAC,CAAC,CAAA;QAEF,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAA;AAC5B,QAAA,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;AACtB,YAAA,IAAI,CAAC,QAAQ,GAAG,IAAI,QAAQ,CAAC,EAAC,SAAS,EAAE,OAAO,EAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAQ,CAAA;AAC9E,YAAA,IAAI,CAAC,MAAM,GAAG,EAAE,CAAA;AAChB,YAAA,IAAI,CAAC,aAAa,GAAG,EAAE,CAAA;AACxB,SAAA;QAED,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,CAAA;KAC1B;AAED;;;;;AAKG;AACH,IAAA,MAAM,CAAC,QAAoB,EAAA;QACzB,IAAI,CAAC,qBAAqB,EAAE,CAAA;QAE5B,IAAI,QAAQ,KAAK,IAAI,EAAE;;AAErB,YAAA,IAAI,CAAC,GAAG,GAAG,EAAE,CAAA;AACb,YAAA,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAA;AACrB,YAAA,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAA;AACxB,YAAA,IAAI,CAAC,eAAe,GAAG,KAAK,CAAA;AAC7B,SAAA;AAAM,aAAA;AACL,YAAA,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAA;;;YAIrB,IAAI,IAAI,CAAC,GAAG,EAAE;gBACZ,IAAI,CAAC,QAAQ,GAAG,IAAI,QAAQ,CAAC,EAAC,SAAS,EAAE,IAAI,CAAC,GAAG,EAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAQ,CAAA;AAC7E,aAAA;AAAM,iBAAA;AACL,gBAAA,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAA;AAC3B,aAAA;AACF,SAAA;QAED,OAAO,IAAI,CAAC,QAAQ,CAAA;KACrB;AACF;;AC1RD,MAAM,UAAU,GAAG,IAAI,GAAG,EAAE,CAAA;AAY5B;;;AAGG;AACH,MAAM,MAAM,CAAA;AACV,IAAA,SAAS,CAAY;AACrB,IAAA,KAAK,CAAQ;AACb,IAAA,OAAO,CAAY;AACnB,IAAA,MAAM,CAAwB;AAE9B,IAAA,WAAA,CACE,SAAqB,EACrB,EAAC,OAAO,EAAE,MAAM,EAAwD,EAAA;AAExE,QAAA,IAAI,CAAC,SAAS,GAAG,SAAS,CAAA;AAC1B,QAAA,IAAI,CAAC,KAAK,GAAG,CAAC,CAAA;AACd,QAAA,IAAI,CAAC,OAAO,GAAG,OAAO,CAAA;AACtB,QAAA,IAAI,CAAC,MAAM,GAAG,MAAM,CAAA;KACrB;AAED,IAAA,KAAK,CAAC,GAAe,EAAA;QACnB,OAAO,QAAQ,CAAC,QAAQ,CAAC,GAAG,EAAE,IAAI,CAAC,SAAS,CAAC,CAAA;KAC9C;AAED,IAAA,MAAM,CAAC,GAAe,EAAA;AACpB,QAAA,MAAM,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,SAAS,CAAC,CAAA;QACnD,MAAM,CAAC,yBAAyB,EAAE,CAAA;AAClC,QAAA,OAAO,MAAM,CAAA;KACd;AACF,CAAA;AAED,MAAM,YAAY,GAAG,CAAC,GAAU,EAAE,GAAa,KAAY,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,CAAA;AAEpF;;AAEG;MACU,gBAAgB,CAAA;AACnB,IAAA,SAAS,CAAY;AAE7B;;AAEG;AACH,IAAA,QAAQ,CAAU;AAElB;;AAEG;AACH,IAAA,KAAK,CAAY;AAEjB;;AAEG;AACK,IAAA,OAAO,CAAU;AAEzB;;AAEG;AACH,IAAA,MAAM,CAAiB;AAEvB;;AAEG;AACH,IAAA,UAAU,CAAiF;AAE3F;;AAEG;AACH,IAAA,gBAAgB,CAA+B;AAE/C;;AAEG;AACH,IAAA,QAAQ,CAAgF;AAExF;;AAEG;AACH,IAAA,QAAQ,CAA4B;AAEpC;;AAEG;AACH,IAAA,oBAAoB,CAAkC;AAEtD;;AAEG;AACH,IAAA,aAAa,CAAsC;AAEnD;;AAEG;IACH,gBAAgB,GAAG,KAAK,CAAA;AAExB,IAAA,WAAA,CAAY,GAAe,EAAA;QACzB,IAAI,CAAC,MAAM,GAAG,IAAI,eAAe,CAAC,GAAG,CAAC,CAAA;QACtC,IAAI,CAAC,QAAQ,GAAG,IAAI,QAAQ,CAAC,GAAG,CAAC,CAAA;AACjC,QAAA,IAAI,CAAC,QAAQ,CAAC,UAAU,GAAG,CAAC,GAAG,KAAK,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAA;QAC/D,IAAI,CAAC,QAAQ,CAAC,gBAAgB,GAAG,CAAC,GAAG,KAAK,IAAI,CAAC,gBAAgB,IAAI,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAA;QAC7F,IAAI,CAAC,QAAQ,CAAC,QAAQ,GAAG,CAAC,IAAI,EAAE,eAAe,EAAE,cAAc,KAC7D,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,eAAe,EAAE,cAAc,CAAC,CAAA;AAC7D,QAAA,IAAI,CAAC,QAAQ,CAAC,oBAAoB,GAAG,CAAC,GAAG,KAAK,IAAI,CAAC,2BAA2B,CAAC,GAAG,CAAC,CAAA;AACnF,QAAA,IAAI,CAAC,KAAK,GAAG,GAAG,CAAA;AAChB,QAAA,IAAI,CAAC,SAAS,GAAG,EAAE,CAAA;AACnB,QAAA,IAAI,CAAC,OAAO,GAAG,EAAE,CAAA;KAClB;;;AAID,IAAA,KAAK,CAAC,GAAe,EAAA;AACnB,QAAA,IAAI,GAAG,EAAE;AACP,YAAA,KAAK,CAAC,qCAAqC,EAAE,GAAG,CAAC,IAAI,CAAC,CAAA;AACvD,SAAA;AAAM,aAAA;YACL,KAAK,CAAC,uCAAuC,CAAC,CAAA;AAC/C,SAAA;AACD,QAAA,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;AACxB,QAAA,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE,EAAE,CAAC,CAAA;QACnB,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,CAAC,CAAA;KAC/D;;AAGD,IAAA,GAAG,CAAC,QAAkB,EAAA;QACpB,IAAI,IAAI,CAAC,oBAAoB,EAAE;AAC7B,YAAA,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAA;AACjC,SAAA;QACD,KAAK,CAAC,uBAAuB,CAAC,CAAA;AAC9B,QAAA,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;AACzB,QAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAA;QAC3B,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;QACvC,IAAI,IAAI,CAAC,UAAU,IAAI,QAAQ,KAAK,IAAI,CAAC,KAAK,EAAE;YAC9C,KAAK,CAAC,kBAAkB,CAAC,CAAA;YACzB,IAAI,CAAC,UAAU,CAAC;gBACd,QAAQ;gBACR,QAAQ,EAAE,IAAI,CAAC,KAAK;AACpB,gBAAA,MAAM,EAAE,KAAK;AACd,aAAA,CAAC,CAAA;YACF,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,IAAI,IAAI,CAAC,QAAQ,EAAE;AACxC,gBAAA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;AAC1B,aAAA;AACF,SAAA;KACF;;AAGD,IAAA,MAAM,CAAC,QAAkB,EAAA;QACvB,KAAK,CAAC,kCAAkC,EAAE,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,SAAS,CAAC,CAAA;AACnF,QAAA,IAAI,QAAQ,CAAC,WAAW,KAAK,QAAQ,CAAC,SAAS,EAAE;AAC/C,YAAA,MAAM,IAAI,KAAK,CACb,CAAA,SAAA,EAAY,QAAQ,CAAC,aAAa,CAAA,gCAAA,EAAmC,QAAQ,CAAC,WAAW,CAAA,CAAA,CAAG,CAC7F,CAAA;AACF,SAAA;QACD,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;KACtC;;IAGD,MAAM,GAAA;QACJ,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,KAAI;;AAErC,YAAA,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,EAAE;AAC7B,gBAAA,OAAO,EAAE,CAAA;gBACT,OAAM;AACP,aAAA;YACD,KAAK,CAAC,0BAA0B,CAAC,CAAA;;YAEjC,MAAM,gBAAgB,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAA;YAC5C,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,gBAAgB,GAAG,CAAC,gBAAgB,CAAC,GAAG,EAAE,EAAE,EAAC,OAAO,EAAE,MAAM,EAAC,CAAC,CAAC,CAAA;;YAE5F,IAAI,CAAC,MAAM,GAAG,IAAI,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;YAC7C,IAAI,CAAC,cAAc,EAAE,CAAA;AACvB,SAAC,CAAC,CAAA;KACH;;;;IAKD,cAAc,GAAA;AACZ,QAAA,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;AACvB,YAAA,MAAM,IAAI,KAAK,CAAC,uDAAuD,CAAC,CAAA;AACzE,SAAA;QACD,IAAI,IAAI,CAAC,gBAAgB,EAAE;;YAEzB,OAAM;AACP,SAAA;QACD,IAAI,CAAC,eAAe,EAAE,CAAA;KACvB;;IAGD,eAAe,GAAA;QACb,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAA;QACnC,IAAI,CAAC,MAAM,EAAE;AACX,YAAA,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAA;YAC7B,OAAM;AACP,SAAA;AAED,QAAA,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAA;QAC5B,MAAM,QAAQ,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;AAC1C,QAAA,MAAM,YAAY,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAA;AAExD,QAAA,MAAM,SAAS,GAAG;YAChB,OAAO,EAAE,MAAK;gBACZ,KAAK,CAAC,kBAAkB,CAAC,CAAA;gBACzB,YAAY,CAAC,OAAO,EAAE,CAAA;gBACtB,MAAM,CAAC,OAAO,EAAE,CAAA;;gBAEhB,IAAI,CAAC,eAAe,EAAE,CAAA;aACvB;YAED,OAAO,EAAE,MAAK;gBACZ,KAAK,CAAC,eAAe,CAAC,CAAA;;AAEtB,gBAAA,MAAM,CAAC,KAAK,IAAI,CAAC,CAAA;AACjB,gBAAA,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,EAAE;;;AAGvB,oBAAA,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAA;AAC7B,iBAAA;gBACD,YAAY,CAAC,OAAO,EAAE,CAAA;;AAGtB,gBAAA,IAAI,MAAM,CAAC,KAAK,GAAG,GAAG,EAAE;oBACtB,UAAU,CAAC,MAAM,IAAI,CAAC,eAAe,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,GAAG,IAAI,EAAE,UAAU,CAAC,CAAC,CAAA;AACpF,iBAAA;aACF;AAED,YAAA,MAAM,EAAE,CAAC,KAAY,KAAI;AACvB,gBAAA,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAA;;AAGlD,gBAAA,IAAI,CAAC,OAAO,GAAG,EAAE,CAAA;;;gBAIjB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAA;;gBAG9B,IAAI,CAAC,MAAM,GAAG,IAAI,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;;AAG7C,gBAAA,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAA;aAC9B;SACF,CAAA;QAED,KAAK,CAAC,gBAAgB,CAAC,CAAA;QACvB,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,IAAI,CAAC,aAAa,CAAC;AACjB,gBAAA,QAAQ,EAAE,QAAQ;gBAClB,OAAO,EAAE,SAAS,CAAC,OAAO;gBAC1B,OAAO,EAAE,SAAS,CAAC,OAAO;gBAC1B,MAAM,EAAE,SAAS,CAAC,MAAM;AACzB,aAAA,CAAC,CAAA;AACH,SAAA;KACF;AAED,IAAA,eAAe,CAAC,IAAgB,EAAE,eAA2B,EAAE,cAA0B,EAAA;AACvF,QAAA,IAAI,CAAC,MAAM,CAAC,eAAe,EAAE,cAAc,CAAC,CAAA;KAC7C;IAED,qBAAqB,GAAA;QACnB,KAAK,CAAC,kBAAkB,CAAC,CAAA;;;;QAIzB,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,IAAI,IAAI,CAAC,QAAQ,EAAE;AACxC,YAAA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;AAC1B,SAAA;AAED,QAAA,IAAI,CAAC,OAAO,GAAG,EAAE,CAAA;AACjB,QAAA,IAAI,CAAC,SAAS,GAAG,EAAE,CAAA;KACpB;AAED,IAAA,iBAAiB,CAAC,GAAgE,EAAA;;AAEhF,QAAA,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,EAAE;YAC1D,KAAK,CAAC,oDAAoD,CAAC,CAAA;YAC3D,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAA;YAC/B,IAAI,CAAC,MAAM,GAAG,IAAI,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;YAC7C,IAAI,IAAI,CAAC,UAAU,EAAE;AACnB,gBAAA,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAA;AACrB,aAAA;YACD,OAAM;AACP,SAAA;QAED,KAAK,CAAC,iDAAiD,CAAC,CAAA;;AAGxD,QAAA,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,KAAK,IAAI,EAAE;YAC/B,IAAI,CAAC,qBAAqB,EAAE,CAAA;AAC7B,SAAA;;QAGD,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAA;KAChC;IAED,MAAM,CAAC,eAA2B,EAAE,cAA0B,EAAA;QAC5D,KAAK,CAAC,mBAAmB,CAAC,CAAA;AAC1B,QAAA,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,KAAK,IAAI,EAAE;YAC/B,IAAI,CAAC,qBAAqB,EAAE,CAAA;AAC7B,SAAA;AAED,QAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAA;AAC3B,QAAA,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,MAAM,KAAK,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAA;AACxF,QAAA,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;;QAG3C,IAAI,QAAQ,KAAK,IAAI,IAAI,IAAI,CAAC,KAAK,KAAK,IAAI,EAAE;YAC5C,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAA;AAChC,SAAA;QAED,MAAM,OAAO,GAAG,CAACD,cAAO,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAA;AAC9C,QAAA,IAAI,OAAO,IAAI,IAAI,CAAC,QAAQ,EAAE;YAC5B,IAAI,CAAC,QAAQ,CACX,IAAI,CAAC,KAAK,EACV,eAAe,CAAC,MAAM,CAAC,YAAY,EAAE,EAAE,CAAC,EACxC,cAAc,CAAC,MAAM,CAAC,YAAY,EAAE,EAAE,CAAC,CACxC,CAAA;AACF,SAAA;KACF;AAED,IAAA,2BAA2B,CAAC,YAAqB,EAAA;AAC/C,QAAA,IAAI,CAAC,IAAI,CAAC,oBAAoB,EAAE;YAC9B,OAAM;AACP,SAAA;AAED,QAAA,MAAM,eAAe,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,CAAA;AAE3E,QAAA,IAAI,YAAY,IAAI,CAAC,eAAe,EAAE;AACpC,YAAA,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAA;AAChC,SAAA;QAED,IAAI,CAAC,YAAY,EAAE;AACjB,YAAA,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAA;AACjC,SAAA;KACF;AACF;;;;;;;"}