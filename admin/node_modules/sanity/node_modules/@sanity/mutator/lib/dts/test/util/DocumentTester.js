import { Document, Mutation } from '../../src/document';
import { extract } from '../../src/jsonpath';
export class DocumentTester {
    constructor(attrs) {
        this.onRebaseCalled = false;
        this.onMutationCalled = false;
        this.doc = new Document(attrs);
        this.onRebaseCalled = false;
        this.doc.onRebase = () => {
            this.onRebaseCalled = true;
        };
        this.doc.onMutation = () => {
            this.onMutationCalled = true;
        };
        this.staged = {};
        this.stagedResponders = {};
        this.context = 'initially';
    }
    reset() {
        this.onMutationCalled = false;
        this.onRebaseCalled = false;
    }
    stage(title) {
        this.context = title;
        return this;
    }
    remotePatch(fromRev, toRev, patch) {
        this.reset();
        const mut = new Mutation({
            transactionId: toRev,
            resultRev: toRev,
            previousRev: fromRev,
            mutations: [{ patch }],
        });
        this.doc.arrive(mut);
        return this;
    }
    localPatch(fromRev, toRev, patch) {
        this.reset();
        const mut = new Mutation({
            transactionId: toRev,
            resultRev: toRev,
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            _previousRev: fromRev,
            mutations: [{ patch }],
        });
        this.staged[toRev] = mut;
        this.stagedResponders[toRev] = this.doc.stage(mut);
        return this;
    }
    localSucceeded(txnId) {
        const responder = this.stagedResponders[txnId];
        if (!responder) {
            throw new Error(`Missing staged responder for transaction ID "${txnId}"`);
        }
        this.reset();
        responder.success();
        delete this.stagedResponders[txnId];
        return this;
    }
    localFailed(txnId) {
        const responder = this.stagedResponders[txnId];
        if (!responder) {
            throw new Error(`Missing staged responder for transaction ID "${txnId}"`);
        }
        this.reset();
        responder.failure();
        delete this.stagedResponders[txnId];
        return this;
    }
    arrivedLocal(txnId) {
        this.reset();
        const submitted = this.staged[txnId];
        if (!submitted) {
            throw new Error(`Missing staged changes for transaction "${txnId}"`);
        }
        // The _previousRev is a hack internal to this document tester
        const params = Object.assign({}, submitted.params);
        params.previousRev = '_previousRev' in params ? params._previousRev : undefined;
        const mut = new Mutation(params);
        this.doc.arrive(mut);
        return this;
    }
    assertEDGE(path, value) {
        expect(extract(path, this.doc.EDGE)[0]).toEqual(value);
        return this;
    }
    assertHEAD(path, value) {
        expect(extract(path, this.doc.HEAD)[0]).toEqual(value);
        return this;
    }
    assertBOTH(path, values) {
        this.assertHEAD(path, values);
        this.assertEDGE(path, values);
        return this;
    }
    didRebase() {
        expect(this.onRebaseCalled).toBe(true);
        return this;
    }
    didNotRebase() {
        expect(this.onRebaseCalled).toBe(false);
        return this;
    }
    onMutationFired() {
        expect(this.onMutationCalled).toBe(true);
        return this;
    }
    onMutationDidNotFire() {
        expect(this.onMutationCalled).toBe(false);
        return this;
    }
    isConsistent() {
        expect(this.doc.isConsistent()).toBe(true);
        expect(this.doc.EDGE).toEqual(this.doc.HEAD);
        return this;
    }
    isInconsistent() {
        expect(this.doc.isConsistent()).toBe(false);
        expect(this.doc.EDGE).not.toEqual(this.doc.HEAD);
        return this;
    }
    hasUnresolvedLocalMutations() {
        expect(this.doc.hasUnresolvedMutations()).toBe(true);
        return this;
    }
    noUnresolvedLocalMutations() {
        expect(this.doc.hasUnresolvedMutations()).toBe(false);
        return this;
    }
}
//# sourceMappingURL=DocumentTester.js.map