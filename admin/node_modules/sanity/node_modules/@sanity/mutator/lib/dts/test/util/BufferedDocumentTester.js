// A test jig for the BufferedDocument model
import debugLogger from 'debug';
import { BufferedDocument, Mutation } from '../../src/document';
import { extract } from '../../src/jsonpath';
const debug = debugLogger('buffered-document-tester');
export class BufferedDocumentTester {
    constructor(attrs) {
        this.onMutationCalled = false;
        this.onRebaseCalled = false;
        this.onDeleteCalled = false;
        this.doc = new BufferedDocument(attrs);
        this.onRebaseCalled = false;
        this.doc.onRebase = () => {
            this.onRebaseCalled = true;
        };
        this.doc.onMutation = () => {
            this.onMutationCalled = true;
        };
        this.doc.onDelete = () => {
            this.onDeleteCalled = true;
        };
        this.doc.commitHandler = (opts) => {
            this.pendingCommit = opts;
        };
        this.pendingCommit = null;
        this.context = 'initially';
    }
    resetState() {
        this.onMutationCalled = false;
        this.onRebaseCalled = false;
        this.onDeleteCalled = false;
    }
    resetDocument(doc) {
        this.resetState();
        this.doc.reset(doc);
    }
    stage(title) {
        debug('Stage: %s', title);
        this.context = title;
        return this;
    }
    remotePatch(fromRev, toRev, patch) {
        this.resetState();
        const mut = new Mutation({
            transactionId: toRev,
            resultRev: toRev,
            previousRev: fromRev,
            mutations: [{ patch }],
        });
        this.doc.arrive(mut);
        return this;
    }
    remoteMutation(fromRev, toRev, operation) {
        this.resetState();
        const mut = new Mutation({
            transactionId: toRev,
            resultRev: toRev,
            previousRev: fromRev,
            mutations: [operation],
        });
        this.doc.arrive(mut);
        return this;
    }
    localPatch(patch) {
        this.resetState();
        const mut = new Mutation({
            mutations: [{ patch }],
        });
        this.doc.add(mut);
        return this;
    }
    localMutation(fromRev, toRev, operation) {
        this.resetState();
        const mut = new Mutation({
            transactionId: toRev,
            resultRev: toRev,
            previousRev: fromRev,
            mutations: [operation],
        });
        debug('Local mutation: %O', mut);
        this.doc.add(mut);
        return this;
    }
    commit() {
        this.resetState();
        this.doc.commit();
        return this;
    }
    commitSucceeds() {
        if (!this.pendingCommit) {
            throw new Error('`pendingCommit` not set');
        }
        this.resetState();
        this.pendingCommit.success();
        // Magically this commit is based on the current HEAD revision
        if (this.doc.document.HEAD) {
            this.pendingCommit.mutation.params.previousRev = this.doc.document.HEAD._rev;
        }
        this.doc.arrive(this.pendingCommit.mutation);
        this.pendingCommit = null;
        return this;
    }
    commitSucceedsButMutationArriveDuringCommitProcess() {
        if (!this.pendingCommit) {
            throw new Error('`pendingCommit` not set');
        }
        this.resetState();
        // Magically this commit is based on the current HEAD revision
        if (this.doc.document.HEAD) {
            this.pendingCommit.mutation.params.previousRev = this.doc.document.HEAD._rev;
        }
        this.doc.arrive(this.pendingCommit.mutation);
        this.pendingCommit.success();
        this.pendingCommit = null;
        return this;
    }
    commitFails() {
        if (!this.pendingCommit) {
            throw new Error('`pendingCommit` not set');
        }
        this.resetState();
        this.pendingCommit.failure();
        this.pendingCommit = null;
        return this;
    }
    assertLOCAL(path, value) {
        expect(extract(path, this.doc.LOCAL)[0]).toEqual(value);
        return this;
    }
    assertEDGE(path, value) {
        expect(extract(path, this.doc.document.EDGE)[0]).toEqual(value);
        return this;
    }
    assertHEAD(path, value) {
        expect(extract(path, this.doc.document.HEAD)[0]).toEqual(value);
        return this;
    }
    assertALL(path, values) {
        this.assertHEAD(path, values);
        this.assertEDGE(path, values);
        this.assertLOCAL(path, values);
        return this;
    }
    assertLOCALDeleted() {
        expect(this.doc.LOCAL === null).toBe(true);
        return this;
    }
    assertEDGEDeleted() {
        expect(this.doc.document.EDGE === null).toBe(true);
        return this;
    }
    assertHEADDeleted() {
        expect(this.doc.document.HEAD === null).toBe(true);
        return this;
    }
    assertALLDeleted() {
        this.assertLOCALDeleted();
        this.assertEDGEDeleted();
        this.assertHEADDeleted();
        return this;
    }
    assert(cb) {
        cb(this.doc);
        return this;
    }
    didRebase() {
        expect(this.onRebaseCalled).toBe(true);
        return this;
    }
    didNotRebase() {
        expect(this.onRebaseCalled).toBe(false);
        return this;
    }
    onMutationFired() {
        expect(this.onMutationCalled).toBe(true);
        return this;
    }
    onMutationDidNotFire() {
        expect(this.onMutationCalled).toBe(false);
        return this;
    }
    onDeleteDidFire() {
        expect(this.onDeleteCalled).toBe(true);
        return this;
    }
    onDeleteDidNotFire() {
        expect(this.onDeleteCalled).toBe(false);
        return this;
    }
    isConsistent() {
        expect(this.doc.document.isConsistent()).toBe(true);
        expect(this.doc.document.EDGE).toEqual(this.doc.document.HEAD);
        return this;
    }
    isInconsistent() {
        expect(this.doc.document.isConsistent()).toBe(false);
        expect(this.doc.document.EDGE).not.toEqual(this.doc.document.HEAD);
        return this;
    }
    hasUnresolvedLocalMutations() {
        expect(this.doc.document.hasUnresolvedMutations()).toBe(true);
        return this;
    }
    noUnresolvedLocalMutations() {
        expect(this.doc.document.hasUnresolvedMutations()).toBe(false);
        return this;
    }
    hasLocalEdits() {
        expect(this.doc.buffer.hasChanges()).toBe(true);
        return this;
    }
    hasNoLocalEdits() {
        expect(this.doc.buffer.hasChanges()).toBe(false);
        return this;
    }
    hasPendingCommit() {
        expect(this.doc.committerRunning).toBe(true);
        return this;
    }
    hasNoPendingCommit() {
        expect(this.doc.committerRunning).toBe(false);
        return this;
    }
}
//# sourceMappingURL=BufferedDocumentTester.js.map