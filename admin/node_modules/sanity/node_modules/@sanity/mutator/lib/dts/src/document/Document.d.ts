import { Mutation } from './Mutation';
import type { Doc } from './types';
/**
 * @internal
 */
export interface SubmissionResponder {
    success: () => void;
    failure: () => void;
}
/**
 * Models a document as it is changed by our own local patches and remote patches coming in from
 * the server. Consolidates incoming patches with our own submitted patches and maintains two
 * versions of the document. EDGE is the optimistic document that the user sees that will always
 * immediately reflect whatever she is doing to it, and HEAD which is the confirmed version of the
 * document consistent with the mutations we have received from the server. As long as nothing out of
 * the ordinary happens, we can track all changes by hooking into the onMutation callback, but we
 * must also respect onRebase events that fire when we have to backtrack because one of our optimistically
 * applied patches were rejected, or some bastard was able to slip a mutation in between ours own.
 *
 * @internal
 */
export declare class Document {
    /**
     * Incoming patches from the server waiting to be applied to HEAD
     */
    incoming: Mutation[];
    /**
     * Patches we know has been subitted to the server, but has not been seen yet in the return channel
     * so we can't be sure about the ordering yet (someone else might have slipped something between them)
     */
    submitted: Mutation[];
    /**
     * Pending mutations
     */
    pending: Mutation[];
    /**
     * Our model of the document according to the incoming patches from the server
     */
    HEAD: Doc | null;
    /**
     * Our optimistic model of what the document will probably look like as soon as all our patches
     * have been processed. Updated every time we stage a new mutation, but also might revert back
     * to previous states if our mutations fail, or could change if unexpected mutations arrive
     * between our own. The `onRebase` callback will be called when EDGE changes in this manner.
     */
    EDGE: Doc | null;
    /**
     * Called with the EDGE document when that document changes for a reason other than us staging
     * a new patch or receiving a mutation from the server while our EDGE is in sync with HEAD:
     * I.e. when EDGE changes because the order of mutations has changed in relation to our
     * optimistic predictions.
     */
    onRebase?: (edge: Doc | null, incomingMutations: Mutation[], pendingMutations: Mutation[]) => void;
    /**
     * Called when we receive a patch in the normal order of things, but the mutation is not ours
     */
    onMutation?: (msg: {
        mutation: Mutation;
        document: Doc | null;
        remote: boolean;
    }) => void;
    /**
     * Called when consistency state changes with the boolean value of the current consistency state
     */
    onConsistencyChanged?: (isConsistent: boolean) => void;
    /**
     * Called whenever a new incoming mutation comes in. These are always ordered correctly.
     */
    onRemoteMutation?: (mut: Mutation) => void;
    /**
     * We are consistent when there are no unresolved mutations of our own, and no un-applicable
     * incoming mutations. When this has been going on for too long, and there has been a while
     * since we staged a new mutation, it is time to reset your state.
     */
    inconsistentAt: Date | null;
    /**
     * The last time we staged a patch of our own. If we have been inconsistent for a while, but it
     * hasn't been long since we staged a new mutation, the reason is probably just because the user
     * is typing or something.
     *
     * Should be used as a guard against resetting state for inconsistency reasons.
     */
    lastStagedAt: Date | null;
    constructor(doc: Doc | null);
    reset(doc: Doc | null): void;
    arrive(mutation: Mutation): void;
    stage(mutation: Mutation, silent?: boolean): SubmissionResponder;
    isConsistent(): boolean;
    considerIncoming(): void;
    updateConsistencyFlag(): void;
    applyIncoming(mut: Mutation | undefined): boolean;
    /**
     * Returns true if there are unresolved mutations between HEAD and EDGE, meaning we have
     * mutations that are still waiting to be either submitted, or to be confirmed by the server.
     *
     * @returns true if there are unresolved mutations between HEAD and EDGE, false otherwise
     */
    hasUnresolvedMutations(): boolean;
    /**
     * When an incoming mutation is applied to HEAD, this is called to remove the mutation from
     * the unresolved state. If the newly applied patch is the next upcoming unresolved mutation,
     * no rebase is needed, but we might have the wrong idea about the ordering of mutations, so in
     * that case we are given the flag `needRebase` to tell us that this mutation arrived out of
     * order in terms of our optimistic version, so a rebase is needed.
     *
     * @param txnId - Transaction ID of the remote mutation
     * @returns true if rebase is needed, false otherwise
     */
    consumeUnresolved(txnId: string): boolean;
    pendingSuccessfullySubmitted(pendingTxnId: string): void;
    pendingFailed(pendingTxnId: string): void;
    rebase(incomingMutations: Mutation[]): void;
}
//# sourceMappingURL=Document.d.ts.map