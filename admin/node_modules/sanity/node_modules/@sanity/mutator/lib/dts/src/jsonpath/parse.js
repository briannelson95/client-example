// Converts a string into an abstract syntax tree representation
import { tokenize } from './tokenize';
// TODO: Support '*'
class Parser {
    constructor(path) {
        this.tokens = tokenize(path);
        this.length = this.tokens.length;
        this.i = 0;
    }
    parse() {
        return this.parsePath();
    }
    EOF() {
        return this.i >= this.length;
    }
    // Look at upcoming token
    peek() {
        if (this.EOF()) {
            return null;
        }
        return this.tokens[this.i];
    }
    consume() {
        const result = this.peek();
        this.i += 1;
        return result;
    }
    // Return next token if it matches the pattern
    probe(pattern) {
        const token = this.peek();
        if (!token) {
            return null;
        }
        const record = token;
        const match = Object.keys(pattern).every((key) => {
            return key in token && pattern[key] === record[key];
        });
        return match ? token : null;
    }
    // Return and consume next token if it matches the pattern
    match(pattern) {
        return this.probe(pattern) ? this.consume() : null;
    }
    parseAttribute() {
        const token = this.match({ type: 'identifier' });
        if (token && token.type === 'identifier') {
            return {
                type: 'attribute',
                name: token.name,
            };
        }
        const quoted = this.match({ type: 'quoted', quote: 'single' });
        if (quoted && quoted.type === 'quoted') {
            return {
                type: 'attribute',
                name: quoted.value || '',
            };
        }
        return null;
    }
    parseAlias() {
        if (this.match({ type: 'keyword', symbol: '@' }) || this.match({ type: 'keyword', symbol: '$' })) {
            return {
                type: 'alias',
                target: 'self',
            };
        }
        return null;
    }
    parseNumber() {
        const token = this.match({ type: 'number' });
        if (token && token.type === 'number') {
            return {
                type: 'number',
                value: token.value,
            };
        }
        return null;
    }
    parseNumberValue() {
        const expr = this.parseNumber();
        if (expr) {
            return expr.value;
        }
        return null;
    }
    parseSliceSelector() {
        const start = this.i;
        const rangeStart = this.parseNumberValue();
        const colon1 = this.match({ type: 'operator', symbol: ':' });
        if (!colon1) {
            if (rangeStart === null) {
                // Rewind, this was actually nothing
                this.i = start;
                return null;
            }
            // Unwrap, this was just a single index not followed by colon
            return { type: 'index', value: rangeStart };
        }
        const result = {
            type: 'range',
            start: rangeStart,
            end: this.parseNumberValue(),
        };
        const colon2 = this.match({ type: 'operator', symbol: ':' });
        if (colon2) {
            result.step = this.parseNumberValue();
        }
        if (result.start === null && result.end === null) {
            // rewind, this wasnt' a slice selector
            this.i = start;
            return null;
        }
        return result;
    }
    parseValueReference() {
        return this.parseAttribute() || this.parseSliceSelector();
    }
    parseLiteralValue() {
        const literalString = this.match({ type: 'quoted', quote: 'double' });
        if (literalString && literalString.type === 'quoted') {
            return {
                type: 'string',
                value: literalString.value || '',
            };
        }
        const literalBoolean = this.match({ type: 'boolean' });
        if (literalBoolean && literalBoolean.type === 'boolean') {
            return {
                type: 'boolean',
                value: literalBoolean.symbol === 'true',
            };
        }
        return this.parseNumber();
    }
    // TODO: Reorder constraints so that literal value is always on rhs, and variable is always
    // on lhs.
    parseFilterExpression() {
        const start = this.i;
        const expr = this.parseAttribute() || this.parseAlias();
        if (!expr) {
            return null;
        }
        if (this.match({ type: 'operator', symbol: '?' })) {
            return {
                type: 'constraint',
                operator: '?',
                lhs: expr,
            };
        }
        const binOp = this.match({ type: 'comparator' });
        if (!binOp || binOp.type !== 'comparator') {
            // No expression, rewind!
            this.i = start;
            return null;
        }
        const lhs = expr;
        const rhs = this.parseLiteralValue();
        if (!rhs) {
            throw new Error(`Operator ${binOp.symbol} needs a literal value at the right hand side`);
        }
        return {
            type: 'constraint',
            operator: binOp.symbol,
            lhs: lhs,
            rhs: rhs,
        };
    }
    parseExpression() {
        return this.parseFilterExpression() || this.parseValueReference();
    }
    parseUnion() {
        if (!this.match({ type: 'paren', symbol: '[' })) {
            return null;
        }
        const terms = [];
        let expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference();
        while (expr) {
            terms.push(expr);
            // End of union?
            if (this.match({ type: 'paren', symbol: ']' })) {
                break;
            }
            if (!this.match({ type: 'operator', symbol: ',' })) {
                throw new Error('Expected ]');
            }
            expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference();
            if (!expr) {
                throw new Error("Expected expression following ','");
            }
        }
        return {
            type: 'union',
            nodes: terms,
        };
    }
    parseRecursive() {
        if (!this.match({ type: 'operator', symbol: '..' })) {
            return null;
        }
        const subpath = this.parsePath();
        if (!subpath) {
            throw new Error("Expected path following '..' operator");
        }
        return {
            type: 'recursive',
            term: subpath,
        };
    }
    parsePath() {
        const nodes = [];
        const expr = this.parseAttribute() || this.parseUnion() || this.parseRecursive();
        if (!expr) {
            return null;
        }
        nodes.push(expr);
        while (!this.EOF()) {
            if (this.match({ type: 'operator', symbol: '.' })) {
                const attr = this.parseAttribute();
                if (!attr) {
                    throw new Error("Expected attribute name following '.");
                }
                nodes.push(attr);
                continue;
            }
            else if (this.probe({ type: 'paren', symbol: '[' })) {
                const union = this.parseUnion();
                if (!union) {
                    throw new Error("Expected union following '['");
                }
                nodes.push(union);
            }
            else {
                const recursive = this.parseRecursive();
                if (recursive) {
                    nodes.push(recursive);
                }
                break;
            }
        }
        if (nodes.length === 1) {
            return nodes[0];
        }
        return {
            type: 'path',
            nodes: nodes,
        };
    }
}
export function parseJsonPath(path) {
    const parsed = new Parser(path).parse();
    if (!parsed) {
        throw new Error(`Failed to parse JSON path "${path}"`);
    }
    return parsed;
}
//# sourceMappingURL=parse.js.map