import { Mutation } from './Mutation';
import type { Doc, Mut } from './types';
/**
 * Implements a buffer for mutations that incrementally optimises the mutations by
 * eliminating set-operations that overwrite earlier set-operations, and rewrite
 * set-operations that change strings into other strings into diffMatchPatch operations.
 *
 * @internal
 */
export declare class SquashingBuffer {
    /**
     * The document forming the basis of this squash
     */
    BASIS: Doc | null;
    /**
     * The document after the out-Mutation has been applied, but before the staged
     * operations are committed.
     */
    PRESTAGE: Doc | null;
    /**
     * setOperations contain the latest set operation by path. If the set-operations are
     * updating strings to new strings, they are rewritten as diffMatchPatch operations,
     * any new set operations on the same paths overwrites any older set operations.
     * Only set-operations assigning plain values to plain values gets optimized like this.
     */
    setOperations: Record<string, Mut | undefined>;
    /**
     * `documentPresent` is true whenever we know that the document must be present due
     * to preceeding mutations. `false` implies that it may or may not already exist.
     */
    documentPresent: boolean;
    /**
     * The operations in the out-Mutation are not able to be optimized any further
     */
    out: Mut[];
    /**
     * Staged mutation operations
     */
    staged: Mut[];
    /**
     * Internal reusable diffMatchPatch instance
     * @internal
     */
    private dmp;
    constructor(doc: Doc | null);
    add(mut: Mutation): void;
    hasChanges(): boolean;
    /**
     * Extracts the mutations in this buffer.
     * After this is done, the buffer lifecycle is over and the client should
     * create an new one with the new, updated BASIS.
     *
     * @param txnId - Transaction ID
     * @returns A `Mutation` instance if we had outgoing mutations pending, null otherwise
     */
    purge(txnId?: string): Mutation | null;
    addOperation(op: Mut): void;
    /**
     * Attempt to perform one single set operation in an optimised manner, return value
     * reflects whether or not the operation could be performed.
  
     * @param path - The JSONPath to the set operation in question
     * @param nextValue - The value to be set
     * @returns True of optimized, false otherwise
     */
    optimiseSetOperation(path: string, nextValue: unknown): boolean;
    stashStagedOperations(): void;
    /**
     * Rebases given the new base-document
     *
     * @param newBasis - New base document to rebase on
     * @returns New "edge" document with buffered changes integrated
     */
    rebase(newBasis: Doc | null): Doc | null;
}
//# sourceMappingURL=SquashingBuffer.d.ts.map