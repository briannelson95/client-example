import { compact } from 'lodash';
import { Matcher } from './Matcher';
import { PlainProbe } from './PlainProbe';
export function extractAccessors(path, value) {
    const result = [];
    const matcher = Matcher.fromPath(path).setPayload(function appendResult(values) {
        result.push(...values);
    });
    const accessor = new PlainProbe(value);
    descend(matcher, accessor);
    return result;
}
function descend(matcher, accessor) {
    const { leads, delivery } = matcher.match(accessor);
    leads.forEach((lead) => {
        accessorsFromTarget(lead.target, accessor).forEach((childAccessor) => {
            descend(lead.matcher, childAccessor);
        });
    });
    if (delivery) {
        delivery.targets.forEach((target) => {
            if (typeof delivery.payload === 'function') {
                delivery.payload(accessorsFromTarget(target, accessor));
            }
        });
    }
}
function accessorsFromTarget(target, accessor) {
    const result = [];
    if (target.isIndexReference()) {
        target.toIndicies(accessor).forEach((i) => {
            result.push(accessor.getIndex(i));
        });
    }
    else if (target.isAttributeReference()) {
        result.push(accessor.getAttribute(target.name()));
    }
    else if (target.isSelfReference()) {
        result.push(accessor);
    }
    else {
        throw new Error(`Unable to derive accessor for target ${target.toString()}`);
    }
    return compact(result);
}
//# sourceMappingURL=extractAccessors.js.map