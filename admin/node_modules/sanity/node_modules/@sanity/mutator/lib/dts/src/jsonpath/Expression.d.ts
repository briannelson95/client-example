import type { Expr, HeadTail } from './types';
import type { Probe } from './Probe';
export interface Range {
    start: number;
    end: number;
    step: number;
}
export declare class Expression {
    expr: Expr;
    constructor(expr: Expr | Expression | null);
    isPath(): boolean;
    isUnion(): boolean;
    isCollection(): boolean;
    isConstraint(): boolean;
    isRecursive(): boolean;
    isExistenceConstraint(): boolean;
    isIndex(): boolean;
    isRange(): boolean;
    expandRange(probe?: Probe): Range;
    isAttributeReference(): boolean;
    isIndexReference(): boolean;
    name(): string;
    isSelfReference(): boolean;
    constraintTargetIsSelf(): boolean;
    constraintTargetIsAttribute(): boolean;
    testConstraint(probe: Probe): boolean;
    pathNodes(): Expr[];
    prepend(node: Expression): Expression;
    concat(other: Expression | null): Expression;
    descend(): HeadTail[];
    unwrapRecursive(): Expression;
    toIndicies(probe?: Probe): number[];
    toFieldReferences(): number[] | string[];
    toString(): string;
    static fromPath(path: string): Expression;
    static attributeReference(name: string): Expression;
    static indexReference(i: number): Expression;
}
//# sourceMappingURL=Expression.d.ts.map