"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.printDebugInfo = void 0;

var _omit2 = _interopRequireDefault(require("lodash/omit"));

var _pick2 = _interopRequireDefault(require("lodash/pick"));

var _os = _interopRequireDefault(require("os"));

var _util = _interopRequireDefault(require("util"));

var _path = _interopRequireDefault(require("path"));

var _xdgBasedir = _interopRequireDefault(require("xdg-basedir"));

var _promisePropsRecursive = _interopRequireDefault(require("promise-props-recursive"));

var _clientWrapper = require("../../util/clientWrapper");

var _getUserConfig = require("../../util/getUserConfig");

var _printVersionResult = require("../versions/printVersionResult");

var _findSanityModuleVersions = require("../../actions/versions/findSanityModuleVersions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const printDebugInfo = async (args, context) => {
  const flags = args.extOptions;
  const {
    user,
    globalConfig,
    projectConfig,
    project,
    versions
  } = await gatherInfo(context);
  const {
    chalk
  } = context; // User info

  context.output.print('\nUser:');

  if (user instanceof Error) {
    context.output.print("  ".concat(chalk.red(user.message), "\n"));
  } else {
    printKeyValue({
      ID: user.id,
      Name: user.name,
      Email: user.email
    }, context);
  } // Project info (API-based)


  if (project) {
    context.output.print('Project:');
    printKeyValue({
      ID: project.id,
      'Display name': project.displayName,
      'Studio URL': project.studioHostname,
      'User role': project.userRole
    }, context);
  } // Auth info
  // eslint-disable-next-line no-process-env


  const authToken = process.env.SANITY_AUTH_TOKEN || globalConfig.authToken;

  if (authToken) {
    context.output.print('Authentication:');
    printKeyValue({
      'User type': globalConfig.authType || 'normal',
      'Auth token': flags.secrets ? authToken : "<redacted>"
    }, context);

    if (!flags.secrets) {
      context.output.print('  (run with --secrets to reveal token)\n');
    }
  } // Global configuration (user home dir config file)


  context.output.print("Global config (".concat(chalk.yellow(getGlobalConfigLocation()), "):"));
  const globalCfg = (0, _omit2.default)(globalConfig, ['authType', 'authToken']);
  context.output.print("  ".concat(formatObject(globalCfg).replace(/\n/g, '\n  '), "\n")); // Project configuration (projectDir/sanity.json)

  if (projectConfig) {
    const configLocation = context.cliConfigPath ? " (".concat(chalk.yellow(_path.default.relative(process.cwd(), context.cliConfigPath)), ")") : '';
    context.output.print("Project config".concat(configLocation, ":"));
    context.output.print("  ".concat(formatObject(projectConfig).replace(/\n/g, '\n  ')));
  } // Print installed package versions


  if (versions) {
    context.output.print('\nPackage versions:');
    (0, _printVersionResult.printResult)(versions, line => context.output.print("  ".concat(line)));
    context.output.print('');
  }
};

exports.printDebugInfo = printDebugInfo;

function formatObject(obj) {
  return _util.default.inspect(obj, {
    colors: true,
    depth: +Infinity
  });
}

function printKeyValue(obj, context) {
  let printedLines = 0;
  Object.keys(obj).forEach(key => {
    if (typeof obj[key] !== 'undefined') {
      context.output.print("  ".concat(key, ": ").concat(formatObject(obj[key])));
      printedLines++;
    }
  });

  if (printedLines > 0) {
    context.output.print('');
  }
}

async function gatherInfo(context) {
  const baseInfo = await (0, _promisePropsRecursive.default)({
    globalConfig: gatherGlobalConfigInfo(),
    projectConfig: gatherProjectConfigInfo(context)
  });
  const withUser = { ...baseInfo,
    user: await gatherUserInfo(context, {
      projectBased: Boolean(baseInfo.projectConfig && baseInfo.projectConfig.api)
    })
  };
  return (0, _promisePropsRecursive.default)({
    project: gatherProjectInfo(context, withUser),
    versions: (0, _findSanityModuleVersions.findSanityModuleVersions)(context, {
      target: 'latest'
    }),
    ...withUser
  });
}

function getGlobalConfigLocation() {
  const user = (_os.default.userInfo().username || 'user').replace(/\\/g, '');

  const configDir = _xdgBasedir.default.config || _path.default.join(_os.default.tmpdir(), user, '.config');

  return _path.default.join(configDir, 'sanity', 'config.json');
}

function gatherGlobalConfigInfo() {
  return (0, _getUserConfig.getUserConfig)().all;
}

function gatherProjectConfigInfo(context) {
  var _cliConfig$api;

  const {
    cliConfig
  } = context;

  if (cliConfig !== null && cliConfig !== void 0 && (_cliConfig$api = cliConfig.api) !== null && _cliConfig$api !== void 0 && _cliConfig$api.projectId) {
    return cliConfig;
  }

  return {
    error: "Missing required \"api.projectId\" key"
  };
}

async function gatherProjectInfo(context, baseInfo) {
  const projectClient = context.apiClient({
    requireUser: false,
    requireProject: false
  });
  const projectId = projectClient.config().projectId;
  const hasToken = Boolean((0, _clientWrapper.getCliToken)());

  if (!projectId || !hasToken) {
    return null;
  }

  const client = context.apiClient({
    requireUser: true,
    requireProject: false
  });
  const projectInfo = await client.projects.getById(projectId);

  if (!projectInfo) {
    return new Error("Project specified in configuration (".concat(projectId, ") does not exist in API"));
  }

  const userId = baseInfo.user instanceof Error ? null : baseInfo.user.id;
  const host = projectInfo.studioHost;
  const member = (projectInfo.members || []).find(user => user.id === userId);
  const hostname = host && "https://".concat(host, ".sanity.studio/");
  return {
    id: projectId,
    displayName: projectInfo.displayName,
    studioHostname: hostname,
    userRole: member ? member.role : 'unknown'
  };
}

async function gatherUserInfo(context, options) {
  const hasToken = Boolean((0, _clientWrapper.getCliToken)());

  if (!hasToken) {
    return new Error('Not logged in');
  }

  const client = context.apiClient({
    requireUser: true,
    requireProject: options.projectBased
  });
  const userInfo = await client.users.getById('me');

  if (!userInfo) {
    return new Error('Token expired or invalid');
  }

  return (0, _pick2.default)(userInfo, ['id', 'name', 'email']);
}