"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _noop2 = _interopRequireDefault(require("lodash/noop"));

var _padStart2 = _interopRequireDefault(require("lodash/padStart"));

var _util = _interopRequireDefault(require("util"));

var _path = _interopRequireDefault(require("path"));

var _fs = require("fs");

var _boxen = _interopRequireDefault(require("boxen"));

var _rimraf = _interopRequireDefault(require("rimraf"));

var _semver = _interopRequireDefault(require("semver"));

var _resolveFrom = _interopRequireDefault(require("resolve-from"));

var _findSanityModuleVersions = require("../../actions/versions/findSanityModuleVersions");

var _printVersionResult = require("../versions/printVersionResult");

var _debug = require("../../debug");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rimraf = _util.default.promisify(_rimraf.default);

const unsupportedMessage = "\n`sanity upgrade` is not supported as of sanity v3.\nUse npm-check-updates or similar (https://www.npmjs.com/package/npm-check-updates)\n".trim();

const upgradeDependencies = async function upgradeDependencies(args, context) {
  const {
    output,
    workDir,
    yarn,
    chalk,
    sanityMajorVersion
  } = context;

  if (sanityMajorVersion >= 3) {
    throw new Error(unsupportedMessage);
  }

  const {
    extOptions,
    argsWithoutOptions
  } = args;
  const modules = argsWithoutOptions.slice();
  const {
    range,
    tag
  } = extOptions;
  const saveExact = extOptions['save-exact'];
  const targetRange = tag || range;

  if (range && tag) {
    throw new Error('Both --tag and --range specified, can only use one');
  }

  if (range && !_semver.default.validRange(range)) {
    throw new Error("Invalid semver range \"".concat(range, "\""));
  } // Find which modules needs update according to the target range


  const versions = await (0, _findSanityModuleVersions.findSanityModuleVersions)(context, {
    target: targetRange,
    includeCli: false
  });
  const allNeedsUpdate = versions.filter(mod => mod.needsUpdate);
  (0, _debug.debug)('In need of update: %s', allNeedsUpdate.map(mod => mod.name).join(', '));
  const needsUpdate = modules.length === 0 ? allNeedsUpdate : allNeedsUpdate.filter(outOfDate => modules.indexOf(outOfDate.name) !== -1);
  const semverBreakingUpgrades = versions.filter(hasSemverBreakingUpgrade);
  const baseMajorUpgrade = semverBreakingUpgrades.find(mod => mod.name === '@sanity/base');
  const majorUpgrades = semverBreakingUpgrades.filter(mod => mod.name !== '@sanity/base');
  schedulePrintMajorUpgrades({
    baseMajorUpgrade,
    majorUpgrades
  }, context); // If all modules are up-to-date, say so and exit

  if (needsUpdate.length === 0) {
    const specified = modules.length === 0 ? 'All' : 'All *specified*';
    context.output.print("".concat(chalk.green('✔'), " ").concat(specified, " Sanity modules are at latest compatible versions"));
    return;
  } // Ignore modules that are pinned, but give some indication that this has happened


  const pinned = needsUpdate.filter(mod => mod.isPinned);
  const nonPinned = needsUpdate.filter(mod => !mod.isPinned);
  const pinnedNames = pinned.map(mod => mod.name).join("\n - ");

  if (nonPinned.length === 0) {
    context.output.warn("".concat(chalk.yellow('⚠'), " All modules are pinned to specific versions, not upgrading:\n - ").concat(pinnedNames));
    return;
  }

  if (pinned.length > 0) {
    context.output.warn("".concat(chalk.yellow('⚠'), " The follow modules are pinned to specific versions, not upgrading:\n - ").concat(pinnedNames));
  } // Yarn fails to upgrade `react-ace` in some versions, see function for details


  await maybeDeleteReactAce(nonPinned, workDir); // Forcefully remove non-symlinked module paths to force upgrade

  await Promise.all(nonPinned.map(mod => deleteIfNotSymlink(_path.default.join(context.workDir, 'node_modules', mod.name.replace(/\//g, _path.default.sep))))); // Replace versions in `package.json`

  const versionPrefix = saveExact ? '' : '^';
  const oldManifest = await readLocalManifest(workDir);
  const newManifest = nonPinned.reduce((target, mod) => {
    if (oldManifest.dependencies && oldManifest.dependencies[mod.name]) {
      target.dependencies[mod.name] = mod.latestInRange === 'unknown' ? oldManifest.dependencies[mod.name] : versionPrefix + mod.latestInRange;
    }

    if (oldManifest.devDependencies && oldManifest.devDependencies[mod.name]) {
      target.devDependencies[mod.name] = mod.latestInRange === 'unknown' ? oldManifest.devDependencies[mod.name] : versionPrefix + mod.latestInRange;
    }

    return target;
  }, oldManifest); // Write new `package.json`

  const manifestPath = _path.default.join(context.workDir, 'package.json');

  await writeJson(manifestPath, newManifest); // Run `yarn install`

  const flags = extOptions.offline ? ['--offline'] : [];
  const cmd = ['install'].concat(flags);
  (0, _debug.debug)('Running yarn %s', cmd.join(' '));
  await yarn(cmd, { ...output,
    rootDir: workDir
  });
  context.output.print('');
  context.output.print("".concat(chalk.green('✔'), " Modules upgraded:"));
  const {
    versionLength,
    formatName
  } = (0, _printVersionResult.getFormatters)(nonPinned);
  nonPinned.forEach(mod => {
    const current = chalk.yellow((0, _padStart2.default)(mod.installed || '<missing>', versionLength));
    const latest = chalk.green(mod.latestInRange);
    context.output.print("".concat(formatName(mod.name), " ").concat(current, " \u2192 ").concat(latest));
  });
};

var _default = upgradeDependencies;
exports.default = _default;

function writeJson(filePath, data) {
  return _fs.promises.writeFile(filePath, "".concat(JSON.stringify(data, null, 2), "\n"));
}

async function deleteIfNotSymlink(modPath) {
  const stats = await _fs.promises.lstat(modPath).catch(_noop2.default);

  if (!stats || stats.isSymbolicLink()) {
    return null;
  }

  return rimraf(modPath);
}

function hasSemverBreakingUpgrade(mod) {
  var _semver$minVersion;

  const current = mod.installed || ((_semver$minVersion = _semver.default.minVersion(mod.declared)) === null || _semver$minVersion === void 0 ? void 0 : _semver$minVersion.toString()) || '';
  return !_semver.default.satisfies(mod.latest, "^".concat(current)) && _semver.default.gt(mod.latest, current);
}

function getMajorUpgradeText(mods, chalk) {
  const modNames = mods.map(mod => "".concat(mod.name, " (v").concat(_semver.default.major(mod.latest), ")")).join('\n - ');
  return ["The following modules has new major versions\n", "released and will have to be manually upgraded:\n\n", " - ".concat(modNames, "\n\n"), chalk.yellow('⚠'), " Note that major versions can contain backwards\n", "  incompatible changes and should be handled with care."].join('');
}

function getMajorStudioUpgradeText(mod, chalk) {
  var _semver$minVersion2;

  const prev = _semver.default.major(mod.installed || ((_semver$minVersion2 = _semver.default.minVersion(mod.declared)) === null || _semver$minVersion2 === void 0 ? void 0 : _semver$minVersion2.toString()) || '');

  const next = _semver.default.major(mod.latest);

  return ['There is now a new major version of Sanity Studio!', '', 'Read more about the new version and how to upgrade:', chalk.blueBright("https://www.sanity.io/changelog/studio?from=v".concat(prev, "&to=v").concat(next))].join('\n');
}

function schedulePrintMajorUpgrades(_ref, _ref2) {
  let {
    baseMajorUpgrade,
    majorUpgrades
  } = _ref;
  let {
    chalk,
    output
  } = _ref2;

  if (majorUpgrades.length === 0 && !baseMajorUpgrade) {
    return;
  }

  process.on('beforeExit', () => {
    output.print(''); // Separate previous output with a newline

    if (baseMajorUpgrade) {
      output.warn((0, _boxen.default)(getMajorStudioUpgradeText(baseMajorUpgrade, chalk), {
        borderColor: 'green',
        padding: 1
      }));
      return;
    }

    output.warn((0, _boxen.default)(getMajorUpgradeText(majorUpgrades, chalk), {
      borderColor: 'yellow',
      padding: 1
    }));
  });
} // Workaround for https://github.com/securingsincity/react-ace/issues/1048
// Yarn fails to upgrade `react-ace` because `react-ace.min.js` is a _file_ in one version
// but a _folder_ in the next. If we're upgrading the `@sanity/code-input`, remove the
// `react-ace` dependency before installing


async function maybeDeleteReactAce(toUpgrade, workDir) {
  const codeInputUpdate = toUpgrade.find(mod => mod.name === '@sanity/code-input');

  if (!codeInputUpdate) {
    return;
  } // Assume it is an old version if we can't figure out which one is installed


  const installed = codeInputUpdate.installed ? codeInputUpdate.installed : '2.4.0';
  const upgradeTo = codeInputUpdate.latestInRange; // react-ace was upgraded in 2.24.1, so if we're going from <= 2.24.0 to => 2.24.1,
  // we should remove it.

  const shouldDelete = _semver.default.lte(installed, '2.24.0') && _semver.default.gte(upgradeTo, '2.24.1');

  if (!shouldDelete) {
    return;
  } // Try to find the path to it from `@sanity/code-input`, otherwise try the studio root `node_modules`


  const depRootPath = _path.default.join(workDir, 'node_modules');

  const closestReactAcePath = getModulePath('react-ace', _path.default.join(depRootPath, '@sanity', 'code-input')) || _path.default.join(depRootPath, 'react-ace');

  await rimraf(closestReactAcePath);
}

function getModulePath(modName, fromPath) {
  const manifestFile = "".concat(modName.replace(/\//g, _path.default.sep), "/package.json");

  const manifestPath = _resolveFrom.default.silent(fromPath, manifestFile);

  return manifestPath ? _path.default.dirname(manifestPath) : undefined;
}

async function readLocalManifest(dirName) {
  let fileName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'package.json';

  try {
    const content = await _fs.promises.readFile(_path.default.join(dirName, fileName), 'utf8');
    return JSON.parse(content);
  } catch (err) {
    if (err.code === 'ENOENT') {
      return {};
    }

    throw new Error("Error while attempting to read projects \"".concat(fileName, "\":\n").concat(err.message));
  }
}