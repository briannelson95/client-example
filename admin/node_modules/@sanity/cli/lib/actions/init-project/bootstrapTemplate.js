"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bootstrapTemplate = bootstrapTemplate;

var _path = _interopRequireDefault(require("path"));

var _promises = _interopRequireDefault(require("fs/promises"));

var _chalk = _interopRequireDefault(require("chalk"));

var _debug = require("../../debug");

var _studioDependencies = require("../../studioDependencies");

var _resolveLatestVersions = require("../../util/resolveLatestVersions");

var _copy = require("../../util/copy");

var _createPackageManifest = require("./createPackageManifest");

var _createCliConfig = require("./createCliConfig");

var _createStudioConfig = require("./createStudioConfig");

var _templates = _interopRequireDefault(require("./templates"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function bootstrapTemplate(opts, context) {
  const {
    apiClient,
    cliRoot,
    output
  } = context;

  const templatesDir = _path.default.join(cliRoot, 'templates');

  const {
    outputPath,
    templateName,
    useTypeScript,
    packageName,
    variables
  } = opts;
  const {
    projectId
  } = variables;

  const sourceDir = _path.default.join(templatesDir, templateName);

  const sharedDir = _path.default.join(templatesDir, 'shared'); // Check that we have a template info file (dependencies, plugins etc)


  const template = _templates.default[templateName];

  if (!template) {
    throw new Error("Template \"".concat(templateName, "\" not defined"));
  } // Copy template files


  (0, _debug.debug)('Copying files from template "%s" to "%s"', templateName, outputPath);
  let spinner = output.spinner('Bootstrapping files from template').start();
  await (0, _copy.copy)(sourceDir, outputPath, {
    rename: useTypeScript ? toTypeScriptPath : undefined
  });
  await (0, _copy.copy)(_path.default.join(sharedDir, 'gitignore.txt'), outputPath, {
    rename: () => '.gitignore'
  });

  if (useTypeScript) {
    await _promises.default.copyFile(_path.default.join(sharedDir, 'tsconfig.json'), _path.default.join(outputPath, 'tsconfig.json'));
  }

  spinner.succeed(); // Merge global and template-specific plugins and dependencies
  // Resolve latest versions of Sanity-dependencies

  spinner = output.spinner('Resolving latest module versions').start();
  const dependencyVersions = await (0, _resolveLatestVersions.resolveLatestVersions)({ ..._studioDependencies.studioDependencies.dependencies,
    ..._studioDependencies.studioDependencies.devDependencies,
    ...(template.dependencies || {})
  });
  spinner.succeed(); // Use the resolved version for the given dependency

  const dependencies = Object.keys({ ..._studioDependencies.studioDependencies.dependencies,
    ...template.dependencies
  }).reduce((deps, dependency) => {
    deps[dependency] = dependencyVersions[dependency];
    return deps;
  }, {});
  const devDependencies = Object.keys({ ..._studioDependencies.studioDependencies.devDependencies,
    ...template.devDependencies
  }).reduce((deps, dependency) => {
    deps[dependency] = dependencyVersions[dependency];
    return deps;
  }, {}); // Now create a package manifest (`package.json`) with the merged dependencies

  spinner = output.spinner('Creating default project files').start();
  const packageManifest = await (0, _createPackageManifest.createPackageManifest)({
    name: packageName,
    dependencies,
    devDependencies
  }); // ...and a studio config (`sanity.config.[ts|js]`)

  const studioConfig = await (0, _createStudioConfig.createStudioConfig)({
    template: template.configTemplate,
    variables
  }); // ...and a CLI config (`sanity.cli.[ts|js]`)

  const cliConfig = await (0, _createCliConfig.createCliConfig)({
    projectId: variables.projectId,
    dataset: variables.dataset
  }); // Write non-template files to disc

  const codeExt = useTypeScript ? 'ts' : 'js';
  await Promise.all([writeFileIfNotExists("sanity.config.".concat(codeExt), studioConfig), writeFileIfNotExists("sanity.cli.".concat(codeExt), cliConfig), writeFileIfNotExists('package.json', packageManifest), writeFileIfNotExists('.eslintrc', "".concat(JSON.stringify({
    extends: '@sanity/eslint-config-studio'
  }, null, 2), "\n"))]); // Store template name metadata on project

  try {
    await apiClient({
      api: {
        projectId
      }
    }).request({
      method: 'PATCH',
      uri: "/projects/".concat(projectId),
      body: {
        metadata: {
          initialTemplate: "cli-".concat(templateName)
        }
      }
    });
  } catch (err) {
    // Non-critical that we update this metadata, and user does not need to be aware
    let message = typeof err === 'string' ? err : '<unknown error>';

    if (err instanceof Error) {
      message = err.message;
    }

    (0, _debug.debug)('Failed to update initial template metadata for project: %s', message);
  } // Finish up by providing init process with template-specific info


  spinner.succeed();
  return template;

  async function writeFileIfNotExists(fileName, content) {
    const filePath = _path.default.join(outputPath, fileName);

    try {
      await _promises.default.writeFile(filePath, content, {
        flag: 'wx'
      });
    } catch (err) {
      if (err.code === 'EEXIST') {
        output.warn("\n".concat(_chalk.default.yellow('âš '), " File \"").concat(filePath, "\" already exists, skipping"));
      } else {
        throw err;
      }
    }
  }
}

function toTypeScriptPath(originalPath) {
  return originalPath.replace(/\.js$/, '.ts');
}