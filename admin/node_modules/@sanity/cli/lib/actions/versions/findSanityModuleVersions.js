"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findSanityModuleVersions = findSanityModuleVersions;

var _path = _interopRequireDefault(require("path"));

var _promisePropsRecursive = _interopRequireDefault(require("promise-props-recursive"));

var _semver = _interopRequireDefault(require("semver"));

var _semverCompare = _interopRequireDefault(require("semver-compare"));

var _getLatestVersion = _interopRequireDefault(require("get-latest-version"));

var pkg = _interopRequireWildcard(require("../../../package.json"));

var _dynamicRequire = require("../../util/dynamicRequire");

var _getLocalVersion = require("../../util/getLocalVersion");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * The `sanity upgrade` command should only be responsible for upgrading the
 * _studio_ related dependencies. Modules like @sanity/block-content-to-react
 * shouldn't be upgraded using the same tag/range as the other studio modules.
 *
 * We don't have a guaranteed list of the "studio modules", so instead we
 * explicitly exclude certain modules from being upgraded.
 */
const PACKAGES_TO_EXCLUDE = ['@sanity/block-content-to-html', '@sanity/block-content-to-react', '@sanity/block-tools', '@sanity/client'];
const defaultOptions = {
  includeCli: true
};

async function findSanityModuleVersions(context) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    spinner
  } = context.output;
  const {
    target,
    includeCli
  } = { ...defaultOptions,
    ...options
  }; // Declared @sanity modules and their wanted version ranges in package.json

  const sanityModules = filterSanityModules(getLocalManifest(context.workDir)); // Figure out the latest versions which match the wanted range

  const resolveOpts = {
    includeCli,
    target
  };
  const spin = spinner('Resolving latest versions').start();
  const versions = await (0, _promisePropsRecursive.default)(buildPackageArray(sanityModules, context.workDir, resolveOpts));
  const packages = Object.values(versions);
  spin.stop();
  return packages.map(mod => {
    var _semver$minVersion;

    const current = mod.installed || ((_semver$minVersion = _semver.default.minVersion(mod.declared)) === null || _semver$minVersion === void 0 ? void 0 : _semver$minVersion.toString()) || '';
    const needsUpdate = target === 'latest' ? (0, _semverCompare.default)(current, mod.latest) === -1 : typeof mod.latestInRange !== 'undefined' && mod.installed !== mod.latestInRange;
    return { ...mod,
      needsUpdate
    };
  });
}

function getLocalManifest(workDir) {
  try {
    return (0, _dynamicRequire.dynamicRequire)(_path.default.join(workDir, 'package.json'));
  } catch (err) {
    return {};
  }
}

function filterSanityModules(manifest) {
  const dependencies = { ...manifest.dependencies,
    ...manifest.devDependencies
  };
  return Object.keys(dependencies).filter(mod => mod.startsWith('@sanity/') || mod === 'sanity').filter(mod => !PACKAGES_TO_EXCLUDE.includes(mod)).sort().reduce((versions, dependency) => {
    versions[dependency] = dependencies[dependency];
    return versions;
  }, {});
}

function buildPackageArray(packages, workDir) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    includeCli,
    target
  } = options;
  const modules = [];

  if (includeCli) {
    const [cliMajor] = pkg.version.split('.');
    const latest = tryFindLatestVersion(pkg.name, target || "^".concat(cliMajor));
    modules.push({
      name: pkg.name,
      declared: "^".concat(pkg.version),
      installed: trimHash(pkg.version),
      latest: latest.then(versions => versions.latest),
      latestInRange: latest.then(versions => versions.latestInRange),
      isPinned: false,
      isGlobal: true
    });
  }

  return [...modules, ...Object.keys(packages).map(pkgName => {
    const latest = tryFindLatestVersion(pkgName, target || packages[pkgName] || 'latest');
    const localVersion = (0, _getLocalVersion.getLocalVersion)(pkgName, workDir);
    return {
      name: pkgName,
      declared: packages[pkgName],
      installed: localVersion ? trimHash(localVersion) : undefined,
      latest: latest.then(versions => versions.latest),
      latestInRange: latest.then(versions => versions.latestInRange),
      isPinned: isPinnedVersion(packages[pkgName]),
      isGlobal: false
    };
  })];
}

async function tryFindLatestVersion(pkgName, range) {
  try {
    const {
      latest,
      inRange
    } = await (0, _getLatestVersion.default)(pkgName, {
      range,
      includeLatest: true
    });
    return {
      latest,
      latestInRange: inRange
    };
  } catch (err) {
    if (!(err instanceof Error) || !err.message.includes('No version exists')) {
      throw err;
    }

    const latest = await (0, _getLatestVersion.default)(pkgName);
    return {
      latest,
      latestInRange: undefined
    };
  }
}

function isPinnedVersion(version) {
  return /^\d+\.\d+\.\d+/.test(version);
}
/**
 * `2.27.3-cookieless-auth.34+8ba9c1504` â†’
 * `2.27.3-cookieless-auth.34`
 */


function trimHash(version) {
  return version.replace(/\+[a-z0-9]{8,}$/, '');
}