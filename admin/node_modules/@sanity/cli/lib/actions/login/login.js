"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.login = login;

var _os = _interopRequireDefault(require("os"));

var _crypto = _interopRequireDefault(require("crypto"));

var _open = _interopRequireDefault(require("open"));

var _chalk = _interopRequireDefault(require("chalk"));

var _eventsource = _interopRequireDefault(require("eventsource"));

var _clientWrapper = require("../../util/clientWrapper");

var _getUserConfig = require("../../util/getUserConfig");

var _canLaunchBrowser = require("../../util/canLaunchBrowser");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function login(args, context) {
  const {
    prompt,
    output,
    apiClient
  } = context;
  const {
    sso,
    experimental,
    provider: specifiedProvider
  } = args.extOptions;
  const previousToken = (0, _clientWrapper.getCliToken)();
  const hasExistingToken = Boolean(previousToken); // Explicitly tell this client not to use a token

  const client = apiClient({
    requireUser: false,
    requireProject: false
  }).clone().config({
    token: undefined
  }); // Get the desired authentication provider

  const provider = await getProvider({
    client,
    sso,
    experimental,
    output,
    prompt,
    specifiedProvider
  });

  if (provider === undefined) {
    output.print(_chalk.default.red('No authentication providers found'));
    return;
  } // Open an authentication listener channel and wait for secret


  const apiHost = client.config().apiHost || 'https://api.sanity.io';

  const iv = _crypto.default.randomBytes(8).toString('hex');

  const es = getAuthChannel(apiHost, provider, iv);
  const encryptedToken = getAuthToken(es); // This is a promise, will resolve later

  const {
    secret,
    url
  } = await getAuthInfo(es); // Open a browser on the login page (or tell the user to)

  const providerUrl = new URL(url);
  providerUrl.searchParams.set('label', "".concat(_os.default.hostname(), " / ").concat(_os.default.platform()));
  const loginUrl = providerUrl.href;
  const shouldLaunchBrowser = (0, _canLaunchBrowser.canLaunchBrowser)();
  const actionText = shouldLaunchBrowser ? 'Opening browser at' : 'Please open a browser at';
  output.print("\n".concat(actionText, " ").concat(loginUrl, "\n"));
  const spin = output.spinner('Waiting for browser login to complete... Press Ctrl + C to cancel').start();
  (0, _open.default)(loginUrl); // Wait for a success/error on the listener channel

  let token;

  try {
    token = await encryptedToken;
    spin.stop();
  } catch (err) {
    spin.stop();
    err.message = "Login failed: ".concat(err.message);
    throw err;
  } // Decrypt the token with the secret we received earlier


  const authToken = decryptToken(token, secret, iv); // Store the token

  (0, _getUserConfig.getUserConfig)().set({
    authToken: authToken,
    authType: 'normal'
  }); // If we had a session previously, attempt to clear it

  if (hasExistingToken) {
    await apiClient({
      requireUser: true,
      requireProject: false
    }).clone().config({
      token: previousToken
    }).request({
      uri: '/auth/logout',
      method: 'POST'
    }).catch(err => {
      const statusCode = err && err.response && err.response.statusCode;

      if (statusCode !== 401) {
        output.warn('[warn] Failed to log out existing session');
      }
    });
  }

  output.print(_chalk.default.green('Login successful'));
}

function getAuthChannel(baseUrl, provider, iv) {
  const uuid = _crypto.default.randomBytes(16).toString('hex');

  let listenUrl;

  if (provider.type === 'saml') {
    listenUrl = "".concat(baseUrl, "/v2021-10-01/auth/saml/listen/").concat(provider.id, "/").concat(uuid, "?iv=").concat(iv);
  } else {
    listenUrl = "".concat(baseUrl, "/v1/auth/listen/").concat(provider.name, "/").concat(uuid, "?iv=").concat(iv);
  }

  return new _eventsource.default(listenUrl);
}

function getAuthInfo(es) {
  const values = {
    secret: '',
    url: ''
  };
  return new Promise((resolve, reject) => {
    es.addEventListener('error', err => {
      es.close();
      const message = 'message' in err && typeof err.message === 'string' ? err.message : '';
      reject(new Error("Unable to get authorization info: ".concat(message)));
    });
    es.addEventListener('message', msg => {
      const data = parseJson(msg.data, null);

      if (!data || !('type' in data)) {
        return;
      }

      if (data.type === 'secret') {
        values.secret = data.secret;
      } else if (data.type === 'url') {
        values.url = data.url;
      } else {
        return;
      }

      if (values.secret && values.url) {
        resolve(values);
      }
    });
  });
}

function getAuthToken(es) {
  return new Promise((resolve, reject) => {
    es.addEventListener('success', msg => {
      es.close();
      const data = parseJson(msg.data, null);

      if (!data || !data.token) {
        reject(new Error('Failed to get token from `success`-message'));
        return;
      }

      resolve(data.token);
    });
    es.addEventListener('failure', msg => {
      es.close();
      const data = parseJson(msg.data, {
        type: 'error',
        message: 'Unknown error'
      });
      reject(new Error(data.message));
    });
  });
}

function decryptToken(token, secret, iv) {
  const decipher = _crypto.default.createDecipheriv('aes-256-cbc', secret, iv);

  const dec = decipher.update(token, 'hex', 'utf8');
  return "".concat(dec).concat(decipher.final('utf8'));
}

async function getProvider(_ref) {
  let {
    output,
    client,
    sso,
    experimental,
    prompt,
    specifiedProvider
  } = _ref;

  if (sso) {
    return getSSOProvider({
      client,
      prompt,
      slug: sso
    });
  } // Fetch and prompt for login provider to use


  const spin = output.spinner('Fetching providers...').start();
  let {
    providers
  } = await client.request({
    uri: '/auth/providers'
  });

  if (experimental) {
    providers = [...providers, {
      name: 'sso',
      title: 'SSO'
    }];
  }

  spin.stop();
  const providerNames = providers.map(prov => prov.name);

  if (specifiedProvider && providerNames.includes(specifiedProvider)) {
    const provider = providers.find(prov => prov.name === specifiedProvider);

    if (!provider) {
      throw new Error("Cannot find login provider with name \"".concat(specifiedProvider, "\""));
    }

    return provider;
  }

  const provider = await promptProviders(prompt, providers);

  if (provider.name === 'sso') {
    const slug = await prompt.single({
      type: 'input',
      message: 'Organization slug:'
    });
    return getSSOProvider({
      client,
      prompt,
      slug
    });
  }

  return provider;
}

async function getSSOProvider(_ref2) {
  let {
    client,
    prompt,
    slug
  } = _ref2;
  const providers = await client.withConfig({
    apiVersion: '2021-10-01'
  }).request({
    uri: "/auth/organizations/by-slug/".concat(slug, "/providers")
  });
  const enabledProviders = providers.filter(candidate => !candidate.disabled);

  if (enabledProviders.length === 0) {
    return undefined;
  }

  if (enabledProviders.length === 1) {
    return enabledProviders[0];
  }

  const choice = await prompt.single({
    type: 'list',
    message: 'Select SSO provider',
    choices: enabledProviders.map(provider => provider.name)
  });
  return enabledProviders.find(provider => provider.name === choice);
}

async function promptProviders(prompt, providers) {
  if (providers.length === 1) {
    return providers[0];
  }

  const provider = await prompt.single({
    type: 'list',
    message: 'Login type',
    choices: providers.map(choice => choice.title)
  });
  return providers.find(prov => prov.title === provider) || providers[0];
}

function parseJson(json, defaultVal) {
  try {
    return JSON.parse(json);
  } catch (err) {
    return defaultVal;
  }
}