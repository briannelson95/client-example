"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bootstrapFromTemplate = bootstrapFromTemplate;

var _path = _interopRequireDefault(require("path"));

var _promises = _interopRequireDefault(require("fs/promises"));

var _semver = _interopRequireDefault(require("semver"));

var _getIt = _interopRequireDefault(require("get-it"));

var _promise = _interopRequireDefault(require("get-it/lib-node/middleware/promise"));

var _decompress = _interopRequireDefault(require("decompress"));

var _resolveFrom = _interopRequireDefault(require("resolve-from"));

var _validateNpmPackageName = _interopRequireDefault(require("validate-npm-package-name"));

var _fs = require("@sanity/util/fs");

var pkg = _interopRequireWildcard(require("../../../package.json"));

var _readJson = require("../../util/readJson");

var _dynamicRequire = require("../../util/dynamicRequire");

var _debug = require("../../debug");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const request = (0, _getIt.default)([(0, _promise.default)()]);

async function bootstrapFromTemplate(context, url) {
  const {
    prompt,
    workDir
  } = context;
  let inProjectContext = false;

  try {
    const projectManifest = await (0, _readJson.readJson)(_path.default.join(workDir, 'sanity.json'));
    inProjectContext = Boolean(projectManifest.root);
  } catch (err) {// Intentional noop
  }

  (0, _debug.debug)(inProjectContext ? 'Project context found' : 'Not in project context');
  let zip;

  try {
    (0, _debug.debug)('Fetching zip from %s', url);
    zip = await getZip(url);
    (0, _debug.debug)('Zip finished downloading');
  } catch (err) {
    err.message = "Failed to get template: ".concat(err.message);
    throw err;
  }

  (0, _debug.debug)('Looking up template manifest from zip');
  const manifest = zip.find(file => _path.default.basename(file.path) === 'package.json' && !file.path.includes('node_modules'));

  if (!manifest) {
    throw new Error('Could not find `package.json` in template');
  } // Note: Paths inside the zips are always unix-style, so do not use `path.join` here


  const baseDir = "".concat(_path.default.dirname(manifest.path), "/template");
  (0, _debug.debug)('Manifest path resolved to %s', manifest.path);
  (0, _debug.debug)('Base directory resolved to %s', baseDir);
  const templateFiles = zip.filter(file => file.type === 'file' && file.path.indexOf(baseDir) === 0);
  (0, _debug.debug)('%d files found in template', templateFiles.length);
  const manifestContent = parseJson(manifest.data.toString());
  const tplVars = (manifestContent === null || manifestContent === void 0 ? void 0 : manifestContent.sanityTemplate) || {};
  const {
    minimumBaseVersion,
    minimumCliVersion
  } = tplVars;

  if (minimumBaseVersion) {
    (0, _debug.debug)('Template requires Sanity version %s', minimumBaseVersion);
    const installed = getSanityVersion(workDir);
    (0, _debug.debug)('Installed Sanity version is %s', installed);

    if (_semver.default.lt(installed, minimumBaseVersion)) {
      throw new Error("Template requires Sanity at version ".concat(minimumBaseVersion, ", installed is ").concat(installed));
    }
  }

  if (minimumCliVersion) {
    (0, _debug.debug)('Template requires Sanity CLI version %s', minimumCliVersion);
    (0, _debug.debug)('Installed CLI version is %s', pkg.version);

    if (_semver.default.lt(pkg.version, minimumCliVersion)) {
      throw new Error("Template requires @sanity/cli at version ".concat(minimumCliVersion, ", installed is ").concat(pkg.version));
    }
  }

  const name = await prompt.single({
    type: 'input',
    message: 'Plugin name:',
    default: tplVars.suggestedName || '',
    validate: async pkgName => {
      const {
        validForNewPackages
      } = (0, _validateNpmPackageName.default)(pkgName);

      if (!validForNewPackages) {
        return 'Name must be a valid npm package name (https://docs.npmjs.com/files/package.json#name)';
      }

      const outputPath = _path.default.join(workDir, 'plugins', pkgName);

      const isEmpty = await (0, _fs.pathIsEmpty)(outputPath);

      if (inProjectContext && !isEmpty) {
        return 'Plugin with given name already exists in project';
      }

      return true;
    }
  });

  let outputPath = _path.default.join(workDir, 'plugins', name);

  if (!inProjectContext) {
    const cwdIsEmpty = await (0, _fs.pathIsEmpty)(workDir);
    outputPath = await prompt.single({
      type: 'input',
      message: 'Output path:',
      default: cwdIsEmpty ? workDir : _path.default.join(workDir, name),
      validate: validateEmptyPath,
      filter: _fs.absolutify
    });
  }

  (0, _debug.debug)('Output path set to %s', outputPath);
  let createConfig = tplVars.requiresConfig;

  if (typeof createConfig === 'undefined') {
    createConfig = await prompt.single({
      type: 'confirm',
      message: 'Does the plugin need a configuration file?',
      default: false
    });
  }

  (0, _debug.debug)('Ensuring directory exists: %s', outputPath);
  await _promises.default.mkdir(outputPath, {
    recursive: true
  });
  await Promise.all(templateFiles.map(file => {
    const filename = file.path.slice(baseDir.length);
    (0, _debug.debug)('Writing template file "%s" to "%s"', filename, outputPath);
    return _promises.default.writeFile(_path.default.join(outputPath, filename), file.data);
  }));
  return {
    name,
    outputPath,
    inPluginsPath: inProjectContext,
    dependencies: tplVars.dependencies
  };
}

async function validateEmptyPath(dir) {
  const isEmpty = await (0, _fs.pathIsEmpty)(dir);
  return isEmpty ? true : 'Path is not empty';
}

function getZip(url) {
  return request({
    url,
    rawBody: true
  }).then(res => {
    if (res.statusCode > 299) {
      const httpErr = ['HTTP', res.statusCode, res.statusMessage].filter(Boolean).join(' ');
      throw new Error("".concat(httpErr, " trying to download ").concat(url));
    }

    return (0, _decompress.default)(res.body);
  });
}

function parseJson(json) {
  try {
    return JSON.parse(json);
  } catch (err) {
    return undefined;
  }
}

function getSanityVersion(workDir) {
  // This is only used in v2, thus `@sanity/base`
  const basePkg = _resolveFrom.default.silent(workDir, '@sanity/base/package.json');

  return basePkg ? (0, _dynamicRequire.dynamicRequire)(basePkg).version : pkg.version;
}