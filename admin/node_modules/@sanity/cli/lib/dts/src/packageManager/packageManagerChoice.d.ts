/// <reference types="node" />
import { CliPrompter } from '../types';
export declare type PackageManager = 'npm' | 'yarn' | 'pnpm' | 'manual';
/**
 * Attempts to resolve the most optimal package manager to use to install/upgrade
 * packages/dependencies at a given path. It does so by looking for package manager
 * specific lockfiles. If it finds a lockfile belonging to a certain package manager,
 * it prioritizes this one. However, if that package manager is not installed, it will
 * prompt the user for which one they want to use and hint at the most optimal one
 * not being installed.
 *
 * Note that this function also takes local npm binary paths into account - for instance,
 * `yarn` can be installed as a dependency of the project instead of globally, and it
 * will use that is available.
 *
 * The user can also select 'manual' to skip the process and run their preferred package
 * manager manually. Commands using this function must take this `manual` choice into
 * account and act accordingly if chosen.
 *
 * @param workDir - The working directory where a lockfile is most likely to be present
 * @param options - Pass `interactive: false` to fall back to npm if most optimal is
 *                  not available, instead of prompting
 * @returns Object of `chosen` and, if a lockfile is found, the `mostOptimal` choice
 */
export declare function getPackageManagerChoice(workDir: string, options: {
    interactive: false;
} | {
    interactive?: true;
    prompt: CliPrompter;
}): Promise<{
    chosen: PackageManager;
    mostOptimal?: PackageManager;
}>;
export declare function hasNpmInstalled(cwd?: string): Promise<boolean>;
export declare function hasYarnInstalled(cwd?: string): Promise<boolean>;
export declare function hasPnpmInstalled(cwd?: string): Promise<boolean>;
export declare function getNpmRunPath(cwd: string): string;
export declare function getPartialEnvWithNpmPath(cwd: string): NodeJS.ProcessEnv;
//# sourceMappingURL=packageManagerChoice.d.ts.map