"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CommandRunner = void 0;
exports.getCliRunner = getCliRunner;

var _cloneDeep2 = _interopRequireDefault(require("lodash/cloneDeep"));

var _sortBy2 = _interopRequireDefault(require("lodash/sortBy"));

var _chalk = _interopRequireDefault(require("chalk"));

var _cliPrompter = require("./prompters/cliPrompter");

var _cliOutputter = _interopRequireDefault(require("./outputters/cliOutputter"));

var _clientWrapper = require("./util/clientWrapper");

var _noSuchCommandText = require("./util/noSuchCommandText");

var _isCommandGroup = require("./util/isCommandGroup");

var _commands = require("./commands");

var _debug = require("./debug");

var _generateCommandsDocumentation = require("./util/generateCommandsDocumentation");

var _packageManager = require("./packageManager");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class CommandRunner {
  constructor(handlers) {
    let commands = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _commands.baseCommands;

    _defineProperty(this, "handlers", void 0);

    _defineProperty(this, "commands", void 0);

    _defineProperty(this, "commandGroups", void 0);

    this.handlers = handlers;
    this.commands = (0, _sortBy2.default)(commands, 'name');
    this.commandGroups = {};

    for (const cmd of this.commands) {
      const group = 'group' in cmd && cmd.group || 'default';
      this.commandGroups[group] = this.commandGroups[group] || [];
      this.commandGroups[group].push(cmd);
    }

    if (!handlers.outputter || !handlers.prompter) {
      throw new Error('`prompter` and `outputter` handlers must be defined');
    }
  }

  async runCommand(commandOrGroup, args, options) {
    var _cliConfig$config;

    if (!commandOrGroup) {
      this.handlers.outputter.print((0, _generateCommandsDocumentation.generateCommandsDocumentation)(this.commandGroups));
      return Promise.resolve();
    } // We might modify arguments for easier parsing in subcommand


    const cmdArgs = (0, _cloneDeep2.default)(args);
    const subCommandName = args.argsWithoutOptions[0];
    const commandInfo = this.resolveCommand(commandOrGroup, subCommandName);

    if (!commandInfo) {
      throw new Error((0, _noSuchCommandText.getNoSuchCommandText)(commandOrGroup, subCommandName, this.commandGroups));
    }

    const command = commandInfo.command;

    if (!(0, _isCommandGroup.isCommandGroup)(command) && command.group && command.group !== 'default') {
      cmdArgs.argsWithoutOptions = args.argsWithoutOptions.slice(1);
    }

    const output = this.handlers.outputter;
    const prompt = this.handlers.prompter;
    const {
      cliConfig,
      ...commandOptions
    } = options;
    const apiClient = (0, _clientWrapper.getClientWrapper)((cliConfig === null || cliConfig === void 0 ? void 0 : (_cliConfig$config = cliConfig.config) === null || _cliConfig$config === void 0 ? void 0 : _cliConfig$config.api) || null, (cliConfig === null || cliConfig === void 0 ? void 0 : cliConfig.path) || ((cliConfig === null || cliConfig === void 0 ? void 0 : cliConfig.version) === 2 ? 'sanity.json' : 'sanity.cli.js'));
    const context = {
      output,
      prompt,
      apiClient,
      chalk: _chalk.default,
      cliPackageManager: _packageManager.cliPackageManager,
      ...commandOptions,
      commandRunner: this,
      yarn: (0, _packageManager.getYarnStub)({
        output,
        workDir: commandOptions.workDir
      }),
      ...getVersionedContextParams(cliConfig)
    };

    if ((0, _isCommandGroup.isCommandGroup)(command)) {
      return context.output.print((0, _generateCommandsDocumentation.generateCommandsDocumentation)(this.commandGroups, command.name));
    }

    if (typeof command.action !== 'function') {
      const cmdName = command.name || commandOrGroup || '<unknown>';
      (0, _debug.debug)("Command \"".concat(cmdName, "\" doesnt have a valid \"action\"-property, showing help"));
      const groupName = command.group && command.group !== 'default' ? command.group : null;
      return context.output.print((0, _generateCommandsDocumentation.generateCommandDocumentation)(command, groupName, subCommandName));
    }

    (0, _debug.debug)("Running command \"".concat(command.name, "\""));
    return command.action(cmdArgs, context);
  }

  resolveCommand(commandOrGroup, subCommandName) {
    // First, see if there is a group with the given name, if a subcommand is provided
    if (this.commandGroups[commandOrGroup] && subCommandName) {
      (0, _debug.debug)("Found group for name \"".concat(commandOrGroup, "\", resolving subcommand"));
      const subCommand = this.resolveSubcommand(this.commandGroups[commandOrGroup], subCommandName, commandOrGroup);
      (0, _debug.debug)(subCommand ? "Subcommand resolved to \"".concat(subCommand.commandName, "\"") : "Subcommand with name \"".concat(subCommandName, "\" not found"));
      return subCommand;
    } // No group? See if there's a command within the default group


    (0, _debug.debug)("No group found with name \"".concat(commandOrGroup, "\", looking for command"));
    const command = this.commandGroups.default.find(cmd => cmd.name === commandOrGroup);

    if (command) {
      (0, _debug.debug)("Found command in default group with name \"".concat(commandOrGroup, "\""));
      return {
        command: command,
        commandName: command.name,
        parentName: 'default',
        isGroup: false,
        isCommand: true
      };
    }

    (0, _debug.debug)("No default command with name \"".concat(commandOrGroup, "\" found, giving up"));
    return null;
  }

  resolveSubcommand(group, subCommandName, parentGroupName) {
    if (!subCommandName) {
      return null;
    }

    const subCommand = group.find(cmd => cmd.name === subCommandName);

    if (!subCommand) {
      throw new Error((0, _noSuchCommandText.getNoSuchCommandText)(subCommandName, parentGroupName, this.commandGroups));
    }

    return {
      command: subCommand,
      commandName: subCommandName,
      parentName: parentGroupName,
      isGroup: false,
      isCommand: true
    };
  }

  resolveHelpForGroup() {
    const command = this.commandGroups.default.find(cmd => cmd.name === 'help');

    if (!command) {
      throw new Error('Failed to find default `help` command');
    }

    return {
      command,
      commandName: 'help',
      isGroup: false,
      isCommand: true
    };
  }

}

exports.CommandRunner = CommandRunner;

function getCliRunner(commands) {
  return new CommandRunner({
    outputter: _cliOutputter.default,
    prompter: _cliPrompter.prompt
  }, commands);
}

function getVersionedContextParams(cliConfig) {
  return (cliConfig === null || cliConfig === void 0 ? void 0 : cliConfig.version) === 2 ? {
    sanityMajorVersion: 2,
    cliConfig: (cliConfig === null || cliConfig === void 0 ? void 0 : cliConfig.config) || undefined,
    cliConfigPath: (cliConfig === null || cliConfig === void 0 ? void 0 : cliConfig.path) || undefined
  } : {
    sanityMajorVersion: 3,
    cliConfig: (cliConfig === null || cliConfig === void 0 ? void 0 : cliConfig.config) || undefined,
    cliConfigPath: (cliConfig === null || cliConfig === void 0 ? void 0 : cliConfig.path) || undefined
  };
}