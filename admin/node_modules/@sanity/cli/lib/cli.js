"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runCli = runCli;

var _path = _interopRequireDefault(require("path"));

var _chalk = _interopRequireDefault(require("chalk"));

var _dotenv = _interopRequireDefault(require("dotenv"));

var _resolveFrom = _interopRequireDefault(require("resolve-from"));

var _updateNotifier = require("./util/updateNotifier");

var _parseArguments = require("./util/parseArguments");

var _mergeCommands = require("./util/mergeCommands");

var _CommandRunner = require("./CommandRunner");

var _commands = require("./commands");

var _neatStack = require("./util/neatStack");

var _resolveRootDir = require("./util/resolveRootDir");

var _getCliConfig = require("./util/getCliConfig");

var _packageManager = require("./packageManager");

var _debug = require("./debug");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-console, no-process-exit, no-sync */
const sanityEnv = process.env.SANITY_INTERNAL_ENV || 'production'; // eslint-disable-line no-process-env

const knownEnvs = ['development', 'staging', 'production'];

async function runCli(cliRoot, _ref) {
  let {
    cliVersion
  } = _ref;
  installUnhandledRejectionsHandler();
  const pkg = {
    name: '@sanity/cli',
    version: cliVersion
  };
  const args = (0, _parseArguments.parseArguments)();
  const isInit = args.groupOrCommand === 'init' && args.argsWithoutOptions[0] !== 'plugin';
  const cwd = getCurrentWorkingDirectory();
  let workDir;

  try {
    workDir = isInit ? process.cwd() : (0, _resolveRootDir.resolveRootDir)(cwd);
  } catch (err) {
    console.error(_chalk.default.red(err.message));
    process.exit(1);
  } // Try to load .env files from the sanity studio directory
  // eslint-disable-next-line no-process-env


  const env = process.env.SANITY_ACTIVE_ENV || process.env.NODE_ENV || 'development';

  _dotenv.default.config({
    path: _path.default.join(workDir, ".env.".concat(env))
  }); // Check if there are updates available for the CLI, and notify if there is


  await (0, _updateNotifier.runUpdateCheck)({
    pkg,
    cwd,
    workDir
  }).notify(); // Try to figure out if we're in a v2 or v3 context by finding a config

  (0, _debug.debug)("Reading CLI config from \"".concat(workDir, "\""));
  const cliConfig = await (0, _getCliConfig.getCliConfig)(workDir, {
    forked: true
  });

  if (!cliConfig) {
    (0, _debug.debug)('No CLI config found');
  }

  const options = {
    cliRoot: cliRoot,
    workDir: workDir,
    corePath: await getCoreModulePath(workDir, cliConfig),
    cliConfig
  };
  warnOnNonProductionEnvironment();
  warnOnInferredProjectDir(isInit, cwd, workDir);
  const core = args.coreOptions;
  const commands = await (0, _mergeCommands.mergeCommands)(_commands.baseCommands, options.corePath, {
    cliVersion,
    cwd,
    workDir
  });

  if (core.v || core.version) {
    console.log("".concat(pkg.name, " version ").concat(pkg.version));
    process.exit();
  } // Translate `sanity -h <command>` to `sanity help <command>`


  if (core.h || core.help) {
    if (args.groupOrCommand) {
      args.argsWithoutOptions.unshift(args.groupOrCommand);
    }

    args.groupOrCommand = 'help';
  }

  const cliRunner = (0, _CommandRunner.getCliRunner)(commands);
  cliRunner.runCommand(args.groupOrCommand, args, options).catch(err => {
    const error = typeof err.details === 'string' ? err.details : err; // eslint-disable-next-line no-console

    console.error("\n".concat(error.stack ? (0, _neatStack.neatStack)(err) : error)); // eslint-disable-next-line no-process-exit

    process.exit(1);
  });
}

async function getCoreModulePath(workDir, cliConfig) {
  const corePath = _resolveFrom.default.silent(workDir, '@sanity/core');

  const sanityPath = _resolveFrom.default.silent(workDir, 'sanity/_internal');

  if (corePath && sanityPath) {
    const closest = corePath.startsWith(workDir) ? corePath : sanityPath;
    const assumedVersion = closest === corePath ? 'v2' : 'v3';
    console.warn(_chalk.default.yellow("Both `@sanity/core` AND `sanity` installed - assuming Sanity ".concat(assumedVersion, " project.")));
    return closest;
  }

  if (sanityPath) {
    // On v3 and everything installed
    return sanityPath;
  }

  if (corePath && cliConfig && (cliConfig === null || cliConfig === void 0 ? void 0 : cliConfig.version) < 3) {
    // On v2 and everything installed
    return corePath;
  }

  const isInstallCommand = process.argv.indexOf('install') === -1;

  if (cliConfig && (cliConfig === null || cliConfig === void 0 ? void 0 : cliConfig.version) < 3 && !corePath && !isInstallCommand) {
    const installCmd = await (0, _packageManager.getInstallCommand)({
      workDir
    });
    console.warn(_chalk.default.yellow(['The `@sanity/core` module is not installed in current project', "Project-specific commands not available until you run `".concat(installCmd, "`")].join('\n')));
  }

  if (cliConfig && cliConfig.version >= 3 && !sanityPath) {
    const installCmd = await (0, _packageManager.getInstallCommand)({
      workDir
    });
    console.warn(_chalk.default.yellow(['The `sanity` module is not installed in current project', "Project-specific commands not available until you run `".concat(installCmd, "`")].join('\n')));
  }

  return undefined;
}
/**
 * Returns the current working directory, but also handles a weird edge case where
 * the folder the terminal is currently in has been removed
 */


function getCurrentWorkingDirectory() {
  let pwd;

  try {
    pwd = process.cwd();
  } catch (err) {
    if (err.code === 'ENOENT') {
      console.error('[ERR] Could not resolve working directory, does the current folder exist?');
      process.exit(1);
    } else {
      throw err;
    }
  }

  return pwd;
}

function installUnhandledRejectionsHandler() {
  process.on('unhandledRejection', reason => {
    if (rejectionHasStack(reason)) {
      console.error('Unhandled rejection:', reason.stack);
    } else {
      console.error('Unhandled rejection\n', reason);
    }
  });
}

function rejectionHasStack(reason) {
  return Boolean(reason && 'stack' in reason && typeof reason.stack === 'string');
}

function warnOnInferredProjectDir(isInit, cwd, workDir) {
  if (isInit || cwd === workDir) {
    return;
  }

  console.log("Not in project directory, assuming context of project at ".concat(workDir));
}

function warnOnNonProductionEnvironment() {
  if (sanityEnv === 'production') {
    return;
  }

  console.warn(_chalk.default.yellow(knownEnvs.includes(sanityEnv) ? "[WARN] Running in ".concat(sanityEnv, " environment mode\n") : "[WARN] Running in ".concat(_chalk.default.red('UNKNOWN'), " \"").concat(sanityEnv, "\" environment mode\n")));
}