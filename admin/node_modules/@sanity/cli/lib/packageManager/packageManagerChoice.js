"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNpmRunPath = getNpmRunPath;
exports.getPackageManagerChoice = getPackageManagerChoice;
exports.getPartialEnvWithNpmPath = getPartialEnvWithNpmPath;
exports.hasNpmInstalled = hasNpmInstalled;
exports.hasPnpmInstalled = hasPnpmInstalled;
exports.hasYarnInstalled = hasYarnInstalled;

var _path = _interopRequireDefault(require("path"));

var _which = _interopRequireDefault(require("which"));

var _preferredPm = _interopRequireDefault(require("preferred-pm"));

var _isInteractive = require("../util/isInteractive");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Attempts to resolve the most optimal package manager to use to install/upgrade
 * packages/dependencies at a given path. It does so by looking for package manager
 * specific lockfiles. If it finds a lockfile belonging to a certain package manager,
 * it prioritizes this one. However, if that package manager is not installed, it will
 * prompt the user for which one they want to use and hint at the most optimal one
 * not being installed.
 *
 * Note that this function also takes local npm binary paths into account - for instance,
 * `yarn` can be installed as a dependency of the project instead of globally, and it
 * will use that is available.
 *
 * The user can also select 'manual' to skip the process and run their preferred package
 * manager manually. Commands using this function must take this `manual` choice into
 * account and act accordingly if chosen.
 *
 * @param workDir - The working directory where a lockfile is most likely to be present
 * @param options - Pass `interactive: false` to fall back to npm if most optimal is
 *                  not available, instead of prompting
 * @returns Object of `chosen` and, if a lockfile is found, the `mostOptimal` choice
 */
async function getPackageManagerChoice(workDir, options) {
  var _await$preferredPM;

  const rootDir = workDir || process.cwd();
  const preferred = (_await$preferredPM = await (0, _preferredPm.default)(rootDir)) === null || _await$preferredPM === void 0 ? void 0 : _await$preferredPM.name;

  if (preferred && (await hasCommand(preferred, rootDir))) {
    // There is an optimal/preferred package manager, and the user has it installed!
    return {
      chosen: preferred,
      mostOptimal: preferred
    };
  }

  const interactive = typeof options.interactive === 'boolean' ? options.interactive : _isInteractive.isInteractive;

  if (!interactive) {
    // We can't ask the user for their preference, so fall back to whatever is installed
    // Note that the most optimal choice is already picked above if available.
    return {
      chosen: await getFallback(rootDir),
      mostOptimal: preferred
    };
  }

  if (!('prompt' in options)) {
    throw new Error('Must pass `prompt` when in interactive mode');
  } // We can ask the user for their preference, hurray!


  const messageSuffix = preferred ? " (preferred is ".concat(preferred, ", but is not installed)") : '';
  const chosen = await options.prompt.single({
    type: 'list',
    choices: await getAvailablePackageManagers(rootDir),
    default: preferred,
    message: "Package manager to use for installing dependencies?".concat(messageSuffix)
  });
  return {
    chosen,
    mostOptimal: preferred
  };
}

async function getFallback(cwd) {
  if (await hasNpmInstalled(cwd)) {
    return 'npm';
  }

  if (await hasYarnInstalled(cwd)) {
    return 'yarn';
  }

  if (await hasPnpmInstalled(cwd)) {
    return 'pnpm';
  }

  return 'manual';
}

async function getAvailablePackageManagers(cwd) {
  const [npm, yarn, pnpm] = await Promise.all([hasNpmInstalled(cwd), hasYarnInstalled(cwd), hasPnpmInstalled(cwd)]);
  const choices = [npm && 'npm', yarn && 'yarn', pnpm && 'pnpm', 'manual'];
  return choices.filter(pm => pm !== false);
}

function hasNpmInstalled(cwd) {
  return hasCommand('npm', cwd);
}

function hasYarnInstalled(cwd) {
  return hasCommand('yarn', cwd);
}

function hasPnpmInstalled(cwd) {
  return hasCommand('pnpm', cwd);
}

function getNpmRunPath(cwd) {
  let previous;

  let cwdPath = _path.default.resolve(cwd);

  const result = [];

  while (previous !== cwdPath) {
    result.push(_path.default.join(cwdPath, 'node_modules', '.bin'));
    previous = cwdPath;
    cwdPath = _path.default.resolve(cwdPath, '..');
  }

  result.push(_path.default.resolve(cwd, process.execPath, '..'));
  const pathEnv = process.env[getPathEnvVarKey()];
  return [...result, pathEnv].join(_path.default.delimiter);
}

function getPartialEnvWithNpmPath(cwd) {
  const key = getPathEnvVarKey();
  return {
    [key]: getNpmRunPath(cwd)
  };
}

function getPathEnvVarKey() {
  if (process.platform !== 'win32') {
    return 'PATH';
  }

  return Object.keys(process.env).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';
}

function getCommandPath(cmd, cwd) {
  const options = cwd ? {
    path: getNpmRunPath(cwd)
  } : {};
  return (0, _which.default)(cmd, options).catch(() => null);
}

function hasCommand(cmd, cwd) {
  return getCommandPath(cmd, cwd).then(cmdPath => cmdPath !== null);
}