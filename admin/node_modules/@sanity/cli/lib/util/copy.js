"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copy = copy;

var _path = _interopRequireDefault(require("path"));

var _promises = _interopRequireDefault(require("fs/promises"));

var _readdirRecursive = require("./readdirRecursive");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function copy(srcPath, dstPath, options) {
  const rename = options === null || options === void 0 ? void 0 : options.rename;
  const content = (await _promises.default.stat(srcPath)).isDirectory() ? await (0, _readdirRecursive.readdirRecursive)(srcPath) : [{
    path: srcPath,
    isDir: false
  }];
  const directories = content.filter(entry => entry.isDir).sort((a, b) => b.path.length - a.path.length).sort((a, b) => a.path.localeCompare(b.path)).map(entry => entry.path);

  for (const subDir of directories) {
    const relativePath = _path.default.relative(srcPath, subDir);

    const fullDstPath = _path.default.join(dstPath, relativePath);

    await _promises.default.mkdir(fullDstPath, {
      recursive: true
    });
  }

  const files = content.filter(entry => !entry.isDir).sort((a, b) => b.path.length - a.path.length).sort((a, b) => a.path.localeCompare(b.path)).map(entry => {
    const relativePath = _path.default.relative(srcPath, entry.path);

    const baseName = _path.default.basename(relativePath);

    const dirName = _path.default.dirname(relativePath);

    const dstName = rename ? rename(baseName) : baseName;

    const fullDstPath = _path.default.join(dstPath, dirName, dstName);

    return {
      from: entry.path,
      to: fullDstPath
    };
  });

  for (const file of files) {
    await _promises.default.copyFile(file.from, file.to);
  }

  return files.length;
}