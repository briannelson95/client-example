"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getProjectDefaults = getProjectDefaults;

var _path = _interopRequireDefault(require("path"));

var _promises = _interopRequireDefault(require("fs/promises"));

var _gitconfiglocal = _interopRequireDefault(require("@rexxars/gitconfiglocal"));

var _gitUserInfo = require("git-user-info");

var _promisePropsRecursive = _interopRequireDefault(require("promise-props-recursive"));

var _clientWrapper = require("./clientWrapper");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getProjectDefaults(workDir, _ref) {
  let {
    isPlugin,
    context
  } = _ref;
  const cwd = process.cwd();
  const isSanityRoot = workDir === cwd;
  return (0, _promisePropsRecursive.default)({
    license: 'UNLICENSED',
    author: getUserInfo(context),
    // Don't try to use git remote from main Sanity project for plugins
    gitRemote: isPlugin && isSanityRoot ? '' : resolveGitRemote(cwd),
    // Don't try to guess plugin name if we're initing from Sanity root
    projectName: isPlugin && isSanityRoot ? '' : _path.default.basename(cwd),
    // If we're initing a plugin, don't use description from Sanity readme
    description: getProjectDescription({
      isSanityRoot,
      isPlugin,
      outputDir: cwd
    })
  });
}

async function resolveGitRemote(cwd) {
  try {
    await _promises.default.stat(_path.default.join(cwd, '.git'));
    const cfg = await (0, _gitconfiglocal.default)(cwd);
    return cfg.remote && cfg.remote.origin && cfg.remote.origin.url;
  } catch (_unused) {
    return undefined;
  }
}

async function getUserInfo(context) {
  const user = await (0, _gitUserInfo.getGitUserInfo)();

  if (!user) {
    return getSanityUserInfo(context);
  }

  if (user.name && user.email) {
    return "".concat(user.name, " <").concat(user.email, ">");
  }

  return undefined;
}

async function getSanityUserInfo(context) {
  const hasToken = Boolean((0, _clientWrapper.getCliToken)());

  if (!hasToken) {
    return undefined;
  }

  const client = context.apiClient({
    requireUser: true,
    requireProject: false
  });

  try {
    const user = await client.users.getById('me');
    return user ? "".concat(user.name, " <").concat(user.email, ">") : undefined;
  } catch (_unused2) {
    return undefined;
  }
}

async function getProjectDescription(_ref2) {
  let {
    isSanityRoot,
    isPlugin,
    outputDir
  } = _ref2;
  const tryResolve = isSanityRoot && !isPlugin;

  if (!tryResolve) {
    return Promise.resolve('');
  } // Try to grab a project description from a standard GitHub-generated readme


  try {
    const readmePath = _path.default.join(outputDir, 'README.md');

    const readme = await _promises.default.readFile(readmePath, {
      encoding: 'utf8'
    });
    const match = readme.match(/^# .*?\n+(\w.*?)(?:$|\n)/);
    return (match && match[1] || '').replace(/\.$/, '') || '';
  } catch (err) {
    return '';
  }
}