"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCliWorkerPath = getCliWorkerPath;

var _path = _interopRequireDefault(require("path"));

var _pkgDir = _interopRequireDefault(require("pkg-dir"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Because we're bundling the CLI into a single file, the classic approach of
 * checking `isMainThread()` and spawning a thread on `__dirname` does not work,
 * as it leads to the entire CLI being re-executed in the worker thread.
 *
 * To make things worse, the built CLI makes it difficult to resolve paths to
 * built source files (that contains the unpackaged worker).
 *
 * This function takes a path _relative to the `src`/`lib` folder, resolves
 * the location of that within the installed location (eg global Sanity CLI)
 * and ensures we can resolve the actual module before trying to spawn the
 * worker thread.
 *
 * @param workerPath - _RELATIVE_ path (relative to `src`/`lib`) to the worker
 * @returns Full, absolute path to the worker
 * @internal
 */
async function getCliWorkerPath(workerPath) {
  const cliDir = await (0, _pkgDir.default)(__dirname);

  if (!cliDir) {
    throw new Error('Failed to find root @sanity/cli module directory');
  }

  const resolvedPath = _path.default.resolve(cliDir, 'lib', workerPath);

  const resolvedFile = require.resolve(resolvedPath);

  if (!resolvedFile) {
    throw new Error("Unable to resolve path for worker: ".concat(resolvedPath));
  }

  return resolvedFile;
}