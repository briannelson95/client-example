"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeCommands = mergeCommands;

var _find2 = _interopRequireDefault(require("lodash/find"));

var _semver = _interopRequireDefault(require("semver"));

var _dynamicRequire = require("./dynamicRequire");

var _isCommandGroup = require("./isCommandGroup");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function mergeCommands(baseCommands, corePath, options) {
  if (!corePath) {
    return baseCommands;
  }

  const {
    cwd,
    workDir,
    cliVersion
  } = options;
  const coreImport = (0, _dynamicRequire.dynamicRequire)(corePath);
  const coercedCliVersion = _semver.default.coerce(cliVersion) || '';
  const moduleName = /@sanity[/\\]core/.test(corePath) ? '@sanity/core' : 'sanity';
  const core = 'cliProjectCommands' in coreImport ? coreImport.cliProjectCommands : coreImport; // @todo the resolving of `sanity`/`@sanity/core` here might find global installs,
  // which can lead to incorrect versioning being reported. We should only run this
  // check if we are within a project dir, and even then only if it is not global

  /*
  if (
    core.requiredCliVersionRange &&
    !semver.satisfies(coercedCliVersion, core.requiredCliVersionRange)
  ) {
    const upgradeCmd = chalk.yellow(await getCliUpgradeCommand({cwd, workDir}))
    console.error(
      `The version of the \`${moduleName}\` installed in this project requires @sanity/cli @ ${chalk.green(
        core.requiredCliVersionRange
      )}. Currently installed version is ${chalk.red(
        cliVersion
      )}.\n\nPlease upgrade by running:\n\n  ${upgradeCmd}\n\n`
    )
    process.exit(1)
  }
  */

  const merged = baseCommands.concat(core.commands).map(addDefaultGroup); // Remove duplicate commands when within the same group,
  // the last defined commands with the given name wins

  return merged.reverse().reduce((cmds, cmd) => {
    const group = (0, _isCommandGroup.isCommandGroup)(cmd) ? undefined : cmd.group;

    if (!(0, _find2.default)(cmds, {
      name: cmd.name,
      group
    })) {
      cmds.push(cmd);
    }

    return cmds;
  }, []);
}

function addDefaultGroup(cmd) {
  if (!(0, _isCommandGroup.isCommandGroup)(cmd) && !cmd.group) {
    cmd.group = 'default';
  }

  return cmd;
}